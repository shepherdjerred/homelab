// deno-lint-ignore-file
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "npm:cdk8s";
import { Construct } from "constructs";

/**
 * BackingImage is where Longhorn stores backing image object.
 *
 * @schema BackingImage
 */
export class BackingImage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "BackingImage",
  };

  /**
   * Renders a Kubernetes manifest for "BackingImage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageProps = {}): any {
    return {
      ...BackingImage.GVK,
      ...toJson_BackingImageProps(props),
    };
  }

  /**
   * Defines a "BackingImage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: BackingImageProps = {},
  ) {
    super(scope, id, {
      ...BackingImage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImage.GVK,
      ...toJson_BackingImageProps(resolved),
    };
  }
}

/**
 * BackingImage is where Longhorn stores backing image object.
 *
 * @schema BackingImage
 */
export interface BackingImageProps {
  /**
   * @schema BackingImage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema BackingImage#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'BackingImageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageProps(
  obj: BackingImageProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackingImage is where Longhorn stores backing image object.
 *
 * @schema BackingImageV1Beta2
 */
export class BackingImageV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImageV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "BackingImage",
  };

  /**
   * Renders a Kubernetes manifest for "BackingImageV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageV1Beta2Props = {}): any {
    return {
      ...BackingImageV1Beta2.GVK,
      ...toJson_BackingImageV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackingImageV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: BackingImageV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...BackingImageV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImageV1Beta2.GVK,
      ...toJson_BackingImageV1Beta2Props(resolved),
    };
  }
}

/**
 * BackingImage is where Longhorn stores backing image object.
 *
 * @schema BackingImageV1Beta2
 */
export interface BackingImageV1Beta2Props {
  /**
   * @schema BackingImageV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackingImageSpec defines the desired state of the Longhorn backing image
   *
   * @schema BackingImageV1Beta2#spec
   */
  readonly spec?: BackingImageV1Beta2Spec;
}

/**
 * Converts an object of type 'BackingImageV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageV1Beta2Props(
  obj: BackingImageV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_BackingImageV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackingImageSpec defines the desired state of the Longhorn backing image
 *
 * @schema BackingImageV1Beta2Spec
 */
export interface BackingImageV1Beta2Spec {
  /**
   * @schema BackingImageV1Beta2Spec#checksum
   */
  readonly checksum?: string;

  /**
   * @schema BackingImageV1Beta2Spec#disks
   */
  readonly disks?: { [key: string]: string };

  /**
   * @schema BackingImageV1Beta2Spec#sourceParameters
   */
  readonly sourceParameters?: { [key: string]: string };

  /**
   * @schema BackingImageV1Beta2Spec#sourceType
   */
  readonly sourceType?: BackingImageV1Beta2SpecSourceType;
}

/**
 * Converts an object of type 'BackingImageV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageV1Beta2Spec(
  obj: BackingImageV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    checksum: obj.checksum,
    disks: obj.disks === undefined
      ? undefined
      : Object.entries(obj.disks).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {},
      ),
    sourceParameters: obj.sourceParameters === undefined
      ? undefined
      : Object.entries(obj.sourceParameters).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {},
      ),
    sourceType: obj.sourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackingImageV1Beta2SpecSourceType
 */
export enum BackingImageV1Beta2SpecSourceType {
  /** download */
  DOWNLOAD = "download",
  /** upload */
  UPLOAD = "upload",
  /** export-from-volume */
  EXPORT_HYPHEN_FROM_HYPHEN_VOLUME = "export-from-volume",
}

/**
 * BackingImageDataSource is where Longhorn stores backing image data source object.
 *
 * @schema BackingImageDataSource
 */
export class BackingImageDataSource extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImageDataSource"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "BackingImageDataSource",
  };

  /**
   * Renders a Kubernetes manifest for "BackingImageDataSource".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageDataSourceProps = {}): any {
    return {
      ...BackingImageDataSource.GVK,
      ...toJson_BackingImageDataSourceProps(props),
    };
  }

  /**
   * Defines a "BackingImageDataSource" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: BackingImageDataSourceProps = {},
  ) {
    super(scope, id, {
      ...BackingImageDataSource.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImageDataSource.GVK,
      ...toJson_BackingImageDataSourceProps(resolved),
    };
  }
}

/**
 * BackingImageDataSource is where Longhorn stores backing image data source object.
 *
 * @schema BackingImageDataSource
 */
export interface BackingImageDataSourceProps {
  /**
   * @schema BackingImageDataSource#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema BackingImageDataSource#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'BackingImageDataSourceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageDataSourceProps(
  obj: BackingImageDataSourceProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackingImageDataSource is where Longhorn stores backing image data source object.
 *
 * @schema BackingImageDataSourceV1Beta2
 */
export class BackingImageDataSourceV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImageDataSourceV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "BackingImageDataSource",
  };

  /**
   * Renders a Kubernetes manifest for "BackingImageDataSourceV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageDataSourceV1Beta2Props = {}): any {
    return {
      ...BackingImageDataSourceV1Beta2.GVK,
      ...toJson_BackingImageDataSourceV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackingImageDataSourceV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: BackingImageDataSourceV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...BackingImageDataSourceV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImageDataSourceV1Beta2.GVK,
      ...toJson_BackingImageDataSourceV1Beta2Props(resolved),
    };
  }
}

/**
 * BackingImageDataSource is where Longhorn stores backing image data source object.
 *
 * @schema BackingImageDataSourceV1Beta2
 */
export interface BackingImageDataSourceV1Beta2Props {
  /**
   * @schema BackingImageDataSourceV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackingImageDataSourceSpec defines the desired state of the Longhorn backing image data source
   *
   * @schema BackingImageDataSourceV1Beta2#spec
   */
  readonly spec?: BackingImageDataSourceV1Beta2Spec;
}

/**
 * Converts an object of type 'BackingImageDataSourceV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageDataSourceV1Beta2Props(
  obj: BackingImageDataSourceV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_BackingImageDataSourceV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackingImageDataSourceSpec defines the desired state of the Longhorn backing image data source
 *
 * @schema BackingImageDataSourceV1Beta2Spec
 */
export interface BackingImageDataSourceV1Beta2Spec {
  /**
   * @schema BackingImageDataSourceV1Beta2Spec#checksum
   */
  readonly checksum?: string;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#diskPath
   */
  readonly diskPath?: string;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#diskUUID
   */
  readonly diskUuid?: string;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#fileTransferred
   */
  readonly fileTransferred?: boolean;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#sourceType
   */
  readonly sourceType?: BackingImageDataSourceV1Beta2SpecSourceType;

  /**
   * @schema BackingImageDataSourceV1Beta2Spec#uuid
   */
  readonly uuid?: string;
}

/**
 * Converts an object of type 'BackingImageDataSourceV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageDataSourceV1Beta2Spec(
  obj: BackingImageDataSourceV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    checksum: obj.checksum,
    diskPath: obj.diskPath,
    diskUUID: obj.diskUuid,
    fileTransferred: obj.fileTransferred,
    nodeID: obj.nodeId,
    parameters: obj.parameters === undefined
      ? undefined
      : Object.entries(obj.parameters).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {},
      ),
    sourceType: obj.sourceType,
    uuid: obj.uuid,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema BackingImageDataSourceV1Beta2SpecSourceType
 */
export enum BackingImageDataSourceV1Beta2SpecSourceType {
  /** download */
  DOWNLOAD = "download",
  /** upload */
  UPLOAD = "upload",
  /** export-from-volume */
  EXPORT_HYPHEN_FROM_HYPHEN_VOLUME = "export-from-volume",
}

/**
 * BackingImageManager is where Longhorn stores backing image manager object.
 *
 * @schema BackingImageManager
 */
export class BackingImageManager extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImageManager"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "BackingImageManager",
  };

  /**
   * Renders a Kubernetes manifest for "BackingImageManager".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageManagerProps = {}): any {
    return {
      ...BackingImageManager.GVK,
      ...toJson_BackingImageManagerProps(props),
    };
  }

  /**
   * Defines a "BackingImageManager" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: BackingImageManagerProps = {},
  ) {
    super(scope, id, {
      ...BackingImageManager.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImageManager.GVK,
      ...toJson_BackingImageManagerProps(resolved),
    };
  }
}

/**
 * BackingImageManager is where Longhorn stores backing image manager object.
 *
 * @schema BackingImageManager
 */
export interface BackingImageManagerProps {
  /**
   * @schema BackingImageManager#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema BackingImageManager#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'BackingImageManagerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageManagerProps(
  obj: BackingImageManagerProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackingImageManager is where Longhorn stores backing image manager object.
 *
 * @schema BackingImageManagerV1Beta2
 */
export class BackingImageManagerV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackingImageManagerV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "BackingImageManager",
  };

  /**
   * Renders a Kubernetes manifest for "BackingImageManagerV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackingImageManagerV1Beta2Props = {}): any {
    return {
      ...BackingImageManagerV1Beta2.GVK,
      ...toJson_BackingImageManagerV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackingImageManagerV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: BackingImageManagerV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...BackingImageManagerV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackingImageManagerV1Beta2.GVK,
      ...toJson_BackingImageManagerV1Beta2Props(resolved),
    };
  }
}

/**
 * BackingImageManager is where Longhorn stores backing image manager object.
 *
 * @schema BackingImageManagerV1Beta2
 */
export interface BackingImageManagerV1Beta2Props {
  /**
   * @schema BackingImageManagerV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackingImageManagerSpec defines the desired state of the Longhorn backing image manager
   *
   * @schema BackingImageManagerV1Beta2#spec
   */
  readonly spec?: BackingImageManagerV1Beta2Spec;
}

/**
 * Converts an object of type 'BackingImageManagerV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageManagerV1Beta2Props(
  obj: BackingImageManagerV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_BackingImageManagerV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackingImageManagerSpec defines the desired state of the Longhorn backing image manager
 *
 * @schema BackingImageManagerV1Beta2Spec
 */
export interface BackingImageManagerV1Beta2Spec {
  /**
   * @schema BackingImageManagerV1Beta2Spec#backingImages
   */
  readonly backingImages?: { [key: string]: string };

  /**
   * @schema BackingImageManagerV1Beta2Spec#diskPath
   */
  readonly diskPath?: string;

  /**
   * @schema BackingImageManagerV1Beta2Spec#diskUUID
   */
  readonly diskUuid?: string;

  /**
   * @schema BackingImageManagerV1Beta2Spec#image
   */
  readonly image?: string;

  /**
   * @schema BackingImageManagerV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;
}

/**
 * Converts an object of type 'BackingImageManagerV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackingImageManagerV1Beta2Spec(
  obj: BackingImageManagerV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    backingImages: obj.backingImages === undefined
      ? undefined
      : Object.entries(obj.backingImages).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {},
      ),
    diskPath: obj.diskPath,
    diskUUID: obj.diskUuid,
    image: obj.image,
    nodeID: obj.nodeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Backup is where Longhorn stores backup object.
 *
 * @schema Backup
 */
export class Backup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Backup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "Backup",
  };

  /**
   * Renders a Kubernetes manifest for "Backup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupProps = {}): any {
    return {
      ...Backup.GVK,
      ...toJson_BackupProps(props),
    };
  }

  /**
   * Defines a "Backup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupProps = {}) {
    super(scope, id, {
      ...Backup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Backup.GVK,
      ...toJson_BackupProps(resolved),
    };
  }
}

/**
 * Backup is where Longhorn stores backup object.
 *
 * @schema Backup
 */
export interface BackupProps {
  /**
   * @schema Backup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Backup#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'BackupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupProps(
  obj: BackupProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Backup is where Longhorn stores backup object.
 *
 * @schema BackupV1Beta2
 */
export class BackupV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "Backup",
  };

  /**
   * Renders a Kubernetes manifest for "BackupV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupV1Beta2Props = {}): any {
    return {
      ...BackupV1Beta2.GVK,
      ...toJson_BackupV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackupV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: BackupV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...BackupV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupV1Beta2.GVK,
      ...toJson_BackupV1Beta2Props(resolved),
    };
  }
}

/**
 * Backup is where Longhorn stores backup object.
 *
 * @schema BackupV1Beta2
 */
export interface BackupV1Beta2Props {
  /**
   * @schema BackupV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupSpec defines the desired state of the Longhorn backup
   *
   * @schema BackupV1Beta2#spec
   */
  readonly spec?: BackupV1Beta2Spec;
}

/**
 * Converts an object of type 'BackupV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupV1Beta2Props(
  obj: BackupV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_BackupV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackupSpec defines the desired state of the Longhorn backup
 *
 * @schema BackupV1Beta2Spec
 */
export interface BackupV1Beta2Spec {
  /**
   * The labels of snapshot backup.
   *
   * @schema BackupV1Beta2Spec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The snapshot name.
   *
   * @schema BackupV1Beta2Spec#snapshotName
   */
  readonly snapshotName?: string;

  /**
   * The time to request run sync the remote backup.
   *
   * @schema BackupV1Beta2Spec#syncRequestedAt
   */
  readonly syncRequestedAt?: Date;
}

/**
 * Converts an object of type 'BackupV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupV1Beta2Spec(
  obj: BackupV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labels: obj.labels === undefined
      ? undefined
      : Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {},
      ),
    snapshotName: obj.snapshotName,
    syncRequestedAt: obj.syncRequestedAt?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackupTarget is where Longhorn stores backup target object.
 *
 * @schema BackupTarget
 */
export class BackupTarget extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupTarget"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "BackupTarget",
  };

  /**
   * Renders a Kubernetes manifest for "BackupTarget".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupTargetProps = {}): any {
    return {
      ...BackupTarget.GVK,
      ...toJson_BackupTargetProps(props),
    };
  }

  /**
   * Defines a "BackupTarget" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: BackupTargetProps = {},
  ) {
    super(scope, id, {
      ...BackupTarget.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupTarget.GVK,
      ...toJson_BackupTargetProps(resolved),
    };
  }
}

/**
 * BackupTarget is where Longhorn stores backup target object.
 *
 * @schema BackupTarget
 */
export interface BackupTargetProps {
  /**
   * @schema BackupTarget#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema BackupTarget#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'BackupTargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupTargetProps(
  obj: BackupTargetProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackupTarget is where Longhorn stores backup target object.
 *
 * @schema BackupTargetV1Beta2
 */
export class BackupTargetV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupTargetV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "BackupTarget",
  };

  /**
   * Renders a Kubernetes manifest for "BackupTargetV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupTargetV1Beta2Props = {}): any {
    return {
      ...BackupTargetV1Beta2.GVK,
      ...toJson_BackupTargetV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackupTargetV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: BackupTargetV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...BackupTargetV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupTargetV1Beta2.GVK,
      ...toJson_BackupTargetV1Beta2Props(resolved),
    };
  }
}

/**
 * BackupTarget is where Longhorn stores backup target object.
 *
 * @schema BackupTargetV1Beta2
 */
export interface BackupTargetV1Beta2Props {
  /**
   * @schema BackupTargetV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupTargetSpec defines the desired state of the Longhorn backup target
   *
   * @schema BackupTargetV1Beta2#spec
   */
  readonly spec?: BackupTargetV1Beta2Spec;
}

/**
 * Converts an object of type 'BackupTargetV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupTargetV1Beta2Props(
  obj: BackupTargetV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_BackupTargetV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackupTargetSpec defines the desired state of the Longhorn backup target
 *
 * @schema BackupTargetV1Beta2Spec
 */
export interface BackupTargetV1Beta2Spec {
  /**
   * The backup target URL.
   *
   * @schema BackupTargetV1Beta2Spec#backupTargetURL
   */
  readonly backupTargetUrl?: string;

  /**
   * The backup target credential secret.
   *
   * @schema BackupTargetV1Beta2Spec#credentialSecret
   */
  readonly credentialSecret?: string;

  /**
   * The interval that the cluster needs to run sync with the backup target.
   *
   * @schema BackupTargetV1Beta2Spec#pollInterval
   */
  readonly pollInterval?: string;

  /**
   * The time to request run sync the remote backup target.
   *
   * @schema BackupTargetV1Beta2Spec#syncRequestedAt
   */
  readonly syncRequestedAt?: Date;
}

/**
 * Converts an object of type 'BackupTargetV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupTargetV1Beta2Spec(
  obj: BackupTargetV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    backupTargetURL: obj.backupTargetUrl,
    credentialSecret: obj.credentialSecret,
    pollInterval: obj.pollInterval,
    syncRequestedAt: obj.syncRequestedAt?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackupVolume is where Longhorn stores backup volume object.
 *
 * @schema BackupVolume
 */
export class BackupVolume extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupVolume"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "BackupVolume",
  };

  /**
   * Renders a Kubernetes manifest for "BackupVolume".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupVolumeProps = {}): any {
    return {
      ...BackupVolume.GVK,
      ...toJson_BackupVolumeProps(props),
    };
  }

  /**
   * Defines a "BackupVolume" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: BackupVolumeProps = {},
  ) {
    super(scope, id, {
      ...BackupVolume.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupVolume.GVK,
      ...toJson_BackupVolumeProps(resolved),
    };
  }
}

/**
 * BackupVolume is where Longhorn stores backup volume object.
 *
 * @schema BackupVolume
 */
export interface BackupVolumeProps {
  /**
   * @schema BackupVolume#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema BackupVolume#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'BackupVolumeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupVolumeProps(
  obj: BackupVolumeProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackupVolume is where Longhorn stores backup volume object.
 *
 * @schema BackupVolumeV1Beta2
 */
export class BackupVolumeV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupVolumeV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "BackupVolume",
  };

  /**
   * Renders a Kubernetes manifest for "BackupVolumeV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupVolumeV1Beta2Props = {}): any {
    return {
      ...BackupVolumeV1Beta2.GVK,
      ...toJson_BackupVolumeV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BackupVolumeV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: BackupVolumeV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...BackupVolumeV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupVolumeV1Beta2.GVK,
      ...toJson_BackupVolumeV1Beta2Props(resolved),
    };
  }
}

/**
 * BackupVolume is where Longhorn stores backup volume object.
 *
 * @schema BackupVolumeV1Beta2
 */
export interface BackupVolumeV1Beta2Props {
  /**
   * @schema BackupVolumeV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupVolumeSpec defines the desired state of the Longhorn backup volume
   *
   * @schema BackupVolumeV1Beta2#spec
   */
  readonly spec?: BackupVolumeV1Beta2Spec;
}

/**
 * Converts an object of type 'BackupVolumeV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupVolumeV1Beta2Props(
  obj: BackupVolumeV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_BackupVolumeV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BackupVolumeSpec defines the desired state of the Longhorn backup volume
 *
 * @schema BackupVolumeV1Beta2Spec
 */
export interface BackupVolumeV1Beta2Spec {
  /**
   * The time to request run sync the remote backup volume.
   *
   * @schema BackupVolumeV1Beta2Spec#syncRequestedAt
   */
  readonly syncRequestedAt?: Date;
}

/**
 * Converts an object of type 'BackupVolumeV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BackupVolumeV1Beta2Spec(
  obj: BackupVolumeV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    syncRequestedAt: obj.syncRequestedAt?.toISOString(),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Engine is where Longhorn stores engine object.
 *
 * @schema Engine
 */
export class Engine extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Engine"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "Engine",
  };

  /**
   * Renders a Kubernetes manifest for "Engine".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EngineProps = {}): any {
    return {
      ...Engine.GVK,
      ...toJson_EngineProps(props),
    };
  }

  /**
   * Defines a "Engine" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EngineProps = {}) {
    super(scope, id, {
      ...Engine.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Engine.GVK,
      ...toJson_EngineProps(resolved),
    };
  }
}

/**
 * Engine is where Longhorn stores engine object.
 *
 * @schema Engine
 */
export interface EngineProps {
  /**
   * @schema Engine#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Engine#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'EngineProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineProps(
  obj: EngineProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Engine is where Longhorn stores engine object.
 *
 * @schema EngineV1Beta2
 */
export class EngineV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EngineV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "Engine",
  };

  /**
   * Renders a Kubernetes manifest for "EngineV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EngineV1Beta2Props = {}): any {
    return {
      ...EngineV1Beta2.GVK,
      ...toJson_EngineV1Beta2Props(props),
    };
  }

  /**
   * Defines a "EngineV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: EngineV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...EngineV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EngineV1Beta2.GVK,
      ...toJson_EngineV1Beta2Props(resolved),
    };
  }
}

/**
 * Engine is where Longhorn stores engine object.
 *
 * @schema EngineV1Beta2
 */
export interface EngineV1Beta2Props {
  /**
   * @schema EngineV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EngineSpec defines the desired state of the Longhorn engine
   *
   * @schema EngineV1Beta2#spec
   */
  readonly spec?: EngineV1Beta2Spec;
}

/**
 * Converts an object of type 'EngineV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineV1Beta2Props(
  obj: EngineV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_EngineV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EngineSpec defines the desired state of the Longhorn engine
 *
 * @schema EngineV1Beta2Spec
 */
export interface EngineV1Beta2Spec {
  /**
   * @schema EngineV1Beta2Spec#active
   */
  readonly active?: boolean;

  /**
   * @schema EngineV1Beta2Spec#backendStoreDriver
   */
  readonly backendStoreDriver?: EngineV1Beta2SpecBackendStoreDriver;

  /**
   * @schema EngineV1Beta2Spec#backupVolume
   */
  readonly backupVolume?: string;

  /**
   * @schema EngineV1Beta2Spec#desireState
   */
  readonly desireState?: string;

  /**
   * @schema EngineV1Beta2Spec#disableFrontend
   */
  readonly disableFrontend?: boolean;

  /**
   * @schema EngineV1Beta2Spec#engineImage
   */
  readonly engineImage?: string;

  /**
   * @schema EngineV1Beta2Spec#frontend
   */
  readonly frontend?: EngineV1Beta2SpecFrontend;

  /**
   * @schema EngineV1Beta2Spec#logRequested
   */
  readonly logRequested?: boolean;

  /**
   * @schema EngineV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;

  /**
   * @schema EngineV1Beta2Spec#replicaAddressMap
   */
  readonly replicaAddressMap?: { [key: string]: string };

  /**
   * @schema EngineV1Beta2Spec#requestedBackupRestore
   */
  readonly requestedBackupRestore?: string;

  /**
   * @schema EngineV1Beta2Spec#requestedDataSource
   */
  readonly requestedDataSource?: string;

  /**
   * @schema EngineV1Beta2Spec#revisionCounterDisabled
   */
  readonly revisionCounterDisabled?: boolean;

  /**
   * @schema EngineV1Beta2Spec#salvageRequested
   */
  readonly salvageRequested?: boolean;

  /**
   * @schema EngineV1Beta2Spec#unmapMarkSnapChainRemovedEnabled
   */
  readonly unmapMarkSnapChainRemovedEnabled?: boolean;

  /**
   * @schema EngineV1Beta2Spec#upgradedReplicaAddressMap
   */
  readonly upgradedReplicaAddressMap?: { [key: string]: string };

  /**
   * @schema EngineV1Beta2Spec#volumeName
   */
  readonly volumeName?: string;

  /**
   * @schema EngineV1Beta2Spec#volumeSize
   */
  readonly volumeSize?: string;
}

/**
 * Converts an object of type 'EngineV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineV1Beta2Spec(
  obj: EngineV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    active: obj.active,
    backendStoreDriver: obj.backendStoreDriver,
    backupVolume: obj.backupVolume,
    desireState: obj.desireState,
    disableFrontend: obj.disableFrontend,
    engineImage: obj.engineImage,
    frontend: obj.frontend,
    logRequested: obj.logRequested,
    nodeID: obj.nodeId,
    replicaAddressMap: obj.replicaAddressMap === undefined
      ? undefined
      : Object.entries(obj.replicaAddressMap).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {},
      ),
    requestedBackupRestore: obj.requestedBackupRestore,
    requestedDataSource: obj.requestedDataSource,
    revisionCounterDisabled: obj.revisionCounterDisabled,
    salvageRequested: obj.salvageRequested,
    unmapMarkSnapChainRemovedEnabled: obj.unmapMarkSnapChainRemovedEnabled,
    upgradedReplicaAddressMap: obj.upgradedReplicaAddressMap === undefined
      ? undefined
      : Object.entries(obj.upgradedReplicaAddressMap).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {},
      ),
    volumeName: obj.volumeName,
    volumeSize: obj.volumeSize,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EngineV1Beta2SpecBackendStoreDriver
 */
export enum EngineV1Beta2SpecBackendStoreDriver {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * @schema EngineV1Beta2SpecFrontend
 */
export enum EngineV1Beta2SpecFrontend {
  /** blockdev */
  BLOCKDEV = "blockdev",
  /** iscsi */
  ISCSI = "iscsi",
  /** nvmf */
  NVMF = "nvmf",
}

/**
 * EngineImage is where Longhorn stores engine image object.
 *
 * @schema EngineImage
 */
export class EngineImage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EngineImage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "EngineImage",
  };

  /**
   * Renders a Kubernetes manifest for "EngineImage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EngineImageProps = {}): any {
    return {
      ...EngineImage.GVK,
      ...toJson_EngineImageProps(props),
    };
  }

  /**
   * Defines a "EngineImage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: EngineImageProps = {},
  ) {
    super(scope, id, {
      ...EngineImage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EngineImage.GVK,
      ...toJson_EngineImageProps(resolved),
    };
  }
}

/**
 * EngineImage is where Longhorn stores engine image object.
 *
 * @schema EngineImage
 */
export interface EngineImageProps {
  /**
   * @schema EngineImage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema EngineImage#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'EngineImageProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineImageProps(
  obj: EngineImageProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EngineImage is where Longhorn stores engine image object.
 *
 * @schema EngineImageV1Beta2
 */
export class EngineImageV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EngineImageV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "EngineImage",
  };

  /**
   * Renders a Kubernetes manifest for "EngineImageV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EngineImageV1Beta2Props = {}): any {
    return {
      ...EngineImageV1Beta2.GVK,
      ...toJson_EngineImageV1Beta2Props(props),
    };
  }

  /**
   * Defines a "EngineImageV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: EngineImageV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...EngineImageV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EngineImageV1Beta2.GVK,
      ...toJson_EngineImageV1Beta2Props(resolved),
    };
  }
}

/**
 * EngineImage is where Longhorn stores engine image object.
 *
 * @schema EngineImageV1Beta2
 */
export interface EngineImageV1Beta2Props {
  /**
   * @schema EngineImageV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EngineImageSpec defines the desired state of the Longhorn engine image
   *
   * @schema EngineImageV1Beta2#spec
   */
  readonly spec?: EngineImageV1Beta2Spec;
}

/**
 * Converts an object of type 'EngineImageV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineImageV1Beta2Props(
  obj: EngineImageV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_EngineImageV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EngineImageSpec defines the desired state of the Longhorn engine image
 *
 * @schema EngineImageV1Beta2Spec
 */
export interface EngineImageV1Beta2Spec {
  /**
   * @schema EngineImageV1Beta2Spec#image
   */
  readonly image: string;
}

/**
 * Converts an object of type 'EngineImageV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EngineImageV1Beta2Spec(
  obj: EngineImageV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    image: obj.image,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceManager is where Longhorn stores instance manager object.
 *
 * @schema InstanceManager
 */
export class InstanceManager extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InstanceManager"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "InstanceManager",
  };

  /**
   * Renders a Kubernetes manifest for "InstanceManager".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceManagerProps = {}): any {
    return {
      ...InstanceManager.GVK,
      ...toJson_InstanceManagerProps(props),
    };
  }

  /**
   * Defines a "InstanceManager" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: InstanceManagerProps = {},
  ) {
    super(scope, id, {
      ...InstanceManager.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InstanceManager.GVK,
      ...toJson_InstanceManagerProps(resolved),
    };
  }
}

/**
 * InstanceManager is where Longhorn stores instance manager object.
 *
 * @schema InstanceManager
 */
export interface InstanceManagerProps {
  /**
   * @schema InstanceManager#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema InstanceManager#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'InstanceManagerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceManagerProps(
  obj: InstanceManagerProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceManager is where Longhorn stores instance manager object.
 *
 * @schema InstanceManagerV1Beta2
 */
export class InstanceManagerV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InstanceManagerV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "InstanceManager",
  };

  /**
   * Renders a Kubernetes manifest for "InstanceManagerV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceManagerV1Beta2Props = {}): any {
    return {
      ...InstanceManagerV1Beta2.GVK,
      ...toJson_InstanceManagerV1Beta2Props(props),
    };
  }

  /**
   * Defines a "InstanceManagerV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: InstanceManagerV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...InstanceManagerV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InstanceManagerV1Beta2.GVK,
      ...toJson_InstanceManagerV1Beta2Props(resolved),
    };
  }
}

/**
 * InstanceManager is where Longhorn stores instance manager object.
 *
 * @schema InstanceManagerV1Beta2
 */
export interface InstanceManagerV1Beta2Props {
  /**
   * @schema InstanceManagerV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceManagerSpec defines the desired state of the Longhorn instancer manager
   *
   * @schema InstanceManagerV1Beta2#spec
   */
  readonly spec?: InstanceManagerV1Beta2Spec;
}

/**
 * Converts an object of type 'InstanceManagerV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceManagerV1Beta2Props(
  obj: InstanceManagerV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_InstanceManagerV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceManagerSpec defines the desired state of the Longhorn instancer manager
 *
 * @schema InstanceManagerV1Beta2Spec
 */
export interface InstanceManagerV1Beta2Spec {
  /**
   * @schema InstanceManagerV1Beta2Spec#image
   */
  readonly image?: string;

  /**
   * @schema InstanceManagerV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;

  /**
   * @schema InstanceManagerV1Beta2Spec#type
   */
  readonly type?: InstanceManagerV1Beta2SpecType;
}

/**
 * Converts an object of type 'InstanceManagerV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceManagerV1Beta2Spec(
  obj: InstanceManagerV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    image: obj.image,
    nodeID: obj.nodeId,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceManagerV1Beta2SpecType
 */
export enum InstanceManagerV1Beta2SpecType {
  /** aio */
  AIO = "aio",
  /** engine */
  ENGINE = "engine",
  /** replica */
  REPLICA = "replica",
}

/**
 * Node is where Longhorn stores Longhorn node object.
 *
 * @schema Node
 */
export class Node extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Node"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "Node",
  };

  /**
   * Renders a Kubernetes manifest for "Node".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodeProps = {}): any {
    return {
      ...Node.GVK,
      ...toJson_NodeProps(props),
    };
  }

  /**
   * Defines a "Node" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodeProps = {}) {
    super(scope, id, {
      ...Node.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Node.GVK,
      ...toJson_NodeProps(resolved),
    };
  }
}

/**
 * Node is where Longhorn stores Longhorn node object.
 *
 * @schema Node
 */
export interface NodeProps {
  /**
   * @schema Node#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Node#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'NodeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeProps(
  obj: NodeProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Node is where Longhorn stores Longhorn node object.
 *
 * @schema NodeV1Beta2
 */
export class NodeV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodeV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "Node",
  };

  /**
   * Renders a Kubernetes manifest for "NodeV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodeV1Beta2Props = {}): any {
    return {
      ...NodeV1Beta2.GVK,
      ...toJson_NodeV1Beta2Props(props),
    };
  }

  /**
   * Defines a "NodeV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: NodeV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...NodeV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodeV1Beta2.GVK,
      ...toJson_NodeV1Beta2Props(resolved),
    };
  }
}

/**
 * Node is where Longhorn stores Longhorn node object.
 *
 * @schema NodeV1Beta2
 */
export interface NodeV1Beta2Props {
  /**
   * @schema NodeV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NodeSpec defines the desired state of the Longhorn node
   *
   * @schema NodeV1Beta2#spec
   */
  readonly spec?: NodeV1Beta2Spec;
}

/**
 * Converts an object of type 'NodeV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeV1Beta2Props(
  obj: NodeV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_NodeV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * NodeSpec defines the desired state of the Longhorn node
 *
 * @schema NodeV1Beta2Spec
 */
export interface NodeV1Beta2Spec {
  /**
   * @schema NodeV1Beta2Spec#allowScheduling
   */
  readonly allowScheduling?: boolean;

  /**
   * @schema NodeV1Beta2Spec#disks
   */
  readonly disks?: { [key: string]: NodeV1Beta2SpecDisks };

  /**
   * @schema NodeV1Beta2Spec#evictionRequested
   */
  readonly evictionRequested?: boolean;

  /**
   * @schema NodeV1Beta2Spec#instanceManagerCPURequest
   */
  readonly instanceManagerCpuRequest?: number;

  /**
   * @schema NodeV1Beta2Spec#name
   */
  readonly name?: string;

  /**
   * @schema NodeV1Beta2Spec#tags
   */
  readonly tags?: string[];
}

/**
 * Converts an object of type 'NodeV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeV1Beta2Spec(
  obj: NodeV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowScheduling: obj.allowScheduling,
    disks: obj.disks === undefined
      ? undefined
      : Object.entries(obj.disks).reduce(
        (r, i) =>
          i[1] === undefined
            ? r
            : { ...r, [i[0]]: toJson_NodeV1Beta2SpecDisks(i[1]) },
        {},
      ),
    evictionRequested: obj.evictionRequested,
    instanceManagerCPURequest: obj.instanceManagerCpuRequest,
    name: obj.name,
    tags: obj.tags?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeV1Beta2SpecDisks
 */
export interface NodeV1Beta2SpecDisks {
  /**
   * @schema NodeV1Beta2SpecDisks#allowScheduling
   */
  readonly allowScheduling?: boolean;

  /**
   * @schema NodeV1Beta2SpecDisks#diskType
   */
  readonly diskType?: NodeV1Beta2SpecDisksDiskType;

  /**
   * @schema NodeV1Beta2SpecDisks#evictionRequested
   */
  readonly evictionRequested?: boolean;

  /**
   * @schema NodeV1Beta2SpecDisks#path
   */
  readonly path?: string;

  /**
   * @schema NodeV1Beta2SpecDisks#storageReserved
   */
  readonly storageReserved?: number;

  /**
   * @schema NodeV1Beta2SpecDisks#tags
   */
  readonly tags?: string[];
}

/**
 * Converts an object of type 'NodeV1Beta2SpecDisks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeV1Beta2SpecDisks(
  obj: NodeV1Beta2SpecDisks | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowScheduling: obj.allowScheduling,
    diskType: obj.diskType,
    evictionRequested: obj.evictionRequested,
    path: obj.path,
    storageReserved: obj.storageReserved,
    tags: obj.tags?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeV1Beta2SpecDisksDiskType
 */
export enum NodeV1Beta2SpecDisksDiskType {
  /** filesystem */
  FILESYSTEM = "filesystem",
  /** block */
  BLOCK = "block",
}

/**
 * Orphan is where Longhorn stores orphan object.
 *
 * @schema Orphan
 */
export class Orphan extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Orphan"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "Orphan",
  };

  /**
   * Renders a Kubernetes manifest for "Orphan".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OrphanProps = {}): any {
    return {
      ...Orphan.GVK,
      ...toJson_OrphanProps(props),
    };
  }

  /**
   * Defines a "Orphan" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OrphanProps = {}) {
    super(scope, id, {
      ...Orphan.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Orphan.GVK,
      ...toJson_OrphanProps(resolved),
    };
  }
}

/**
 * Orphan is where Longhorn stores orphan object.
 *
 * @schema Orphan
 */
export interface OrphanProps {
  /**
   * @schema Orphan#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OrphanSpec defines the desired state of the Longhorn orphaned data
   *
   * @schema Orphan#spec
   */
  readonly spec?: OrphanSpec;
}

/**
 * Converts an object of type 'OrphanProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrphanProps(
  obj: OrphanProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_OrphanSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OrphanSpec defines the desired state of the Longhorn orphaned data
 *
 * @schema OrphanSpec
 */
export interface OrphanSpec {
  /**
   * The node ID on which the controller is responsible to reconcile this orphan CR.
   *
   * @schema OrphanSpec#nodeID
   */
  readonly nodeId?: string;

  /**
   * The type of the orphaned data. Can be "replica".
   *
   * @schema OrphanSpec#orphanType
   */
  readonly orphanType?: string;

  /**
   * The parameters of the orphaned data
   *
   * @schema OrphanSpec#parameters
   */
  readonly parameters?: { [key: string]: string };
}

/**
 * Converts an object of type 'OrphanSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OrphanSpec(
  obj: OrphanSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeID: obj.nodeId,
    orphanType: obj.orphanType,
    parameters: obj.parameters === undefined
      ? undefined
      : Object.entries(obj.parameters).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {},
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RecurringJob is where Longhorn stores recurring job object.
 *
 * @schema RecurringJob
 */
export class RecurringJob extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RecurringJob"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "RecurringJob",
  };

  /**
   * Renders a Kubernetes manifest for "RecurringJob".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RecurringJobProps = {}): any {
    return {
      ...RecurringJob.GVK,
      ...toJson_RecurringJobProps(props),
    };
  }

  /**
   * Defines a "RecurringJob" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: RecurringJobProps = {},
  ) {
    super(scope, id, {
      ...RecurringJob.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RecurringJob.GVK,
      ...toJson_RecurringJobProps(resolved),
    };
  }
}

/**
 * RecurringJob is where Longhorn stores recurring job object.
 *
 * @schema RecurringJob
 */
export interface RecurringJobProps {
  /**
   * @schema RecurringJob#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema RecurringJob#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'RecurringJobProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecurringJobProps(
  obj: RecurringJobProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RecurringJob is where Longhorn stores recurring job object.
 *
 * @schema RecurringJobV1Beta2
 */
export class RecurringJobV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RecurringJobV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "RecurringJob",
  };

  /**
   * Renders a Kubernetes manifest for "RecurringJobV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RecurringJobV1Beta2Props = {}): any {
    return {
      ...RecurringJobV1Beta2.GVK,
      ...toJson_RecurringJobV1Beta2Props(props),
    };
  }

  /**
   * Defines a "RecurringJobV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: RecurringJobV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...RecurringJobV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RecurringJobV1Beta2.GVK,
      ...toJson_RecurringJobV1Beta2Props(resolved),
    };
  }
}

/**
 * RecurringJob is where Longhorn stores recurring job object.
 *
 * @schema RecurringJobV1Beta2
 */
export interface RecurringJobV1Beta2Props {
  /**
   * @schema RecurringJobV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RecurringJobSpec defines the desired state of the Longhorn recurring job
   *
   * @schema RecurringJobV1Beta2#spec
   */
  readonly spec?: RecurringJobV1Beta2Spec;
}

/**
 * Converts an object of type 'RecurringJobV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecurringJobV1Beta2Props(
  obj: RecurringJobV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_RecurringJobV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RecurringJobSpec defines the desired state of the Longhorn recurring job
 *
 * @schema RecurringJobV1Beta2Spec
 */
export interface RecurringJobV1Beta2Spec {
  /**
   * The concurrency of taking the snapshot/backup.
   *
   * @schema RecurringJobV1Beta2Spec#concurrency
   */
  readonly concurrency?: number;

  /**
   * The cron setting.
   *
   * @schema RecurringJobV1Beta2Spec#cron
   */
  readonly cron?: string;

  /**
   * The recurring job group.
   *
   * @schema RecurringJobV1Beta2Spec#groups
   */
  readonly groups?: string[];

  /**
   * The label of the snapshot/backup.
   *
   * @schema RecurringJobV1Beta2Spec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The recurring job name.
   *
   * @schema RecurringJobV1Beta2Spec#name
   */
  readonly name?: string;

  /**
   * The retain count of the snapshot/backup.
   *
   * @schema RecurringJobV1Beta2Spec#retain
   */
  readonly retain?: number;

  /**
   * The recurring job task. Can be "snapshot", "snapshot-force-create", "snapshot-cleanup", "snapshot-delete", "backup", "backup-force-create" or "filesystem-trim"
   *
   * @schema RecurringJobV1Beta2Spec#task
   */
  readonly task?: RecurringJobV1Beta2SpecTask;
}

/**
 * Converts an object of type 'RecurringJobV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecurringJobV1Beta2Spec(
  obj: RecurringJobV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    concurrency: obj.concurrency,
    cron: obj.cron,
    groups: obj.groups?.map((y) => y),
    labels: obj.labels === undefined
      ? undefined
      : Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {},
      ),
    name: obj.name,
    retain: obj.retain,
    task: obj.task,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The recurring job task. Can be "snapshot", "snapshot-force-create", "snapshot-cleanup", "snapshot-delete", "backup", "backup-force-create" or "filesystem-trim"
 *
 * @schema RecurringJobV1Beta2SpecTask
 */
export enum RecurringJobV1Beta2SpecTask {
  /** snapshot */
  SNAPSHOT = "snapshot",
  /** snapshot-force-create */
  SNAPSHOT_HYPHEN_FORCE_HYPHEN_CREATE = "snapshot-force-create",
  /** snapshot-cleanup */
  SNAPSHOT_HYPHEN_CLEANUP = "snapshot-cleanup",
  /** snapshot-delete */
  SNAPSHOT_HYPHEN_DELETE = "snapshot-delete",
  /** backup */
  BACKUP = "backup",
  /** backup-force-create */
  BACKUP_HYPHEN_FORCE_HYPHEN_CREATE = "backup-force-create",
  /** filesystem-trim */
  FILESYSTEM_HYPHEN_TRIM = "filesystem-trim",
}

/**
 * Replica is where Longhorn stores replica object.
 *
 * @schema Replica
 */
export class Replica extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Replica"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "Replica",
  };

  /**
   * Renders a Kubernetes manifest for "Replica".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicaProps = {}): any {
    return {
      ...Replica.GVK,
      ...toJson_ReplicaProps(props),
    };
  }

  /**
   * Defines a "Replica" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReplicaProps = {}) {
    super(scope, id, {
      ...Replica.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Replica.GVK,
      ...toJson_ReplicaProps(resolved),
    };
  }
}

/**
 * Replica is where Longhorn stores replica object.
 *
 * @schema Replica
 */
export interface ReplicaProps {
  /**
   * @schema Replica#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Replica#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'ReplicaProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaProps(
  obj: ReplicaProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Replica is where Longhorn stores replica object.
 *
 * @schema ReplicaV1Beta2
 */
export class ReplicaV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReplicaV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "Replica",
  };

  /**
   * Renders a Kubernetes manifest for "ReplicaV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicaV1Beta2Props = {}): any {
    return {
      ...ReplicaV1Beta2.GVK,
      ...toJson_ReplicaV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ReplicaV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ReplicaV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...ReplicaV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReplicaV1Beta2.GVK,
      ...toJson_ReplicaV1Beta2Props(resolved),
    };
  }
}

/**
 * Replica is where Longhorn stores replica object.
 *
 * @schema ReplicaV1Beta2
 */
export interface ReplicaV1Beta2Props {
  /**
   * @schema ReplicaV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReplicaSpec defines the desired state of the Longhorn replica
   *
   * @schema ReplicaV1Beta2#spec
   */
  readonly spec?: ReplicaV1Beta2Spec;
}

/**
 * Converts an object of type 'ReplicaV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaV1Beta2Props(
  obj: ReplicaV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ReplicaV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicaSpec defines the desired state of the Longhorn replica
 *
 * @schema ReplicaV1Beta2Spec
 */
export interface ReplicaV1Beta2Spec {
  /**
   * @schema ReplicaV1Beta2Spec#active
   */
  readonly active?: boolean;

  /**
   * @schema ReplicaV1Beta2Spec#backendStoreDriver
   */
  readonly backendStoreDriver?: ReplicaV1Beta2SpecBackendStoreDriver;

  /**
   * @schema ReplicaV1Beta2Spec#backingImage
   */
  readonly backingImage?: string;

  /**
   * @schema ReplicaV1Beta2Spec#dataDirectoryName
   */
  readonly dataDirectoryName?: string;

  /**
   * @schema ReplicaV1Beta2Spec#desireState
   */
  readonly desireState?: string;

  /**
   * @schema ReplicaV1Beta2Spec#diskID
   */
  readonly diskId?: string;

  /**
   * @schema ReplicaV1Beta2Spec#diskPath
   */
  readonly diskPath?: string;

  /**
   * @schema ReplicaV1Beta2Spec#engineImage
   */
  readonly engineImage?: string;

  /**
   * @schema ReplicaV1Beta2Spec#engineName
   */
  readonly engineName?: string;

  /**
   * @schema ReplicaV1Beta2Spec#failedAt
   */
  readonly failedAt?: string;

  /**
   * @schema ReplicaV1Beta2Spec#hardNodeAffinity
   */
  readonly hardNodeAffinity?: string;

  /**
   * @schema ReplicaV1Beta2Spec#healthyAt
   */
  readonly healthyAt?: string;

  /**
   * @schema ReplicaV1Beta2Spec#logRequested
   */
  readonly logRequested?: boolean;

  /**
   * @schema ReplicaV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;

  /**
   * @schema ReplicaV1Beta2Spec#rebuildRetryCount
   */
  readonly rebuildRetryCount?: number;

  /**
   * @schema ReplicaV1Beta2Spec#revisionCounterDisabled
   */
  readonly revisionCounterDisabled?: boolean;

  /**
   * @schema ReplicaV1Beta2Spec#salvageRequested
   */
  readonly salvageRequested?: boolean;

  /**
   * @schema ReplicaV1Beta2Spec#unmapMarkDiskChainRemovedEnabled
   */
  readonly unmapMarkDiskChainRemovedEnabled?: boolean;

  /**
   * @schema ReplicaV1Beta2Spec#volumeName
   */
  readonly volumeName?: string;

  /**
   * @schema ReplicaV1Beta2Spec#volumeSize
   */
  readonly volumeSize?: string;
}

/**
 * Converts an object of type 'ReplicaV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicaV1Beta2Spec(
  obj: ReplicaV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    active: obj.active,
    backendStoreDriver: obj.backendStoreDriver,
    backingImage: obj.backingImage,
    dataDirectoryName: obj.dataDirectoryName,
    desireState: obj.desireState,
    diskID: obj.diskId,
    diskPath: obj.diskPath,
    engineImage: obj.engineImage,
    engineName: obj.engineName,
    failedAt: obj.failedAt,
    hardNodeAffinity: obj.hardNodeAffinity,
    healthyAt: obj.healthyAt,
    logRequested: obj.logRequested,
    nodeID: obj.nodeId,
    rebuildRetryCount: obj.rebuildRetryCount,
    revisionCounterDisabled: obj.revisionCounterDisabled,
    salvageRequested: obj.salvageRequested,
    unmapMarkDiskChainRemovedEnabled: obj.unmapMarkDiskChainRemovedEnabled,
    volumeName: obj.volumeName,
    volumeSize: obj.volumeSize,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ReplicaV1Beta2SpecBackendStoreDriver
 */
export enum ReplicaV1Beta2SpecBackendStoreDriver {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * Setting is where Longhorn stores setting object.
 *
 * @schema Setting
 */
export class Setting extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Setting"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "Setting",
  };

  /**
   * Renders a Kubernetes manifest for "Setting".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SettingProps): any {
    return {
      ...Setting.GVK,
      ...toJson_SettingProps(props),
    };
  }

  /**
   * Defines a "Setting" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SettingProps) {
    super(scope, id, {
      ...Setting.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Setting.GVK,
      ...toJson_SettingProps(resolved),
    };
  }
}

/**
 * Setting is where Longhorn stores setting object.
 *
 * @schema Setting
 */
export interface SettingProps {
  /**
   * @schema Setting#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Setting#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'SettingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SettingProps(
  obj: SettingProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Setting is where Longhorn stores setting object.
 *
 * @schema SettingV1Beta2
 */
export class SettingV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SettingV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "Setting",
  };

  /**
   * Renders a Kubernetes manifest for "SettingV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SettingV1Beta2Props): any {
    return {
      ...SettingV1Beta2.GVK,
      ...toJson_SettingV1Beta2Props(props),
    };
  }

  /**
   * Defines a "SettingV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SettingV1Beta2Props) {
    super(scope, id, {
      ...SettingV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SettingV1Beta2.GVK,
      ...toJson_SettingV1Beta2Props(resolved),
    };
  }
}

/**
 * Setting is where Longhorn stores setting object.
 *
 * @schema SettingV1Beta2
 */
export interface SettingV1Beta2Props {
  /**
   * @schema SettingV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema SettingV1Beta2#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'SettingV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SettingV1Beta2Props(
  obj: SettingV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ShareManager is where Longhorn stores share manager object.
 *
 * @schema ShareManager
 */
export class ShareManager extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ShareManager"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "ShareManager",
  };

  /**
   * Renders a Kubernetes manifest for "ShareManager".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ShareManagerProps = {}): any {
    return {
      ...ShareManager.GVK,
      ...toJson_ShareManagerProps(props),
    };
  }

  /**
   * Defines a "ShareManager" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ShareManagerProps = {},
  ) {
    super(scope, id, {
      ...ShareManager.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ShareManager.GVK,
      ...toJson_ShareManagerProps(resolved),
    };
  }
}

/**
 * ShareManager is where Longhorn stores share manager object.
 *
 * @schema ShareManager
 */
export interface ShareManagerProps {
  /**
   * @schema ShareManager#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ShareManager#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'ShareManagerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ShareManagerProps(
  obj: ShareManagerProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ShareManager is where Longhorn stores share manager object.
 *
 * @schema ShareManagerV1Beta2
 */
export class ShareManagerV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ShareManagerV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "ShareManager",
  };

  /**
   * Renders a Kubernetes manifest for "ShareManagerV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ShareManagerV1Beta2Props = {}): any {
    return {
      ...ShareManagerV1Beta2.GVK,
      ...toJson_ShareManagerV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ShareManagerV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ShareManagerV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...ShareManagerV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ShareManagerV1Beta2.GVK,
      ...toJson_ShareManagerV1Beta2Props(resolved),
    };
  }
}

/**
 * ShareManager is where Longhorn stores share manager object.
 *
 * @schema ShareManagerV1Beta2
 */
export interface ShareManagerV1Beta2Props {
  /**
   * @schema ShareManagerV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ShareManagerSpec defines the desired state of the Longhorn share manager
   *
   * @schema ShareManagerV1Beta2#spec
   */
  readonly spec?: ShareManagerV1Beta2Spec;
}

/**
 * Converts an object of type 'ShareManagerV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ShareManagerV1Beta2Props(
  obj: ShareManagerV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ShareManagerV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ShareManagerSpec defines the desired state of the Longhorn share manager
 *
 * @schema ShareManagerV1Beta2Spec
 */
export interface ShareManagerV1Beta2Spec {
  /**
   * Share manager image used for creating a share manager pod
   *
   * @schema ShareManagerV1Beta2Spec#image
   */
  readonly image?: string;
}

/**
 * Converts an object of type 'ShareManagerV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ShareManagerV1Beta2Spec(
  obj: ShareManagerV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    image: obj.image,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Snapshot is the Schema for the snapshots API
 *
 * @schema Snapshot
 */
export class Snapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Snapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "Snapshot",
  };

  /**
   * Renders a Kubernetes manifest for "Snapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SnapshotProps = {}): any {
    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(props),
    };
  }

  /**
   * Defines a "Snapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SnapshotProps = {}) {
    super(scope, id, {
      ...Snapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Snapshot.GVK,
      ...toJson_SnapshotProps(resolved),
    };
  }
}

/**
 * Snapshot is the Schema for the snapshots API
 *
 * @schema Snapshot
 */
export interface SnapshotProps {
  /**
   * @schema Snapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SnapshotSpec defines the desired state of Longhorn Snapshot
   *
   * @schema Snapshot#spec
   */
  readonly spec?: SnapshotSpec;
}

/**
 * Converts an object of type 'SnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotProps(
  obj: SnapshotProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_SnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SnapshotSpec defines the desired state of Longhorn Snapshot
 *
 * @schema SnapshotSpec
 */
export interface SnapshotSpec {
  /**
   * require creating a new snapshot
   *
   * @schema SnapshotSpec#createSnapshot
   */
  readonly createSnapshot?: boolean;

  /**
   * The labels of snapshot
   *
   * @schema SnapshotSpec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * the volume that this snapshot belongs to. This field is immutable after creation. Required
   *
   * @schema SnapshotSpec#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'SnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SnapshotSpec(
  obj: SnapshotSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    createSnapshot: obj.createSnapshot,
    labels: obj.labels === undefined
      ? undefined
      : Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {},
      ),
    volume: obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SupportBundle is where Longhorn stores support bundle object
 *
 * @schema SupportBundle
 */
export class SupportBundle extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SupportBundle"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "SupportBundle",
  };

  /**
   * Renders a Kubernetes manifest for "SupportBundle".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SupportBundleProps = {}): any {
    return {
      ...SupportBundle.GVK,
      ...toJson_SupportBundleProps(props),
    };
  }

  /**
   * Defines a "SupportBundle" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: SupportBundleProps = {},
  ) {
    super(scope, id, {
      ...SupportBundle.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SupportBundle.GVK,
      ...toJson_SupportBundleProps(resolved),
    };
  }
}

/**
 * SupportBundle is where Longhorn stores support bundle object
 *
 * @schema SupportBundle
 */
export interface SupportBundleProps {
  /**
   * @schema SupportBundle#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SupportBundleSpec defines the desired state of the Longhorn SupportBundle
   *
   * @schema SupportBundle#spec
   */
  readonly spec?: SupportBundleSpec;
}

/**
 * Converts an object of type 'SupportBundleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SupportBundleProps(
  obj: SupportBundleProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_SupportBundleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SupportBundleSpec defines the desired state of the Longhorn SupportBundle
 *
 * @schema SupportBundleSpec
 */
export interface SupportBundleSpec {
  /**
   * A brief description of the issue
   *
   * @schema SupportBundleSpec#description
   */
  readonly description: string;

  /**
   * The issue URL
   *
   * @schema SupportBundleSpec#issueURL
   */
  readonly issueUrl?: string;

  /**
   * The preferred responsible controller node ID.
   *
   * @schema SupportBundleSpec#nodeID
   */
  readonly nodeId?: string;
}

/**
 * Converts an object of type 'SupportBundleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SupportBundleSpec(
  obj: SupportBundleSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    description: obj.description,
    issueURL: obj.issueUrl,
    nodeID: obj.nodeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SystemBackup is where Longhorn stores system backup object
 *
 * @schema SystemBackup
 */
export class SystemBackup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SystemBackup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "SystemBackup",
  };

  /**
   * Renders a Kubernetes manifest for "SystemBackup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SystemBackupProps = {}): any {
    return {
      ...SystemBackup.GVK,
      ...toJson_SystemBackupProps(props),
    };
  }

  /**
   * Defines a "SystemBackup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: SystemBackupProps = {},
  ) {
    super(scope, id, {
      ...SystemBackup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SystemBackup.GVK,
      ...toJson_SystemBackupProps(resolved),
    };
  }
}

/**
 * SystemBackup is where Longhorn stores system backup object
 *
 * @schema SystemBackup
 */
export interface SystemBackupProps {
  /**
   * @schema SystemBackup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SystemBackupSpec defines the desired state of the Longhorn SystemBackup
   *
   * @schema SystemBackup#spec
   */
  readonly spec?: SystemBackupSpec;
}

/**
 * Converts an object of type 'SystemBackupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SystemBackupProps(
  obj: SystemBackupProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_SystemBackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SystemBackupSpec defines the desired state of the Longhorn SystemBackup
 *
 * @schema SystemBackupSpec
 */
export interface SystemBackupSpec {
  /**
   * The create volume backup policy Can be "if-not-present", "always" or "disabled"
   *
   * @schema SystemBackupSpec#volumeBackupPolicy
   */
  readonly volumeBackupPolicy?: string;
}

/**
 * Converts an object of type 'SystemBackupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SystemBackupSpec(
  obj: SystemBackupSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    volumeBackupPolicy: obj.volumeBackupPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SystemRestore is where Longhorn stores system restore object
 *
 * @schema SystemRestore
 */
export class SystemRestore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SystemRestore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "SystemRestore",
  };

  /**
   * Renders a Kubernetes manifest for "SystemRestore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SystemRestoreProps = {}): any {
    return {
      ...SystemRestore.GVK,
      ...toJson_SystemRestoreProps(props),
    };
  }

  /**
   * Defines a "SystemRestore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: SystemRestoreProps = {},
  ) {
    super(scope, id, {
      ...SystemRestore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SystemRestore.GVK,
      ...toJson_SystemRestoreProps(resolved),
    };
  }
}

/**
 * SystemRestore is where Longhorn stores system restore object
 *
 * @schema SystemRestore
 */
export interface SystemRestoreProps {
  /**
   * @schema SystemRestore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SystemRestoreSpec defines the desired state of the Longhorn SystemRestore
   *
   * @schema SystemRestore#spec
   */
  readonly spec?: SystemRestoreSpec;
}

/**
 * Converts an object of type 'SystemRestoreProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SystemRestoreProps(
  obj: SystemRestoreProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_SystemRestoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SystemRestoreSpec defines the desired state of the Longhorn SystemRestore
 *
 * @schema SystemRestoreSpec
 */
export interface SystemRestoreSpec {
  /**
   * The system backup name in the object store.
   *
   * @schema SystemRestoreSpec#systemBackup
   */
  readonly systemBackup: string;
}

/**
 * Converts an object of type 'SystemRestoreSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SystemRestoreSpec(
  obj: SystemRestoreSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    systemBackup: obj.systemBackup,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Volume is where Longhorn stores volume object.
 *
 * @schema Volume
 */
export class Volume extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Volume"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta1",
    kind: "Volume",
  };

  /**
   * Renders a Kubernetes manifest for "Volume".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VolumeProps = {}): any {
    return {
      ...Volume.GVK,
      ...toJson_VolumeProps(props),
    };
  }

  /**
   * Defines a "Volume" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VolumeProps = {}) {
    super(scope, id, {
      ...Volume.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Volume.GVK,
      ...toJson_VolumeProps(resolved),
    };
  }
}

/**
 * Volume is where Longhorn stores volume object.
 *
 * @schema Volume
 */
export interface VolumeProps {
  /**
   * @schema Volume#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Volume#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'VolumeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeProps(
  obj: VolumeProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Volume is where Longhorn stores volume object.
 *
 * @schema VolumeV1Beta2
 */
export class VolumeV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VolumeV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "Volume",
  };

  /**
   * Renders a Kubernetes manifest for "VolumeV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VolumeV1Beta2Props = {}): any {
    return {
      ...VolumeV1Beta2.GVK,
      ...toJson_VolumeV1Beta2Props(props),
    };
  }

  /**
   * Defines a "VolumeV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: VolumeV1Beta2Props = {},
  ) {
    super(scope, id, {
      ...VolumeV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VolumeV1Beta2.GVK,
      ...toJson_VolumeV1Beta2Props(resolved),
    };
  }
}

/**
 * Volume is where Longhorn stores volume object.
 *
 * @schema VolumeV1Beta2
 */
export interface VolumeV1Beta2Props {
  /**
   * @schema VolumeV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VolumeSpec defines the desired state of the Longhorn volume
   *
   * @schema VolumeV1Beta2#spec
   */
  readonly spec?: VolumeV1Beta2Spec;
}

/**
 * Converts an object of type 'VolumeV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeV1Beta2Props(
  obj: VolumeV1Beta2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_VolumeV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeSpec defines the desired state of the Longhorn volume
 *
 * @schema VolumeV1Beta2Spec
 */
export interface VolumeV1Beta2Spec {
  /**
   * @schema VolumeV1Beta2Spec#Standby
   */
  readonly standby?: boolean;

  /**
   * @schema VolumeV1Beta2Spec#accessMode
   */
  readonly accessMode?: VolumeV1Beta2SpecAccessMode;

  /**
   * @schema VolumeV1Beta2Spec#backendStoreDriver
   */
  readonly backendStoreDriver?: VolumeV1Beta2SpecBackendStoreDriver;

  /**
   * @schema VolumeV1Beta2Spec#backingImage
   */
  readonly backingImage?: string;

  /**
   * @schema VolumeV1Beta2Spec#backupCompressionMethod
   */
  readonly backupCompressionMethod?: VolumeV1Beta2SpecBackupCompressionMethod;

  /**
   * @schema VolumeV1Beta2Spec#dataLocality
   */
  readonly dataLocality?: VolumeV1Beta2SpecDataLocality;

  /**
   * @schema VolumeV1Beta2Spec#dataSource
   */
  readonly dataSource?: string;

  /**
   * @schema VolumeV1Beta2Spec#disableFrontend
   */
  readonly disableFrontend?: boolean;

  /**
   * @schema VolumeV1Beta2Spec#diskSelector
   */
  readonly diskSelector?: string[];

  /**
   * @schema VolumeV1Beta2Spec#encrypted
   */
  readonly encrypted?: boolean;

  /**
   * @schema VolumeV1Beta2Spec#engineImage
   */
  readonly engineImage?: string;

  /**
   * @schema VolumeV1Beta2Spec#fromBackup
   */
  readonly fromBackup?: string;

  /**
   * @schema VolumeV1Beta2Spec#frontend
   */
  readonly frontend?: VolumeV1Beta2SpecFrontend;

  /**
   * @schema VolumeV1Beta2Spec#lastAttachedBy
   */
  readonly lastAttachedBy?: string;

  /**
   * @schema VolumeV1Beta2Spec#migratable
   */
  readonly migratable?: boolean;

  /**
   * @schema VolumeV1Beta2Spec#migrationNodeID
   */
  readonly migrationNodeId?: string;

  /**
   * @schema VolumeV1Beta2Spec#nodeID
   */
  readonly nodeId?: string;

  /**
   * @schema VolumeV1Beta2Spec#nodeSelector
   */
  readonly nodeSelector?: string[];

  /**
   * @schema VolumeV1Beta2Spec#numberOfReplicas
   */
  readonly numberOfReplicas?: number;

  /**
   * OfflineReplicaRebuilding is used to determine if the offline replica rebuilding feature is enabled or not
   *
   * @schema VolumeV1Beta2Spec#offlineReplicaRebuilding
   */
  readonly offlineReplicaRebuilding?: VolumeV1Beta2SpecOfflineReplicaRebuilding;

  /**
   * @schema VolumeV1Beta2Spec#replicaAutoBalance
   */
  readonly replicaAutoBalance?: VolumeV1Beta2SpecReplicaAutoBalance;

  /**
   * Replica soft anti affinity of the volume. Set enabled to allow replicas to be scheduled on the same node
   *
   * @schema VolumeV1Beta2Spec#replicaSoftAntiAffinity
   */
  readonly replicaSoftAntiAffinity?: VolumeV1Beta2SpecReplicaSoftAntiAffinity;

  /**
   * Replica zone soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same zone
   *
   * @schema VolumeV1Beta2Spec#replicaZoneSoftAntiAffinity
   */
  readonly replicaZoneSoftAntiAffinity?:
    VolumeV1Beta2SpecReplicaZoneSoftAntiAffinity;

  /**
   * @schema VolumeV1Beta2Spec#restoreVolumeRecurringJob
   */
  readonly restoreVolumeRecurringJob?:
    VolumeV1Beta2SpecRestoreVolumeRecurringJob;

  /**
   * @schema VolumeV1Beta2Spec#revisionCounterDisabled
   */
  readonly revisionCounterDisabled?: boolean;

  /**
   * @schema VolumeV1Beta2Spec#size
   */
  readonly size?: string;

  /**
   * @schema VolumeV1Beta2Spec#snapshotDataIntegrity
   */
  readonly snapshotDataIntegrity?: VolumeV1Beta2SpecSnapshotDataIntegrity;

  /**
   * @schema VolumeV1Beta2Spec#staleReplicaTimeout
   */
  readonly staleReplicaTimeout?: number;

  /**
   * @schema VolumeV1Beta2Spec#unmapMarkSnapChainRemoved
   */
  readonly unmapMarkSnapChainRemoved?:
    VolumeV1Beta2SpecUnmapMarkSnapChainRemoved;
}

/**
 * Converts an object of type 'VolumeV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeV1Beta2Spec(
  obj: VolumeV1Beta2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    Standby: obj.standby,
    accessMode: obj.accessMode,
    backendStoreDriver: obj.backendStoreDriver,
    backingImage: obj.backingImage,
    backupCompressionMethod: obj.backupCompressionMethod,
    dataLocality: obj.dataLocality,
    dataSource: obj.dataSource,
    disableFrontend: obj.disableFrontend,
    diskSelector: obj.diskSelector?.map((y) => y),
    encrypted: obj.encrypted,
    engineImage: obj.engineImage,
    fromBackup: obj.fromBackup,
    frontend: obj.frontend,
    lastAttachedBy: obj.lastAttachedBy,
    migratable: obj.migratable,
    migrationNodeID: obj.migrationNodeId,
    nodeID: obj.nodeId,
    nodeSelector: obj.nodeSelector?.map((y) => y),
    numberOfReplicas: obj.numberOfReplicas,
    offlineReplicaRebuilding: obj.offlineReplicaRebuilding,
    replicaAutoBalance: obj.replicaAutoBalance,
    replicaSoftAntiAffinity: obj.replicaSoftAntiAffinity,
    replicaZoneSoftAntiAffinity: obj.replicaZoneSoftAntiAffinity,
    restoreVolumeRecurringJob: obj.restoreVolumeRecurringJob,
    revisionCounterDisabled: obj.revisionCounterDisabled,
    size: obj.size,
    snapshotDataIntegrity: obj.snapshotDataIntegrity,
    staleReplicaTimeout: obj.staleReplicaTimeout,
    unmapMarkSnapChainRemoved: obj.unmapMarkSnapChainRemoved,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VolumeV1Beta2SpecAccessMode
 */
export enum VolumeV1Beta2SpecAccessMode {
  /** rwo */
  RWO = "rwo",
  /** rwx */
  RWX = "rwx",
}

/**
 * @schema VolumeV1Beta2SpecBackendStoreDriver
 */
export enum VolumeV1Beta2SpecBackendStoreDriver {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * @schema VolumeV1Beta2SpecBackupCompressionMethod
 */
export enum VolumeV1Beta2SpecBackupCompressionMethod {
  /** none */
  NONE = "none",
  /** lz4 */
  LZ4 = "lz4",
  /** gzip */
  GZIP = "gzip",
}

/**
 * @schema VolumeV1Beta2SpecDataLocality
 */
export enum VolumeV1Beta2SpecDataLocality {
  /** disabled */
  DISABLED = "disabled",
  /** best-effort */
  BEST_HYPHEN_EFFORT = "best-effort",
  /** strict-local */
  STRICT_HYPHEN_LOCAL = "strict-local",
}

/**
 * @schema VolumeV1Beta2SpecFrontend
 */
export enum VolumeV1Beta2SpecFrontend {
  /** blockdev */
  BLOCKDEV = "blockdev",
  /** iscsi */
  ISCSI = "iscsi",
  /** nvmf */
  NVMF = "nvmf",
}

/**
 * OfflineReplicaRebuilding is used to determine if the offline replica rebuilding feature is enabled or not
 *
 * @schema VolumeV1Beta2SpecOfflineReplicaRebuilding
 */
export enum VolumeV1Beta2SpecOfflineReplicaRebuilding {
  /** ignored */
  IGNORED = "ignored",
  /** disabled */
  DISABLED = "disabled",
  /** enabled */
  ENABLED = "enabled",
}

/**
 * @schema VolumeV1Beta2SpecReplicaAutoBalance
 */
export enum VolumeV1Beta2SpecReplicaAutoBalance {
  /** ignored */
  IGNORED = "ignored",
  /** disabled */
  DISABLED = "disabled",
  /** least-effort */
  LEAST_HYPHEN_EFFORT = "least-effort",
  /** best-effort */
  BEST_HYPHEN_EFFORT = "best-effort",
}

/**
 * Replica soft anti affinity of the volume. Set enabled to allow replicas to be scheduled on the same node
 *
 * @schema VolumeV1Beta2SpecReplicaSoftAntiAffinity
 */
export enum VolumeV1Beta2SpecReplicaSoftAntiAffinity {
  /** ignored */
  IGNORED = "ignored",
  /** enabled */
  ENABLED = "enabled",
  /** disabled */
  DISABLED = "disabled",
}

/**
 * Replica zone soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same zone
 *
 * @schema VolumeV1Beta2SpecReplicaZoneSoftAntiAffinity
 */
export enum VolumeV1Beta2SpecReplicaZoneSoftAntiAffinity {
  /** ignored */
  IGNORED = "ignored",
  /** enabled */
  ENABLED = "enabled",
  /** disabled */
  DISABLED = "disabled",
}

/**
 * @schema VolumeV1Beta2SpecRestoreVolumeRecurringJob
 */
export enum VolumeV1Beta2SpecRestoreVolumeRecurringJob {
  /** ignored */
  IGNORED = "ignored",
  /** enabled */
  ENABLED = "enabled",
  /** disabled */
  DISABLED = "disabled",
}

/**
 * @schema VolumeV1Beta2SpecSnapshotDataIntegrity
 */
export enum VolumeV1Beta2SpecSnapshotDataIntegrity {
  /** ignored */
  IGNORED = "ignored",
  /** disabled */
  DISABLED = "disabled",
  /** enabled */
  ENABLED = "enabled",
  /** fast-check */
  FAST_HYPHEN_CHECK = "fast-check",
}

/**
 * @schema VolumeV1Beta2SpecUnmapMarkSnapChainRemoved
 */
export enum VolumeV1Beta2SpecUnmapMarkSnapChainRemoved {
  /** ignored */
  IGNORED = "ignored",
  /** disabled */
  DISABLED = "disabled",
  /** enabled */
  ENABLED = "enabled",
}

/**
 * VolumeAttachment stores attachment information of a Longhorn volume
 *
 * @schema VolumeAttachment
 */
export class VolumeAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VolumeAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "longhorn.io/v1beta2",
    kind: "VolumeAttachment",
  };

  /**
   * Renders a Kubernetes manifest for "VolumeAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VolumeAttachmentProps = {}): any {
    return {
      ...VolumeAttachment.GVK,
      ...toJson_VolumeAttachmentProps(props),
    };
  }

  /**
   * Defines a "VolumeAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: VolumeAttachmentProps = {},
  ) {
    super(scope, id, {
      ...VolumeAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VolumeAttachment.GVK,
      ...toJson_VolumeAttachmentProps(resolved),
    };
  }
}

/**
 * VolumeAttachment stores attachment information of a Longhorn volume
 *
 * @schema VolumeAttachment
 */
export interface VolumeAttachmentProps {
  /**
   * @schema VolumeAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VolumeAttachmentSpec defines the desired state of Longhorn VolumeAttachment
   *
   * @schema VolumeAttachment#spec
   */
  readonly spec?: VolumeAttachmentSpec;
}

/**
 * Converts an object of type 'VolumeAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeAttachmentProps(
  obj: VolumeAttachmentProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_VolumeAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeAttachmentSpec defines the desired state of Longhorn VolumeAttachment
 *
 * @schema VolumeAttachmentSpec
 */
export interface VolumeAttachmentSpec {
  /**
   * @schema VolumeAttachmentSpec#attachmentTickets
   */
  readonly attachmentTickets?: {
    [key: string]: VolumeAttachmentSpecAttachmentTickets;
  };

  /**
   * The name of Longhorn volume of this VolumeAttachment
   *
   * @schema VolumeAttachmentSpec#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'VolumeAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeAttachmentSpec(
  obj: VolumeAttachmentSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    attachmentTickets: obj.attachmentTickets === undefined
      ? undefined
      : Object.entries(obj.attachmentTickets).reduce(
        (r, i) =>
          i[1] === undefined ? r : {
            ...r,
            [i[0]]: toJson_VolumeAttachmentSpecAttachmentTickets(i[1]),
          },
        {},
      ),
    volume: obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VolumeAttachmentSpecAttachmentTickets
 */
export interface VolumeAttachmentSpecAttachmentTickets {
  /**
   * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
   *
   * @schema VolumeAttachmentSpecAttachmentTickets#generation
   */
  readonly generation?: number;

  /**
   * The unique ID of this attachment. Used to differentiate different attachments of the same volume.
   *
   * @schema VolumeAttachmentSpecAttachmentTickets#id
   */
  readonly id?: string;

  /**
   * The node that this attachment is requesting
   *
   * @schema VolumeAttachmentSpecAttachmentTickets#nodeID
   */
  readonly nodeId?: string;

  /**
   * Optional additional parameter for this attachment
   *
   * @schema VolumeAttachmentSpecAttachmentTickets#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * @schema VolumeAttachmentSpecAttachmentTickets#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'VolumeAttachmentSpecAttachmentTickets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VolumeAttachmentSpecAttachmentTickets(
  obj: VolumeAttachmentSpecAttachmentTickets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    generation: obj.generation,
    id: obj.id,
    nodeID: obj.nodeId,
    parameters: obj.parameters === undefined
      ? undefined
      : Object.entries(obj.parameters).reduce(
        (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
        {},
      ),
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */
