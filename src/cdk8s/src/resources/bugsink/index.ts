import { Chart, Duration, Size } from "cdk8s";
import { Cpu, Deployment, DeploymentStrategy, EnvValue, Probe, Secret, Service, Volume } from "cdk8s-plus-31";
import { IntOrString, KubeCronJob, KubeNetworkPolicy, Quantity } from "../../../generated/imports/k8s.ts";
import { OnePasswordItem } from "../../../generated/imports/onepassword.com.ts";
import { TailscaleIngress } from "../../misc/tailscale.ts";
import { createCloudflareTunnelBinding } from "../../misc/cloudflare-tunnel.ts";
import { withCommonProps } from "../../misc/common.ts";
import versions from "../../versions.ts";

export function createBugsinkDeployment(chart: Chart) {
  // Bugsink v2.0.7+ runs as non-root user with UID 14237
  const UID = 14237;
  const GID = 14237;

  // 1Password secret containing:
  // - secret-key: Django secret key (64+ chars, use: openssl rand -base64 64)
  // - postgres-password: PostgreSQL password (generated by postgres-operator, copy from k8s secret)
  const bugsinkSecrets = new OnePasswordItem(chart, "bugsink-secrets", {
    spec: {
      itemPath: "vaults/v64ocnykdqju4ui6j6pua56xw4/items/bugsink-credentials",
    },
  });
  const secretRef = Secret.fromSecretName(chart, "bugsink-secrets-ref", bugsinkSecrets.name);

  // PostgreSQL credentials from postgres-operator
  const postgresSecretName = "bugsink.bugsink-postgresql.credentials.postgresql.acid.zalan.do";

  const deployment = new Deployment(chart, "bugsink", {
    replicas: 1,
    strategy: DeploymentStrategy.recreate(),
    securityContext: {
      fsGroup: GID,
    },
    podMetadata: {
      labels: {
        app: "bugsink",
      },
    },
  });

  // Create shared volumes
  const pgSecretVolume = Volume.fromSecret(
    chart,
    "bugsink-pg-secret-volume",
    Secret.fromSecretName(chart, "bugsink-pg-secret", postgresSecretName),
    {
      name: "pg-secret",
    },
  );
  const dbUrlVolume = Volume.fromEmptyDir(chart, "bugsink-db-url-volume", "bugsink-db-url");

  // Init container to build DATABASE_URL from postgres-operator secret
  deployment.addInitContainer(
    withCommonProps({
      name: "build-db-url",
      image: `library/busybox:${versions["library/busybox"]}`,
      command: ["/bin/sh", "-c"],
      args: [
        `
USER=$(cat /pg-secret/username)
PASS=$(cat /pg-secret/password)
echo "postgres://$USER:$PASS@bugsink-postgresql:5432/bugsink_db" > /db-url/url
echo "Database URL built successfully"
`,
      ],
      securityContext: {
        user: UID,
        group: GID,
        ensureNonRoot: true,
        readOnlyRootFilesystem: false,
      },
      volumeMounts: [
        {
          path: "/pg-secret",
          volume: pgSecretVolume,
          readOnly: true,
        },
        {
          path: "/db-url",
          volume: dbUrlVolume,
        },
      ],
    }),
  );

  // Init container to run Django migrations
  deployment.addInitContainer(
    withCommonProps({
      name: "migrate",
      image: `bugsink/bugsink:${versions["bugsink/bugsink"]}`,
      command: ["/bin/sh", "-c"],
      args: ["export DATABASE_URL=$(cat /db-url/url) && bugsink-manage migrate --noinput"],
      securityContext: {
        user: UID,
        group: GID,
        ensureNonRoot: true,
        allowPrivilegeEscalation: false,
        readOnlyRootFilesystem: false,
      },
      envVariables: {
        SECRET_KEY: EnvValue.fromSecretValue({
          secret: secretRef,
          key: "secret-key",
        }),
        DEBUG: EnvValue.fromValue("False"),
      },
      volumeMounts: [
        {
          path: "/db-url",
          volume: dbUrlVolume,
          readOnly: true,
        },
      ],
    }),
  );

  deployment.addContainer(
    withCommonProps({
      name: "bugsink",
      image: `bugsink/bugsink:${versions["bugsink/bugsink"]}`,
      command: ["/bin/sh", "-c"],
      args: ["export DATABASE_URL=$(cat /db-url/url) && bugsink-manage runserver 0.0.0.0:8000"],
      ports: [{ name: "http", number: 8000 }],
      envVariables: {
        // Security configuration
        SECRET_KEY: EnvValue.fromSecretValue({
          secret: secretRef,
          key: "secret-key",
        }),
        DEBUG: EnvValue.fromValue("False"),

        // URL configuration
        BASE_URL: EnvValue.fromValue("https://bugsink.shepherdjerred.com"),

        // Proxy configuration
        BEHIND_HTTPS_PROXY: EnvValue.fromValue("True"),

        // User registration - disable to prevent race condition vulnerability
        USER_REGISTRATION: EnvValue.fromValue("CB_NOBODY"),

        // Task processing - run synchronously, no Snappea worker needed
        TASK_ALWAYS_EAGER: EnvValue.fromValue("True"),
      },
      securityContext: {
        user: UID,
        group: GID,
        ensureNonRoot: true,
        allowPrivilegeEscalation: false,
        readOnlyRootFilesystem: false,
      },
      volumeMounts: [
        {
          path: "/db-url",
          volume: dbUrlVolume,
          readOnly: true,
        },
      ],
      resources: {
        cpu: {
          request: Cpu.millis(100),
          limit: Cpu.millis(750),
        },
        memory: {
          request: Size.mebibytes(256),
          limit: Size.gibibytes(1),
        },
      },
      liveness: Probe.fromTcpSocket({
        port: 8000,
        initialDelaySeconds: Duration.seconds(10),
        periodSeconds: Duration.seconds(30),
      }),
      readiness: Probe.fromTcpSocket({
        port: 8000,
        initialDelaySeconds: Duration.seconds(5),
        periodSeconds: Duration.seconds(10),
      }),
      startup: Probe.fromTcpSocket({
        port: 8000,
        // Django migrations can be slow - allow up to 5 minutes
        failureThreshold: 30,
        periodSeconds: Duration.seconds(10),
      }),
    }),
  );

  const service = new Service(chart, "bugsink-service", {
    selector: deployment,
    metadata: {
      labels: { app: "bugsink" },
    },
    ports: [{ port: 8000, name: "http" }],
  });

  // Network Policy - restrict egress to PostgreSQL and DNS only
  new KubeNetworkPolicy(chart, "bugsink-netpol", {
    metadata: { name: "bugsink-netpol" },
    spec: {
      podSelector: { matchLabels: { app: "bugsink" } },
      policyTypes: ["Egress", "Ingress"],
      ingress: [
        {
          // Allow from Tailscale and Cloudflare Tunnel
          from: [
            // Tailscale operator
            {
              namespaceSelector: {
                matchLabels: {
                  "kubernetes.io/metadata.name": "tailscale",
                },
              },
            },
            // Cloudflare tunnel
            {
              namespaceSelector: {
                matchLabels: {
                  "kubernetes.io/metadata.name": "cloudflare-tunnel",
                },
              },
            },
          ],
          ports: [{ port: IntOrString.fromNumber(8000), protocol: "TCP" }],
        },
      ],
      egress: [
        {
          // Allow DNS
          to: [
            {
              namespaceSelector: {},
              podSelector: {
                matchLabels: {
                  "k8s-app": "kube-dns",
                },
              },
            },
          ],
          ports: [
            { port: IntOrString.fromNumber(53), protocol: "UDP" },
            { port: IntOrString.fromNumber(53), protocol: "TCP" },
          ],
        },
        {
          // Allow PostgreSQL within namespace
          to: [
            {
              podSelector: {
                matchLabels: {
                  cluster_name: "bugsink-postgresql",
                },
              },
            },
          ],
          ports: [{ port: IntOrString.fromNumber(5432), protocol: "TCP" }],
        },
      ],
    },
  });

  // Tailscale Ingress with Funnel for public access (error ingestion from external clients)
  new TailscaleIngress(chart, "bugsink-tailscale-ingress", {
    service,
    host: "bugsink",
    funnel: true,
  });

  // Cloudflare Tunnel for public access
  createCloudflareTunnelBinding(chart, "bugsink-cf-tunnel", {
    serviceName: service.name,
    fqdn: "bugsink.shepherdjerred.com",
  });

  return { deployment, service };
}

export function createBugsinkHousekeepingCronJob(chart: Chart) {
  const UID = 14237;
  const GID = 14237;

  // Reuse bugsink secrets
  const bugsinkSecrets = new OnePasswordItem(chart, "bugsink-housekeeping-secrets", {
    spec: {
      itemPath: "vaults/v64ocnykdqju4ui6j6pua56xw4/items/bugsink-credentials",
    },
  });

  // PostgreSQL credentials
  const postgresSecretName = "bugsink.bugsink-postgresql.credentials.postgresql.acid.zalan.do";

  // CronJob for daily housekeeping at 3am
  new KubeCronJob(chart, "bugsink-housekeeping", {
    metadata: {
      name: "bugsink-housekeeping",
    },
    spec: {
      schedule: "0 3 * * *",
      timeZone: "America/Los_Angeles",
      concurrencyPolicy: "Forbid",
      successfulJobsHistoryLimit: 3,
      failedJobsHistoryLimit: 3,
      jobTemplate: {
        spec: {
          backoffLimit: 2,
          template: {
            spec: {
              restartPolicy: "OnFailure",
              securityContext: {
                runAsUser: UID,
                runAsGroup: GID,
                fsGroup: GID,
                runAsNonRoot: true,
              },
              initContainers: [
                {
                  name: "build-db-url",
                  image: `library/busybox:${versions["library/busybox"]}`,
                  command: ["/bin/sh", "-c"],
                  args: [
                    `
USER=$(cat /pg-secret/username)
PASS=$(cat /pg-secret/password)
echo "postgres://$USER:$PASS@bugsink-postgresql:5432/bugsink_db" > /db-url/url
`,
                  ],
                  volumeMounts: [
                    {
                      name: "pg-secret",
                      mountPath: "/pg-secret",
                      readOnly: true,
                    },
                    {
                      name: "db-url",
                      mountPath: "/db-url",
                    },
                  ],
                  securityContext: {
                    allowPrivilegeEscalation: false,
                    readOnlyRootFilesystem: false,
                  },
                },
              ],
              containers: [
                {
                  name: "housekeeping",
                  image: `bugsink/bugsink:${versions["bugsink/bugsink"]}`,
                  command: ["/bin/sh", "-c"],
                  args: [
                    `
export DATABASE_URL=$(cat /db-url/url)
echo "Running vacuum_tags..."
bugsink-manage vacuum_tags
echo "Running vacuum_files..."
bugsink-manage vacuum_files
echo "Running vacuum_eventless_issuetags..."
bugsink-manage vacuum_eventless_issuetags
echo "Running cleanup_eventstorage..."
bugsink-manage cleanup_eventstorage default
echo "Housekeeping complete!"
`,
                  ],
                  env: [
                    {
                      name: "SECRET_KEY",
                      valueFrom: {
                        secretKeyRef: {
                          name: bugsinkSecrets.name,
                          key: "secret-key",
                        },
                      },
                    },
                    {
                      name: "DEBUG",
                      value: "False",
                    },
                  ],
                  volumeMounts: [
                    {
                      name: "db-url",
                      mountPath: "/db-url",
                      readOnly: true,
                    },
                  ],
                  resources: {
                    requests: {
                      cpu: Quantity.fromString("100m"),
                      memory: Quantity.fromString("256Mi"),
                    },
                    limits: {
                      cpu: Quantity.fromString("500m"),
                      memory: Quantity.fromString("512Mi"),
                    },
                  },
                  securityContext: {
                    allowPrivilegeEscalation: false,
                    readOnlyRootFilesystem: false,
                  },
                },
              ],
              volumes: [
                {
                  name: "pg-secret",
                  secret: {
                    secretName: postgresSecretName,
                  },
                },
                {
                  name: "db-url",
                  emptyDir: {},
                },
              ],
            },
          },
        },
      },
    },
  });
}
