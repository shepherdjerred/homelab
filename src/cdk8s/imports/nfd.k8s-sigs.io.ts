// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "cdk8s";
import { Construct } from "constructs";

/**
 * NodeFeature resource holds the features discovered for one node in the
cluster.
 *
 * @schema NodeFeature
 */
export class NodeFeature extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodeFeature"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "nfd.k8s-sigs.io/v1alpha1",
    kind: "NodeFeature",
  };

  /**
   * Renders a Kubernetes manifest for "NodeFeature".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodeFeatureProps): any {
    return {
      ...NodeFeature.GVK,
      ...toJson_NodeFeatureProps(props),
    };
  }

  /**
   * Defines a "NodeFeature" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodeFeatureProps) {
    super(scope, id, {
      ...NodeFeature.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodeFeature.GVK,
      ...toJson_NodeFeatureProps(resolved),
    };
  }
}

/**
 * NodeFeature resource holds the features discovered for one node in the
 * cluster.
 *
 * @schema NodeFeature
 */
export interface NodeFeatureProps {
  /**
   * @schema NodeFeature#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of the NodeFeature, containing features discovered for a node.
   *
   * @schema NodeFeature#spec
   */
  readonly spec: NodeFeatureSpec;
}

/**
 * Converts an object of type 'NodeFeatureProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureProps(
  obj: NodeFeatureProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_NodeFeatureSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the NodeFeature, containing features discovered for a node.
 *
 * @schema NodeFeatureSpec
 */
export interface NodeFeatureSpec {
  /**
   * Features is the full "raw" features data that has been discovered.
   *
   * @schema NodeFeatureSpec#features
   */
  readonly features?: NodeFeatureSpecFeatures;

  /**
   * Labels is the set of node labels that are requested to be created.
   *
   * @schema NodeFeatureSpec#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'NodeFeatureSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureSpec(
  obj: NodeFeatureSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    features: toJson_NodeFeatureSpecFeatures(obj.features),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Features is the full "raw" features data that has been discovered.
 *
 * @schema NodeFeatureSpecFeatures
 */
export interface NodeFeatureSpecFeatures {
  /**
   * Attributes contains all the attribute-type features of the node.
   *
   * @schema NodeFeatureSpecFeatures#attributes
   */
  readonly attributes?: { [key: string]: NodeFeatureSpecFeaturesAttributes };

  /**
   * Flags contains all the flag-type features of the node.
   *
   * @schema NodeFeatureSpecFeatures#flags
   */
  readonly flags?: { [key: string]: NodeFeatureSpecFeaturesFlags };

  /**
   * Instances contains all the instance-type features of the node.
   *
   * @schema NodeFeatureSpecFeatures#instances
   */
  readonly instances?: { [key: string]: NodeFeatureSpecFeaturesInstances };
}

/**
 * Converts an object of type 'NodeFeatureSpecFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureSpecFeatures(
  obj: NodeFeatureSpecFeatures | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    attributes:
      obj.attributes === undefined
        ? undefined
        : Object.entries(obj.attributes).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]: toJson_NodeFeatureSpecFeaturesAttributes(i[1]),
                  },
            {},
          ),
    flags:
      obj.flags === undefined
        ? undefined
        : Object.entries(obj.flags).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : { ...r, [i[0]]: toJson_NodeFeatureSpecFeaturesFlags(i[1]) },
            {},
          ),
    instances:
      obj.instances === undefined
        ? undefined
        : Object.entries(obj.instances).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]: toJson_NodeFeatureSpecFeaturesInstances(i[1]),
                  },
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AttributeFeatureSet is a set of features having string value.
 *
 * @schema NodeFeatureSpecFeaturesAttributes
 */
export interface NodeFeatureSpecFeaturesAttributes {
  /**
   * Individual features of the feature set.
   *
   * @schema NodeFeatureSpecFeaturesAttributes#elements
   */
  readonly elements: { [key: string]: string };
}

/**
 * Converts an object of type 'NodeFeatureSpecFeaturesAttributes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureSpecFeaturesAttributes(
  obj: NodeFeatureSpecFeaturesAttributes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    elements:
      obj.elements === undefined
        ? undefined
        : Object.entries(obj.elements).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FlagFeatureSet is a set of simple features only containing names without values.
 *
 * @schema NodeFeatureSpecFeaturesFlags
 */
export interface NodeFeatureSpecFeaturesFlags {
  /**
   * Individual features of the feature set.
   *
   * @schema NodeFeatureSpecFeaturesFlags#elements
   */
  readonly elements: { [key: string]: any };
}

/**
 * Converts an object of type 'NodeFeatureSpecFeaturesFlags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureSpecFeaturesFlags(
  obj: NodeFeatureSpecFeaturesFlags | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    elements:
      obj.elements === undefined
        ? undefined
        : Object.entries(obj.elements).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InstanceFeatureSet is a set of features each of which is an instance having multiple attributes.
 *
 * @schema NodeFeatureSpecFeaturesInstances
 */
export interface NodeFeatureSpecFeaturesInstances {
  /**
   * Individual features of the feature set.
   *
   * @schema NodeFeatureSpecFeaturesInstances#elements
   */
  readonly elements: NodeFeatureSpecFeaturesInstancesElements[];
}

/**
 * Converts an object of type 'NodeFeatureSpecFeaturesInstances' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureSpecFeaturesInstances(
  obj: NodeFeatureSpecFeaturesInstances | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    elements: obj.elements?.map((y) =>
      toJson_NodeFeatureSpecFeaturesInstancesElements(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * InstanceFeature represents one instance of a complex features, e.g. a device.
 *
 * @schema NodeFeatureSpecFeaturesInstancesElements
 */
export interface NodeFeatureSpecFeaturesInstancesElements {
  /**
   * Attributes of the instance feature.
   *
   * @schema NodeFeatureSpecFeaturesInstancesElements#attributes
   */
  readonly attributes: { [key: string]: string };
}

/**
 * Converts an object of type 'NodeFeatureSpecFeaturesInstancesElements' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureSpecFeaturesInstancesElements(
  obj: NodeFeatureSpecFeaturesInstancesElements | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    attributes:
      obj.attributes === undefined
        ? undefined
        : Object.entries(obj.attributes).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeFeatureGroup resource holds Node pools by featureGroup
 *
 * @schema NodeFeatureGroup
 */
export class NodeFeatureGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodeFeatureGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "nfd.k8s-sigs.io/v1alpha1",
    kind: "NodeFeatureGroup",
  };

  /**
   * Renders a Kubernetes manifest for "NodeFeatureGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodeFeatureGroupProps): any {
    return {
      ...NodeFeatureGroup.GVK,
      ...toJson_NodeFeatureGroupProps(props),
    };
  }

  /**
   * Defines a "NodeFeatureGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: NodeFeatureGroupProps,
  ) {
    super(scope, id, {
      ...NodeFeatureGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodeFeatureGroup.GVK,
      ...toJson_NodeFeatureGroupProps(resolved),
    };
  }
}

/**
 * NodeFeatureGroup resource holds Node pools by featureGroup
 *
 * @schema NodeFeatureGroup
 */
export interface NodeFeatureGroupProps {
  /**
   * @schema NodeFeatureGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines the rules to be evaluated.
   *
   * @schema NodeFeatureGroup#spec
   */
  readonly spec: NodeFeatureGroupSpec;
}

/**
 * Converts an object of type 'NodeFeatureGroupProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureGroupProps(
  obj: NodeFeatureGroupProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_NodeFeatureGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the rules to be evaluated.
 *
 * @schema NodeFeatureGroupSpec
 */
export interface NodeFeatureGroupSpec {
  /**
   * List of rules to evaluate to determine nodes that belong in this group.
   *
   * @schema NodeFeatureGroupSpec#featureGroupRules
   */
  readonly featureGroupRules: NodeFeatureGroupSpecFeatureGroupRules[];
}

/**
 * Converts an object of type 'NodeFeatureGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureGroupSpec(
  obj: NodeFeatureGroupSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    featureGroupRules: obj.featureGroupRules?.map((y) =>
      toJson_NodeFeatureGroupSpecFeatureGroupRules(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GroupRule defines a rule for nodegroup filtering.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRules
 */
export interface NodeFeatureGroupSpecFeatureGroupRules {
  /**
   * MatchAny specifies a list of matchers one of which must match.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRules#matchAny
   */
  readonly matchAny?: NodeFeatureGroupSpecFeatureGroupRulesMatchAny[];

  /**
   * MatchFeatures specifies a set of matcher terms all of which must match.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRules#matchFeatures
   */
  readonly matchFeatures?: NodeFeatureGroupSpecFeatureGroupRulesMatchFeatures[];

  /**
   * Name of the rule.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRules#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'NodeFeatureGroupSpecFeatureGroupRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureGroupSpecFeatureGroupRules(
  obj: NodeFeatureGroupSpecFeatureGroupRules | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchAny: obj.matchAny?.map((y) =>
      toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchAny(y),
    ),
    matchFeatures: obj.matchFeatures?.map((y) =>
      toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchFeatures(y),
    ),
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MatchAnyElem specifies one sub-matcher of MatchAny.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAny
 */
export interface NodeFeatureGroupSpecFeatureGroupRulesMatchAny {
  /**
   * MatchFeatures specifies a set of matcher terms all of which must match.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAny#matchFeatures
   */
  readonly matchFeatures: NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeatures[];
}

/**
 * Converts an object of type 'NodeFeatureGroupSpecFeatureGroupRulesMatchAny' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchAny(
  obj: NodeFeatureGroupSpecFeatureGroupRulesMatchAny | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchFeatures: obj.matchFeatures?.map((y) =>
      toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeatures(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FeatureMatcherTerm defines requirements against one feature set. All
 * requirements (specified as MatchExpressions) are evaluated against each
 * element in the feature set.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeatures
 */
export interface NodeFeatureGroupSpecFeatureGroupRulesMatchFeatures {
  /**
   * Feature is the name of the feature set to match against.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeatures#feature
   */
  readonly feature: string;

  /**
   * MatchExpressions is the set of per-element expressions evaluated. These
   * match against the value of the specified elements.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeatures#matchExpressions
   */
  readonly matchExpressions?: {
    [
      key: string
    ]: NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressions;
  };

  /**
   * MatchName in an expression that is matched against the name of each
   * element in the feature set.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeatures#matchName
   */
  readonly matchName?: NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchName;
}

/**
 * Converts an object of type 'NodeFeatureGroupSpecFeatureGroupRulesMatchFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchFeatures(
  obj: NodeFeatureGroupSpecFeatureGroupRulesMatchFeatures | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    feature: obj.feature,
    matchExpressions:
      obj.matchExpressions === undefined
        ? undefined
        : Object.entries(obj.matchExpressions).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]:
                      toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressions(
                        i[1],
                      ),
                  },
            {},
          ),
    matchName:
      toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchName(
        obj.matchName,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FeatureMatcherTerm defines requirements against one feature set. All
 * requirements (specified as MatchExpressions) are evaluated against each
 * element in the feature set.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeatures
 */
export interface NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeatures {
  /**
   * Feature is the name of the feature set to match against.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeatures#feature
   */
  readonly feature: string;

  /**
   * MatchExpressions is the set of per-element expressions evaluated. These
   * match against the value of the specified elements.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeatures#matchExpressions
   */
  readonly matchExpressions?: {
    [
      key: string
    ]: NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressions;
  };

  /**
   * MatchName in an expression that is matched against the name of each
   * element in the feature set.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeatures#matchName
   */
  readonly matchName?: NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchName;
}

/**
 * Converts an object of type 'NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeatures(
  obj: NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeatures | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    feature: obj.feature,
    matchExpressions:
      obj.matchExpressions === undefined
        ? undefined
        : Object.entries(obj.matchExpressions).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]:
                      toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressions(
                        i[1],
                      ),
                  },
            {},
          ),
    matchName:
      toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchName(
        obj.matchName,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MatchExpression specifies an expression to evaluate against a set of input
 * values. It contains an operator that is applied when matching the input and
 * an array of values that the operator evaluates the input against.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressions
 */
export interface NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressions {
  /**
   * Op is the operator to be applied.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressions#op
   */
  readonly op: NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressionsOp;

  /**
   * Value is the list of values that the operand evaluates the input
   * against. Value should be empty if the operator is Exists, DoesNotExist,
   * IsTrue or IsFalse. Value should contain exactly one element if the
   * operator is Gt or Lt and exactly two elements if the operator is GtLt.
   * In other cases Value should contain at least one element.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressions#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressions(
  obj:
    | NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    op: obj.op,
    value: obj.value?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MatchName in an expression that is matched against the name of each
 * element in the feature set.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchName
 */
export interface NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchName {
  /**
   * Op is the operator to be applied.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchName#op
   */
  readonly op: NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchNameOp;

  /**
   * Value is the list of values that the operand evaluates the input
   * against. Value should be empty if the operator is Exists, DoesNotExist,
   * IsTrue or IsFalse. Value should contain exactly one element if the
   * operator is Gt or Lt and exactly two elements if the operator is GtLt.
   * In other cases Value should contain at least one element.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchName#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchName' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchName(
  obj: NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchName | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    op: obj.op,
    value: obj.value?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MatchExpression specifies an expression to evaluate against a set of input
 * values. It contains an operator that is applied when matching the input and
 * an array of values that the operator evaluates the input against.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressions
 */
export interface NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressions {
  /**
   * Op is the operator to be applied.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressions#op
   */
  readonly op: NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressionsOp;

  /**
   * Value is the list of values that the operand evaluates the input
   * against. Value should be empty if the operator is Exists, DoesNotExist,
   * IsTrue or IsFalse. Value should contain exactly one element if the
   * operator is Gt or Lt and exactly two elements if the operator is GtLt.
   * In other cases Value should contain at least one element.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressions#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressions(
  obj:
    | NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    op: obj.op,
    value: obj.value?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MatchName in an expression that is matched against the name of each
 * element in the feature set.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchName
 */
export interface NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchName {
  /**
   * Op is the operator to be applied.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchName#op
   */
  readonly op: NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchNameOp;

  /**
   * Value is the list of values that the operand evaluates the input
   * against. Value should be empty if the operator is Exists, DoesNotExist,
   * IsTrue or IsFalse. Value should contain exactly one element if the
   * operator is Gt or Lt and exactly two elements if the operator is GtLt.
   * In other cases Value should contain at least one element.
   *
   * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchName#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchName' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchName(
  obj:
    | NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchName
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    op: obj.op,
    value: obj.value?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Op is the operator to be applied.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressionsOp
 */
export enum NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchExpressionsOp {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** InRegexp */
  IN_REGEXP = "InRegexp",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
  /** Gt */
  GT = "Gt",
  /** Lt */
  LT = "Lt",
  /** GtLt */
  GT_LT = "GtLt",
  /** IsTrue */
  IS_TRUE = "IsTrue",
  /** IsFalse */
  IS_FALSE = "IsFalse",
}

/**
 * Op is the operator to be applied.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchNameOp
 */
export enum NodeFeatureGroupSpecFeatureGroupRulesMatchFeaturesMatchNameOp {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** InRegexp */
  IN_REGEXP = "InRegexp",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
  /** Gt */
  GT = "Gt",
  /** Lt */
  LT = "Lt",
  /** GtLt */
  GT_LT = "GtLt",
  /** IsTrue */
  IS_TRUE = "IsTrue",
  /** IsFalse */
  IS_FALSE = "IsFalse",
}

/**
 * Op is the operator to be applied.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressionsOp
 */
export enum NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchExpressionsOp {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** InRegexp */
  IN_REGEXP = "InRegexp",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
  /** Gt */
  GT = "Gt",
  /** Lt */
  LT = "Lt",
  /** GtLt */
  GT_LT = "GtLt",
  /** IsTrue */
  IS_TRUE = "IsTrue",
  /** IsFalse */
  IS_FALSE = "IsFalse",
}

/**
 * Op is the operator to be applied.
 *
 * @schema NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchNameOp
 */
export enum NodeFeatureGroupSpecFeatureGroupRulesMatchAnyMatchFeaturesMatchNameOp {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** InRegexp */
  IN_REGEXP = "InRegexp",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
  /** Gt */
  GT = "Gt",
  /** Lt */
  LT = "Lt",
  /** GtLt */
  GT_LT = "GtLt",
  /** IsTrue */
  IS_TRUE = "IsTrue",
  /** IsFalse */
  IS_FALSE = "IsFalse",
}

/**
 * NodeFeatureRule resource specifies a configuration for feature-based
customization of node objects, such as node labeling.
 *
 * @schema NodeFeatureRule
 */
export class NodeFeatureRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodeFeatureRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "nfd.k8s-sigs.io/v1alpha1",
    kind: "NodeFeatureRule",
  };

  /**
   * Renders a Kubernetes manifest for "NodeFeatureRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodeFeatureRuleProps): any {
    return {
      ...NodeFeatureRule.GVK,
      ...toJson_NodeFeatureRuleProps(props),
    };
  }

  /**
   * Defines a "NodeFeatureRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: NodeFeatureRuleProps,
  ) {
    super(scope, id, {
      ...NodeFeatureRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodeFeatureRule.GVK,
      ...toJson_NodeFeatureRuleProps(resolved),
    };
  }
}

/**
 * NodeFeatureRule resource specifies a configuration for feature-based
 * customization of node objects, such as node labeling.
 *
 * @schema NodeFeatureRule
 */
export interface NodeFeatureRuleProps {
  /**
   * @schema NodeFeatureRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines the rules to be evaluated.
   *
   * @schema NodeFeatureRule#spec
   */
  readonly spec: NodeFeatureRuleSpec;
}

/**
 * Converts an object of type 'NodeFeatureRuleProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureRuleProps(
  obj: NodeFeatureRuleProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_NodeFeatureRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the rules to be evaluated.
 *
 * @schema NodeFeatureRuleSpec
 */
export interface NodeFeatureRuleSpec {
  /**
   * Rules is a list of node customization rules.
   *
   * @schema NodeFeatureRuleSpec#rules
   */
  readonly rules: NodeFeatureRuleSpecRules[];
}

/**
 * Converts an object of type 'NodeFeatureRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureRuleSpec(
  obj: NodeFeatureRuleSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    rules: obj.rules?.map((y) => toJson_NodeFeatureRuleSpecRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Rule defines a rule for node customization such as labeling.
 *
 * @schema NodeFeatureRuleSpecRules
 */
export interface NodeFeatureRuleSpecRules {
  /**
   * Annotations to create if the rule matches.
   *
   * @schema NodeFeatureRuleSpecRules#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * ExtendedResources to create if the rule matches.
   *
   * @schema NodeFeatureRuleSpecRules#extendedResources
   */
  readonly extendedResources?: { [key: string]: string };

  /**
   * Labels to create if the rule matches.
   *
   * @schema NodeFeatureRuleSpecRules#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * LabelsTemplate specifies a template to expand for dynamically generating
   * multiple labels. Data (after template expansion) must be keys with an
   * optional value (<key>[=<value>]) separated by newlines.
   *
   * @schema NodeFeatureRuleSpecRules#labelsTemplate
   */
  readonly labelsTemplate?: string;

  /**
   * MatchAny specifies a list of matchers one of which must match.
   *
   * @schema NodeFeatureRuleSpecRules#matchAny
   */
  readonly matchAny?: NodeFeatureRuleSpecRulesMatchAny[];

  /**
   * MatchFeatures specifies a set of matcher terms all of which must match.
   *
   * @schema NodeFeatureRuleSpecRules#matchFeatures
   */
  readonly matchFeatures?: NodeFeatureRuleSpecRulesMatchFeatures[];

  /**
   * Name of the rule.
   *
   * @schema NodeFeatureRuleSpecRules#name
   */
  readonly name: string;

  /**
   * Taints to create if the rule matches.
   *
   * @schema NodeFeatureRuleSpecRules#taints
   */
  readonly taints?: NodeFeatureRuleSpecRulesTaints[];

  /**
   * Vars is the variables to store if the rule matches. Variables do not
   * directly inflict any changes in the node object. However, they can be
   * referenced from other rules enabling more complex rule hierarchies,
   * without exposing intermediary output values as labels.
   *
   * @schema NodeFeatureRuleSpecRules#vars
   */
  readonly vars?: { [key: string]: string };

  /**
   * VarsTemplate specifies a template to expand for dynamically generating
   * multiple variables. Data (after template expansion) must be keys with an
   * optional value (<key>[=<value>]) separated by newlines.
   *
   * @schema NodeFeatureRuleSpecRules#varsTemplate
   */
  readonly varsTemplate?: string;
}

/**
 * Converts an object of type 'NodeFeatureRuleSpecRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureRuleSpecRules(
  obj: NodeFeatureRuleSpecRules | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    extendedResources:
      obj.extendedResources === undefined
        ? undefined
        : Object.entries(obj.extendedResources).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    labelsTemplate: obj.labelsTemplate,
    matchAny: obj.matchAny?.map((y) =>
      toJson_NodeFeatureRuleSpecRulesMatchAny(y),
    ),
    matchFeatures: obj.matchFeatures?.map((y) =>
      toJson_NodeFeatureRuleSpecRulesMatchFeatures(y),
    ),
    name: obj.name,
    taints: obj.taints?.map((y) => toJson_NodeFeatureRuleSpecRulesTaints(y)),
    vars:
      obj.vars === undefined
        ? undefined
        : Object.entries(obj.vars).reduce(
            (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
            {},
          ),
    varsTemplate: obj.varsTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MatchAnyElem specifies one sub-matcher of MatchAny.
 *
 * @schema NodeFeatureRuleSpecRulesMatchAny
 */
export interface NodeFeatureRuleSpecRulesMatchAny {
  /**
   * MatchFeatures specifies a set of matcher terms all of which must match.
   *
   * @schema NodeFeatureRuleSpecRulesMatchAny#matchFeatures
   */
  readonly matchFeatures: NodeFeatureRuleSpecRulesMatchAnyMatchFeatures[];
}

/**
 * Converts an object of type 'NodeFeatureRuleSpecRulesMatchAny' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureRuleSpecRulesMatchAny(
  obj: NodeFeatureRuleSpecRulesMatchAny | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchFeatures: obj.matchFeatures?.map((y) =>
      toJson_NodeFeatureRuleSpecRulesMatchAnyMatchFeatures(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FeatureMatcherTerm defines requirements against one feature set. All
 * requirements (specified as MatchExpressions) are evaluated against each
 * element in the feature set.
 *
 * @schema NodeFeatureRuleSpecRulesMatchFeatures
 */
export interface NodeFeatureRuleSpecRulesMatchFeatures {
  /**
   * Feature is the name of the feature set to match against.
   *
   * @schema NodeFeatureRuleSpecRulesMatchFeatures#feature
   */
  readonly feature: string;

  /**
   * MatchExpressions is the set of per-element expressions evaluated. These
   * match against the value of the specified elements.
   *
   * @schema NodeFeatureRuleSpecRulesMatchFeatures#matchExpressions
   */
  readonly matchExpressions?: {
    [key: string]: NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressions;
  };

  /**
   * MatchName in an expression that is matched against the name of each
   * element in the feature set.
   *
   * @schema NodeFeatureRuleSpecRulesMatchFeatures#matchName
   */
  readonly matchName?: NodeFeatureRuleSpecRulesMatchFeaturesMatchName;
}

/**
 * Converts an object of type 'NodeFeatureRuleSpecRulesMatchFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureRuleSpecRulesMatchFeatures(
  obj: NodeFeatureRuleSpecRulesMatchFeatures | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    feature: obj.feature,
    matchExpressions:
      obj.matchExpressions === undefined
        ? undefined
        : Object.entries(obj.matchExpressions).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]:
                      toJson_NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressions(
                        i[1],
                      ),
                  },
            {},
          ),
    matchName: toJson_NodeFeatureRuleSpecRulesMatchFeaturesMatchName(
      obj.matchName,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The node this Taint is attached to has the "effect" on
 * any pod that does not tolerate the Taint.
 *
 * @schema NodeFeatureRuleSpecRulesTaints
 */
export interface NodeFeatureRuleSpecRulesTaints {
  /**
   * Required. The effect of the taint on pods
   * that do not tolerate the taint.
   * Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema NodeFeatureRuleSpecRulesTaints#effect
   */
  readonly effect: string;

  /**
   * Required. The taint key to be applied to a node.
   *
   * @schema NodeFeatureRuleSpecRulesTaints#key
   */
  readonly key: string;

  /**
   * TimeAdded represents the time at which the taint was added.
   * It is only written for NoExecute taints.
   *
   * @schema NodeFeatureRuleSpecRulesTaints#timeAdded
   */
  readonly timeAdded?: Date;

  /**
   * The taint value corresponding to the taint key.
   *
   * @schema NodeFeatureRuleSpecRulesTaints#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'NodeFeatureRuleSpecRulesTaints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureRuleSpecRulesTaints(
  obj: NodeFeatureRuleSpecRulesTaints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    timeAdded: obj.timeAdded?.toISOString(),
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FeatureMatcherTerm defines requirements against one feature set. All
 * requirements (specified as MatchExpressions) are evaluated against each
 * element in the feature set.
 *
 * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeatures
 */
export interface NodeFeatureRuleSpecRulesMatchAnyMatchFeatures {
  /**
   * Feature is the name of the feature set to match against.
   *
   * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeatures#feature
   */
  readonly feature: string;

  /**
   * MatchExpressions is the set of per-element expressions evaluated. These
   * match against the value of the specified elements.
   *
   * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeatures#matchExpressions
   */
  readonly matchExpressions?: {
    [
      key: string
    ]: NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressions;
  };

  /**
   * MatchName in an expression that is matched against the name of each
   * element in the feature set.
   *
   * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeatures#matchName
   */
  readonly matchName?: NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchName;
}

/**
 * Converts an object of type 'NodeFeatureRuleSpecRulesMatchAnyMatchFeatures' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureRuleSpecRulesMatchAnyMatchFeatures(
  obj: NodeFeatureRuleSpecRulesMatchAnyMatchFeatures | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    feature: obj.feature,
    matchExpressions:
      obj.matchExpressions === undefined
        ? undefined
        : Object.entries(obj.matchExpressions).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]:
                      toJson_NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressions(
                        i[1],
                      ),
                  },
            {},
          ),
    matchName: toJson_NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchName(
      obj.matchName,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MatchExpression specifies an expression to evaluate against a set of input
 * values. It contains an operator that is applied when matching the input and
 * an array of values that the operator evaluates the input against.
 *
 * @schema NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressions
 */
export interface NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressions {
  /**
   * Op is the operator to be applied.
   *
   * @schema NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressions#op
   */
  readonly op: NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressionsOp;

  /**
   * Value is the list of values that the operand evaluates the input
   * against. Value should be empty if the operator is Exists, DoesNotExist,
   * IsTrue or IsFalse. Value should contain exactly one element if the
   * operator is Gt or Lt and exactly two elements if the operator is GtLt.
   * In other cases Value should contain at least one element.
   *
   * @schema NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressions#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressions(
  obj: NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    op: obj.op,
    value: obj.value?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MatchName in an expression that is matched against the name of each
 * element in the feature set.
 *
 * @schema NodeFeatureRuleSpecRulesMatchFeaturesMatchName
 */
export interface NodeFeatureRuleSpecRulesMatchFeaturesMatchName {
  /**
   * Op is the operator to be applied.
   *
   * @schema NodeFeatureRuleSpecRulesMatchFeaturesMatchName#op
   */
  readonly op: NodeFeatureRuleSpecRulesMatchFeaturesMatchNameOp;

  /**
   * Value is the list of values that the operand evaluates the input
   * against. Value should be empty if the operator is Exists, DoesNotExist,
   * IsTrue or IsFalse. Value should contain exactly one element if the
   * operator is Gt or Lt and exactly two elements if the operator is GtLt.
   * In other cases Value should contain at least one element.
   *
   * @schema NodeFeatureRuleSpecRulesMatchFeaturesMatchName#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'NodeFeatureRuleSpecRulesMatchFeaturesMatchName' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureRuleSpecRulesMatchFeaturesMatchName(
  obj: NodeFeatureRuleSpecRulesMatchFeaturesMatchName | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    op: obj.op,
    value: obj.value?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MatchExpression specifies an expression to evaluate against a set of input
 * values. It contains an operator that is applied when matching the input and
 * an array of values that the operator evaluates the input against.
 *
 * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressions
 */
export interface NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressions {
  /**
   * Op is the operator to be applied.
   *
   * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressions#op
   */
  readonly op: NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressionsOp;

  /**
   * Value is the list of values that the operand evaluates the input
   * against. Value should be empty if the operator is Exists, DoesNotExist,
   * IsTrue or IsFalse. Value should contain exactly one element if the
   * operator is Gt or Lt and exactly two elements if the operator is GtLt.
   * In other cases Value should contain at least one element.
   *
   * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressions#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressions(
  obj:
    | NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    op: obj.op,
    value: obj.value?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MatchName in an expression that is matched against the name of each
 * element in the feature set.
 *
 * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchName
 */
export interface NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchName {
  /**
   * Op is the operator to be applied.
   *
   * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchName#op
   */
  readonly op: NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchNameOp;

  /**
   * Value is the list of values that the operand evaluates the input
   * against. Value should be empty if the operator is Exists, DoesNotExist,
   * IsTrue or IsFalse. Value should contain exactly one element if the
   * operator is Gt or Lt and exactly two elements if the operator is GtLt.
   * In other cases Value should contain at least one element.
   *
   * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchName#value
   */
  readonly value?: string[];
}

/**
 * Converts an object of type 'NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchName' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchName(
  obj: NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchName | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    op: obj.op,
    value: obj.value?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Op is the operator to be applied.
 *
 * @schema NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressionsOp
 */
export enum NodeFeatureRuleSpecRulesMatchFeaturesMatchExpressionsOp {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** InRegexp */
  IN_REGEXP = "InRegexp",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
  /** Gt */
  GT = "Gt",
  /** Lt */
  LT = "Lt",
  /** GtLt */
  GT_LT = "GtLt",
  /** IsTrue */
  IS_TRUE = "IsTrue",
  /** IsFalse */
  IS_FALSE = "IsFalse",
}

/**
 * Op is the operator to be applied.
 *
 * @schema NodeFeatureRuleSpecRulesMatchFeaturesMatchNameOp
 */
export enum NodeFeatureRuleSpecRulesMatchFeaturesMatchNameOp {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** InRegexp */
  IN_REGEXP = "InRegexp",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
  /** Gt */
  GT = "Gt",
  /** Lt */
  LT = "Lt",
  /** GtLt */
  GT_LT = "GtLt",
  /** IsTrue */
  IS_TRUE = "IsTrue",
  /** IsFalse */
  IS_FALSE = "IsFalse",
}

/**
 * Op is the operator to be applied.
 *
 * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressionsOp
 */
export enum NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchExpressionsOp {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** InRegexp */
  IN_REGEXP = "InRegexp",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
  /** Gt */
  GT = "Gt",
  /** Lt */
  LT = "Lt",
  /** GtLt */
  GT_LT = "GtLt",
  /** IsTrue */
  IS_TRUE = "IsTrue",
  /** IsFalse */
  IS_FALSE = "IsFalse",
}

/**
 * Op is the operator to be applied.
 *
 * @schema NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchNameOp
 */
export enum NodeFeatureRuleSpecRulesMatchAnyMatchFeaturesMatchNameOp {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** InRegexp */
  IN_REGEXP = "InRegexp",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
  /** Gt */
  GT = "Gt",
  /** Lt */
  LT = "Lt",
  /** GtLt */
  GT_LT = "GtLt",
  /** IsTrue */
  IS_TRUE = "IsTrue",
  /** IsFalse */
  IS_FALSE = "IsFalse",
}
