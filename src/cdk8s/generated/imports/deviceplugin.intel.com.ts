// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "cdk8s";
import { Construct } from "constructs";

/**
 * DEPRECATED: DlbDevicePlugin is the Schema for the dlbdeviceplugins API. It represents
the DLB device plugin responsible for advertising Intel DLB hardware resources to
the kubelet.
 *
 * @schema DlbDevicePlugin
 */
export class DlbDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DlbDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "DlbDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "DlbDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DlbDevicePluginProps = {}): any {
    return {
      ...DlbDevicePlugin.GVK,
      ...toJson_DlbDevicePluginProps(props),
    };
  }

  /**
   * Defines a "DlbDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DlbDevicePluginProps = {}) {
    super(scope, id, {
      ...DlbDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...DlbDevicePlugin.GVK,
      ...toJson_DlbDevicePluginProps(resolved),
    };
  }
}

/**
 * DEPRECATED: DlbDevicePlugin is the Schema for the dlbdeviceplugins API. It represents
 * the DLB device plugin responsible for advertising Intel DLB hardware resources to
 * the kubelet.
 *
 * @schema DlbDevicePlugin
 */
export interface DlbDevicePluginProps {
  /**
   * @schema DlbDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DlbDevicePluginSpec defines the desired state of DlbDevicePlugin.
   *
   * @schema DlbDevicePlugin#spec
   */
  readonly spec?: DlbDevicePluginSpec;
}

/**
 * Converts an object of type 'DlbDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DlbDevicePluginProps(obj: DlbDevicePluginProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_DlbDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DlbDevicePluginSpec defines the desired state of DlbDevicePlugin.
 *
 * @schema DlbDevicePluginSpec
 */
export interface DlbDevicePluginSpec {
  /**
   * Image is a container image with DLB device plugin executable.
   *
   * @schema DlbDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is a container image with a script that initializes devices.
   *
   * @schema DlbDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema DlbDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema DlbDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema DlbDevicePluginSpec#tolerations
   */
  readonly tolerations?: DlbDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'DlbDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DlbDevicePluginSpec(obj: DlbDevicePluginSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    image: obj.image,
    initImage: obj.initImage,
    logLevel: obj.logLevel,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    tolerations: obj.tolerations?.map((y) => toJson_DlbDevicePluginSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DlbDevicePluginSpecTolerations
 */
export interface DlbDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DlbDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DlbDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DlbDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema DlbDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DlbDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'DlbDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DlbDevicePluginSpecTolerations(
  obj: DlbDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DsaDevicePlugin is the Schema for the dsadeviceplugins API. It represents
the DSA device plugin responsible for advertising Intel DSA hardware resources to
the kubelet.
 *
 * @schema DsaDevicePlugin
 */
export class DsaDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DsaDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "DsaDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "DsaDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DsaDevicePluginProps = {}): any {
    return {
      ...DsaDevicePlugin.GVK,
      ...toJson_DsaDevicePluginProps(props),
    };
  }

  /**
   * Defines a "DsaDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DsaDevicePluginProps = {}) {
    super(scope, id, {
      ...DsaDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...DsaDevicePlugin.GVK,
      ...toJson_DsaDevicePluginProps(resolved),
    };
  }
}

/**
 * DsaDevicePlugin is the Schema for the dsadeviceplugins API. It represents
 * the DSA device plugin responsible for advertising Intel DSA hardware resources to
 * the kubelet.
 *
 * @schema DsaDevicePlugin
 */
export interface DsaDevicePluginProps {
  /**
   * @schema DsaDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DsaDevicePluginSpec defines the desired state of DsaDevicePlugin.
   *
   * @schema DsaDevicePlugin#spec
   */
  readonly spec?: DsaDevicePluginSpec;
}

/**
 * Converts an object of type 'DsaDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DsaDevicePluginProps(obj: DsaDevicePluginProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_DsaDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DsaDevicePluginSpec defines the desired state of DsaDevicePlugin.
 *
 * @schema DsaDevicePluginSpec
 */
export interface DsaDevicePluginSpec {
  /**
   * Image is a container image with DSA device plugin executable.
   *
   * @schema DsaDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is an initcontainer image to configure and enable DSA devices and workqueues with idxd-config (accel-config) utility
   *
   * @schema DsaDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema DsaDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema DsaDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * ProvisioningConfig is a ConfigMap used to pass the DSA devices and workqueues configuration into idxd-config initcontainer.
   *
   * @schema DsaDevicePluginSpec#provisioningConfig
   */
  readonly provisioningConfig?: string;

  /**
   * SharedDevNum is a number of containers that can share the same DSA device.
   *
   * @schema DsaDevicePluginSpec#sharedDevNum
   */
  readonly sharedDevNum?: number;

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema DsaDevicePluginSpec#tolerations
   */
  readonly tolerations?: DsaDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'DsaDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DsaDevicePluginSpec(obj: DsaDevicePluginSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    image: obj.image,
    initImage: obj.initImage,
    logLevel: obj.logLevel,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    provisioningConfig: obj.provisioningConfig,
    sharedDevNum: obj.sharedDevNum,
    tolerations: obj.tolerations?.map((y) => toJson_DsaDevicePluginSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DsaDevicePluginSpecTolerations
 */
export interface DsaDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DsaDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DsaDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DsaDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema DsaDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DsaDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'DsaDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DsaDevicePluginSpecTolerations(
  obj: DsaDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DEPRECATED: FpgaDevicePlugin is the Schema for the fpgadeviceplugins API. It represents
the FPGA device plugin responsible for advertising Intel FPGA hardware resources to
the kubelet.
 *
 * @schema FpgaDevicePlugin
 */
export class FpgaDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FpgaDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "FpgaDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "FpgaDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FpgaDevicePluginProps = {}): any {
    return {
      ...FpgaDevicePlugin.GVK,
      ...toJson_FpgaDevicePluginProps(props),
    };
  }

  /**
   * Defines a "FpgaDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FpgaDevicePluginProps = {}) {
    super(scope, id, {
      ...FpgaDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...FpgaDevicePlugin.GVK,
      ...toJson_FpgaDevicePluginProps(resolved),
    };
  }
}

/**
 * DEPRECATED: FpgaDevicePlugin is the Schema for the fpgadeviceplugins API. It represents
 * the FPGA device plugin responsible for advertising Intel FPGA hardware resources to
 * the kubelet.
 *
 * @schema FpgaDevicePlugin
 */
export interface FpgaDevicePluginProps {
  /**
   * @schema FpgaDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FpgaDevicePluginSpec defines the desired state of FpgaDevicePlugin.
   *
   * @schema FpgaDevicePlugin#spec
   */
  readonly spec?: FpgaDevicePluginSpec;
}

/**
 * Converts an object of type 'FpgaDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FpgaDevicePluginProps(obj: FpgaDevicePluginProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_FpgaDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FpgaDevicePluginSpec defines the desired state of FpgaDevicePlugin.
 *
 * @schema FpgaDevicePluginSpec
 */
export interface FpgaDevicePluginSpec {
  /**
   * Image is a container image with FPGA device plugin executable.
   *
   * @schema FpgaDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is a container image with tools used to initialize the host before starting FPGA workloads on it.
   *
   * @schema FpgaDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema FpgaDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * Mode is a mode of the plugin's operation.
   *
   * @schema FpgaDevicePluginSpec#mode
   */
  readonly mode?: FpgaDevicePluginSpecMode;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema FpgaDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema FpgaDevicePluginSpec#tolerations
   */
  readonly tolerations?: FpgaDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'FpgaDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FpgaDevicePluginSpec(obj: FpgaDevicePluginSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    image: obj.image,
    initImage: obj.initImage,
    logLevel: obj.logLevel,
    mode: obj.mode,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    tolerations: obj.tolerations?.map((y) => toJson_FpgaDevicePluginSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mode is a mode of the plugin's operation.
 *
 * @schema FpgaDevicePluginSpecMode
 */
export enum FpgaDevicePluginSpecMode {
  /** af */
  AF = "af",
  /** region */
  REGION = "region",
  /** regiondevel */
  REGIONDEVEL = "regiondevel",
}

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema FpgaDevicePluginSpecTolerations
 */
export interface FpgaDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema FpgaDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema FpgaDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema FpgaDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema FpgaDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema FpgaDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'FpgaDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FpgaDevicePluginSpecTolerations(
  obj: FpgaDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GpuDevicePlugin is the Schema for the gpudeviceplugins API. It represents
the GPU device plugin responsible for advertising Intel GPU hardware resources to
the kubelet.
 *
 * @schema GpuDevicePlugin
 */
export class GpuDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GpuDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "GpuDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "GpuDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GpuDevicePluginProps = {}): any {
    return {
      ...GpuDevicePlugin.GVK,
      ...toJson_GpuDevicePluginProps(props),
    };
  }

  /**
   * Defines a "GpuDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GpuDevicePluginProps = {}) {
    super(scope, id, {
      ...GpuDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GpuDevicePlugin.GVK,
      ...toJson_GpuDevicePluginProps(resolved),
    };
  }
}

/**
 * GpuDevicePlugin is the Schema for the gpudeviceplugins API. It represents
 * the GPU device plugin responsible for advertising Intel GPU hardware resources to
 * the kubelet.
 *
 * @schema GpuDevicePlugin
 */
export interface GpuDevicePluginProps {
  /**
   * @schema GpuDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GpuDevicePluginSpec defines the desired state of GpuDevicePlugin.
   *
   * @schema GpuDevicePlugin#spec
   */
  readonly spec?: GpuDevicePluginSpec;
}

/**
 * Converts an object of type 'GpuDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GpuDevicePluginProps(obj: GpuDevicePluginProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_GpuDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GpuDevicePluginSpec defines the desired state of GpuDevicePlugin.
 *
 * @schema GpuDevicePluginSpec
 */
export interface GpuDevicePluginSpec {
  /**
   * AllowIDs is a comma-separated list of PCI IDs of GPU devices that should only be advertised by the plugin.
   * If not set, all devices are advertised.
   * The list can contain IDs in the form of '0x1234,0x49a4,0x50b4'.
   * Cannot be used together with DenyIDs.
   *
   * @schema GpuDevicePluginSpec#allowIDs
   */
  readonly allowIDs?: string;

  /**
   * ByPathMode changes how plugin handles the DRM by-path/ directory mounting for GPU devices.
   * See GPU plugin documentation for detailed description of the modes.
   * If left empty, it defaults to 'single'.
   *
   * @schema GpuDevicePluginSpec#bypathMode
   */
  readonly bypathMode?: GpuDevicePluginSpecBypathMode;

  /**
   * DenyIDs is a comma-separated list of PCI IDs of GPU devices that should only be denied by the plugin.
   * If not set, all devices are advertised.
   * The list can contain IDs in the form of '0x1234,0x49a4,0x50b4'.
   * Cannot be used together with AllowIDs.
   *
   * @schema GpuDevicePluginSpec#denyIDs
   */
  readonly denyIDs?: string;

  /**
   * EnableMonitoring enables the monitoring resource ('i915_monitoring')
   * which gives access to all GPU devices on given node. Typically used with Intel XPU-Manager.
   *
   * @schema GpuDevicePluginSpec#enableMonitoring
   */
  readonly enableMonitoring?: boolean;

  /**
   * Image is a container image with GPU device plugin executable.
   *
   * @schema GpuDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is a container image with tools (e.g., GPU NFD source hook) installed on each node.
   *
   * @schema GpuDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema GpuDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema GpuDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PreferredAllocationPolicy sets the mode of allocating GPU devices on a node.
   * See documentation for detailed description of the policies. Only valid when SharedDevNum > 1 is set.
   *
   * @schema GpuDevicePluginSpec#preferredAllocationPolicy
   */
  readonly preferredAllocationPolicy?: GpuDevicePluginSpecPreferredAllocationPolicy;

  /**
   * SharedDevNum is a number of containers that can share the same GPU device.
   *
   * @schema GpuDevicePluginSpec#sharedDevNum
   */
  readonly sharedDevNum?: number;

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema GpuDevicePluginSpec#tolerations
   */
  readonly tolerations?: GpuDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'GpuDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GpuDevicePluginSpec(obj: GpuDevicePluginSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowIDs: obj.allowIDs,
    bypathMode: obj.bypathMode,
    denyIDs: obj.denyIDs,
    enableMonitoring: obj.enableMonitoring,
    image: obj.image,
    initImage: obj.initImage,
    logLevel: obj.logLevel,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    preferredAllocationPolicy: obj.preferredAllocationPolicy,
    sharedDevNum: obj.sharedDevNum,
    tolerations: obj.tolerations?.map((y) => toJson_GpuDevicePluginSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ByPathMode changes how plugin handles the DRM by-path/ directory mounting for GPU devices.
 * See GPU plugin documentation for detailed description of the modes.
 * If left empty, it defaults to 'single'.
 *
 * @schema GpuDevicePluginSpecBypathMode
 */
export enum GpuDevicePluginSpecBypathMode {
  /** none */
  NONE = "none",
  /** single */
  SINGLE = "single",
  /** all */
  ALL = "all",
}

/**
 * PreferredAllocationPolicy sets the mode of allocating GPU devices on a node.
 * See documentation for detailed description of the policies. Only valid when SharedDevNum > 1 is set.
 *
 * @schema GpuDevicePluginSpecPreferredAllocationPolicy
 */
export enum GpuDevicePluginSpecPreferredAllocationPolicy {
  /** balanced */
  BALANCED = "balanced",
  /** packed */
  PACKED = "packed",
  /** none */
  NONE = "none",
}

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema GpuDevicePluginSpecTolerations
 */
export interface GpuDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema GpuDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema GpuDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema GpuDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema GpuDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema GpuDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'GpuDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GpuDevicePluginSpecTolerations(
  obj: GpuDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IaaDevicePlugin is the Schema for the iaadeviceplugins API. It represents
the IAA device plugin responsible for advertising Intel IAA hardware resources to
the kubelet.
 *
 * @schema IaaDevicePlugin
 */
export class IaaDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IaaDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "IaaDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "IaaDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IaaDevicePluginProps = {}): any {
    return {
      ...IaaDevicePlugin.GVK,
      ...toJson_IaaDevicePluginProps(props),
    };
  }

  /**
   * Defines a "IaaDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IaaDevicePluginProps = {}) {
    super(scope, id, {
      ...IaaDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...IaaDevicePlugin.GVK,
      ...toJson_IaaDevicePluginProps(resolved),
    };
  }
}

/**
 * IaaDevicePlugin is the Schema for the iaadeviceplugins API. It represents
 * the IAA device plugin responsible for advertising Intel IAA hardware resources to
 * the kubelet.
 *
 * @schema IaaDevicePlugin
 */
export interface IaaDevicePluginProps {
  /**
   * @schema IaaDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IaaDevicePluginSpec defines the desired state of IaaDevicePlugin.
   *
   * @schema IaaDevicePlugin#spec
   */
  readonly spec?: IaaDevicePluginSpec;
}

/**
 * Converts an object of type 'IaaDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IaaDevicePluginProps(obj: IaaDevicePluginProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_IaaDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IaaDevicePluginSpec defines the desired state of IaaDevicePlugin.
 *
 * @schema IaaDevicePluginSpec
 */
export interface IaaDevicePluginSpec {
  /**
   * Image is a container image with IAA device plugin executable.
   *
   * @schema IaaDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is an initcontainer image to configure and enable IAA devices and workqueues with accel-config utility
   *
   * @schema IaaDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema IaaDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema IaaDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * ProvisioningConfig is a ConfigMap used to pass the IAA configuration into idxd initcontainer.
   *
   * @schema IaaDevicePluginSpec#provisioningConfig
   */
  readonly provisioningConfig?: string;

  /**
   * SharedDevNum is a number of containers that can share the same IAA device.
   *
   * @schema IaaDevicePluginSpec#sharedDevNum
   */
  readonly sharedDevNum?: number;

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema IaaDevicePluginSpec#tolerations
   */
  readonly tolerations?: IaaDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'IaaDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IaaDevicePluginSpec(obj: IaaDevicePluginSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    image: obj.image,
    initImage: obj.initImage,
    logLevel: obj.logLevel,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    provisioningConfig: obj.provisioningConfig,
    sharedDevNum: obj.sharedDevNum,
    tolerations: obj.tolerations?.map((y) => toJson_IaaDevicePluginSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema IaaDevicePluginSpecTolerations
 */
export interface IaaDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema IaaDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema IaaDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema IaaDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema IaaDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema IaaDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'IaaDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IaaDevicePluginSpecTolerations(
  obj: IaaDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NpuDevicePlugin is the Schema for the npudeviceplugins API. It represents
the NPU device plugin responsible for advertising Intel NPU hardware resources to
the kubelet.
 *
 * @schema NpuDevicePlugin
 */
export class NpuDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NpuDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "NpuDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "NpuDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NpuDevicePluginProps = {}): any {
    return {
      ...NpuDevicePlugin.GVK,
      ...toJson_NpuDevicePluginProps(props),
    };
  }

  /**
   * Defines a "NpuDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NpuDevicePluginProps = {}) {
    super(scope, id, {
      ...NpuDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...NpuDevicePlugin.GVK,
      ...toJson_NpuDevicePluginProps(resolved),
    };
  }
}

/**
 * NpuDevicePlugin is the Schema for the npudeviceplugins API. It represents
 * the NPU device plugin responsible for advertising Intel NPU hardware resources to
 * the kubelet.
 *
 * @schema NpuDevicePlugin
 */
export interface NpuDevicePluginProps {
  /**
   * @schema NpuDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NpuDevicePluginSpec defines the desired state of NpuDevicePlugin.
   *
   * @schema NpuDevicePlugin#spec
   */
  readonly spec?: NpuDevicePluginSpec;
}

/**
 * Converts an object of type 'NpuDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NpuDevicePluginProps(obj: NpuDevicePluginProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_NpuDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NpuDevicePluginSpec defines the desired state of NpuDevicePlugin.
 *
 * @schema NpuDevicePluginSpec
 */
export interface NpuDevicePluginSpec {
  /**
   * Image is a container image with NPU device plugin executable.
   *
   * @schema NpuDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema NpuDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema NpuDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * SharedDevNum is a number of containers that can share the same NPU device.
   *
   * @schema NpuDevicePluginSpec#sharedDevNum
   */
  readonly sharedDevNum?: number;

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema NpuDevicePluginSpec#tolerations
   */
  readonly tolerations?: NpuDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'NpuDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NpuDevicePluginSpec(obj: NpuDevicePluginSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    image: obj.image,
    logLevel: obj.logLevel,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    sharedDevNum: obj.sharedDevNum,
    tolerations: obj.tolerations?.map((y) => toJson_NpuDevicePluginSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema NpuDevicePluginSpecTolerations
 */
export interface NpuDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema NpuDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema NpuDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema NpuDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema NpuDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema NpuDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'NpuDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NpuDevicePluginSpecTolerations(
  obj: NpuDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * QatDevicePlugin is the Schema for the qatdeviceplugins API. It represents the QAT device
plugin responsible for advertising Intel QuickAssist Technology hardware resources
to the kubelet.
 *
 * @schema QatDevicePlugin
 */
export class QatDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "QatDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "QatDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "QatDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: QatDevicePluginProps = {}): any {
    return {
      ...QatDevicePlugin.GVK,
      ...toJson_QatDevicePluginProps(props),
    };
  }

  /**
   * Defines a "QatDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: QatDevicePluginProps = {}) {
    super(scope, id, {
      ...QatDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...QatDevicePlugin.GVK,
      ...toJson_QatDevicePluginProps(resolved),
    };
  }
}

/**
 * QatDevicePlugin is the Schema for the qatdeviceplugins API. It represents the QAT device
 * plugin responsible for advertising Intel QuickAssist Technology hardware resources
 * to the kubelet.
 *
 * @schema QatDevicePlugin
 */
export interface QatDevicePluginProps {
  /**
   * @schema QatDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * QatDevicePluginSpec defines the desired state of QatDevicePlugin.
   *
   * @schema QatDevicePlugin#spec
   */
  readonly spec?: QatDevicePluginSpec;
}

/**
 * Converts an object of type 'QatDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_QatDevicePluginProps(obj: QatDevicePluginProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_QatDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * QatDevicePluginSpec defines the desired state of QatDevicePlugin.
 *
 * @schema QatDevicePluginSpec
 */
export interface QatDevicePluginSpec {
  /**
   * DpdkDriver is a DPDK device driver for configuring the QAT device.
   *
   * @schema QatDevicePluginSpec#dpdkDriver
   */
  readonly dpdkDriver?: QatDevicePluginSpecDpdkDriver;

  /**
   * Image is a container image with QAT device plugin executable.
   *
   * @schema QatDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is a container image with a script that initialize devices.
   *
   * @schema QatDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * KernelVfDrivers is a list of VF device drivers for the QuickAssist devices in the system.
   *
   * @schema QatDevicePluginSpec#kernelVfDrivers
   */
  readonly kernelVfDrivers?: QatDevicePluginSpecKernelVfDrivers[];

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema QatDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * MaxNumDevices is a maximum number of QAT devices to be provided to the QuickAssist device plugin
   *
   * @schema QatDevicePluginSpec#maxNumDevices
   */
  readonly maxNumDevices?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema QatDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PreferredAllocationPolicy sets the mode of allocating QAT devices on a node.
   * See documentation for detailed description of the policies.
   *
   * @schema QatDevicePluginSpec#preferredAllocationPolicy
   */
  readonly preferredAllocationPolicy?: QatDevicePluginSpecPreferredAllocationPolicy;

  /**
   * ProvisioningConfig is a ConfigMap used to pass the configuration of QAT devices into qat initcontainer.
   *
   * @schema QatDevicePluginSpec#provisioningConfig
   */
  readonly provisioningConfig?: string;

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema QatDevicePluginSpec#tolerations
   */
  readonly tolerations?: QatDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'QatDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_QatDevicePluginSpec(obj: QatDevicePluginSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    dpdkDriver: obj.dpdkDriver,
    image: obj.image,
    initImage: obj.initImage,
    kernelVfDrivers: obj.kernelVfDrivers?.map((y) => y),
    logLevel: obj.logLevel,
    maxNumDevices: obj.maxNumDevices,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    preferredAllocationPolicy: obj.preferredAllocationPolicy,
    provisioningConfig: obj.provisioningConfig,
    tolerations: obj.tolerations?.map((y) => toJson_QatDevicePluginSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DpdkDriver is a DPDK device driver for configuring the QAT device.
 *
 * @schema QatDevicePluginSpecDpdkDriver
 */
export enum QatDevicePluginSpecDpdkDriver {
  /** igb_uio */
  IGB_UNDERSCORE_UIO = "igb_uio",
  /** vfio-pci */
  VFIO_HYPHEN_PCI = "vfio-pci",
}

/**
 * KernelVfDriver is a VF device driver for QuickAssist devices.
 *
 * @schema QatDevicePluginSpecKernelVfDrivers
 */
export enum QatDevicePluginSpecKernelVfDrivers {
  /** dh895xccvf */
  DH895XCCVF = "dh895xccvf",
  /** c6xxvf */
  C6XXVF = "c6xxvf",
  /** c3xxxvf */
  C3XXXVF = "c3xxxvf",
  /** d15xxvf */
  D15XXVF = "d15xxvf",
  /** 4xxxvf */
  VALUE_4XXXVF = "4xxxvf",
  /** 420xxvf */
  VALUE_420XXVF = "420xxvf",
  /** c4xxxvf */
  C4XXXVF = "c4xxxvf",
  /** 6xxxvf */
  VALUE_6XXXVF = "6xxxvf",
}

/**
 * PreferredAllocationPolicy sets the mode of allocating QAT devices on a node.
 * See documentation for detailed description of the policies.
 *
 * @schema QatDevicePluginSpecPreferredAllocationPolicy
 */
export enum QatDevicePluginSpecPreferredAllocationPolicy {
  /** balanced */
  BALANCED = "balanced",
  /** packed */
  PACKED = "packed",
}

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema QatDevicePluginSpecTolerations
 */
export interface QatDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema QatDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema QatDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema QatDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema QatDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema QatDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'QatDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_QatDevicePluginSpecTolerations(
  obj: QatDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SgxDevicePlugin is the Schema for the sgxdeviceplugins API. It represents
the SGX device plugin responsible for advertising SGX device nodes to
the kubelet.
 *
 * @schema SgxDevicePlugin
 */
export class SgxDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SgxDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "SgxDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "SgxDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SgxDevicePluginProps = {}): any {
    return {
      ...SgxDevicePlugin.GVK,
      ...toJson_SgxDevicePluginProps(props),
    };
  }

  /**
   * Defines a "SgxDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SgxDevicePluginProps = {}) {
    super(scope, id, {
      ...SgxDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...SgxDevicePlugin.GVK,
      ...toJson_SgxDevicePluginProps(resolved),
    };
  }
}

/**
 * SgxDevicePlugin is the Schema for the sgxdeviceplugins API. It represents
 * the SGX device plugin responsible for advertising SGX device nodes to
 * the kubelet.
 *
 * @schema SgxDevicePlugin
 */
export interface SgxDevicePluginProps {
  /**
   * @schema SgxDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SgxDevicePluginSpec defines the desired state of SgxDevicePlugin.
   *
   * @schema SgxDevicePlugin#spec
   */
  readonly spec?: SgxDevicePluginSpec;
}

/**
 * Converts an object of type 'SgxDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SgxDevicePluginProps(obj: SgxDevicePluginProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_SgxDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SgxDevicePluginSpec defines the desired state of SgxDevicePlugin.
 *
 * @schema SgxDevicePluginSpec
 */
export interface SgxDevicePluginSpec {
  /**
   * DcapInfraResources flag enables two special resources for Intel DCAP infrastructure containers.
   *
   * @schema SgxDevicePluginSpec#dcapInfraResources
   */
  readonly dcapInfraResources?: boolean;

  /**
   * EnclaveLimit is a number of containers that can share the same SGX enclave device.
   *
   * @schema SgxDevicePluginSpec#enclaveLimit
   */
  readonly enclaveLimit?: number;

  /**
   * Image is a container image with SGX device plugin executable.
   *
   * @schema SgxDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is a container image with tools (i.e., SGX NFD source hook) installed on each node.
   * Recommendation is to leave this unset and prefer the SGX NodeFeatureRule instead.
   *
   * @schema SgxDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema SgxDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema SgxDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * ProvisionLimit is a number of containers that can share the same SGX provision device.
   *
   * @schema SgxDevicePluginSpec#provisionLimit
   */
  readonly provisionLimit?: number;

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema SgxDevicePluginSpec#tolerations
   */
  readonly tolerations?: SgxDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'SgxDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SgxDevicePluginSpec(obj: SgxDevicePluginSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    dcapInfraResources: obj.dcapInfraResources,
    enclaveLimit: obj.enclaveLimit,
    image: obj.image,
    initImage: obj.initImage,
    logLevel: obj.logLevel,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    provisionLimit: obj.provisionLimit,
    tolerations: obj.tolerations?.map((y) => toJson_SgxDevicePluginSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema SgxDevicePluginSpecTolerations
 */
export interface SgxDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema SgxDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema SgxDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema SgxDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema SgxDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema SgxDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'SgxDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SgxDevicePluginSpecTolerations(
  obj: SgxDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
