// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "cdk8s";
import { Construct } from "constructs";

/**
 * AutoscalingListener is the Schema for the autoscalinglisteners API
 *
 * @schema AutoscalingListener
 */
export class AutoscalingListener extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AutoscalingListener"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "actions.github.com/v1alpha1",
    kind: "AutoscalingListener",
  };

  /**
   * Renders a Kubernetes manifest for "AutoscalingListener".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AutoscalingListenerProps = {}): any {
    return {
      ...AutoscalingListener.GVK,
      ...toJson_AutoscalingListenerProps(props),
    };
  }

  /**
   * Defines a "AutoscalingListener" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AutoscalingListenerProps = {}) {
    super(scope, id, {
      ...AutoscalingListener.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...AutoscalingListener.GVK,
      ...toJson_AutoscalingListenerProps(resolved),
    };
  }
}

/**
 * AutoscalingListener is the Schema for the autoscalinglisteners API
 *
 * @schema AutoscalingListener
 */
export interface AutoscalingListenerProps {
  /**
   * @schema AutoscalingListener#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AutoscalingListenerSpec defines the desired state of AutoscalingListener
   *
   * @schema AutoscalingListener#spec
   */
  readonly spec?: AutoscalingListenerSpec;
}

/**
 * Converts an object of type 'AutoscalingListenerProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerProps(
  obj: AutoscalingListenerProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_AutoscalingListenerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AutoscalingListenerSpec defines the desired state of AutoscalingListener
 *
 * @schema AutoscalingListenerSpec
 */
export interface AutoscalingListenerSpec {
  /**
   * Required
   *
   * @schema AutoscalingListenerSpec#autoscalingRunnerSetName
   */
  readonly autoscalingRunnerSetName?: string;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpec#autoscalingRunnerSetNamespace
   */
  readonly autoscalingRunnerSetNamespace?: string;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpec#ephemeralRunnerSetName
   */
  readonly ephemeralRunnerSetName?: string;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpec#githubConfigSecret
   */
  readonly githubConfigSecret?: string;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpec#githubConfigUrl
   */
  readonly githubConfigUrl?: string;

  /**
   * @schema AutoscalingListenerSpec#githubServerTLS
   */
  readonly githubServerTls?: AutoscalingListenerSpecGithubServerTls;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpec#image
   */
  readonly image?: string;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: AutoscalingListenerSpecImagePullSecrets[];

  /**
   * Required
   *
   * @schema AutoscalingListenerSpec#maxRunners
   */
  readonly maxRunners?: number;

  /**
   * MetricsConfig holds configuration parameters for each metric type
   *
   * @schema AutoscalingListenerSpec#metrics
   */
  readonly metrics?: AutoscalingListenerSpecMetrics;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpec#minRunners
   */
  readonly minRunners?: number;

  /**
   * @schema AutoscalingListenerSpec#proxy
   */
  readonly proxy?: AutoscalingListenerSpecProxy;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpec#runnerScaleSetId
   */
  readonly runnerScaleSetId?: number;

  /**
   * PodTemplateSpec describes the data a pod should have when created from a template
   *
   * @schema AutoscalingListenerSpec#template
   */
  readonly template?: AutoscalingListenerSpecTemplate;

  /**
   * @schema AutoscalingListenerSpec#vaultConfig
   */
  readonly vaultConfig?: AutoscalingListenerSpecVaultConfig;
}

/**
 * Converts an object of type 'AutoscalingListenerSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpec(
  obj: AutoscalingListenerSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    autoscalingRunnerSetName: obj.autoscalingRunnerSetName,
    autoscalingRunnerSetNamespace: obj.autoscalingRunnerSetNamespace,
    ephemeralRunnerSetName: obj.ephemeralRunnerSetName,
    githubConfigSecret: obj.githubConfigSecret,
    githubConfigUrl: obj.githubConfigUrl,
    githubServerTLS: toJson_AutoscalingListenerSpecGithubServerTls(obj.githubServerTls),
    image: obj.image,
    imagePullSecrets: obj.imagePullSecrets?.map((y) => toJson_AutoscalingListenerSpecImagePullSecrets(y)),
    maxRunners: obj.maxRunners,
    metrics: toJson_AutoscalingListenerSpecMetrics(obj.metrics),
    minRunners: obj.minRunners,
    proxy: toJson_AutoscalingListenerSpecProxy(obj.proxy),
    runnerScaleSetId: obj.runnerScaleSetId,
    template: toJson_AutoscalingListenerSpecTemplate(obj.template),
    vaultConfig: toJson_AutoscalingListenerSpecVaultConfig(obj.vaultConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecGithubServerTls
 */
export interface AutoscalingListenerSpecGithubServerTls {
  /**
   * Required
   *
   * @schema AutoscalingListenerSpecGithubServerTls#certificateFrom
   */
  readonly certificateFrom?: AutoscalingListenerSpecGithubServerTlsCertificateFrom;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecGithubServerTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecGithubServerTls(
  obj: AutoscalingListenerSpecGithubServerTls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certificateFrom: toJson_AutoscalingListenerSpecGithubServerTlsCertificateFrom(obj.certificateFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema AutoscalingListenerSpecImagePullSecrets
 */
export interface AutoscalingListenerSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecImagePullSecrets(
  obj: AutoscalingListenerSpecImagePullSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MetricsConfig holds configuration parameters for each metric type
 *
 * @schema AutoscalingListenerSpecMetrics
 */
export interface AutoscalingListenerSpecMetrics {
  /**
   * @schema AutoscalingListenerSpecMetrics#counters
   */
  readonly counters?: { [key: string]: AutoscalingListenerSpecMetricsCounters };

  /**
   * @schema AutoscalingListenerSpecMetrics#gauges
   */
  readonly gauges?: { [key: string]: AutoscalingListenerSpecMetricsGauges };

  /**
   * @schema AutoscalingListenerSpecMetrics#histograms
   */
  readonly histograms?: {
    [key: string]: AutoscalingListenerSpecMetricsHistograms;
  };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecMetrics' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecMetrics(
  obj: AutoscalingListenerSpecMetrics | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    counters:
      obj.counters === undefined
        ? undefined
        : Object.entries(obj.counters).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]: toJson_AutoscalingListenerSpecMetricsCounters(i[1]),
                  },
            {},
          ),
    gauges:
      obj.gauges === undefined
        ? undefined
        : Object.entries(obj.gauges).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]: toJson_AutoscalingListenerSpecMetricsGauges(i[1]),
                  },
            {},
          ),
    histograms:
      obj.histograms === undefined
        ? undefined
        : Object.entries(obj.histograms).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]: toJson_AutoscalingListenerSpecMetricsHistograms(i[1]),
                  },
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecProxy
 */
export interface AutoscalingListenerSpecProxy {
  /**
   * @schema AutoscalingListenerSpecProxy#http
   */
  readonly http?: AutoscalingListenerSpecProxyHttp;

  /**
   * @schema AutoscalingListenerSpecProxy#https
   */
  readonly https?: AutoscalingListenerSpecProxyHttps;

  /**
   * @schema AutoscalingListenerSpecProxy#noProxy
   */
  readonly noProxy?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecProxy(
  obj: AutoscalingListenerSpecProxy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_AutoscalingListenerSpecProxyHttp(obj.http),
    https: toJson_AutoscalingListenerSpecProxyHttps(obj.https),
    noProxy: obj.noProxy?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodTemplateSpec describes the data a pod should have when created from a template
 *
 * @schema AutoscalingListenerSpecTemplate
 */
export interface AutoscalingListenerSpecTemplate {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema AutoscalingListenerSpecTemplate#metadata
   */
  readonly metadata?: AutoscalingListenerSpecTemplateMetadata;

  /**
   * Specification of the desired behavior of the pod.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema AutoscalingListenerSpecTemplate#spec
   */
  readonly spec?: AutoscalingListenerSpecTemplateSpec;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplate(
  obj: AutoscalingListenerSpecTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: toJson_AutoscalingListenerSpecTemplateMetadata(obj.metadata),
    spec: toJson_AutoscalingListenerSpecTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecVaultConfig
 */
export interface AutoscalingListenerSpecVaultConfig {
  /**
   * @schema AutoscalingListenerSpecVaultConfig#azureKeyVault
   */
  readonly azureKeyVault?: AutoscalingListenerSpecVaultConfigAzureKeyVault;

  /**
   * @schema AutoscalingListenerSpecVaultConfig#proxy
   */
  readonly proxy?: AutoscalingListenerSpecVaultConfigProxy;

  /**
   * VaultType represents the type of vault that can be used in the application.
   * It is used to identify which vault integration should be used to resolve secrets.
   *
   * @schema AutoscalingListenerSpecVaultConfig#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecVaultConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecVaultConfig(
  obj: AutoscalingListenerSpecVaultConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    azureKeyVault: toJson_AutoscalingListenerSpecVaultConfigAzureKeyVault(obj.azureKeyVault),
    proxy: toJson_AutoscalingListenerSpecVaultConfigProxy(obj.proxy),
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required
 *
 * @schema AutoscalingListenerSpecGithubServerTlsCertificateFrom
 */
export interface AutoscalingListenerSpecGithubServerTlsCertificateFrom {
  /**
   * Required
   *
   * @schema AutoscalingListenerSpecGithubServerTlsCertificateFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: AutoscalingListenerSpecGithubServerTlsCertificateFromConfigMapKeyRef;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecGithubServerTlsCertificateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecGithubServerTlsCertificateFrom(
  obj: AutoscalingListenerSpecGithubServerTlsCertificateFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_AutoscalingListenerSpecGithubServerTlsCertificateFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CounterMetric holds configuration of a single metric of type Counter
 *
 * @schema AutoscalingListenerSpecMetricsCounters
 */
export interface AutoscalingListenerSpecMetricsCounters {
  /**
   * @schema AutoscalingListenerSpecMetricsCounters#labels
   */
  readonly labels: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecMetricsCounters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecMetricsCounters(
  obj: AutoscalingListenerSpecMetricsCounters | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labels: obj.labels?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GaugeMetric holds configuration of a single metric of type Gauge
 *
 * @schema AutoscalingListenerSpecMetricsGauges
 */
export interface AutoscalingListenerSpecMetricsGauges {
  /**
   * @schema AutoscalingListenerSpecMetricsGauges#labels
   */
  readonly labels: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecMetricsGauges' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecMetricsGauges(
  obj: AutoscalingListenerSpecMetricsGauges | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labels: obj.labels?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HistogramMetric holds configuration of a single metric of type Histogram
 *
 * @schema AutoscalingListenerSpecMetricsHistograms
 */
export interface AutoscalingListenerSpecMetricsHistograms {
  /**
   * @schema AutoscalingListenerSpecMetricsHistograms#buckets
   */
  readonly buckets?: number[];

  /**
   * @schema AutoscalingListenerSpecMetricsHistograms#labels
   */
  readonly labels: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecMetricsHistograms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecMetricsHistograms(
  obj: AutoscalingListenerSpecMetricsHistograms | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    buckets: obj.buckets?.map((y) => y),
    labels: obj.labels?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecProxyHttp
 */
export interface AutoscalingListenerSpecProxyHttp {
  /**
   * @schema AutoscalingListenerSpecProxyHttp#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpecProxyHttp#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecProxyHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecProxyHttp(
  obj: AutoscalingListenerSpecProxyHttp | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecProxyHttps
 */
export interface AutoscalingListenerSpecProxyHttps {
  /**
   * @schema AutoscalingListenerSpecProxyHttps#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpecProxyHttps#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecProxyHttps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecProxyHttps(
  obj: AutoscalingListenerSpecProxyHttps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Standard object's metadata.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema AutoscalingListenerSpecTemplateMetadata
 */
export interface AutoscalingListenerSpecTemplateMetadata {
  /**
   * @schema AutoscalingListenerSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema AutoscalingListenerSpecTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema AutoscalingListenerSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema AutoscalingListenerSpecTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema AutoscalingListenerSpecTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateMetadata(
  obj: AutoscalingListenerSpecTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    finalizers: obj.finalizers?.map((y) => y),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the desired behavior of the pod.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema AutoscalingListenerSpecTemplateSpec
 */
export interface AutoscalingListenerSpecTemplateSpec {
  /**
   * Optional duration in seconds the pod may be active on the node relative to
   * StartTime before the system will actively try to mark it failed and kill associated containers.
   * Value must be a positive integer.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema AutoscalingListenerSpecTemplateSpec#affinity
   */
  readonly affinity?: AutoscalingListenerSpecTemplateSpecAffinity;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * List of containers belonging to the pod.
   * Containers cannot currently be added or removed.
   * There must be at least one container in a Pod.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#containers
   */
  readonly containers: AutoscalingListenerSpecTemplateSpecContainers[];

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#dnsConfig
   */
  readonly dnsConfig?: AutoscalingListenerSpecTemplateSpecDnsConfig;

  /**
   * Set DNS policy for the pod.
   * Defaults to "ClusterFirst".
   * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
   * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
   * To have DNS options set along with hostNetwork, you have to specify DNS policy
   * explicitly to 'ClusterFirstWithHostNet'.
   *
   * @default ClusterFirst".
   * @schema AutoscalingListenerSpecTemplateSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's
   * environment variables, matching the syntax of Docker links.
   * Optional: Defaults to true.
   *
   * @default true.
   * @schema AutoscalingListenerSpecTemplateSpec#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
   * pod to perform user-initiated actions such as debugging. This list cannot be specified when
   * creating a pod, and it cannot be modified by updating the pod spec. In order to add an
   * ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#ephemeralContainers
   */
  readonly ephemeralContainers?: AutoscalingListenerSpecTemplateSpecEphemeralContainers[];

  /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
   * file if specified.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#hostAliases
   */
  readonly hostAliases?: AutoscalingListenerSpecTemplateSpecHostAliases[];

  /**
   * Use the host's ipc namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpec#hostIPC
   */
  readonly hostIpc?: boolean;

  /**
   * Host networking requested for this pod. Use the host's network namespace.
   * If this option is set, the ports that will be used must be specified.
   * Default to false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Use the host's pid namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpec#hostPID
   */
  readonly hostPid?: boolean;

  /**
   * Use the host's user namespace.
   * Optional: Default to true.
   * If set to true or not present, the pod will be run in the host user namespace, useful
   * for when the pod needs a feature only available to the host user namespace, such as
   * loading a kernel module with CAP_SYS_MODULE.
   * When set to false, a new userns is created for the pod. Setting false is useful for
   * mitigating container breakout vulnerabilities even allowing users to run their
   * containers as root without actually having root privileges on the host.
   * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
   *
   * @default true.
   * @schema AutoscalingListenerSpecTemplateSpec#hostUsers
   */
  readonly hostUsers?: boolean;

  /**
   * Specifies the hostname of the Pod
   * If not specified, the pod's hostname will be set to a system-defined value.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#hostname
   */
  readonly hostname?: string;

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
   * If specified, these secrets will be passed to individual puller implementations for them to use.
   * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema AutoscalingListenerSpecTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: AutoscalingListenerSpecTemplateSpecImagePullSecrets[];

  /**
   * List of initialization containers belonging to the pod.
   * Init containers are executed in order prior to containers being started. If any
   * init container fails, the pod is considered to have failed and is handled according
   * to its restartPolicy. The name for an init container or normal container must be
   * unique among all containers.
   * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
   * The resourceRequirements of an init container are taken into account during scheduling
   * by finding the highest request/limit for each resource type, and then using the max of
   * of that value or the sum of the normal containers. Limits are applied to init containers
   * in a similar fashion.
   * Init containers cannot currently be added or removed.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpec#initContainers
   */
  readonly initContainers?: AutoscalingListenerSpecTemplateSpecInitContainers[];

  /**
   * NodeName indicates in which node this pod is scheduled.
   * If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName.
   * Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod.
   * This field should not be used to express a desire for the pod to be scheduled on a specific node.
   * https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename
   *
   * @schema AutoscalingListenerSpecTemplateSpec#nodeName
   */
  readonly nodeName?: string;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema AutoscalingListenerSpecTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specifies the OS of the containers in the pod.
   * Some pod and container fields are restricted if this is set.
   *
   * If the OS field is set to linux, the following fields must be unset:
   * -securityContext.windowsOptions
   *
   * If the OS field is set to windows, following fields must be unset:
   * - spec.hostPID
   * - spec.hostIPC
   * - spec.hostUsers
   * - spec.securityContext.appArmorProfile
   * - spec.securityContext.seLinuxOptions
   * - spec.securityContext.seccompProfile
   * - spec.securityContext.fsGroup
   * - spec.securityContext.fsGroupChangePolicy
   * - spec.securityContext.sysctls
   * - spec.shareProcessNamespace
   * - spec.securityContext.runAsUser
   * - spec.securityContext.runAsGroup
   * - spec.securityContext.supplementalGroups
   * - spec.securityContext.supplementalGroupsPolicy
   * - spec.containers[*].securityContext.appArmorProfile
   * - spec.containers[*].securityContext.seLinuxOptions
   * - spec.containers[*].securityContext.seccompProfile
   * - spec.containers[*].securityContext.capabilities
   * - spec.containers[*].securityContext.readOnlyRootFilesystem
   * - spec.containers[*].securityContext.privileged
   * - spec.containers[*].securityContext.allowPrivilegeEscalation
   * - spec.containers[*].securityContext.procMount
   * - spec.containers[*].securityContext.runAsUser
   * - spec.containers[*].securityContext.runAsGroup
   *
   * @schema AutoscalingListenerSpecTemplateSpec#os
   */
  readonly os?: AutoscalingListenerSpecTemplateSpecOs;

  /**
   * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
   * This field will be autopopulated at admission time by the RuntimeClass admission controller. If
   * the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
   * The RuntimeClass admission controller will reject Pod create requests which have the overhead already
   * set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
   * defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
   *
   * @schema AutoscalingListenerSpecTemplateSpec#overhead
   */
  readonly overhead?: {
    [key: string]: AutoscalingListenerSpecTemplateSpecOverhead;
  };

  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority.
   * One of Never, PreemptLowerPriority.
   * Defaults to PreemptLowerPriority if unset.
   *
   * @default PreemptLowerPriority if unset.
   * @schema AutoscalingListenerSpecTemplateSpec#preemptionPolicy
   */
  readonly preemptionPolicy?: string;

  /**
   * The priority value. Various system components use this field to find the
   * priority of the pod. When Priority Admission Controller is enabled, it
   * prevents users from setting this field. The admission controller populates
   * this field from PriorityClassName.
   * The higher the value, the higher the priority.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#priority
   */
  readonly priority?: number;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and
   * "system-cluster-critical" are two special keywords which indicate the
   * highest priorities with the former being the highest priority. Any other
   * name must be defined by creating a PriorityClass object with that name.
   * If not specified, the pod priority will be default or zero if there is no
   * default.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, all readiness gates will be evaluated for pod readiness.
   * A pod is ready when all its containers are ready AND
   * all conditions specified in the readiness gates have status equal to "True"
   * More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
   *
   * @schema AutoscalingListenerSpecTemplateSpec#readinessGates
   */
  readonly readinessGates?: AutoscalingListenerSpecTemplateSpecReadinessGates[];

  /**
   * ResourceClaims defines which ResourceClaims must be allocated
   * and reserved before the Pod is allowed to start. The resources
   * will be made available to those containers which consume them
   * by name.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#resourceClaims
   */
  readonly resourceClaims?: AutoscalingListenerSpecTemplateSpecResourceClaims[];

  /**
   * Resources is the total amount of CPU and Memory resources required by all
   * containers in the pod. It supports specifying Requests and Limits for
   * "cpu" and "memory" resource names only. ResourceClaims are not supported.
   *
   * This field enables fine-grained control over resource allocation for the
   * entire pod, allowing resource sharing among containers in a pod.
   *
   * This is an alpha field and requires enabling the PodLevelResources feature
   * gate.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#resources
   */
  readonly resources?: AutoscalingListenerSpecTemplateSpecResources;

  /**
   * Restart policy for all containers within the pod.
   * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
   * Default to Always.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   *
   * @default Always.
   * @schema AutoscalingListenerSpecTemplateSpec#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
   * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
   * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
   * empty definition that uses the default runtime handler.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   *
   * @schema AutoscalingListenerSpecTemplateSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * If specified, the pod will be dispatched by specified scheduler.
   * If not specified, the pod will be dispatched by default scheduler.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * SchedulingGates is an opaque list of values that if specified will block scheduling the pod.
   * If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the
   * scheduler will not attempt to schedule the pod.
   *
   * SchedulingGates can only be set at pod creation time, and be removed only afterwards.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#schedulingGates
   */
  readonly schedulingGates?: AutoscalingListenerSpecTemplateSpecSchedulingGates[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * Optional: Defaults to empty.  See type description for default values of each field.
   *
   * @default empty.  See type description for default values of each field.
   * @schema AutoscalingListenerSpecTemplateSpec#securityContext
   */
  readonly securityContext?: AutoscalingListenerSpecTemplateSpecSecurityContext;

  /**
   * DeprecatedServiceAccount is a deprecated alias for ServiceAccountName.
   * Deprecated: Use serviceAccountName instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @schema AutoscalingListenerSpecTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
   * In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
   * In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
   * If a pod does not have FQDN, this has no effect.
   * Default to false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpec#setHostnameAsFQDN
   */
  readonly setHostnameAsFqdn?: boolean;

  /**
   * Share a single process namespace between all of the containers in a pod.
   * When this is set containers will be able to view and signal processes from other containers
   * in the same pod, and the first process in each container will not be assigned PID 1.
   * HostPID and ShareProcessNamespace cannot both be set.
   * Optional: Default to false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpec#shareProcessNamespace
   */
  readonly shareProcessNamespace?: boolean;

  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
   * If not specified, the pod will not have a domainname at all.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#subdomain
   */
  readonly subdomain?: string;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * If this value is nil, the default grace period will be used instead.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema AutoscalingListenerSpecTemplateSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#tolerations
   */
  readonly tolerations?: AutoscalingListenerSpecTemplateSpecTolerations[];

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology
   * domains. Scheduler will schedule pods in a way which abides by the constraints.
   * All topologySpreadConstraints are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints[];

  /**
   * List of volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema AutoscalingListenerSpecTemplateSpec#volumes
   */
  readonly volumes?: AutoscalingListenerSpecTemplateSpecVolumes[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpec(
  obj: AutoscalingListenerSpecTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    activeDeadlineSeconds: obj.activeDeadlineSeconds,
    affinity: toJson_AutoscalingListenerSpecTemplateSpecAffinity(obj.affinity),
    automountServiceAccountToken: obj.automountServiceAccountToken,
    containers: obj.containers?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecContainers(y)),
    dnsConfig: toJson_AutoscalingListenerSpecTemplateSpecDnsConfig(obj.dnsConfig),
    dnsPolicy: obj.dnsPolicy,
    enableServiceLinks: obj.enableServiceLinks,
    ephemeralContainers: obj.ephemeralContainers?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainers(y),
    ),
    hostAliases: obj.hostAliases?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecHostAliases(y)),
    hostIPC: obj.hostIpc,
    hostNetwork: obj.hostNetwork,
    hostPID: obj.hostPid,
    hostUsers: obj.hostUsers,
    hostname: obj.hostname,
    imagePullSecrets: obj.imagePullSecrets?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecImagePullSecrets(y)),
    initContainers: obj.initContainers?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecInitContainers(y)),
    nodeName: obj.nodeName,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    os: toJson_AutoscalingListenerSpecTemplateSpecOs(obj.os),
    overhead:
      obj.overhead === undefined
        ? undefined
        : Object.entries(obj.overhead).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    preemptionPolicy: obj.preemptionPolicy,
    priority: obj.priority,
    priorityClassName: obj.priorityClassName,
    readinessGates: obj.readinessGates?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecReadinessGates(y)),
    resourceClaims: obj.resourceClaims?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecResourceClaims(y)),
    resources: toJson_AutoscalingListenerSpecTemplateSpecResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    runtimeClassName: obj.runtimeClassName,
    schedulerName: obj.schedulerName,
    schedulingGates: obj.schedulingGates?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecSchedulingGates(y)),
    securityContext: toJson_AutoscalingListenerSpecTemplateSpecSecurityContext(obj.securityContext),
    serviceAccount: obj.serviceAccount,
    serviceAccountName: obj.serviceAccountName,
    setHostnameAsFQDN: obj.setHostnameAsFqdn,
    shareProcessNamespace: obj.shareProcessNamespace,
    subdomain: obj.subdomain,
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    tolerations: obj.tolerations?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecTolerations(y)),
    topologySpreadConstraints: obj.topologySpreadConstraints?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints(y),
    ),
    volumes: obj.volumes?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecVaultConfigAzureKeyVault
 */
export interface AutoscalingListenerSpecVaultConfigAzureKeyVault {
  /**
   * @schema AutoscalingListenerSpecVaultConfigAzureKeyVault#certificatePath
   */
  readonly certificatePath: string;

  /**
   * @schema AutoscalingListenerSpecVaultConfigAzureKeyVault#clientId
   */
  readonly clientId: string;

  /**
   * @schema AutoscalingListenerSpecVaultConfigAzureKeyVault#tenantId
   */
  readonly tenantId: string;

  /**
   * @schema AutoscalingListenerSpecVaultConfigAzureKeyVault#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecVaultConfigAzureKeyVault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecVaultConfigAzureKeyVault(
  obj: AutoscalingListenerSpecVaultConfigAzureKeyVault | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certificatePath: obj.certificatePath,
    clientId: obj.clientId,
    tenantId: obj.tenantId,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecVaultConfigProxy
 */
export interface AutoscalingListenerSpecVaultConfigProxy {
  /**
   * @schema AutoscalingListenerSpecVaultConfigProxy#http
   */
  readonly http?: AutoscalingListenerSpecVaultConfigProxyHttp;

  /**
   * @schema AutoscalingListenerSpecVaultConfigProxy#https
   */
  readonly https?: AutoscalingListenerSpecVaultConfigProxyHttps;

  /**
   * @schema AutoscalingListenerSpecVaultConfigProxy#noProxy
   */
  readonly noProxy?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecVaultConfigProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecVaultConfigProxy(
  obj: AutoscalingListenerSpecVaultConfigProxy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_AutoscalingListenerSpecVaultConfigProxyHttp(obj.http),
    https: toJson_AutoscalingListenerSpecVaultConfigProxyHttps(obj.https),
    noProxy: obj.noProxy?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required
 *
 * @schema AutoscalingListenerSpecGithubServerTlsCertificateFromConfigMapKeyRef
 */
export interface AutoscalingListenerSpecGithubServerTlsCertificateFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AutoscalingListenerSpecGithubServerTlsCertificateFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecGithubServerTlsCertificateFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AutoscalingListenerSpecGithubServerTlsCertificateFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecGithubServerTlsCertificateFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecGithubServerTlsCertificateFromConfigMapKeyRef(
  obj: AutoscalingListenerSpecGithubServerTlsCertificateFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If specified, the pod's scheduling constraints
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinity
 */
export interface AutoscalingListenerSpecTemplateSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: AutoscalingListenerSpecTemplateSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: AutoscalingListenerSpecTemplateSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinity(
  obj: AutoscalingListenerSpecTemplateSpecAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeAffinity: toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinity(obj.nodeAffinity),
    podAffinity: toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinity(obj.podAffinity),
    podAntiAffinity: toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainers
 */
export interface AutoscalingListenerSpecTemplateSpecContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#env
   */
  readonly env?: AutoscalingListenerSpecTemplateSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#envFrom
   */
  readonly envFrom?: AutoscalingListenerSpecTemplateSpecContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingListenerSpecTemplateSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#lifecycle
   */
  readonly lifecycle?: AutoscalingListenerSpecTemplateSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#livenessProbe
   */
  readonly livenessProbe?: AutoscalingListenerSpecTemplateSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#ports
   */
  readonly ports?: AutoscalingListenerSpecTemplateSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#readinessProbe
   */
  readonly readinessProbe?: AutoscalingListenerSpecTemplateSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#resizePolicy
   */
  readonly resizePolicy?: AutoscalingListenerSpecTemplateSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#resources
   */
  readonly resources?: AutoscalingListenerSpecTemplateSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#securityContext
   */
  readonly securityContext?: AutoscalingListenerSpecTemplateSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#startupProbe
   */
  readonly startupProbe?: AutoscalingListenerSpecTemplateSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema AutoscalingListenerSpecTemplateSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema AutoscalingListenerSpecTemplateSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema AutoscalingListenerSpecTemplateSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#volumeDevices
   */
  readonly volumeDevices?: AutoscalingListenerSpecTemplateSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#volumeMounts
   */
  readonly volumeMounts?: AutoscalingListenerSpecTemplateSpecContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainers(
  obj: AutoscalingListenerSpecTemplateSpecContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_AutoscalingListenerSpecTemplateSpecContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecContainersPorts(y)),
    readinessProbe: toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecContainersResizePolicy(y)),
    resources: toJson_AutoscalingListenerSpecTemplateSpecContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContext(obj.securityContext),
    startupProbe: toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecContainersVolumeDevices(y)),
    volumeMounts: obj.volumeMounts?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecContainersVolumeMounts(y)),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema AutoscalingListenerSpecTemplateSpecDnsConfig
 */
export interface AutoscalingListenerSpecTemplateSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecDnsConfig#options
   */
  readonly options?: AutoscalingListenerSpecTemplateSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecDnsConfig#searches
   */
  readonly searches?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecDnsConfig(
  obj: AutoscalingListenerSpecTemplateSpecDnsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nameservers: obj.nameservers?.map((y) => y),
    options: obj.options?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecDnsConfigOptions(y)),
    searches: obj.searches?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for
 * user-initiated activities such as debugging. Ephemeral containers have no resource or
 * scheduling guarantees, and they will not be restarted when they exit or when a Pod is
 * removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the
 * Pod to exceed its resource allocation.
 *
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing
 * Pod. Ephemeral containers may not be removed or restarted.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainers {
  /**
   * Arguments to the entrypoint.
   * The image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#env
   */
  readonly env?: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#envFrom
   */
  readonly envFrom?: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#lifecycle
   */
  readonly lifecycle?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecycle;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#livenessProbe
   */
  readonly livenessProbe?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe;

  /**
   * Name of the ephemeral container specified as a DNS_LABEL.
   * This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#name
   */
  readonly name: string;

  /**
   * Ports are not allowed for ephemeral containers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#ports
   */
  readonly ports?: AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts[];

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#readinessProbe
   */
  readonly readinessProbe?: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#resizePolicy
   */
  readonly resizePolicy?: AutoscalingListenerSpecTemplateSpecEphemeralContainersResizePolicy[];

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
   * already allocated to the pod.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#resources
   */
  readonly resources?: AutoscalingListenerSpecTemplateSpecEphemeralContainersResources;

  /**
   * Restart policy for the container to manage the restart behavior of each
   * container within a pod.
   * This may only be set for init containers. You cannot set this field on
   * ephemeral containers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#securityContext
   */
  readonly securityContext?: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#startupProbe
   */
  readonly startupProbe?: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets.
   * The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
   * If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   *
   * The container runtime must implement support for this feature. If the runtime does not
   * support namespace targeting then the result of setting this field is undefined.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#targetContainerName
   */
  readonly targetContainerName?: string;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#volumeDevices
   */
  readonly volumeDevices?: AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#volumeMounts
   */
  readonly volumeMounts?: AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainers(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts(y)),
    readinessProbe: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersResizePolicy(y),
    ),
    resources: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext(obj.securityContext),
    startupProbe: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    targetContainerName: obj.targetContainerName,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeDevices(y),
    ),
    volumeMounts: obj.volumeMounts?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts(y),
    ),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema AutoscalingListenerSpecTemplateSpecHostAliases
 */
export interface AutoscalingListenerSpecTemplateSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema AutoscalingListenerSpecTemplateSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema AutoscalingListenerSpecTemplateSpecHostAliases#ip
   */
  readonly ip: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecHostAliases(
  obj: AutoscalingListenerSpecTemplateSpecHostAliases | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    hostnames: obj.hostnames?.map((y) => y),
    ip: obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema AutoscalingListenerSpecTemplateSpecImagePullSecrets
 */
export interface AutoscalingListenerSpecTemplateSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecImagePullSecrets(
  obj: AutoscalingListenerSpecTemplateSpecImagePullSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainers
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#env
   */
  readonly env?: AutoscalingListenerSpecTemplateSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#envFrom
   */
  readonly envFrom?: AutoscalingListenerSpecTemplateSpecInitContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#lifecycle
   */
  readonly lifecycle?: AutoscalingListenerSpecTemplateSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#ports
   */
  readonly ports?: AutoscalingListenerSpecTemplateSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: AutoscalingListenerSpecTemplateSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#resources
   */
  readonly resources?: AutoscalingListenerSpecTemplateSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#securityContext
   */
  readonly securityContext?: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#startupProbe
   */
  readonly startupProbe?: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: AutoscalingListenerSpecTemplateSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainers(
  obj: AutoscalingListenerSpecTemplateSpecInitContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecInitContainersPorts(y)),
    readinessProbe: toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecInitContainersResizePolicy(y)),
    resources: toJson_AutoscalingListenerSpecTemplateSpecInitContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext(obj.securityContext),
    startupProbe: toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecInitContainersVolumeDevices(y),
    ),
    volumeMounts: obj.volumeMounts?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts(y)),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the OS of the containers in the pod.
 * Some pod and container fields are restricted if this is set.
 *
 * If the OS field is set to linux, the following fields must be unset:
 * -securityContext.windowsOptions
 *
 * If the OS field is set to windows, following fields must be unset:
 * - spec.hostPID
 * - spec.hostIPC
 * - spec.hostUsers
 * - spec.securityContext.appArmorProfile
 * - spec.securityContext.seLinuxOptions
 * - spec.securityContext.seccompProfile
 * - spec.securityContext.fsGroup
 * - spec.securityContext.fsGroupChangePolicy
 * - spec.securityContext.sysctls
 * - spec.shareProcessNamespace
 * - spec.securityContext.runAsUser
 * - spec.securityContext.runAsGroup
 * - spec.securityContext.supplementalGroups
 * - spec.securityContext.supplementalGroupsPolicy
 * - spec.containers[*].securityContext.appArmorProfile
 * - spec.containers[*].securityContext.seLinuxOptions
 * - spec.containers[*].securityContext.seccompProfile
 * - spec.containers[*].securityContext.capabilities
 * - spec.containers[*].securityContext.readOnlyRootFilesystem
 * - spec.containers[*].securityContext.privileged
 * - spec.containers[*].securityContext.allowPrivilegeEscalation
 * - spec.containers[*].securityContext.procMount
 * - spec.containers[*].securityContext.runAsUser
 * - spec.containers[*].securityContext.runAsGroup
 *
 * @schema AutoscalingListenerSpecTemplateSpecOs
 */
export interface AutoscalingListenerSpecTemplateSpecOs {
  /**
   * Name is the name of the operating system. The currently supported values are linux and windows.
   * Additional value may be defined in future and can be one of:
   * https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
   * Clients should expect to handle additional values and treat unrecognized values in this field as os: null
   *
   * @schema AutoscalingListenerSpecTemplateSpecOs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecOs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecOs(
  obj: AutoscalingListenerSpecTemplateSpecOs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecTemplateSpecOverhead
 */
export class AutoscalingListenerSpecTemplateSpecOverhead {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecOverhead {
    return new AutoscalingListenerSpecTemplateSpecOverhead(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecOverhead {
    return new AutoscalingListenerSpecTemplateSpecOverhead(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema AutoscalingListenerSpecTemplateSpecReadinessGates
 */
export interface AutoscalingListenerSpecTemplateSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema AutoscalingListenerSpecTemplateSpecReadinessGates#conditionType
   */
  readonly conditionType: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecReadinessGates(
  obj: AutoscalingListenerSpecTemplateSpecReadinessGates | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conditionType: obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodResourceClaim references exactly one ResourceClaim, either directly
 * or by naming a ResourceClaimTemplate which is then turned into a ResourceClaim
 * for the pod.
 *
 * It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
 * Containers that need access to the ResourceClaim reference it with this name.
 *
 * @schema AutoscalingListenerSpecTemplateSpecResourceClaims
 */
export interface AutoscalingListenerSpecTemplateSpecResourceClaims {
  /**
   * Name uniquely identifies this resource claim inside the pod.
   * This must be a DNS_LABEL.
   *
   * @schema AutoscalingListenerSpecTemplateSpecResourceClaims#name
   */
  readonly name: string;

  /**
   * ResourceClaimName is the name of a ResourceClaim object in the same
   * namespace as this pod.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema AutoscalingListenerSpecTemplateSpecResourceClaims#resourceClaimName
   */
  readonly resourceClaimName?: string;

  /**
   * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
   * object in the same namespace as this pod.
   *
   * The template will be used to create a new ResourceClaim, which will
   * be bound to this pod. When this pod is deleted, the ResourceClaim
   * will also be deleted. The pod name and resource name, along with a
   * generated component, will be used to form a unique name for the
   * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
   *
   * This field is immutable and no changes will be made to the
   * corresponding ResourceClaim by the control plane after creating the
   * ResourceClaim.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema AutoscalingListenerSpecTemplateSpecResourceClaims#resourceClaimTemplateName
   */
  readonly resourceClaimTemplateName?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecResourceClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecResourceClaims(
  obj: AutoscalingListenerSpecTemplateSpecResourceClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    resourceClaimName: obj.resourceClaimName,
    resourceClaimTemplateName: obj.resourceClaimTemplateName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources is the total amount of CPU and Memory resources required by all
 * containers in the pod. It supports specifying Requests and Limits for
 * "cpu" and "memory" resource names only. ResourceClaims are not supported.
 *
 * This field enables fine-grained control over resource allocation for the
 * entire pod, allowing resource sharing among containers in a pod.
 *
 * This is an alpha field and requires enabling the PodLevelResources feature
 * gate.
 *
 * @schema AutoscalingListenerSpecTemplateSpecResources
 */
export interface AutoscalingListenerSpecTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecResources#claims
   */
  readonly claims?: AutoscalingListenerSpecTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingListenerSpecTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingListenerSpecTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecResources(
  obj: AutoscalingListenerSpecTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodSchedulingGate is associated to a Pod to guard its scheduling.
 *
 * @schema AutoscalingListenerSpecTemplateSpecSchedulingGates
 */
export interface AutoscalingListenerSpecTemplateSpecSchedulingGates {
  /**
   * Name of the scheduling gate.
   * Each scheduling gate must have a unique name field.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSchedulingGates#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecSchedulingGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecSchedulingGates(
  obj: AutoscalingListenerSpecTemplateSpecSchedulingGates | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings.
 * Optional: Defaults to empty.  See type description for default values of each field.
 *
 * @default empty.  See type description for default values of each field.
 * @schema AutoscalingListenerSpecTemplateSpecSecurityContext
 */
export interface AutoscalingListenerSpecTemplateSpecSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingListenerSpecTemplateSpecSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingListenerSpecTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingListenerSpecTemplateSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: AutoscalingListenerSpecTemplateSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingListenerSpecTemplateSpecSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecSecurityContext(
  obj: AutoscalingListenerSpecTemplateSpecSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    appArmorProfile: toJson_AutoscalingListenerSpecTemplateSpecSecurityContextAppArmorProfile(obj.appArmorProfile),
    fsGroup: obj.fsGroup,
    fsGroupChangePolicy: obj.fsGroupChangePolicy,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxChangePolicy: obj.seLinuxChangePolicy,
    seLinuxOptions: toJson_AutoscalingListenerSpecTemplateSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    seccompProfile: toJson_AutoscalingListenerSpecTemplateSpecSecurityContextSeccompProfile(obj.seccompProfile),
    supplementalGroups: obj.supplementalGroups?.map((y) => y),
    supplementalGroupsPolicy: obj.supplementalGroupsPolicy,
    sysctls: obj.sysctls?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecSecurityContextSysctls(y)),
    windowsOptions: toJson_AutoscalingListenerSpecTemplateSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema AutoscalingListenerSpecTemplateSpecTolerations
 */
export interface AutoscalingListenerSpecTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema AutoscalingListenerSpecTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecTolerations(
  obj: AutoscalingListenerSpecTemplateSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints
 */
export interface AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints(
  obj: AutoscalingListenerSpecTemplateSpecTopologySpreadConstraints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector: toJson_AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    maxSkew: obj.maxSkew,
    minDomains: obj.minDomains,
    nodeAffinityPolicy: obj.nodeAffinityPolicy,
    nodeTaintsPolicy: obj.nodeTaintsPolicy,
    topologyKey: obj.topologyKey,
    whenUnsatisfiable: obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumes
 */
export interface AutoscalingListenerSpecTemplateSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
   * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: AutoscalingListenerSpecTemplateSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
   * are redirected to the disk.csi.azure.com CSI driver.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#azureDisk
   */
  readonly azureDisk?: AutoscalingListenerSpecTemplateSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
   * are redirected to the file.csi.azure.com CSI driver.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#azureFile
   */
  readonly azureFile?: AutoscalingListenerSpecTemplateSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
   * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#cephfs
   */
  readonly cephfs?: AutoscalingListenerSpecTemplateSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
   * are redirected to the cinder.csi.openstack.org CSI driver.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#cinder
   */
  readonly cinder?: AutoscalingListenerSpecTemplateSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#configMap
   */
  readonly configMap?: AutoscalingListenerSpecTemplateSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#csi
   */
  readonly csi?: AutoscalingListenerSpecTemplateSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#downwardAPI
   */
  readonly downwardApi?: AutoscalingListenerSpecTemplateSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#emptyDir
   */
  readonly emptyDir?: AutoscalingListenerSpecTemplateSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#ephemeral
   */
  readonly ephemeral?: AutoscalingListenerSpecTemplateSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#fc
   */
  readonly fc?: AutoscalingListenerSpecTemplateSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#flexVolume
   */
  readonly flexVolume?: AutoscalingListenerSpecTemplateSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
   * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#flocker
   */
  readonly flocker?: AutoscalingListenerSpecTemplateSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
   * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: AutoscalingListenerSpecTemplateSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#gitRepo
   */
  readonly gitRepo?: AutoscalingListenerSpecTemplateSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#glusterfs
   */
  readonly glusterfs?: AutoscalingListenerSpecTemplateSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#hostPath
   */
  readonly hostPath?: AutoscalingListenerSpecTemplateSpecVolumesHostPath;

  /**
   * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
   * The volume is resolved at pod startup depending on which PullPolicy value is provided:
   *
   * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   *
   * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
   * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
   * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
   * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
   * The volume will be mounted read-only (ro) and non-executable files (noexec).
   * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
   * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#image
   */
  readonly image?: AutoscalingListenerSpecTemplateSpecVolumesImage;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#iscsi
   */
  readonly iscsi?: AutoscalingListenerSpecTemplateSpecVolumesIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#nfs
   */
  readonly nfs?: AutoscalingListenerSpecTemplateSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: AutoscalingListenerSpecTemplateSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
   * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: AutoscalingListenerSpecTemplateSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
   * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
   * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
   * is on.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: AutoscalingListenerSpecTemplateSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#projected
   */
  readonly projected?: AutoscalingListenerSpecTemplateSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
   * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#quobyte
   */
  readonly quobyte?: AutoscalingListenerSpecTemplateSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#rbd
   */
  readonly rbd?: AutoscalingListenerSpecTemplateSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#scaleIO
   */
  readonly scaleIo?: AutoscalingListenerSpecTemplateSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#secret
   */
  readonly secret?: AutoscalingListenerSpecTemplateSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#storageos
   */
  readonly storageos?: AutoscalingListenerSpecTemplateSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
   * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
   * are redirected to the csi.vsphere.vmware.com CSI driver.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: AutoscalingListenerSpecTemplateSpecVolumesVsphereVolume;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumes(
  obj: AutoscalingListenerSpecTemplateSpecVolumes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    awsElasticBlockStore: toJson_AutoscalingListenerSpecTemplateSpecVolumesAwsElasticBlockStore(
      obj.awsElasticBlockStore,
    ),
    azureDisk: toJson_AutoscalingListenerSpecTemplateSpecVolumesAzureDisk(obj.azureDisk),
    azureFile: toJson_AutoscalingListenerSpecTemplateSpecVolumesAzureFile(obj.azureFile),
    cephfs: toJson_AutoscalingListenerSpecTemplateSpecVolumesCephfs(obj.cephfs),
    cinder: toJson_AutoscalingListenerSpecTemplateSpecVolumesCinder(obj.cinder),
    configMap: toJson_AutoscalingListenerSpecTemplateSpecVolumesConfigMap(obj.configMap),
    csi: toJson_AutoscalingListenerSpecTemplateSpecVolumesCsi(obj.csi),
    downwardAPI: toJson_AutoscalingListenerSpecTemplateSpecVolumesDownwardApi(obj.downwardApi),
    emptyDir: toJson_AutoscalingListenerSpecTemplateSpecVolumesEmptyDir(obj.emptyDir),
    ephemeral: toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeral(obj.ephemeral),
    fc: toJson_AutoscalingListenerSpecTemplateSpecVolumesFc(obj.fc),
    flexVolume: toJson_AutoscalingListenerSpecTemplateSpecVolumesFlexVolume(obj.flexVolume),
    flocker: toJson_AutoscalingListenerSpecTemplateSpecVolumesFlocker(obj.flocker),
    gcePersistentDisk: toJson_AutoscalingListenerSpecTemplateSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    gitRepo: toJson_AutoscalingListenerSpecTemplateSpecVolumesGitRepo(obj.gitRepo),
    glusterfs: toJson_AutoscalingListenerSpecTemplateSpecVolumesGlusterfs(obj.glusterfs),
    hostPath: toJson_AutoscalingListenerSpecTemplateSpecVolumesHostPath(obj.hostPath),
    image: toJson_AutoscalingListenerSpecTemplateSpecVolumesImage(obj.image),
    iscsi: toJson_AutoscalingListenerSpecTemplateSpecVolumesIscsi(obj.iscsi),
    name: obj.name,
    nfs: toJson_AutoscalingListenerSpecTemplateSpecVolumesNfs(obj.nfs),
    persistentVolumeClaim: toJson_AutoscalingListenerSpecTemplateSpecVolumesPersistentVolumeClaim(
      obj.persistentVolumeClaim,
    ),
    photonPersistentDisk: toJson_AutoscalingListenerSpecTemplateSpecVolumesPhotonPersistentDisk(
      obj.photonPersistentDisk,
    ),
    portworxVolume: toJson_AutoscalingListenerSpecTemplateSpecVolumesPortworxVolume(obj.portworxVolume),
    projected: toJson_AutoscalingListenerSpecTemplateSpecVolumesProjected(obj.projected),
    quobyte: toJson_AutoscalingListenerSpecTemplateSpecVolumesQuobyte(obj.quobyte),
    rbd: toJson_AutoscalingListenerSpecTemplateSpecVolumesRbd(obj.rbd),
    scaleIO: toJson_AutoscalingListenerSpecTemplateSpecVolumesScaleIo(obj.scaleIo),
    secret: toJson_AutoscalingListenerSpecTemplateSpecVolumesSecret(obj.secret),
    storageos: toJson_AutoscalingListenerSpecTemplateSpecVolumesStorageos(obj.storageos),
    vsphereVolume: toJson_AutoscalingListenerSpecTemplateSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecVaultConfigProxyHttp
 */
export interface AutoscalingListenerSpecVaultConfigProxyHttp {
  /**
   * @schema AutoscalingListenerSpecVaultConfigProxyHttp#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpecVaultConfigProxyHttp#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecVaultConfigProxyHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecVaultConfigProxyHttp(
  obj: AutoscalingListenerSpecVaultConfigProxyHttp | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecVaultConfigProxyHttps
 */
export interface AutoscalingListenerSpecVaultConfigProxyHttps {
  /**
   * @schema AutoscalingListenerSpecVaultConfigProxyHttps#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema AutoscalingListenerSpecVaultConfigProxyHttps#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecVaultConfigProxyHttps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecVaultConfigProxyHttps(
  obj: AutoscalingListenerSpecVaultConfigProxyHttps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinity
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinity(
  obj: AutoscalingListenerSpecTemplateSpecAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y),
    ),
    requiredDuringSchedulingIgnoredDuringExecution:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinity
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinity(
  obj: AutoscalingListenerSpecTemplateSpecAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y),
    ),
    requiredDuringSchedulingIgnoredDuringExecution: obj.requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinity
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinity(
  obj: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
    requiredDuringSchedulingIgnoredDuringExecution: obj.requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersEnv
 */
export interface AutoscalingListenerSpecTemplateSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: AutoscalingListenerSpecTemplateSpecContainersEnvValueFrom;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersEnv(
  obj: AutoscalingListenerSpecTemplateSpecContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_AutoscalingListenerSpecTemplateSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersEnvFrom
 */
export interface AutoscalingListenerSpecTemplateSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: AutoscalingListenerSpecTemplateSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: AutoscalingListenerSpecTemplateSpecContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersEnvFrom(
  obj: AutoscalingListenerSpecTemplateSpecContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_AutoscalingListenerSpecTemplateSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    prefix: obj.prefix,
    secretRef: toJson_AutoscalingListenerSpecTemplateSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecycle
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecycle#postStart
   */
  readonly postStart?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecycle#preStop
   */
  readonly preStop?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecycle(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbe
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbe#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbe(
  obj: AutoscalingListenerSpecTemplateSpecContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersPorts
 */
export interface AutoscalingListenerSpecTemplateSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema AutoscalingListenerSpecTemplateSpecContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersPorts(
  obj: AutoscalingListenerSpecTemplateSpecContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbe
 */
export interface AutoscalingListenerSpecTemplateSpecContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbe#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbe(
  obj: AutoscalingListenerSpecTemplateSpecContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersResizePolicy
 */
export interface AutoscalingListenerSpecTemplateSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersResizePolicy(
  obj: AutoscalingListenerSpecTemplateSpecContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersResources
 */
export interface AutoscalingListenerSpecTemplateSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersResources#claims
   */
  readonly claims?: AutoscalingListenerSpecTemplateSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingListenerSpecTemplateSpecContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingListenerSpecTemplateSpecContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersResources(
  obj: AutoscalingListenerSpecTemplateSpecContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext
 */
export interface AutoscalingListenerSpecTemplateSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingListenerSpecTemplateSpecContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: AutoscalingListenerSpecTemplateSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingListenerSpecTemplateSpecContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContext(
  obj: AutoscalingListenerSpecTemplateSpecContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    capabilities: toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContextCapabilities(obj.capabilities),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    windowsOptions: toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbe
 */
export interface AutoscalingListenerSpecTemplateSpecContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbe#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbe#grpc
   */
  readonly grpc?: AutoscalingListenerSpecTemplateSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbe(
  obj: AutoscalingListenerSpecTemplateSpecContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersVolumeDevices
 */
export interface AutoscalingListenerSpecTemplateSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersVolumeDevices(
  obj: AutoscalingListenerSpecTemplateSpecContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersVolumeMounts
 */
export interface AutoscalingListenerSpecTemplateSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AutoscalingListenerSpecTemplateSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema AutoscalingListenerSpecTemplateSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersVolumeMounts(
  obj: AutoscalingListenerSpecTemplateSpecContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema AutoscalingListenerSpecTemplateSpecDnsConfigOptions
 */
export interface AutoscalingListenerSpecTemplateSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema AutoscalingListenerSpecTemplateSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema AutoscalingListenerSpecTemplateSpecDnsConfigOptions#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecDnsConfigOptions(
  obj: AutoscalingListenerSpecTemplateSpecDnsConfigOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnv
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnv#valueFrom
   */
  readonly valueFrom?: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFrom;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnv(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFrom
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFrom#secretRef
   */
  readonly secretRef?: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFrom(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(obj.configMapRef),
    prefix: obj.prefix,
    secretRef: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Lifecycle is not allowed for ephemeral containers.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecycle
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecycle#postStart
   */
  readonly postStart?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecycle#preStop
   */
  readonly preStop?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecycle(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe#grpc
   */
  readonly grpc?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe#grpc
   */
  readonly grpc?: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResizePolicy
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersResizePolicy(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
 * already allocated to the pod.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResources
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResources#claims
   */
  readonly claims?: AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersResources(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#capabilities
   */
  readonly capabilities?: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    capabilities: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(
      obj.capabilities,
    ),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    windowsOptions: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe#grpc
   */
  readonly grpc?: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeDevices
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeDevices(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnv
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFrom;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnv(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvFrom
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: AutoscalingListenerSpecTemplateSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: AutoscalingListenerSpecTemplateSpecInitContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvFrom(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    prefix: obj.prefix,
    secretRef: toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecycle
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecycle(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersPorts
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersPorts(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersResizePolicy
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersResizePolicy(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersResources
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersResources#claims
   */
  readonly claims?: AutoscalingListenerSpecTemplateSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingListenerSpecTemplateSpecInitContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingListenerSpecTemplateSpecInitContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersResources(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecInitContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    capabilities: toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextCapabilities(obj.capabilities),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    windowsOptions: toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersVolumeDevices
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersVolumeDevices(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingListenerSpecTemplateSpecResourcesClaims
 */
export interface AutoscalingListenerSpecTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingListenerSpecTemplateSpecResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecResourcesClaims(
  obj: AutoscalingListenerSpecTemplateSpecResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecTemplateSpecResourcesLimits
 */
export class AutoscalingListenerSpecTemplateSpecResourcesLimits {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecResourcesLimits {
    return new AutoscalingListenerSpecTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecResourcesLimits {
    return new AutoscalingListenerSpecTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingListenerSpecTemplateSpecResourcesRequests
 */
export class AutoscalingListenerSpecTemplateSpecResourcesRequests {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecResourcesRequests {
    return new AutoscalingListenerSpecTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecResourcesRequests {
    return new AutoscalingListenerSpecTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecSecurityContextAppArmorProfile
 */
export interface AutoscalingListenerSpecTemplateSpecSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecSecurityContextAppArmorProfile(
  obj: AutoscalingListenerSpecTemplateSpecSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecSecurityContextSeLinuxOptions
 */
export interface AutoscalingListenerSpecTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecSecurityContextSeLinuxOptions(
  obj: AutoscalingListenerSpecTemplateSpecSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecSecurityContextSeccompProfile
 */
export interface AutoscalingListenerSpecTemplateSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecSecurityContextSeccompProfile(
  obj: AutoscalingListenerSpecTemplateSpecSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema AutoscalingListenerSpecTemplateSpecSecurityContextSysctls
 */
export interface AutoscalingListenerSpecTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecSecurityContextSysctls(
  obj: AutoscalingListenerSpecTemplateSpecSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingListenerSpecTemplateSpecSecurityContextWindowsOptions
 */
export interface AutoscalingListenerSpecTemplateSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingListenerSpecTemplateSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecSecurityContextWindowsOptions(
  obj: AutoscalingListenerSpecTemplateSpecSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelector
 */
export interface AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelector(
  obj: AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
 * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesAwsElasticBlockStore
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesAwsElasticBlockStore(
  obj: AutoscalingListenerSpecTemplateSpecVolumesAwsElasticBlockStore | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    partition: obj.partition,
    readOnly: obj.readOnly,
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
 * are redirected to the disk.csi.azure.com CSI driver.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesAzureDisk
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesAzureDisk(
  obj: AutoscalingListenerSpecTemplateSpecVolumesAzureDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cachingMode: obj.cachingMode,
    diskName: obj.diskName,
    diskURI: obj.diskUri,
    fsType: obj.fsType,
    kind: obj.kind,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
 * are redirected to the file.csi.azure.com CSI driver.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesAzureFile
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesAzureFile(
  obj: AutoscalingListenerSpecTemplateSpecVolumesAzureFile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    readOnly: obj.readOnly,
    secretName: obj.secretName,
    shareName: obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
 * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesCephfs
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: AutoscalingListenerSpecTemplateSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesCephfs(
  obj: AutoscalingListenerSpecTemplateSpecVolumesCephfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    monitors: obj.monitors?.map((y) => y),
    path: obj.path,
    readOnly: obj.readOnly,
    secretFile: obj.secretFile,
    secretRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesCephfsSecretRef(obj.secretRef),
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
 * are redirected to the cinder.csi.openstack.org CSI driver.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesCinder
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCinder#secretRef
   */
  readonly secretRef?: AutoscalingListenerSpecTemplateSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesCinder(
  obj: AutoscalingListenerSpecTemplateSpecVolumesCinder | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesCinderSecretRef(obj.secretRef),
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesConfigMap
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesConfigMap#items
   */
  readonly items?: AutoscalingListenerSpecTemplateSpecVolumesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesConfigMap(
  obj: AutoscalingListenerSpecTemplateSpecVolumesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecVolumesConfigMapItems(y)),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesCsi
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: AutoscalingListenerSpecTemplateSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesCsi(
  obj: AutoscalingListenerSpecTemplateSpecVolumesCsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    driver: obj.driver,
    fsType: obj.fsType,
    nodePublishSecretRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesCsiNodePublishSecretRef(
      obj.nodePublishSecretRef,
    ),
    readOnly: obj.readOnly,
    volumeAttributes:
      obj.volumeAttributes === undefined
        ? undefined
        : Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApi
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApi#items
   */
  readonly items?: AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItems[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesDownwardApi(
  obj: AutoscalingListenerSpecTemplateSpecVolumesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEmptyDir
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: AutoscalingListenerSpecTemplateSpecVolumesEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesEmptyDir(
  obj: AutoscalingListenerSpecTemplateSpecVolumesEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    medium: obj.medium,
    sizeLimit: obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeral
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeral(
  obj: AutoscalingListenerSpecTemplateSpecVolumesEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    volumeClaimTemplate: toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(
      obj.volumeClaimTemplate,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesFc
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesFc(
  obj: AutoscalingListenerSpecTemplateSpecVolumesFc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    lun: obj.lun,
    readOnly: obj.readOnly,
    targetWWNs: obj.targetWwNs?.map((y) => y),
    wwids: obj.wwids?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesFlexVolume
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: AutoscalingListenerSpecTemplateSpecVolumesFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesFlexVolume(
  obj: AutoscalingListenerSpecTemplateSpecVolumesFlexVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    driver: obj.driver,
    fsType: obj.fsType,
    options:
      obj.options === undefined
        ? undefined
        : Object.entries(obj.options).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
 * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesFlocker
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesFlocker(
  obj: AutoscalingListenerSpecTemplateSpecVolumesFlocker | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    datasetName: obj.datasetName,
    datasetUUID: obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
 * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesGcePersistentDisk
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesGcePersistentDisk(
  obj: AutoscalingListenerSpecTemplateSpecVolumesGcePersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    partition: obj.partition,
    pdName: obj.pdName,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesGitRepo
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesGitRepo(
  obj: AutoscalingListenerSpecTemplateSpecVolumesGitRepo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    directory: obj.directory,
    repository: obj.repository,
    revision: obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesGlusterfs
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesGlusterfs(
  obj: AutoscalingListenerSpecTemplateSpecVolumesGlusterfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    endpoints: obj.endpoints,
    path: obj.path,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesHostPath
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema AutoscalingListenerSpecTemplateSpecVolumesHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesHostPath(
  obj: AutoscalingListenerSpecTemplateSpecVolumesHostPath | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
 * The volume is resolved at pod startup depending on which PullPolicy value is provided:
 *
 * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
 * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
 * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
 *
 * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
 * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
 * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
 * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
 * The volume will be mounted read-only (ro) and non-executable files (noexec).
 * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
 * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesImage
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesImage {
  /**
   * Policy for pulling OCI objects. Possible values are:
   * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Required: Image or artifact reference to be used.
   * Behaves in the same way as pod.spec.containers[*].image.
   * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesImage#reference
   */
  readonly reference?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesImage(
  obj: AutoscalingListenerSpecTemplateSpecVolumesImage | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    pullPolicy: obj.pullPolicy,
    reference: obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: AutoscalingListenerSpecTemplateSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesIscsi(
  obj: AutoscalingListenerSpecTemplateSpecVolumesIscsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    chapAuthDiscovery: obj.chapAuthDiscovery,
    chapAuthSession: obj.chapAuthSession,
    fsType: obj.fsType,
    initiatorName: obj.initiatorName,
    iqn: obj.iqn,
    iscsiInterface: obj.iscsiInterface,
    lun: obj.lun,
    portals: obj.portals?.map((y) => y),
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesIscsiSecretRef(obj.secretRef),
    targetPortal: obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesNfs
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesNfs(
  obj: AutoscalingListenerSpecTemplateSpecVolumesNfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    readOnly: obj.readOnly,
    server: obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesPersistentVolumeClaim
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesPersistentVolumeClaim(
  obj: AutoscalingListenerSpecTemplateSpecVolumesPersistentVolumeClaim | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claimName: obj.claimName,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
 * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesPhotonPersistentDisk
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesPhotonPersistentDisk(
  obj: AutoscalingListenerSpecTemplateSpecVolumesPhotonPersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    pdID: obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
 * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
 * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
 * is on.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesPortworxVolume
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesPortworxVolume(
  obj: AutoscalingListenerSpecTemplateSpecVolumesPortworxVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjected
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections. Each entry in this list
   * handles one source.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjected#sources
   */
  readonly sources?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSources[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjected(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjected | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    sources: obj.sources?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
 * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesQuobyte
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema AutoscalingListenerSpecTemplateSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema AutoscalingListenerSpecTemplateSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesQuobyte(
  obj: AutoscalingListenerSpecTemplateSpecVolumesQuobyte | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    group: obj.group,
    readOnly: obj.readOnly,
    registry: obj.registry,
    tenant: obj.tenant,
    user: obj.user,
    volume: obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesRbd
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesRbd#secretRef
   */
  readonly secretRef?: AutoscalingListenerSpecTemplateSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesRbd(
  obj: AutoscalingListenerSpecTemplateSpecVolumesRbd | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    image: obj.image,
    keyring: obj.keyring,
    monitors: obj.monitors?.map((y) => y),
    pool: obj.pool,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesRbdSecretRef(obj.secretRef),
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIo
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: AutoscalingListenerSpecTemplateSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesScaleIo(
  obj: AutoscalingListenerSpecTemplateSpecVolumesScaleIo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    gateway: obj.gateway,
    protectionDomain: obj.protectionDomain,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesScaleIoSecretRef(obj.secretRef),
    sslEnabled: obj.sslEnabled,
    storageMode: obj.storageMode,
    storagePool: obj.storagePool,
    system: obj.system,
    volumeName: obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesSecret
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema AutoscalingListenerSpecTemplateSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesSecret#items
   */
  readonly items?: AutoscalingListenerSpecTemplateSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesSecret(
  obj: AutoscalingListenerSpecTemplateSpecVolumesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecVolumesSecretItems(y)),
    optional: obj.optional,
    secretName: obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesStorageos
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: AutoscalingListenerSpecTemplateSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesStorageos(
  obj: AutoscalingListenerSpecTemplateSpecVolumesStorageos | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesStorageosSecretRef(obj.secretRef),
    volumeName: obj.volumeName,
    volumeNamespace: obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
 * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
 * are redirected to the csi.vsphere.vmware.com CSI driver.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesVsphereVolume
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesVsphereVolume(
  obj: AutoscalingListenerSpecTemplateSpecVolumesVsphereVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    storagePolicyID: obj.storagePolicyId,
    storagePolicyName: obj.storagePolicyName,
    volumePath: obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preference:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeSelectorTerms: obj.nodeSelectorTerms?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    podAffinityTerm:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    podAffinityTerm:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFrom
 */
export interface AutoscalingListenerSpecTemplateSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: AutoscalingListenerSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: AutoscalingListenerSpecTemplateSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: AutoscalingListenerSpecTemplateSpecContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersEnvValueFrom(
  obj: AutoscalingListenerSpecTemplateSpecContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_AutoscalingListenerSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_AutoscalingListenerSpecTemplateSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRef(
      obj.resourceFieldRef,
    ),
    secretKeyRef: toJson_AutoscalingListenerSpecTemplateSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersEnvFromConfigMapRef
 */
export interface AutoscalingListenerSpecTemplateSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersEnvFromConfigMapRef(
  obj: AutoscalingListenerSpecTemplateSpecContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersEnvFromSecretRef
 */
export interface AutoscalingListenerSpecTemplateSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersEnvFromSecretRef(
  obj: AutoscalingListenerSpecTemplateSpecContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStart
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStart#sleep
   */
  readonly sleep?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStart(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStop
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStop#sleep
   */
  readonly sleep?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStop(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeExec
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbeExec(
  obj: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeGrpc
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbeGrpc(
  obj: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeExec
 */
export interface AutoscalingListenerSpecTemplateSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbeExec(
  obj: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeGrpc
 */
export interface AutoscalingListenerSpecTemplateSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbeGrpc(
  obj: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersResourcesClaims
 */
export interface AutoscalingListenerSpecTemplateSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersResourcesClaims(
  obj: AutoscalingListenerSpecTemplateSpecContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecTemplateSpecContainersResourcesLimits
 */
export class AutoscalingListenerSpecTemplateSpecContainersResourcesLimits {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecContainersResourcesLimits {
    return new AutoscalingListenerSpecTemplateSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecContainersResourcesLimits {
    return new AutoscalingListenerSpecTemplateSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingListenerSpecTemplateSpecContainersResourcesRequests
 */
export class AutoscalingListenerSpecTemplateSpecContainersResourcesRequests {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecContainersResourcesRequests {
    return new AutoscalingListenerSpecTemplateSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecContainersResourcesRequests {
    return new AutoscalingListenerSpecTemplateSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextAppArmorProfile
 */
export interface AutoscalingListenerSpecTemplateSpecContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContextAppArmorProfile(
  obj: AutoscalingListenerSpecTemplateSpecContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextCapabilities
 */
export interface AutoscalingListenerSpecTemplateSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContextCapabilities(
  obj: AutoscalingListenerSpecTemplateSpecContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeLinuxOptions
 */
export interface AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeLinuxOptions(
  obj: AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeccompProfile
 */
export interface AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeccompProfile(
  obj: AutoscalingListenerSpecTemplateSpecContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextWindowsOptions
 */
export interface AutoscalingListenerSpecTemplateSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingListenerSpecTemplateSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersSecurityContextWindowsOptions(
  obj: AutoscalingListenerSpecTemplateSpecContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeExec
 */
export interface AutoscalingListenerSpecTemplateSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbeExec(
  obj: AutoscalingListenerSpecTemplateSpecContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeGrpc
 */
export interface AutoscalingListenerSpecTemplateSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbeGrpc(
  obj: AutoscalingListenerSpecTemplateSpecContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFrom
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFrom(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(
      obj.resourceFieldRef,
    ),
    secretKeyRef: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromSecretRef
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromSecretRef(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStart
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStart#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStart#sleep
   */
  readonly sleep?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStart(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStop
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStop#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStop#sleep
   */
  readonly sleep?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStop(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeExec
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeExec(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeGrpc
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeExec
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeExec(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeGrpc
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesClaims
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesClaims(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesLimits
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesLimits {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesRequests
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesRequests {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextCapabilities
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeExec
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeExec(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeGrpc
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeGrpc(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFrom
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFrom(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(
      obj.resourceFieldRef,
    ),
    secretKeyRef: toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvFromConfigMapRef
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvFromConfigMapRef(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvFromSecretRef
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvFromSecretRef(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStart
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStart#sleep
   */
  readonly sleep?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStart(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStop
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStop#sleep
   */
  readonly sleep?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStop(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeExec
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeExec(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeGrpc
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeGrpc(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeExec
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeExec(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeGrpc
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeGrpc(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersResourcesClaims
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersResourcesClaims(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersResourcesLimits
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecInitContainersResourcesLimits {
    return new AutoscalingListenerSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecInitContainersResourcesLimits {
    return new AutoscalingListenerSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersResourcesRequests
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecInitContainersResourcesRequests {
    return new AutoscalingListenerSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecInitContainersResourcesRequests {
    return new AutoscalingListenerSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextAppArmorProfile
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextAppArmorProfile(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextCapabilities
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextCapabilities(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeccompProfile
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeccompProfile(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextWindowsOptions
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextWindowsOptions(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeExec
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeExec(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeGrpc
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeGrpc(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
  obj: AutoscalingListenerSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesCephfsSecretRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesCephfsSecretRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesCephfsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesCinderSecretRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesCinderSecretRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesCinderSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesConfigMapItems
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesConfigMapItems(
  obj: AutoscalingListenerSpecTemplateSpecVolumesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesCsiNodePublishSecretRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesCsiNodePublishSecretRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesCsiNodePublishSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItems
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItems(
  obj: AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fieldRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    mode: obj.mode,
    path: obj.path,
    resourceFieldRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(
      obj.resourceFieldRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEmptyDirSizeLimit
 */
export class AutoscalingListenerSpecTemplateSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new AutoscalingListenerSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new AutoscalingListenerSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 * Required, must not be nil.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(
  obj: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    spec: toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesFlexVolumeSecretRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesFlexVolumeSecretRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesFlexVolumeSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsiSecretRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesIscsiSecretRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesIscsiSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types.
 * Exactly one of these fields must be set.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSources
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSources#secret
   */
  readonly secret?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSources(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clusterTrustBundle: toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle(
      obj.clusterTrustBundle,
    ),
    configMap: toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    downwardAPI: toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    secret: toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecret(obj.secret),
    serviceAccountToken: toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(
      obj.serviceAccountToken,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema AutoscalingListenerSpecTemplateSpecVolumesRbdSecretRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesRbdSecretRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesRbdSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIoSecretRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesScaleIoSecretRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesScaleIoSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesSecretItems
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesSecretItems(
  obj: AutoscalingListenerSpecTemplateSpecVolumesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesStorageosSecretRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesStorageosSecretRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesStorageosSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface AutoscalingListenerSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(
  obj: AutoscalingListenerSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromFieldRef
 */
export interface AutoscalingListenerSpecTemplateSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersEnvValueFromFieldRef(
  obj: AutoscalingListenerSpecTemplateSpecContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRef
 */
export interface AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRef(
  obj: AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromSecretKeyRef
 */
export interface AutoscalingListenerSpecTemplateSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersEnvValueFromSecretKeyRef(
  obj: AutoscalingListenerSpecTemplateSpecContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartExec
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartExec(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartSleep
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartSleep(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopExec
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopExec(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopSleep
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopSleep(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartExec
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopExec
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromFieldRef
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromFieldRef(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartExec
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartExec(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartSleep
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartSleep(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopExec
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopExec(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopSleep
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopSleep(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsFieldRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsFieldRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC
 * when creating it. No other fields are allowed and will be rejected during
 * validation.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(
  obj: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    finalizers: obj.finalizers?.map((y) => y),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(
  obj: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessModes: obj.accessModes?.map((y) => y),
    dataSource: toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
      obj.dataSource,
    ),
    dataSourceRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
      obj.dataSourceRef,
    ),
    resources: toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
      obj.resources,
    ),
    selector: toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    storageClassName: obj.storageClassName,
    volumeAttributesClassName: obj.volumeAttributesClassName,
    volumeMode: obj.volumeMode,
    volumeName: obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector: toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(
      obj.labelSelector,
    ),
    name: obj.name,
    optional: obj.optional,
    path: obj.path,
    signerName: obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMap
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMap(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(y)),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApi
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApi(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecret
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecret(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) => toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecretItems(y)),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audience: obj.audience,
    expirationSeconds: obj.expirationSeconds,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingListenerSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingListenerSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingListenerSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingListenerSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
  obj: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
  obj: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
  obj: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMapItems
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fieldRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    mode: obj.mode,
    path: obj.path,
    resourceFieldRef: toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
      obj.resourceFieldRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecretItems
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecretItems(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingListenerSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj: AutoscalingListenerSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(
  obj:
    | AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
  obj: AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingListenerSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * AutoscalingRunnerSet is the Schema for the autoscalingrunnersets API
 *
 * @schema AutoscalingRunnerSet
 */
export class AutoscalingRunnerSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AutoscalingRunnerSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "actions.github.com/v1alpha1",
    kind: "AutoscalingRunnerSet",
  };

  /**
   * Renders a Kubernetes manifest for "AutoscalingRunnerSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AutoscalingRunnerSetProps = {}): any {
    return {
      ...AutoscalingRunnerSet.GVK,
      ...toJson_AutoscalingRunnerSetProps(props),
    };
  }

  /**
   * Defines a "AutoscalingRunnerSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AutoscalingRunnerSetProps = {}) {
    super(scope, id, {
      ...AutoscalingRunnerSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...AutoscalingRunnerSet.GVK,
      ...toJson_AutoscalingRunnerSetProps(resolved),
    };
  }
}

/**
 * AutoscalingRunnerSet is the Schema for the autoscalingrunnersets API
 *
 * @schema AutoscalingRunnerSet
 */
export interface AutoscalingRunnerSetProps {
  /**
   * @schema AutoscalingRunnerSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AutoscalingRunnerSetSpec defines the desired state of AutoscalingRunnerSet
   *
   * @schema AutoscalingRunnerSet#spec
   */
  readonly spec?: AutoscalingRunnerSetSpec;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetProps(
  obj: AutoscalingRunnerSetProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_AutoscalingRunnerSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AutoscalingRunnerSetSpec defines the desired state of AutoscalingRunnerSet
 *
 * @schema AutoscalingRunnerSetSpec
 */
export interface AutoscalingRunnerSetSpec {
  /**
   * Required
   *
   * @schema AutoscalingRunnerSetSpec#githubConfigSecret
   */
  readonly githubConfigSecret?: string;

  /**
   * Required
   *
   * @schema AutoscalingRunnerSetSpec#githubConfigUrl
   */
  readonly githubConfigUrl?: string;

  /**
   * @schema AutoscalingRunnerSetSpec#githubServerTLS
   */
  readonly githubServerTls?: AutoscalingRunnerSetSpecGithubServerTls;

  /**
   * MetricsConfig holds configuration parameters for each metric type
   *
   * @schema AutoscalingRunnerSetSpec#listenerMetrics
   */
  readonly listenerMetrics?: AutoscalingRunnerSetSpecListenerMetrics;

  /**
   * PodTemplateSpec describes the data a pod should have when created from a template
   *
   * @schema AutoscalingRunnerSetSpec#listenerTemplate
   */
  readonly listenerTemplate?: AutoscalingRunnerSetSpecListenerTemplate;

  /**
   * @schema AutoscalingRunnerSetSpec#maxRunners
   */
  readonly maxRunners?: number;

  /**
   * @schema AutoscalingRunnerSetSpec#minRunners
   */
  readonly minRunners?: number;

  /**
   * @schema AutoscalingRunnerSetSpec#proxy
   */
  readonly proxy?: AutoscalingRunnerSetSpecProxy;

  /**
   * @schema AutoscalingRunnerSetSpec#runnerGroup
   */
  readonly runnerGroup?: string;

  /**
   * @schema AutoscalingRunnerSetSpec#runnerScaleSetName
   */
  readonly runnerScaleSetName?: string;

  /**
   * Required
   *
   * @schema AutoscalingRunnerSetSpec#template
   */
  readonly template?: AutoscalingRunnerSetSpecTemplate;

  /**
   * @schema AutoscalingRunnerSetSpec#vaultConfig
   */
  readonly vaultConfig?: AutoscalingRunnerSetSpecVaultConfig;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpec(
  obj: AutoscalingRunnerSetSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    githubConfigSecret: obj.githubConfigSecret,
    githubConfigUrl: obj.githubConfigUrl,
    githubServerTLS: toJson_AutoscalingRunnerSetSpecGithubServerTls(obj.githubServerTls),
    listenerMetrics: toJson_AutoscalingRunnerSetSpecListenerMetrics(obj.listenerMetrics),
    listenerTemplate: toJson_AutoscalingRunnerSetSpecListenerTemplate(obj.listenerTemplate),
    maxRunners: obj.maxRunners,
    minRunners: obj.minRunners,
    proxy: toJson_AutoscalingRunnerSetSpecProxy(obj.proxy),
    runnerGroup: obj.runnerGroup,
    runnerScaleSetName: obj.runnerScaleSetName,
    template: toJson_AutoscalingRunnerSetSpecTemplate(obj.template),
    vaultConfig: toJson_AutoscalingRunnerSetSpecVaultConfig(obj.vaultConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecGithubServerTls
 */
export interface AutoscalingRunnerSetSpecGithubServerTls {
  /**
   * Required
   *
   * @schema AutoscalingRunnerSetSpecGithubServerTls#certificateFrom
   */
  readonly certificateFrom?: AutoscalingRunnerSetSpecGithubServerTlsCertificateFrom;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecGithubServerTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecGithubServerTls(
  obj: AutoscalingRunnerSetSpecGithubServerTls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certificateFrom: toJson_AutoscalingRunnerSetSpecGithubServerTlsCertificateFrom(obj.certificateFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MetricsConfig holds configuration parameters for each metric type
 *
 * @schema AutoscalingRunnerSetSpecListenerMetrics
 */
export interface AutoscalingRunnerSetSpecListenerMetrics {
  /**
   * @schema AutoscalingRunnerSetSpecListenerMetrics#counters
   */
  readonly counters?: {
    [key: string]: AutoscalingRunnerSetSpecListenerMetricsCounters;
  };

  /**
   * @schema AutoscalingRunnerSetSpecListenerMetrics#gauges
   */
  readonly gauges?: {
    [key: string]: AutoscalingRunnerSetSpecListenerMetricsGauges;
  };

  /**
   * @schema AutoscalingRunnerSetSpecListenerMetrics#histograms
   */
  readonly histograms?: {
    [key: string]: AutoscalingRunnerSetSpecListenerMetricsHistograms;
  };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerMetrics' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerMetrics(
  obj: AutoscalingRunnerSetSpecListenerMetrics | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    counters:
      obj.counters === undefined
        ? undefined
        : Object.entries(obj.counters).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]: toJson_AutoscalingRunnerSetSpecListenerMetricsCounters(i[1]),
                  },
            {},
          ),
    gauges:
      obj.gauges === undefined
        ? undefined
        : Object.entries(obj.gauges).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]: toJson_AutoscalingRunnerSetSpecListenerMetricsGauges(i[1]),
                  },
            {},
          ),
    histograms:
      obj.histograms === undefined
        ? undefined
        : Object.entries(obj.histograms).reduce(
            (r, i) =>
              i[1] === undefined
                ? r
                : {
                    ...r,
                    [i[0]]: toJson_AutoscalingRunnerSetSpecListenerMetricsHistograms(i[1]),
                  },
            {},
          ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodTemplateSpec describes the data a pod should have when created from a template
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplate
 */
export interface AutoscalingRunnerSetSpecListenerTemplate {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplate#metadata
   */
  readonly metadata?: AutoscalingRunnerSetSpecListenerTemplateMetadata;

  /**
   * Specification of the desired behavior of the pod.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplate#spec
   */
  readonly spec?: AutoscalingRunnerSetSpecListenerTemplateSpec;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplate(
  obj: AutoscalingRunnerSetSpecListenerTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: toJson_AutoscalingRunnerSetSpecListenerTemplateMetadata(obj.metadata),
    spec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecProxy
 */
export interface AutoscalingRunnerSetSpecProxy {
  /**
   * @schema AutoscalingRunnerSetSpecProxy#http
   */
  readonly http?: AutoscalingRunnerSetSpecProxyHttp;

  /**
   * @schema AutoscalingRunnerSetSpecProxy#https
   */
  readonly https?: AutoscalingRunnerSetSpecProxyHttps;

  /**
   * @schema AutoscalingRunnerSetSpecProxy#noProxy
   */
  readonly noProxy?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecProxy(
  obj: AutoscalingRunnerSetSpecProxy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_AutoscalingRunnerSetSpecProxyHttp(obj.http),
    https: toJson_AutoscalingRunnerSetSpecProxyHttps(obj.https),
    noProxy: obj.noProxy?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required
 *
 * @schema AutoscalingRunnerSetSpecTemplate
 */
export interface AutoscalingRunnerSetSpecTemplate {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema AutoscalingRunnerSetSpecTemplate#metadata
   */
  readonly metadata?: AutoscalingRunnerSetSpecTemplateMetadata;

  /**
   * Specification of the desired behavior of the pod.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema AutoscalingRunnerSetSpecTemplate#spec
   */
  readonly spec?: AutoscalingRunnerSetSpecTemplateSpec;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplate(
  obj: AutoscalingRunnerSetSpecTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: toJson_AutoscalingRunnerSetSpecTemplateMetadata(obj.metadata),
    spec: toJson_AutoscalingRunnerSetSpecTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecVaultConfig
 */
export interface AutoscalingRunnerSetSpecVaultConfig {
  /**
   * @schema AutoscalingRunnerSetSpecVaultConfig#azureKeyVault
   */
  readonly azureKeyVault?: AutoscalingRunnerSetSpecVaultConfigAzureKeyVault;

  /**
   * @schema AutoscalingRunnerSetSpecVaultConfig#proxy
   */
  readonly proxy?: AutoscalingRunnerSetSpecVaultConfigProxy;

  /**
   * VaultType represents the type of vault that can be used in the application.
   * It is used to identify which vault integration should be used to resolve secrets.
   *
   * @schema AutoscalingRunnerSetSpecVaultConfig#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecVaultConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecVaultConfig(
  obj: AutoscalingRunnerSetSpecVaultConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    azureKeyVault: toJson_AutoscalingRunnerSetSpecVaultConfigAzureKeyVault(obj.azureKeyVault),
    proxy: toJson_AutoscalingRunnerSetSpecVaultConfigProxy(obj.proxy),
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required
 *
 * @schema AutoscalingRunnerSetSpecGithubServerTlsCertificateFrom
 */
export interface AutoscalingRunnerSetSpecGithubServerTlsCertificateFrom {
  /**
   * Required
   *
   * @schema AutoscalingRunnerSetSpecGithubServerTlsCertificateFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: AutoscalingRunnerSetSpecGithubServerTlsCertificateFromConfigMapKeyRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecGithubServerTlsCertificateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecGithubServerTlsCertificateFrom(
  obj: AutoscalingRunnerSetSpecGithubServerTlsCertificateFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_AutoscalingRunnerSetSpecGithubServerTlsCertificateFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CounterMetric holds configuration of a single metric of type Counter
 *
 * @schema AutoscalingRunnerSetSpecListenerMetricsCounters
 */
export interface AutoscalingRunnerSetSpecListenerMetricsCounters {
  /**
   * @schema AutoscalingRunnerSetSpecListenerMetricsCounters#labels
   */
  readonly labels: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerMetricsCounters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerMetricsCounters(
  obj: AutoscalingRunnerSetSpecListenerMetricsCounters | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labels: obj.labels?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GaugeMetric holds configuration of a single metric of type Gauge
 *
 * @schema AutoscalingRunnerSetSpecListenerMetricsGauges
 */
export interface AutoscalingRunnerSetSpecListenerMetricsGauges {
  /**
   * @schema AutoscalingRunnerSetSpecListenerMetricsGauges#labels
   */
  readonly labels: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerMetricsGauges' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerMetricsGauges(
  obj: AutoscalingRunnerSetSpecListenerMetricsGauges | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labels: obj.labels?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HistogramMetric holds configuration of a single metric of type Histogram
 *
 * @schema AutoscalingRunnerSetSpecListenerMetricsHistograms
 */
export interface AutoscalingRunnerSetSpecListenerMetricsHistograms {
  /**
   * @schema AutoscalingRunnerSetSpecListenerMetricsHistograms#buckets
   */
  readonly buckets?: number[];

  /**
   * @schema AutoscalingRunnerSetSpecListenerMetricsHistograms#labels
   */
  readonly labels: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerMetricsHistograms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerMetricsHistograms(
  obj: AutoscalingRunnerSetSpecListenerMetricsHistograms | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    buckets: obj.buckets?.map((y) => y),
    labels: obj.labels?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Standard object's metadata.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateMetadata
 */
export interface AutoscalingRunnerSetSpecListenerTemplateMetadata {
  /**
   * @schema AutoscalingRunnerSetSpecListenerTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema AutoscalingRunnerSetSpecListenerTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema AutoscalingRunnerSetSpecListenerTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema AutoscalingRunnerSetSpecListenerTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema AutoscalingRunnerSetSpecListenerTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateMetadata(
  obj: AutoscalingRunnerSetSpecListenerTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    finalizers: obj.finalizers?.map((y) => y),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the desired behavior of the pod.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpec {
  /**
   * Optional duration in seconds the pod may be active on the node relative to
   * StartTime before the system will actively try to mark it failed and kill associated containers.
   * Value must be a positive integer.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#affinity
   */
  readonly affinity?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinity;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * List of containers belonging to the pod.
   * Containers cannot currently be added or removed.
   * There must be at least one container in a Pod.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#containers
   */
  readonly containers: AutoscalingRunnerSetSpecListenerTemplateSpecContainers[];

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#dnsConfig
   */
  readonly dnsConfig?: AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfig;

  /**
   * Set DNS policy for the pod.
   * Defaults to "ClusterFirst".
   * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
   * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
   * To have DNS options set along with hostNetwork, you have to specify DNS policy
   * explicitly to 'ClusterFirstWithHostNet'.
   *
   * @default ClusterFirst".
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's
   * environment variables, matching the syntax of Docker links.
   * Optional: Defaults to true.
   *
   * @default true.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
   * pod to perform user-initiated actions such as debugging. This list cannot be specified when
   * creating a pod, and it cannot be modified by updating the pod spec. In order to add an
   * ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#ephemeralContainers
   */
  readonly ephemeralContainers?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers[];

  /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
   * file if specified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#hostAliases
   */
  readonly hostAliases?: AutoscalingRunnerSetSpecListenerTemplateSpecHostAliases[];

  /**
   * Use the host's ipc namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#hostIPC
   */
  readonly hostIpc?: boolean;

  /**
   * Host networking requested for this pod. Use the host's network namespace.
   * If this option is set, the ports that will be used must be specified.
   * Default to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Use the host's pid namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#hostPID
   */
  readonly hostPid?: boolean;

  /**
   * Use the host's user namespace.
   * Optional: Default to true.
   * If set to true or not present, the pod will be run in the host user namespace, useful
   * for when the pod needs a feature only available to the host user namespace, such as
   * loading a kernel module with CAP_SYS_MODULE.
   * When set to false, a new userns is created for the pod. Setting false is useful for
   * mitigating container breakout vulnerabilities even allowing users to run their
   * containers as root without actually having root privileges on the host.
   * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
   *
   * @default true.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#hostUsers
   */
  readonly hostUsers?: boolean;

  /**
   * Specifies the hostname of the Pod
   * If not specified, the pod's hostname will be set to a system-defined value.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#hostname
   */
  readonly hostname?: string;

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
   * If specified, these secrets will be passed to individual puller implementations for them to use.
   * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: AutoscalingRunnerSetSpecListenerTemplateSpecImagePullSecrets[];

  /**
   * List of initialization containers belonging to the pod.
   * Init containers are executed in order prior to containers being started. If any
   * init container fails, the pod is considered to have failed and is handled according
   * to its restartPolicy. The name for an init container or normal container must be
   * unique among all containers.
   * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
   * The resourceRequirements of an init container are taken into account during scheduling
   * by finding the highest request/limit for each resource type, and then using the max of
   * of that value or the sum of the normal containers. Limits are applied to init containers
   * in a similar fashion.
   * Init containers cannot currently be added or removed.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#initContainers
   */
  readonly initContainers?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers[];

  /**
   * NodeName indicates in which node this pod is scheduled.
   * If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName.
   * Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod.
   * This field should not be used to express a desire for the pod to be scheduled on a specific node.
   * https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#nodeName
   */
  readonly nodeName?: string;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specifies the OS of the containers in the pod.
   * Some pod and container fields are restricted if this is set.
   *
   * If the OS field is set to linux, the following fields must be unset:
   * -securityContext.windowsOptions
   *
   * If the OS field is set to windows, following fields must be unset:
   * - spec.hostPID
   * - spec.hostIPC
   * - spec.hostUsers
   * - spec.securityContext.appArmorProfile
   * - spec.securityContext.seLinuxOptions
   * - spec.securityContext.seccompProfile
   * - spec.securityContext.fsGroup
   * - spec.securityContext.fsGroupChangePolicy
   * - spec.securityContext.sysctls
   * - spec.shareProcessNamespace
   * - spec.securityContext.runAsUser
   * - spec.securityContext.runAsGroup
   * - spec.securityContext.supplementalGroups
   * - spec.securityContext.supplementalGroupsPolicy
   * - spec.containers[*].securityContext.appArmorProfile
   * - spec.containers[*].securityContext.seLinuxOptions
   * - spec.containers[*].securityContext.seccompProfile
   * - spec.containers[*].securityContext.capabilities
   * - spec.containers[*].securityContext.readOnlyRootFilesystem
   * - spec.containers[*].securityContext.privileged
   * - spec.containers[*].securityContext.allowPrivilegeEscalation
   * - spec.containers[*].securityContext.procMount
   * - spec.containers[*].securityContext.runAsUser
   * - spec.containers[*].securityContext.runAsGroup
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#os
   */
  readonly os?: AutoscalingRunnerSetSpecListenerTemplateSpecOs;

  /**
   * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
   * This field will be autopopulated at admission time by the RuntimeClass admission controller. If
   * the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
   * The RuntimeClass admission controller will reject Pod create requests which have the overhead already
   * set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
   * defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#overhead
   */
  readonly overhead?: {
    [key: string]: AutoscalingRunnerSetSpecListenerTemplateSpecOverhead;
  };

  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority.
   * One of Never, PreemptLowerPriority.
   * Defaults to PreemptLowerPriority if unset.
   *
   * @default PreemptLowerPriority if unset.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#preemptionPolicy
   */
  readonly preemptionPolicy?: string;

  /**
   * The priority value. Various system components use this field to find the
   * priority of the pod. When Priority Admission Controller is enabled, it
   * prevents users from setting this field. The admission controller populates
   * this field from PriorityClassName.
   * The higher the value, the higher the priority.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#priority
   */
  readonly priority?: number;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and
   * "system-cluster-critical" are two special keywords which indicate the
   * highest priorities with the former being the highest priority. Any other
   * name must be defined by creating a PriorityClass object with that name.
   * If not specified, the pod priority will be default or zero if there is no
   * default.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, all readiness gates will be evaluated for pod readiness.
   * A pod is ready when all its containers are ready AND
   * all conditions specified in the readiness gates have status equal to "True"
   * More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#readinessGates
   */
  readonly readinessGates?: AutoscalingRunnerSetSpecListenerTemplateSpecReadinessGates[];

  /**
   * ResourceClaims defines which ResourceClaims must be allocated
   * and reserved before the Pod is allowed to start. The resources
   * will be made available to those containers which consume them
   * by name.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#resourceClaims
   */
  readonly resourceClaims?: AutoscalingRunnerSetSpecListenerTemplateSpecResourceClaims[];

  /**
   * Resources is the total amount of CPU and Memory resources required by all
   * containers in the pod. It supports specifying Requests and Limits for
   * "cpu" and "memory" resource names only. ResourceClaims are not supported.
   *
   * This field enables fine-grained control over resource allocation for the
   * entire pod, allowing resource sharing among containers in a pod.
   *
   * This is an alpha field and requires enabling the PodLevelResources feature
   * gate.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#resources
   */
  readonly resources?: AutoscalingRunnerSetSpecListenerTemplateSpecResources;

  /**
   * Restart policy for all containers within the pod.
   * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
   * Default to Always.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   *
   * @default Always.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
   * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
   * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
   * empty definition that uses the default runtime handler.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * If specified, the pod will be dispatched by specified scheduler.
   * If not specified, the pod will be dispatched by default scheduler.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * SchedulingGates is an opaque list of values that if specified will block scheduling the pod.
   * If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the
   * scheduler will not attempt to schedule the pod.
   *
   * SchedulingGates can only be set at pod creation time, and be removed only afterwards.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#schedulingGates
   */
  readonly schedulingGates?: AutoscalingRunnerSetSpecListenerTemplateSpecSchedulingGates[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * Optional: Defaults to empty.  See type description for default values of each field.
   *
   * @default empty.  See type description for default values of each field.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#securityContext
   */
  readonly securityContext?: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext;

  /**
   * DeprecatedServiceAccount is a deprecated alias for ServiceAccountName.
   * Deprecated: Use serviceAccountName instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
   * In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
   * In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
   * If a pod does not have FQDN, this has no effect.
   * Default to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#setHostnameAsFQDN
   */
  readonly setHostnameAsFqdn?: boolean;

  /**
   * Share a single process namespace between all of the containers in a pod.
   * When this is set containers will be able to view and signal processes from other containers
   * in the same pod, and the first process in each container will not be assigned PID 1.
   * HostPID and ShareProcessNamespace cannot both be set.
   * Optional: Default to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#shareProcessNamespace
   */
  readonly shareProcessNamespace?: boolean;

  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
   * If not specified, the pod will not have a domainname at all.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#subdomain
   */
  readonly subdomain?: string;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * If this value is nil, the default grace period will be used instead.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#tolerations
   */
  readonly tolerations?: AutoscalingRunnerSetSpecListenerTemplateSpecTolerations[];

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology
   * domains. Scheduler will schedule pods in a way which abides by the constraints.
   * All topologySpreadConstraints are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints[];

  /**
   * List of volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpec#volumes
   */
  readonly volumes?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumes[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    activeDeadlineSeconds: obj.activeDeadlineSeconds,
    affinity: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinity(obj.affinity),
    automountServiceAccountToken: obj.automountServiceAccountToken,
    containers: obj.containers?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainers(y)),
    dnsConfig: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfig(obj.dnsConfig),
    dnsPolicy: obj.dnsPolicy,
    enableServiceLinks: obj.enableServiceLinks,
    ephemeralContainers: obj.ephemeralContainers?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers(y),
    ),
    hostAliases: obj.hostAliases?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecHostAliases(y)),
    hostIPC: obj.hostIpc,
    hostNetwork: obj.hostNetwork,
    hostPID: obj.hostPid,
    hostUsers: obj.hostUsers,
    hostname: obj.hostname,
    imagePullSecrets: obj.imagePullSecrets?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecImagePullSecrets(y),
    ),
    initContainers: obj.initContainers?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers(y),
    ),
    nodeName: obj.nodeName,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    os: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecOs(obj.os),
    overhead:
      obj.overhead === undefined
        ? undefined
        : Object.entries(obj.overhead).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    preemptionPolicy: obj.preemptionPolicy,
    priority: obj.priority,
    priorityClassName: obj.priorityClassName,
    readinessGates: obj.readinessGates?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecReadinessGates(y),
    ),
    resourceClaims: obj.resourceClaims?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecResourceClaims(y),
    ),
    resources: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    runtimeClassName: obj.runtimeClassName,
    schedulerName: obj.schedulerName,
    schedulingGates: obj.schedulingGates?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSchedulingGates(y),
    ),
    securityContext: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext(obj.securityContext),
    serviceAccount: obj.serviceAccount,
    serviceAccountName: obj.serviceAccountName,
    setHostnameAsFQDN: obj.setHostnameAsFqdn,
    shareProcessNamespace: obj.shareProcessNamespace,
    subdomain: obj.subdomain,
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    tolerations: obj.tolerations?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecTolerations(y)),
    topologySpreadConstraints: obj.topologySpreadConstraints?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints(y),
    ),
    volumes: obj.volumes?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecProxyHttp
 */
export interface AutoscalingRunnerSetSpecProxyHttp {
  /**
   * @schema AutoscalingRunnerSetSpecProxyHttp#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema AutoscalingRunnerSetSpecProxyHttp#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecProxyHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecProxyHttp(
  obj: AutoscalingRunnerSetSpecProxyHttp | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecProxyHttps
 */
export interface AutoscalingRunnerSetSpecProxyHttps {
  /**
   * @schema AutoscalingRunnerSetSpecProxyHttps#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema AutoscalingRunnerSetSpecProxyHttps#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecProxyHttps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecProxyHttps(
  obj: AutoscalingRunnerSetSpecProxyHttps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Standard object's metadata.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema AutoscalingRunnerSetSpecTemplateMetadata
 */
export interface AutoscalingRunnerSetSpecTemplateMetadata {
  /**
   * @schema AutoscalingRunnerSetSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema AutoscalingRunnerSetSpecTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema AutoscalingRunnerSetSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema AutoscalingRunnerSetSpecTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema AutoscalingRunnerSetSpecTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateMetadata(
  obj: AutoscalingRunnerSetSpecTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    finalizers: obj.finalizers?.map((y) => y),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the desired behavior of the pod.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpec
 */
export interface AutoscalingRunnerSetSpecTemplateSpec {
  /**
   * Optional duration in seconds the pod may be active on the node relative to
   * StartTime before the system will actively try to mark it failed and kill associated containers.
   * Value must be a positive integer.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#affinity
   */
  readonly affinity?: AutoscalingRunnerSetSpecTemplateSpecAffinity;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * List of containers belonging to the pod.
   * Containers cannot currently be added or removed.
   * There must be at least one container in a Pod.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#containers
   */
  readonly containers: AutoscalingRunnerSetSpecTemplateSpecContainers[];

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#dnsConfig
   */
  readonly dnsConfig?: AutoscalingRunnerSetSpecTemplateSpecDnsConfig;

  /**
   * Set DNS policy for the pod.
   * Defaults to "ClusterFirst".
   * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
   * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
   * To have DNS options set along with hostNetwork, you have to specify DNS policy
   * explicitly to 'ClusterFirstWithHostNet'.
   *
   * @default ClusterFirst".
   * @schema AutoscalingRunnerSetSpecTemplateSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's
   * environment variables, matching the syntax of Docker links.
   * Optional: Defaults to true.
   *
   * @default true.
   * @schema AutoscalingRunnerSetSpecTemplateSpec#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
   * pod to perform user-initiated actions such as debugging. This list cannot be specified when
   * creating a pod, and it cannot be modified by updating the pod spec. In order to add an
   * ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#ephemeralContainers
   */
  readonly ephemeralContainers?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers[];

  /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
   * file if specified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#hostAliases
   */
  readonly hostAliases?: AutoscalingRunnerSetSpecTemplateSpecHostAliases[];

  /**
   * Use the host's ipc namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpec#hostIPC
   */
  readonly hostIpc?: boolean;

  /**
   * Host networking requested for this pod. Use the host's network namespace.
   * If this option is set, the ports that will be used must be specified.
   * Default to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Use the host's pid namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpec#hostPID
   */
  readonly hostPid?: boolean;

  /**
   * Use the host's user namespace.
   * Optional: Default to true.
   * If set to true or not present, the pod will be run in the host user namespace, useful
   * for when the pod needs a feature only available to the host user namespace, such as
   * loading a kernel module with CAP_SYS_MODULE.
   * When set to false, a new userns is created for the pod. Setting false is useful for
   * mitigating container breakout vulnerabilities even allowing users to run their
   * containers as root without actually having root privileges on the host.
   * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
   *
   * @default true.
   * @schema AutoscalingRunnerSetSpecTemplateSpec#hostUsers
   */
  readonly hostUsers?: boolean;

  /**
   * Specifies the hostname of the Pod
   * If not specified, the pod's hostname will be set to a system-defined value.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#hostname
   */
  readonly hostname?: string;

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
   * If specified, these secrets will be passed to individual puller implementations for them to use.
   * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: AutoscalingRunnerSetSpecTemplateSpecImagePullSecrets[];

  /**
   * List of initialization containers belonging to the pod.
   * Init containers are executed in order prior to containers being started. If any
   * init container fails, the pod is considered to have failed and is handled according
   * to its restartPolicy. The name for an init container or normal container must be
   * unique among all containers.
   * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
   * The resourceRequirements of an init container are taken into account during scheduling
   * by finding the highest request/limit for each resource type, and then using the max of
   * of that value or the sum of the normal containers. Limits are applied to init containers
   * in a similar fashion.
   * Init containers cannot currently be added or removed.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#initContainers
   */
  readonly initContainers?: AutoscalingRunnerSetSpecTemplateSpecInitContainers[];

  /**
   * NodeName indicates in which node this pod is scheduled.
   * If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName.
   * Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod.
   * This field should not be used to express a desire for the pod to be scheduled on a specific node.
   * https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#nodeName
   */
  readonly nodeName?: string;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specifies the OS of the containers in the pod.
   * Some pod and container fields are restricted if this is set.
   *
   * If the OS field is set to linux, the following fields must be unset:
   * -securityContext.windowsOptions
   *
   * If the OS field is set to windows, following fields must be unset:
   * - spec.hostPID
   * - spec.hostIPC
   * - spec.hostUsers
   * - spec.securityContext.appArmorProfile
   * - spec.securityContext.seLinuxOptions
   * - spec.securityContext.seccompProfile
   * - spec.securityContext.fsGroup
   * - spec.securityContext.fsGroupChangePolicy
   * - spec.securityContext.sysctls
   * - spec.shareProcessNamespace
   * - spec.securityContext.runAsUser
   * - spec.securityContext.runAsGroup
   * - spec.securityContext.supplementalGroups
   * - spec.securityContext.supplementalGroupsPolicy
   * - spec.containers[*].securityContext.appArmorProfile
   * - spec.containers[*].securityContext.seLinuxOptions
   * - spec.containers[*].securityContext.seccompProfile
   * - spec.containers[*].securityContext.capabilities
   * - spec.containers[*].securityContext.readOnlyRootFilesystem
   * - spec.containers[*].securityContext.privileged
   * - spec.containers[*].securityContext.allowPrivilegeEscalation
   * - spec.containers[*].securityContext.procMount
   * - spec.containers[*].securityContext.runAsUser
   * - spec.containers[*].securityContext.runAsGroup
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#os
   */
  readonly os?: AutoscalingRunnerSetSpecTemplateSpecOs;

  /**
   * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
   * This field will be autopopulated at admission time by the RuntimeClass admission controller. If
   * the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
   * The RuntimeClass admission controller will reject Pod create requests which have the overhead already
   * set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
   * defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#overhead
   */
  readonly overhead?: {
    [key: string]: AutoscalingRunnerSetSpecTemplateSpecOverhead;
  };

  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority.
   * One of Never, PreemptLowerPriority.
   * Defaults to PreemptLowerPriority if unset.
   *
   * @default PreemptLowerPriority if unset.
   * @schema AutoscalingRunnerSetSpecTemplateSpec#preemptionPolicy
   */
  readonly preemptionPolicy?: string;

  /**
   * The priority value. Various system components use this field to find the
   * priority of the pod. When Priority Admission Controller is enabled, it
   * prevents users from setting this field. The admission controller populates
   * this field from PriorityClassName.
   * The higher the value, the higher the priority.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#priority
   */
  readonly priority?: number;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and
   * "system-cluster-critical" are two special keywords which indicate the
   * highest priorities with the former being the highest priority. Any other
   * name must be defined by creating a PriorityClass object with that name.
   * If not specified, the pod priority will be default or zero if there is no
   * default.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, all readiness gates will be evaluated for pod readiness.
   * A pod is ready when all its containers are ready AND
   * all conditions specified in the readiness gates have status equal to "True"
   * More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#readinessGates
   */
  readonly readinessGates?: AutoscalingRunnerSetSpecTemplateSpecReadinessGates[];

  /**
   * ResourceClaims defines which ResourceClaims must be allocated
   * and reserved before the Pod is allowed to start. The resources
   * will be made available to those containers which consume them
   * by name.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#resourceClaims
   */
  readonly resourceClaims?: AutoscalingRunnerSetSpecTemplateSpecResourceClaims[];

  /**
   * Resources is the total amount of CPU and Memory resources required by all
   * containers in the pod. It supports specifying Requests and Limits for
   * "cpu" and "memory" resource names only. ResourceClaims are not supported.
   *
   * This field enables fine-grained control over resource allocation for the
   * entire pod, allowing resource sharing among containers in a pod.
   *
   * This is an alpha field and requires enabling the PodLevelResources feature
   * gate.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#resources
   */
  readonly resources?: AutoscalingRunnerSetSpecTemplateSpecResources;

  /**
   * Restart policy for all containers within the pod.
   * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
   * Default to Always.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   *
   * @default Always.
   * @schema AutoscalingRunnerSetSpecTemplateSpec#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
   * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
   * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
   * empty definition that uses the default runtime handler.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * If specified, the pod will be dispatched by specified scheduler.
   * If not specified, the pod will be dispatched by default scheduler.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * SchedulingGates is an opaque list of values that if specified will block scheduling the pod.
   * If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the
   * scheduler will not attempt to schedule the pod.
   *
   * SchedulingGates can only be set at pod creation time, and be removed only afterwards.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#schedulingGates
   */
  readonly schedulingGates?: AutoscalingRunnerSetSpecTemplateSpecSchedulingGates[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * Optional: Defaults to empty.  See type description for default values of each field.
   *
   * @default empty.  See type description for default values of each field.
   * @schema AutoscalingRunnerSetSpecTemplateSpec#securityContext
   */
  readonly securityContext?: AutoscalingRunnerSetSpecTemplateSpecSecurityContext;

  /**
   * DeprecatedServiceAccount is a deprecated alias for ServiceAccountName.
   * Deprecated: Use serviceAccountName instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
   * In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
   * In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
   * If a pod does not have FQDN, this has no effect.
   * Default to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpec#setHostnameAsFQDN
   */
  readonly setHostnameAsFqdn?: boolean;

  /**
   * Share a single process namespace between all of the containers in a pod.
   * When this is set containers will be able to view and signal processes from other containers
   * in the same pod, and the first process in each container will not be assigned PID 1.
   * HostPID and ShareProcessNamespace cannot both be set.
   * Optional: Default to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpec#shareProcessNamespace
   */
  readonly shareProcessNamespace?: boolean;

  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
   * If not specified, the pod will not have a domainname at all.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#subdomain
   */
  readonly subdomain?: string;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * If this value is nil, the default grace period will be used instead.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema AutoscalingRunnerSetSpecTemplateSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#tolerations
   */
  readonly tolerations?: AutoscalingRunnerSetSpecTemplateSpecTolerations[];

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology
   * domains. Scheduler will schedule pods in a way which abides by the constraints.
   * All topologySpreadConstraints are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints[];

  /**
   * List of volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpec#volumes
   */
  readonly volumes?: AutoscalingRunnerSetSpecTemplateSpecVolumes[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpec(
  obj: AutoscalingRunnerSetSpecTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    activeDeadlineSeconds: obj.activeDeadlineSeconds,
    affinity: toJson_AutoscalingRunnerSetSpecTemplateSpecAffinity(obj.affinity),
    automountServiceAccountToken: obj.automountServiceAccountToken,
    containers: obj.containers?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecContainers(y)),
    dnsConfig: toJson_AutoscalingRunnerSetSpecTemplateSpecDnsConfig(obj.dnsConfig),
    dnsPolicy: obj.dnsPolicy,
    enableServiceLinks: obj.enableServiceLinks,
    ephemeralContainers: obj.ephemeralContainers?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers(y),
    ),
    hostAliases: obj.hostAliases?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecHostAliases(y)),
    hostIPC: obj.hostIpc,
    hostNetwork: obj.hostNetwork,
    hostPID: obj.hostPid,
    hostUsers: obj.hostUsers,
    hostname: obj.hostname,
    imagePullSecrets: obj.imagePullSecrets?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecImagePullSecrets(y)),
    initContainers: obj.initContainers?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainers(y)),
    nodeName: obj.nodeName,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    os: toJson_AutoscalingRunnerSetSpecTemplateSpecOs(obj.os),
    overhead:
      obj.overhead === undefined
        ? undefined
        : Object.entries(obj.overhead).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    preemptionPolicy: obj.preemptionPolicy,
    priority: obj.priority,
    priorityClassName: obj.priorityClassName,
    readinessGates: obj.readinessGates?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecReadinessGates(y)),
    resourceClaims: obj.resourceClaims?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecResourceClaims(y)),
    resources: toJson_AutoscalingRunnerSetSpecTemplateSpecResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    runtimeClassName: obj.runtimeClassName,
    schedulerName: obj.schedulerName,
    schedulingGates: obj.schedulingGates?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecSchedulingGates(y)),
    securityContext: toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContext(obj.securityContext),
    serviceAccount: obj.serviceAccount,
    serviceAccountName: obj.serviceAccountName,
    setHostnameAsFQDN: obj.setHostnameAsFqdn,
    shareProcessNamespace: obj.shareProcessNamespace,
    subdomain: obj.subdomain,
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    tolerations: obj.tolerations?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecTolerations(y)),
    topologySpreadConstraints: obj.topologySpreadConstraints?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints(y),
    ),
    volumes: obj.volumes?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecVaultConfigAzureKeyVault
 */
export interface AutoscalingRunnerSetSpecVaultConfigAzureKeyVault {
  /**
   * @schema AutoscalingRunnerSetSpecVaultConfigAzureKeyVault#certificatePath
   */
  readonly certificatePath: string;

  /**
   * @schema AutoscalingRunnerSetSpecVaultConfigAzureKeyVault#clientId
   */
  readonly clientId: string;

  /**
   * @schema AutoscalingRunnerSetSpecVaultConfigAzureKeyVault#tenantId
   */
  readonly tenantId: string;

  /**
   * @schema AutoscalingRunnerSetSpecVaultConfigAzureKeyVault#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecVaultConfigAzureKeyVault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecVaultConfigAzureKeyVault(
  obj: AutoscalingRunnerSetSpecVaultConfigAzureKeyVault | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certificatePath: obj.certificatePath,
    clientId: obj.clientId,
    tenantId: obj.tenantId,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecVaultConfigProxy
 */
export interface AutoscalingRunnerSetSpecVaultConfigProxy {
  /**
   * @schema AutoscalingRunnerSetSpecVaultConfigProxy#http
   */
  readonly http?: AutoscalingRunnerSetSpecVaultConfigProxyHttp;

  /**
   * @schema AutoscalingRunnerSetSpecVaultConfigProxy#https
   */
  readonly https?: AutoscalingRunnerSetSpecVaultConfigProxyHttps;

  /**
   * @schema AutoscalingRunnerSetSpecVaultConfigProxy#noProxy
   */
  readonly noProxy?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecVaultConfigProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecVaultConfigProxy(
  obj: AutoscalingRunnerSetSpecVaultConfigProxy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_AutoscalingRunnerSetSpecVaultConfigProxyHttp(obj.http),
    https: toJson_AutoscalingRunnerSetSpecVaultConfigProxyHttps(obj.https),
    noProxy: obj.noProxy?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required
 *
 * @schema AutoscalingRunnerSetSpecGithubServerTlsCertificateFromConfigMapKeyRef
 */
export interface AutoscalingRunnerSetSpecGithubServerTlsCertificateFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AutoscalingRunnerSetSpecGithubServerTlsCertificateFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecGithubServerTlsCertificateFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecGithubServerTlsCertificateFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecGithubServerTlsCertificateFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecGithubServerTlsCertificateFromConfigMapKeyRef(
  obj: AutoscalingRunnerSetSpecGithubServerTlsCertificateFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If specified, the pod's scheduling constraints
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinity
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinity(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeAffinity: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinity(obj.nodeAffinity),
    podAffinity: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinity(obj.podAffinity),
    podAntiAffinity: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#env
   */
  readonly env?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#envFrom
   */
  readonly envFrom?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#lifecycle
   */
  readonly lifecycle?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#livenessProbe
   */
  readonly livenessProbe?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#ports
   */
  readonly ports?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#readinessProbe
   */
  readonly readinessProbe?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#resizePolicy
   */
  readonly resizePolicy?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#resources
   */
  readonly resources?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#securityContext
   */
  readonly securityContext?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#startupProbe
   */
  readonly startupProbe?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#volumeDevices
   */
  readonly volumeDevices?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#volumeMounts
   */
  readonly volumeMounts?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainers(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts(y)),
    readinessProbe: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersResizePolicy(y),
    ),
    resources: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext(obj.securityContext),
    startupProbe: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeDevices(y),
    ),
    volumeMounts: obj.volumeMounts?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts(y),
    ),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfig
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfig#options
   */
  readonly options?: AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfig#searches
   */
  readonly searches?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfig(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nameservers: obj.nameservers?.map((y) => y),
    options: obj.options?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfigOptions(y)),
    searches: obj.searches?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for
 * user-initiated activities such as debugging. Ephemeral containers have no resource or
 * scheduling guarantees, and they will not be restarted when they exit or when a Pod is
 * removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the
 * Pod to exceed its resource allocation.
 *
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing
 * Pod. Ephemeral containers may not be removed or restarted.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers {
  /**
   * Arguments to the entrypoint.
   * The image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#env
   */
  readonly env?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#envFrom
   */
  readonly envFrom?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#lifecycle
   */
  readonly lifecycle?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecycle;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#livenessProbe
   */
  readonly livenessProbe?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe;

  /**
   * Name of the ephemeral container specified as a DNS_LABEL.
   * This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#name
   */
  readonly name: string;

  /**
   * Ports are not allowed for ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#ports
   */
  readonly ports?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts[];

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#readinessProbe
   */
  readonly readinessProbe?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#resizePolicy
   */
  readonly resizePolicy?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResizePolicy[];

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
   * already allocated to the pod.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#resources
   */
  readonly resources?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResources;

  /**
   * Restart policy for the container to manage the restart behavior of each
   * container within a pod.
   * This may only be set for init containers. You cannot set this field on
   * ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#securityContext
   */
  readonly securityContext?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#startupProbe
   */
  readonly startupProbe?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets.
   * The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
   * If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   *
   * The container runtime must implement support for this feature. If the runtime does not
   * support namespace targeting then the result of setting this field is undefined.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#targetContainerName
   */
  readonly targetContainerName?: string;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#volumeDevices
   */
  readonly volumeDevices?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#volumeMounts
   */
  readonly volumeMounts?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe(
      obj.livenessProbe,
    ),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts(y)),
    readinessProbe: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe(
      obj.readinessProbe,
    ),
    resizePolicy: obj.resizePolicy?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResizePolicy(y),
    ),
    resources: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext(
      obj.securityContext,
    ),
    startupProbe: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    targetContainerName: obj.targetContainerName,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeDevices(y),
    ),
    volumeMounts: obj.volumeMounts?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts(y),
    ),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecHostAliases
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecHostAliases#ip
   */
  readonly ip: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecHostAliases(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecHostAliases | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    hostnames: obj.hostnames?.map((y) => y),
    ip: obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecImagePullSecrets
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecImagePullSecrets(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecImagePullSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#env
   */
  readonly env?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#envFrom
   */
  readonly envFrom?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#lifecycle
   */
  readonly lifecycle?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#ports
   */
  readonly ports?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#resources
   */
  readonly resources?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#securityContext
   */
  readonly securityContext?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#startupProbe
   */
  readonly startupProbe?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts(y)),
    readinessProbe: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResizePolicy(y),
    ),
    resources: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext(
      obj.securityContext,
    ),
    startupProbe: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeDevices(y),
    ),
    volumeMounts: obj.volumeMounts?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts(y),
    ),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the OS of the containers in the pod.
 * Some pod and container fields are restricted if this is set.
 *
 * If the OS field is set to linux, the following fields must be unset:
 * -securityContext.windowsOptions
 *
 * If the OS field is set to windows, following fields must be unset:
 * - spec.hostPID
 * - spec.hostIPC
 * - spec.hostUsers
 * - spec.securityContext.appArmorProfile
 * - spec.securityContext.seLinuxOptions
 * - spec.securityContext.seccompProfile
 * - spec.securityContext.fsGroup
 * - spec.securityContext.fsGroupChangePolicy
 * - spec.securityContext.sysctls
 * - spec.shareProcessNamespace
 * - spec.securityContext.runAsUser
 * - spec.securityContext.runAsGroup
 * - spec.securityContext.supplementalGroups
 * - spec.securityContext.supplementalGroupsPolicy
 * - spec.containers[*].securityContext.appArmorProfile
 * - spec.containers[*].securityContext.seLinuxOptions
 * - spec.containers[*].securityContext.seccompProfile
 * - spec.containers[*].securityContext.capabilities
 * - spec.containers[*].securityContext.readOnlyRootFilesystem
 * - spec.containers[*].securityContext.privileged
 * - spec.containers[*].securityContext.allowPrivilegeEscalation
 * - spec.containers[*].securityContext.procMount
 * - spec.containers[*].securityContext.runAsUser
 * - spec.containers[*].securityContext.runAsGroup
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecOs
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecOs {
  /**
   * Name is the name of the operating system. The currently supported values are linux and windows.
   * Additional value may be defined in future and can be one of:
   * https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
   * Clients should expect to handle additional values and treat unrecognized values in this field as os: null
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecOs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecOs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecOs(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecOs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecOverhead
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecOverhead {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecListenerTemplateSpecOverhead {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecOverhead(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecListenerTemplateSpecOverhead {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecOverhead(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecReadinessGates
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecReadinessGates#conditionType
   */
  readonly conditionType: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecReadinessGates(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecReadinessGates | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conditionType: obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodResourceClaim references exactly one ResourceClaim, either directly
 * or by naming a ResourceClaimTemplate which is then turned into a ResourceClaim
 * for the pod.
 *
 * It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
 * Containers that need access to the ResourceClaim reference it with this name.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResourceClaims
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecResourceClaims {
  /**
   * Name uniquely identifies this resource claim inside the pod.
   * This must be a DNS_LABEL.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResourceClaims#name
   */
  readonly name: string;

  /**
   * ResourceClaimName is the name of a ResourceClaim object in the same
   * namespace as this pod.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResourceClaims#resourceClaimName
   */
  readonly resourceClaimName?: string;

  /**
   * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
   * object in the same namespace as this pod.
   *
   * The template will be used to create a new ResourceClaim, which will
   * be bound to this pod. When this pod is deleted, the ResourceClaim
   * will also be deleted. The pod name and resource name, along with a
   * generated component, will be used to form a unique name for the
   * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
   *
   * This field is immutable and no changes will be made to the
   * corresponding ResourceClaim by the control plane after creating the
   * ResourceClaim.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResourceClaims#resourceClaimTemplateName
   */
  readonly resourceClaimTemplateName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecResourceClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecResourceClaims(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecResourceClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    resourceClaimName: obj.resourceClaimName,
    resourceClaimTemplateName: obj.resourceClaimTemplateName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources is the total amount of CPU and Memory resources required by all
 * containers in the pod. It supports specifying Requests and Limits for
 * "cpu" and "memory" resource names only. ResourceClaims are not supported.
 *
 * This field enables fine-grained control over resource allocation for the
 * entire pod, allowing resource sharing among containers in a pod.
 *
 * This is an alpha field and requires enabling the PodLevelResources feature
 * gate.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResources
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResources#claims
   */
  readonly claims?: AutoscalingRunnerSetSpecListenerTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingRunnerSetSpecListenerTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingRunnerSetSpecListenerTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecResources(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodSchedulingGate is associated to a Pod to guard its scheduling.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSchedulingGates
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecSchedulingGates {
  /**
   * Name of the scheduling gate.
   * Each scheduling gate must have a unique name field.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSchedulingGates#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecSchedulingGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSchedulingGates(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecSchedulingGates | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings.
 * Optional: Defaults to empty.  See type description for default values of each field.
 *
 * @default empty.  See type description for default values of each field.
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    appArmorProfile: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    fsGroup: obj.fsGroup,
    fsGroupChangePolicy: obj.fsGroupChangePolicy,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxChangePolicy: obj.seLinuxChangePolicy,
    seLinuxOptions: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    supplementalGroups: obj.supplementalGroups?.map((y) => y),
    supplementalGroupsPolicy: obj.supplementalGroupsPolicy,
    sysctls: obj.sysctls?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSysctls(y)),
    windowsOptions: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTolerations
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecTolerations(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelector(
      obj.labelSelector,
    ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    maxSkew: obj.maxSkew,
    minDomains: obj.minDomains,
    nodeAffinityPolicy: obj.nodeAffinityPolicy,
    nodeTaintsPolicy: obj.nodeTaintsPolicy,
    topologyKey: obj.topologyKey,
    whenUnsatisfiable: obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
   * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
   * are redirected to the disk.csi.azure.com CSI driver.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#azureDisk
   */
  readonly azureDisk?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
   * are redirected to the file.csi.azure.com CSI driver.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#azureFile
   */
  readonly azureFile?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
   * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#cephfs
   */
  readonly cephfs?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
   * are redirected to the cinder.csi.openstack.org CSI driver.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#cinder
   */
  readonly cinder?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#configMap
   */
  readonly configMap?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#csi
   */
  readonly csi?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#downwardAPI
   */
  readonly downwardApi?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#emptyDir
   */
  readonly emptyDir?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#ephemeral
   */
  readonly ephemeral?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#fc
   */
  readonly fc?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#flexVolume
   */
  readonly flexVolume?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
   * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#flocker
   */
  readonly flocker?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
   * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#gitRepo
   */
  readonly gitRepo?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#glusterfs
   */
  readonly glusterfs?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#hostPath
   */
  readonly hostPath?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesHostPath;

  /**
   * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
   * The volume is resolved at pod startup depending on which PullPolicy value is provided:
   *
   * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   *
   * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
   * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
   * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
   * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
   * The volume will be mounted read-only (ro) and non-executable files (noexec).
   * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
   * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#image
   */
  readonly image?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesImage;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#iscsi
   */
  readonly iscsi?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#nfs
   */
  readonly nfs?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
   * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
   * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
   * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
   * is on.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#projected
   */
  readonly projected?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
   * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#quobyte
   */
  readonly quobyte?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#rbd
   */
  readonly rbd?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#scaleIO
   */
  readonly scaleIo?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#secret
   */
  readonly secret?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#storageos
   */
  readonly storageos?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
   * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
   * are redirected to the csi.vsphere.vmware.com CSI driver.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesVsphereVolume;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumes(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    awsElasticBlockStore: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAwsElasticBlockStore(
      obj.awsElasticBlockStore,
    ),
    azureDisk: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk(obj.azureDisk),
    azureFile: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureFile(obj.azureFile),
    cephfs: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs(obj.cephfs),
    cinder: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinder(obj.cinder),
    configMap: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMap(obj.configMap),
    csi: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi(obj.csi),
    downwardAPI: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApi(obj.downwardApi),
    emptyDir: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDir(obj.emptyDir),
    ephemeral: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeral(obj.ephemeral),
    fc: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc(obj.fc),
    flexVolume: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume(obj.flexVolume),
    flocker: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlocker(obj.flocker),
    gcePersistentDisk: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGcePersistentDisk(
      obj.gcePersistentDisk,
    ),
    gitRepo: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGitRepo(obj.gitRepo),
    glusterfs: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGlusterfs(obj.glusterfs),
    hostPath: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesHostPath(obj.hostPath),
    image: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesImage(obj.image),
    iscsi: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi(obj.iscsi),
    name: obj.name,
    nfs: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesNfs(obj.nfs),
    persistentVolumeClaim: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPersistentVolumeClaim(
      obj.persistentVolumeClaim,
    ),
    photonPersistentDisk: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPhotonPersistentDisk(
      obj.photonPersistentDisk,
    ),
    portworxVolume: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPortworxVolume(obj.portworxVolume),
    projected: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjected(obj.projected),
    quobyte: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte(obj.quobyte),
    rbd: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd(obj.rbd),
    scaleIO: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo(obj.scaleIo),
    secret: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecret(obj.secret),
    storageos: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos(obj.storageos),
    vsphereVolume: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If specified, the pod's scheduling constraints
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinity
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinity(
  obj: AutoscalingRunnerSetSpecTemplateSpecAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeAffinity: toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinity(obj.nodeAffinity),
    podAffinity: toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinity(obj.podAffinity),
    podAntiAffinity: toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainers
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#env
   */
  readonly env?: AutoscalingRunnerSetSpecTemplateSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#envFrom
   */
  readonly envFrom?: AutoscalingRunnerSetSpecTemplateSpecContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#lifecycle
   */
  readonly lifecycle?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#livenessProbe
   */
  readonly livenessProbe?: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#ports
   */
  readonly ports?: AutoscalingRunnerSetSpecTemplateSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#readinessProbe
   */
  readonly readinessProbe?: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#resizePolicy
   */
  readonly resizePolicy?: AutoscalingRunnerSetSpecTemplateSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#resources
   */
  readonly resources?: AutoscalingRunnerSetSpecTemplateSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#securityContext
   */
  readonly securityContext?: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#startupProbe
   */
  readonly startupProbe?: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#volumeDevices
   */
  readonly volumeDevices?: AutoscalingRunnerSetSpecTemplateSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#volumeMounts
   */
  readonly volumeMounts?: AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainers(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecContainersPorts(y)),
    readinessProbe: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecContainersResizePolicy(y)),
    resources: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext(obj.securityContext),
    startupProbe: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecContainersVolumeDevices(y)),
    volumeMounts: obj.volumeMounts?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts(y)),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecDnsConfig
 */
export interface AutoscalingRunnerSetSpecTemplateSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecDnsConfig#options
   */
  readonly options?: AutoscalingRunnerSetSpecTemplateSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecDnsConfig#searches
   */
  readonly searches?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecDnsConfig(
  obj: AutoscalingRunnerSetSpecTemplateSpecDnsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nameservers: obj.nameservers?.map((y) => y),
    options: obj.options?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecDnsConfigOptions(y)),
    searches: obj.searches?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for
 * user-initiated activities such as debugging. Ephemeral containers have no resource or
 * scheduling guarantees, and they will not be restarted when they exit or when a Pod is
 * removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the
 * Pod to exceed its resource allocation.
 *
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing
 * Pod. Ephemeral containers may not be removed or restarted.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers {
  /**
   * Arguments to the entrypoint.
   * The image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#env
   */
  readonly env?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#envFrom
   */
  readonly envFrom?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#lifecycle
   */
  readonly lifecycle?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecycle;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#livenessProbe
   */
  readonly livenessProbe?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe;

  /**
   * Name of the ephemeral container specified as a DNS_LABEL.
   * This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#name
   */
  readonly name: string;

  /**
   * Ports are not allowed for ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#ports
   */
  readonly ports?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts[];

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#readinessProbe
   */
  readonly readinessProbe?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#resizePolicy
   */
  readonly resizePolicy?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResizePolicy[];

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
   * already allocated to the pod.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#resources
   */
  readonly resources?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResources;

  /**
   * Restart policy for the container to manage the restart behavior of each
   * container within a pod.
   * This may only be set for init containers. You cannot set this field on
   * ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#securityContext
   */
  readonly securityContext?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#startupProbe
   */
  readonly startupProbe?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets.
   * The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
   * If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   *
   * The container runtime must implement support for this feature. If the runtime does not
   * support namespace targeting then the result of setting this field is undefined.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#targetContainerName
   */
  readonly targetContainerName?: string;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#volumeDevices
   */
  readonly volumeDevices?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#volumeMounts
   */
  readonly volumeMounts?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts(y)),
    readinessProbe: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResizePolicy(y),
    ),
    resources: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext(obj.securityContext),
    startupProbe: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    targetContainerName: obj.targetContainerName,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices(y),
    ),
    volumeMounts: obj.volumeMounts?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts(y),
    ),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecHostAliases
 */
export interface AutoscalingRunnerSetSpecTemplateSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecHostAliases#ip
   */
  readonly ip: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecHostAliases(
  obj: AutoscalingRunnerSetSpecTemplateSpecHostAliases | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    hostnames: obj.hostnames?.map((y) => y),
    ip: obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecImagePullSecrets
 */
export interface AutoscalingRunnerSetSpecTemplateSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecImagePullSecrets(
  obj: AutoscalingRunnerSetSpecTemplateSpecImagePullSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#env
   */
  readonly env?: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#envFrom
   */
  readonly envFrom?: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#lifecycle
   */
  readonly lifecycle?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#ports
   */
  readonly ports?: AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: AutoscalingRunnerSetSpecTemplateSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#resources
   */
  readonly resources?: AutoscalingRunnerSetSpecTemplateSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#securityContext
   */
  readonly securityContext?: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#startupProbe
   */
  readonly startupProbe?: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainers(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts(y)),
    readinessProbe: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersResizePolicy(y),
    ),
    resources: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext(obj.securityContext),
    startupProbe: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeDevices(y),
    ),
    volumeMounts: obj.volumeMounts?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts(y),
    ),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the OS of the containers in the pod.
 * Some pod and container fields are restricted if this is set.
 *
 * If the OS field is set to linux, the following fields must be unset:
 * -securityContext.windowsOptions
 *
 * If the OS field is set to windows, following fields must be unset:
 * - spec.hostPID
 * - spec.hostIPC
 * - spec.hostUsers
 * - spec.securityContext.appArmorProfile
 * - spec.securityContext.seLinuxOptions
 * - spec.securityContext.seccompProfile
 * - spec.securityContext.fsGroup
 * - spec.securityContext.fsGroupChangePolicy
 * - spec.securityContext.sysctls
 * - spec.shareProcessNamespace
 * - spec.securityContext.runAsUser
 * - spec.securityContext.runAsGroup
 * - spec.securityContext.supplementalGroups
 * - spec.securityContext.supplementalGroupsPolicy
 * - spec.containers[*].securityContext.appArmorProfile
 * - spec.containers[*].securityContext.seLinuxOptions
 * - spec.containers[*].securityContext.seccompProfile
 * - spec.containers[*].securityContext.capabilities
 * - spec.containers[*].securityContext.readOnlyRootFilesystem
 * - spec.containers[*].securityContext.privileged
 * - spec.containers[*].securityContext.allowPrivilegeEscalation
 * - spec.containers[*].securityContext.procMount
 * - spec.containers[*].securityContext.runAsUser
 * - spec.containers[*].securityContext.runAsGroup
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecOs
 */
export interface AutoscalingRunnerSetSpecTemplateSpecOs {
  /**
   * Name is the name of the operating system. The currently supported values are linux and windows.
   * Additional value may be defined in future and can be one of:
   * https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
   * Clients should expect to handle additional values and treat unrecognized values in this field as os: null
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecOs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecOs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecOs(
  obj: AutoscalingRunnerSetSpecTemplateSpecOs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecTemplateSpecOverhead
 */
export class AutoscalingRunnerSetSpecTemplateSpecOverhead {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecOverhead {
    return new AutoscalingRunnerSetSpecTemplateSpecOverhead(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecOverhead {
    return new AutoscalingRunnerSetSpecTemplateSpecOverhead(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecReadinessGates
 */
export interface AutoscalingRunnerSetSpecTemplateSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecReadinessGates#conditionType
   */
  readonly conditionType: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecReadinessGates(
  obj: AutoscalingRunnerSetSpecTemplateSpecReadinessGates | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conditionType: obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodResourceClaim references exactly one ResourceClaim, either directly
 * or by naming a ResourceClaimTemplate which is then turned into a ResourceClaim
 * for the pod.
 *
 * It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
 * Containers that need access to the ResourceClaim reference it with this name.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecResourceClaims
 */
export interface AutoscalingRunnerSetSpecTemplateSpecResourceClaims {
  /**
   * Name uniquely identifies this resource claim inside the pod.
   * This must be a DNS_LABEL.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecResourceClaims#name
   */
  readonly name: string;

  /**
   * ResourceClaimName is the name of a ResourceClaim object in the same
   * namespace as this pod.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecResourceClaims#resourceClaimName
   */
  readonly resourceClaimName?: string;

  /**
   * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
   * object in the same namespace as this pod.
   *
   * The template will be used to create a new ResourceClaim, which will
   * be bound to this pod. When this pod is deleted, the ResourceClaim
   * will also be deleted. The pod name and resource name, along with a
   * generated component, will be used to form a unique name for the
   * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
   *
   * This field is immutable and no changes will be made to the
   * corresponding ResourceClaim by the control plane after creating the
   * ResourceClaim.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecResourceClaims#resourceClaimTemplateName
   */
  readonly resourceClaimTemplateName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecResourceClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecResourceClaims(
  obj: AutoscalingRunnerSetSpecTemplateSpecResourceClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    resourceClaimName: obj.resourceClaimName,
    resourceClaimTemplateName: obj.resourceClaimTemplateName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources is the total amount of CPU and Memory resources required by all
 * containers in the pod. It supports specifying Requests and Limits for
 * "cpu" and "memory" resource names only. ResourceClaims are not supported.
 *
 * This field enables fine-grained control over resource allocation for the
 * entire pod, allowing resource sharing among containers in a pod.
 *
 * This is an alpha field and requires enabling the PodLevelResources feature
 * gate.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecResources
 */
export interface AutoscalingRunnerSetSpecTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecResources#claims
   */
  readonly claims?: AutoscalingRunnerSetSpecTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingRunnerSetSpecTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingRunnerSetSpecTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecResources(
  obj: AutoscalingRunnerSetSpecTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodSchedulingGate is associated to a Pod to guard its scheduling.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecSchedulingGates
 */
export interface AutoscalingRunnerSetSpecTemplateSpecSchedulingGates {
  /**
   * Name of the scheduling gate.
   * Each scheduling gate must have a unique name field.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSchedulingGates#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecSchedulingGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecSchedulingGates(
  obj: AutoscalingRunnerSetSpecTemplateSpecSchedulingGates | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings.
 * Optional: Defaults to empty.  See type description for default values of each field.
 *
 * @default empty.  See type description for default values of each field.
 * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext
 */
export interface AutoscalingRunnerSetSpecTemplateSpecSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingRunnerSetSpecTemplateSpecSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: AutoscalingRunnerSetSpecTemplateSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingRunnerSetSpecTemplateSpecSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContext(
  obj: AutoscalingRunnerSetSpecTemplateSpecSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    appArmorProfile: toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContextAppArmorProfile(obj.appArmorProfile),
    fsGroup: obj.fsGroup,
    fsGroupChangePolicy: obj.fsGroupChangePolicy,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxChangePolicy: obj.seLinuxChangePolicy,
    seLinuxOptions: toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    seccompProfile: toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeccompProfile(obj.seccompProfile),
    supplementalGroups: obj.supplementalGroups?.map((y) => y),
    supplementalGroupsPolicy: obj.supplementalGroupsPolicy,
    sysctls: obj.sysctls?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContextSysctls(y)),
    windowsOptions: toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecTolerations
 */
export interface AutoscalingRunnerSetSpecTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema AutoscalingRunnerSetSpecTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecTolerations(
  obj: AutoscalingRunnerSetSpecTemplateSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints
 */
export interface AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints(
  obj: AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector: toJson_AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    maxSkew: obj.maxSkew,
    minDomains: obj.minDomains,
    nodeAffinityPolicy: obj.nodeAffinityPolicy,
    nodeTaintsPolicy: obj.nodeTaintsPolicy,
    topologyKey: obj.topologyKey,
    whenUnsatisfiable: obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
   * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: AutoscalingRunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
   * are redirected to the disk.csi.azure.com CSI driver.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#azureDisk
   */
  readonly azureDisk?: AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
   * are redirected to the file.csi.azure.com CSI driver.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#azureFile
   */
  readonly azureFile?: AutoscalingRunnerSetSpecTemplateSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
   * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#cephfs
   */
  readonly cephfs?: AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
   * are redirected to the cinder.csi.openstack.org CSI driver.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#cinder
   */
  readonly cinder?: AutoscalingRunnerSetSpecTemplateSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#configMap
   */
  readonly configMap?: AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#csi
   */
  readonly csi?: AutoscalingRunnerSetSpecTemplateSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#downwardAPI
   */
  readonly downwardApi?: AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#emptyDir
   */
  readonly emptyDir?: AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#ephemeral
   */
  readonly ephemeral?: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#fc
   */
  readonly fc?: AutoscalingRunnerSetSpecTemplateSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#flexVolume
   */
  readonly flexVolume?: AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
   * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#flocker
   */
  readonly flocker?: AutoscalingRunnerSetSpecTemplateSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
   * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: AutoscalingRunnerSetSpecTemplateSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#gitRepo
   */
  readonly gitRepo?: AutoscalingRunnerSetSpecTemplateSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#glusterfs
   */
  readonly glusterfs?: AutoscalingRunnerSetSpecTemplateSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#hostPath
   */
  readonly hostPath?: AutoscalingRunnerSetSpecTemplateSpecVolumesHostPath;

  /**
   * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
   * The volume is resolved at pod startup depending on which PullPolicy value is provided:
   *
   * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   *
   * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
   * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
   * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
   * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
   * The volume will be mounted read-only (ro) and non-executable files (noexec).
   * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
   * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#image
   */
  readonly image?: AutoscalingRunnerSetSpecTemplateSpecVolumesImage;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#iscsi
   */
  readonly iscsi?: AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#nfs
   */
  readonly nfs?: AutoscalingRunnerSetSpecTemplateSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: AutoscalingRunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
   * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: AutoscalingRunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
   * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
   * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
   * is on.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: AutoscalingRunnerSetSpecTemplateSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#projected
   */
  readonly projected?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
   * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#quobyte
   */
  readonly quobyte?: AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#rbd
   */
  readonly rbd?: AutoscalingRunnerSetSpecTemplateSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#scaleIO
   */
  readonly scaleIo?: AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#secret
   */
  readonly secret?: AutoscalingRunnerSetSpecTemplateSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#storageos
   */
  readonly storageos?: AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
   * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
   * are redirected to the csi.vsphere.vmware.com CSI driver.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: AutoscalingRunnerSetSpecTemplateSpecVolumesVsphereVolume;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumes(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    awsElasticBlockStore: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore(
      obj.awsElasticBlockStore,
    ),
    azureDisk: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk(obj.azureDisk),
    azureFile: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesAzureFile(obj.azureFile),
    cephfs: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs(obj.cephfs),
    cinder: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCinder(obj.cinder),
    configMap: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMap(obj.configMap),
    csi: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCsi(obj.csi),
    downwardAPI: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApi(obj.downwardApi),
    emptyDir: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDir(obj.emptyDir),
    ephemeral: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeral(obj.ephemeral),
    fc: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesFc(obj.fc),
    flexVolume: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume(obj.flexVolume),
    flocker: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesFlocker(obj.flocker),
    gcePersistentDisk: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    gitRepo: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesGitRepo(obj.gitRepo),
    glusterfs: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesGlusterfs(obj.glusterfs),
    hostPath: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesHostPath(obj.hostPath),
    image: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesImage(obj.image),
    iscsi: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi(obj.iscsi),
    name: obj.name,
    nfs: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesNfs(obj.nfs),
    persistentVolumeClaim: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim(
      obj.persistentVolumeClaim,
    ),
    photonPersistentDisk: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk(
      obj.photonPersistentDisk,
    ),
    portworxVolume: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesPortworxVolume(obj.portworxVolume),
    projected: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjected(obj.projected),
    quobyte: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte(obj.quobyte),
    rbd: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesRbd(obj.rbd),
    scaleIO: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo(obj.scaleIo),
    secret: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesSecret(obj.secret),
    storageos: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos(obj.storageos),
    vsphereVolume: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecVaultConfigProxyHttp
 */
export interface AutoscalingRunnerSetSpecVaultConfigProxyHttp {
  /**
   * @schema AutoscalingRunnerSetSpecVaultConfigProxyHttp#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema AutoscalingRunnerSetSpecVaultConfigProxyHttp#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecVaultConfigProxyHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecVaultConfigProxyHttp(
  obj: AutoscalingRunnerSetSpecVaultConfigProxyHttp | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecVaultConfigProxyHttps
 */
export interface AutoscalingRunnerSetSpecVaultConfigProxyHttps {
  /**
   * @schema AutoscalingRunnerSetSpecVaultConfigProxyHttps#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema AutoscalingRunnerSetSpecVaultConfigProxyHttps#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecVaultConfigProxyHttps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecVaultConfigProxyHttps(
  obj: AutoscalingRunnerSetSpecVaultConfigProxyHttps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinity
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinity(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
    requiredDuringSchedulingIgnoredDuringExecution:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinity
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinity(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
    requiredDuringSchedulingIgnoredDuringExecution: obj.requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinity
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinity(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
    requiredDuringSchedulingIgnoredDuringExecution: obj.requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnv
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFrom;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnv(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFrom
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFrom(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    prefix: obj.prefix,
    secretRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecycle
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecycle#postStart
   */
  readonly postStart?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecycle#preStop
   */
  readonly preStop?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecycle(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResizePolicy
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersResizePolicy(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResources
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResources#claims
   */
  readonly claims?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersResources(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    capabilities: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextCapabilities(
      obj.capabilities,
    ),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    windowsOptions: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeDevices
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeDevices(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfigOptions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfigOptions#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfigOptions(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecDnsConfigOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnv
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnv#valueFrom
   */
  readonly valueFrom?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFrom;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnv(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFrom
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFrom#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFrom(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    prefix: obj.prefix,
    secretRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Lifecycle is not allowed for ephemeral containers.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecycle
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecycle#postStart
   */
  readonly postStart?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecycle#preStop
   */
  readonly preStop?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecycle(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocket(
      obj.tcpSocket,
    ),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocket(
      obj.tcpSocket,
    ),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResizePolicy
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResizePolicy(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
 * already allocated to the pod.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResources
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResources#claims
   */
  readonly claims?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResources(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesClaims(y),
    ),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#capabilities
   */
  readonly capabilities?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextAppArmorProfile(
        obj.appArmorProfile,
      ),
    capabilities: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextCapabilities(
      obj.capabilities,
    ),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    windowsOptions: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocket(
      obj.tcpSocket,
    ),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeDevices
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeDevices(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnv
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFrom;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnv(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFrom
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFrom(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    prefix: obj.prefix,
    secretRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecycle
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecycle(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResizePolicy
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResizePolicy(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResources
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResources#claims
   */
  readonly claims?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResources(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    capabilities: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextCapabilities(
      obj.capabilities,
    ),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    windowsOptions: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeDevices
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeDevices(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResourcesClaims
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecResourcesClaims(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResourcesLimits
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecResourcesLimits {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecListenerTemplateSpecResourcesLimits {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecListenerTemplateSpecResourcesLimits {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecResourcesRequests
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecResourcesRequests {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecListenerTemplateSpecResourcesRequests {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecListenerTemplateSpecResourcesRequests {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextAppArmorProfile
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextAppArmorProfile(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeLinuxOptions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeLinuxOptions(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeccompProfile
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeccompProfile(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSysctls
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSysctls(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextWindowsOptions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextWindowsOptions(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelector
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelector(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
 * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAwsElasticBlockStore
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAwsElasticBlockStore(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAwsElasticBlockStore | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    partition: obj.partition,
    readOnly: obj.readOnly,
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
 * are redirected to the disk.csi.azure.com CSI driver.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cachingMode: obj.cachingMode,
    diskName: obj.diskName,
    diskURI: obj.diskUri,
    fsType: obj.fsType,
    kind: obj.kind,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
 * are redirected to the file.csi.azure.com CSI driver.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureFile
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureFile(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesAzureFile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    readOnly: obj.readOnly,
    secretName: obj.secretName,
    shareName: obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
 * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    monitors: obj.monitors?.map((y) => y),
    path: obj.path,
    readOnly: obj.readOnly,
    secretFile: obj.secretFile,
    secretRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfsSecretRef(obj.secretRef),
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
 * are redirected to the cinder.csi.openstack.org CSI driver.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinder
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinder#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinder(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinder | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinderSecretRef(obj.secretRef),
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMap
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMap#items
   */
  readonly items?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMap(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMapItems(y)),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    driver: obj.driver,
    fsType: obj.fsType,
    nodePublishSecretRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsiNodePublishSecretRef(
      obj.nodePublishSecretRef,
    ),
    readOnly: obj.readOnly,
    volumeAttributes:
      obj.volumeAttributes === undefined
        ? undefined
        : Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApi
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApi#items
   */
  readonly items?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItems[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApi(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDir
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDir(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    medium: obj.medium,
    sizeLimit: obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeral
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeral(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    volumeClaimTemplate: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplate(
      obj.volumeClaimTemplate,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    lun: obj.lun,
    readOnly: obj.readOnly,
    targetWWNs: obj.targetWwNs?.map((y) => y),
    wwids: obj.wwids?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    driver: obj.driver,
    fsType: obj.fsType,
    options:
      obj.options === undefined
        ? undefined
        : Object.entries(obj.options).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
 * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlocker
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlocker(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlocker | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    datasetName: obj.datasetName,
    datasetUUID: obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
 * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGcePersistentDisk
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGcePersistentDisk(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGcePersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    partition: obj.partition,
    pdName: obj.pdName,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGitRepo
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGitRepo(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGitRepo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    directory: obj.directory,
    repository: obj.repository,
    revision: obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGlusterfs
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGlusterfs(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesGlusterfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    endpoints: obj.endpoints,
    path: obj.path,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesHostPath
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesHostPath(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesHostPath | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
 * The volume is resolved at pod startup depending on which PullPolicy value is provided:
 *
 * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
 * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
 * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
 *
 * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
 * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
 * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
 * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
 * The volume will be mounted read-only (ro) and non-executable files (noexec).
 * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
 * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesImage
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesImage {
  /**
   * Policy for pulling OCI objects. Possible values are:
   * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Required: Image or artifact reference to be used.
   * Behaves in the same way as pod.spec.containers[*].image.
   * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesImage#reference
   */
  readonly reference?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesImage(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesImage | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    pullPolicy: obj.pullPolicy,
    reference: obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    chapAuthDiscovery: obj.chapAuthDiscovery,
    chapAuthSession: obj.chapAuthSession,
    fsType: obj.fsType,
    initiatorName: obj.initiatorName,
    iqn: obj.iqn,
    iscsiInterface: obj.iscsiInterface,
    lun: obj.lun,
    portals: obj.portals?.map((y) => y),
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsiSecretRef(obj.secretRef),
    targetPortal: obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesNfs
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesNfs(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesNfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    readOnly: obj.readOnly,
    server: obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPersistentVolumeClaim
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPersistentVolumeClaim(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPersistentVolumeClaim | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claimName: obj.claimName,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
 * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPhotonPersistentDisk
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPhotonPersistentDisk(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPhotonPersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    pdID: obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
 * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
 * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
 * is on.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPortworxVolume
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPortworxVolume(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesPortworxVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjected
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections. Each entry in this list
   * handles one source.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjected#sources
   */
  readonly sources?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjected(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjected | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    sources: obj.sources?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
 * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesQuobyte | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    group: obj.group,
    readOnly: obj.readOnly,
    registry: obj.registry,
    tenant: obj.tenant,
    user: obj.user,
    volume: obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbd | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    image: obj.image,
    keyring: obj.keyring,
    monitors: obj.monitors?.map((y) => y),
    pool: obj.pool,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbdSecretRef(obj.secretRef),
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    gateway: obj.gateway,
    protectionDomain: obj.protectionDomain,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIoSecretRef(obj.secretRef),
    sslEnabled: obj.sslEnabled,
    storageMode: obj.storageMode,
    storagePool: obj.storagePool,
    system: obj.system,
    volumeName: obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecret
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecret#items
   */
  readonly items?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecret(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecretItems(y)),
    optional: obj.optional,
    secretName: obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageos | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageosSecretRef(obj.secretRef),
    volumeName: obj.volumeName,
    volumeNamespace: obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
 * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
 * are redirected to the csi.vsphere.vmware.com CSI driver.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesVsphereVolume
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesVsphereVolume(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesVsphereVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    storagePolicyID: obj.storagePolicyId,
    storagePolicyName: obj.storagePolicyName,
    volumePath: obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinity
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinity(
  obj: AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y),
    ),
    requiredDuringSchedulingIgnoredDuringExecution:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinity
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinity(
  obj: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y),
    ),
    requiredDuringSchedulingIgnoredDuringExecution: obj.requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinity
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinity(
  obj: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
    requiredDuringSchedulingIgnoredDuringExecution: obj.requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnv
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFrom;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnv(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvFrom
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvFrom(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    prefix: obj.prefix,
    secretRef: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecycle
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecycle#postStart
   */
  readonly postStart?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecycle#preStop
   */
  readonly preStop?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecycle(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersPorts
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersPorts(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResizePolicy
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersResizePolicy(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResources
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResources#claims
   */
  readonly claims?: AutoscalingRunnerSetSpecTemplateSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingRunnerSetSpecTemplateSpecContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingRunnerSetSpecTemplateSpecContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersResources(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    capabilities: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextCapabilities(obj.capabilities),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    windowsOptions: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersVolumeDevices
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersVolumeDevices(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecDnsConfigOptions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecDnsConfigOptions#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecDnsConfigOptions(
  obj: AutoscalingRunnerSetSpecTemplateSpecDnsConfigOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnv
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnv#valueFrom
   */
  readonly valueFrom?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnv(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFrom
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFrom#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFrom(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(obj.configMapRef),
    prefix: obj.prefix,
    secretRef: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Lifecycle is not allowed for ephemeral containers.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecycle
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecycle#postStart
   */
  readonly postStart?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecycle#preStop
   */
  readonly preStop?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecycle(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResizePolicy
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResizePolicy(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
 * already allocated to the pod.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResources
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResources#claims
   */
  readonly claims?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResources(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#capabilities
   */
  readonly capabilities?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    capabilities: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(
      obj.capabilities,
    ),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    windowsOptions: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnv
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFrom;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnv(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFrom
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFrom(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    prefix: obj.prefix,
    secretRef: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecycle
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecycle(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResizePolicy
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersResizePolicy(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResources
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResources#claims
   */
  readonly claims?: AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersResources(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    capabilities: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities(
      obj.capabilities,
    ),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    windowsOptions: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeDevices
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeDevices(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecResourcesClaims
 */
export interface AutoscalingRunnerSetSpecTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecResourcesClaims(
  obj: AutoscalingRunnerSetSpecTemplateSpecResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecTemplateSpecResourcesLimits
 */
export class AutoscalingRunnerSetSpecTemplateSpecResourcesLimits {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecResourcesLimits {
    return new AutoscalingRunnerSetSpecTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecResourcesLimits {
    return new AutoscalingRunnerSetSpecTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingRunnerSetSpecTemplateSpecResourcesRequests
 */
export class AutoscalingRunnerSetSpecTemplateSpecResourcesRequests {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecResourcesRequests {
    return new AutoscalingRunnerSetSpecTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecResourcesRequests {
    return new AutoscalingRunnerSetSpecTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextAppArmorProfile
 */
export interface AutoscalingRunnerSetSpecTemplateSpecSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContextAppArmorProfile(
  obj: AutoscalingRunnerSetSpecTemplateSpecSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions(
  obj: AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeccompProfile
 */
export interface AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeccompProfile(
  obj: AutoscalingRunnerSetSpecTemplateSpecSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextSysctls
 */
export interface AutoscalingRunnerSetSpecTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContextSysctls(
  obj: AutoscalingRunnerSetSpecTemplateSpecSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextWindowsOptions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecTemplateSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecSecurityContextWindowsOptions(
  obj: AutoscalingRunnerSetSpecTemplateSpecSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector
 */
export interface AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector(
  obj: AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
 * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesAwsElasticBlockStore | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    partition: obj.partition,
    readOnly: obj.readOnly,
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
 * are redirected to the disk.csi.azure.com CSI driver.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesAzureDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cachingMode: obj.cachingMode,
    diskName: obj.diskName,
    diskURI: obj.diskUri,
    fsType: obj.fsType,
    kind: obj.kind,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
 * are redirected to the file.csi.azure.com CSI driver.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAzureFile
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesAzureFile(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesAzureFile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    readOnly: obj.readOnly,
    secretName: obj.secretName,
    shareName: obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
 * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesCephfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    monitors: obj.monitors?.map((y) => y),
    path: obj.path,
    readOnly: obj.readOnly,
    secretFile: obj.secretFile,
    secretRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCephfsSecretRef(obj.secretRef),
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
 * are redirected to the cinder.csi.openstack.org CSI driver.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCinder
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCinder#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCinder(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesCinder | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCinderSecretRef(obj.secretRef),
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMap
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMap#items
   */
  readonly items?: AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMap(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMapItems(y)),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCsi
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCsi(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesCsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    driver: obj.driver,
    fsType: obj.fsType,
    nodePublishSecretRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef(
      obj.nodePublishSecretRef,
    ),
    readOnly: obj.readOnly,
    volumeAttributes:
      obj.volumeAttributes === undefined
        ? undefined
        : Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApi
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApi#items
   */
  readonly items?: AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItems[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApi(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDir
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDir(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    medium: obj.medium,
    sizeLimit: obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeral
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeral(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    volumeClaimTemplate: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(
      obj.volumeClaimTemplate,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFc
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesFc(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesFc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    lun: obj.lun,
    readOnly: obj.readOnly,
    targetWWNs: obj.targetWwNs?.map((y) => y),
    wwids: obj.wwids?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    driver: obj.driver,
    fsType: obj.fsType,
    options:
      obj.options === undefined
        ? undefined
        : Object.entries(obj.options).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
 * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFlocker
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesFlocker(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesFlocker | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    datasetName: obj.datasetName,
    datasetUUID: obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
 * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGcePersistentDisk
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesGcePersistentDisk(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesGcePersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    partition: obj.partition,
    pdName: obj.pdName,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGitRepo
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesGitRepo(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesGitRepo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    directory: obj.directory,
    repository: obj.repository,
    revision: obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGlusterfs
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesGlusterfs(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesGlusterfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    endpoints: obj.endpoints,
    path: obj.path,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesHostPath
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesHostPath(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesHostPath | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
 * The volume is resolved at pod startup depending on which PullPolicy value is provided:
 *
 * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
 * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
 * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
 *
 * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
 * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
 * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
 * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
 * The volume will be mounted read-only (ro) and non-executable files (noexec).
 * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
 * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesImage
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesImage {
  /**
   * Policy for pulling OCI objects. Possible values are:
   * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Required: Image or artifact reference to be used.
   * Behaves in the same way as pod.spec.containers[*].image.
   * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesImage#reference
   */
  readonly reference?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesImage(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesImage | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    pullPolicy: obj.pullPolicy,
    reference: obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesIscsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    chapAuthDiscovery: obj.chapAuthDiscovery,
    chapAuthSession: obj.chapAuthSession,
    fsType: obj.fsType,
    initiatorName: obj.initiatorName,
    iqn: obj.iqn,
    iscsiInterface: obj.iscsiInterface,
    lun: obj.lun,
    portals: obj.portals?.map((y) => y),
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesIscsiSecretRef(obj.secretRef),
    targetPortal: obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesNfs
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesNfs(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesNfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    readOnly: obj.readOnly,
    server: obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesPersistentVolumeClaim | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claimName: obj.claimName,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
 * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesPhotonPersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    pdID: obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
 * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
 * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
 * is on.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesPortworxVolume
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesPortworxVolume(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesPortworxVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjected
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections. Each entry in this list
   * handles one source.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjected#sources
   */
  readonly sources?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjected(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjected | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    sources: obj.sources?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
 * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesQuobyte | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    group: obj.group,
    readOnly: obj.readOnly,
    registry: obj.registry,
    tenant: obj.tenant,
    user: obj.user,
    volume: obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesRbd
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesRbd#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesRbd(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesRbd | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    image: obj.image,
    keyring: obj.keyring,
    monitors: obj.monitors?.map((y) => y),
    pool: obj.pool,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesRbdSecretRef(obj.secretRef),
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    gateway: obj.gateway,
    protectionDomain: obj.protectionDomain,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIoSecretRef(obj.secretRef),
    sslEnabled: obj.sslEnabled,
    storageMode: obj.storageMode,
    storagePool: obj.storagePool,
    system: obj.system,
    volumeName: obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesSecret
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesSecret#items
   */
  readonly items?: AutoscalingRunnerSetSpecTemplateSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesSecret(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesSecretItems(y)),
    optional: obj.optional,
    secretName: obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesStorageos | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    secretRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesStorageosSecretRef(obj.secretRef),
    volumeName: obj.volumeName,
    volumeNamespace: obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
 * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
 * are redirected to the csi.vsphere.vmware.com CSI driver.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesVsphereVolume
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesVsphereVolume(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesVsphereVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    storagePolicyID: obj.storagePolicyId,
    storagePolicyName: obj.storagePolicyName,
    volumePath: obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preference:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeSelectorTerms: obj.nodeSelectorTerms?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    podAffinityTerm:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    podAffinityTerm:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFrom
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFrom(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRef(
      obj.resourceFieldRef,
    ),
    secretKeyRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromConfigMapRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromConfigMapRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromSecretRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromSecretRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStart
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStart#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStart(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStop
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStop#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStop(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeGrpc(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeGrpc(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesClaims
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesClaims(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesLimits
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesLimits {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesRequests
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesRequests {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextAppArmorProfile
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextAppArmorProfile(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextCapabilities
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextCapabilities(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeLinuxOptions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeLinuxOptions(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeccompProfile
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeccompProfile(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextWindowsOptions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextWindowsOptions(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeGrpc
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeGrpc(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFrom
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFrom(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(
        obj.resourceFieldRef,
      ),
    secretKeyRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromConfigMapRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromConfigMapRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromSecretRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromSecretRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStart
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStart#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStart#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStart(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(
      obj.httpGet,
    ),
    sleep: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStop
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStop#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStop#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStop(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeGrpc(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeGrpc(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesClaims
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesClaims(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesLimits
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesLimits {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesRequests
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesRequests {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextAppArmorProfile
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextAppArmorProfile(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextCapabilities
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextCapabilities(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeccompProfile
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeccompProfile(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextWindowsOptions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextWindowsOptions(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeGrpc
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeGrpc(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFrom
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFrom(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRef(
      obj.resourceFieldRef,
    ),
    secretKeyRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromConfigMapRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromConfigMapRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromSecretRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromSecretRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStart
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStart#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStart(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStop
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStop#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStop(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeGrpc(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeGrpc(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesClaims
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesClaims(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesLimits
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesRequests
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextAppArmorProfile
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextAppArmorProfile(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextCapabilities
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextCapabilities(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeLinuxOptions(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeccompProfile
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeccompProfile(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextWindowsOptions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextWindowsOptions(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeGrpc
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeGrpc(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfsSecretRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfsSecretRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCephfsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinderSecretRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinderSecretRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCinderSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMapItems
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMapItems(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsiNodePublishSecretRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsiNodePublishSecretRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesCsiNodePublishSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItems
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItems(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fieldRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    mode: obj.mode,
    path: obj.path,
    resourceFieldRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRef(
      obj.resourceFieldRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDirSizeLimit
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDirSizeLimit {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDirSizeLimit {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 * Required, must not be nil.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplate(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(
      obj.metadata,
    ),
    spec: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolumeSecretRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolumeSecretRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesFlexVolumeSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsiSecretRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsiSecretRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesIscsiSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types.
 * Exactly one of these fields must be set.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources#secret
   */
  readonly secret?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clusterTrustBundle: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle(
      obj.clusterTrustBundle,
    ),
    configMap: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    downwardAPI: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    secret: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecret(obj.secret),
    serviceAccountToken: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesServiceAccountToken(
      obj.serviceAccountToken,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbdSecretRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbdSecretRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesRbdSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIoSecretRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIoSecretRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesScaleIoSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecretItems
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecretItems(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageosSecretRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageosSecretRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesStorageosSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preference:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeSelectorTerms: obj.nodeSelectorTerms?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    podAffinityTerm:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    podAffinityTerm:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFrom
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFrom(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef(
      obj.resourceFieldRef,
    ),
    secretKeyRef: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromSecretRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromSecretRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStart
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStart#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStart(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStop
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStop#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStop(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeGrpc(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeGrpc(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResourcesClaims
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersResourcesClaims(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResourcesLimits
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersResourcesLimits {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersResourcesRequests
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersResourcesRequests {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextAppArmorProfile
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextAppArmorProfile(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextCapabilities
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextCapabilities(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeGrpc
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeGrpc(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(
      obj.resourceFieldRef,
    ),
    secretKeyRef: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesClaims
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesClaims(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFrom
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFrom(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(
      obj.resourceFieldRef,
    ),
    secretKeyRef: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStart
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStart#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStart(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStop
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStop#sleep
   */
  readonly sleep?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStop(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesClaims
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesClaims(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesLimits
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesLimits {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesRequests
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesRequests {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextAppArmorProfile
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextAppArmorProfile(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
  obj: AutoscalingRunnerSetSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCephfsSecretRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCephfsSecretRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesCephfsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCinderSecretRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCinderSecretRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesCinderSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMapItems
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMapItems(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesCsiNodePublishSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItems
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItems(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fieldRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    mode: obj.mode,
    path: obj.path,
    resourceFieldRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(
      obj.resourceFieldRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit
 */
export class AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit {
    return new AutoscalingRunnerSetSpecTemplateSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 * Required, must not be nil.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    spec: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesFlexVolumeSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsiSecretRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesIscsiSecretRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesIscsiSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types.
 * Exactly one of these fields must be set.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources#secret
   */
  readonly secret?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clusterTrustBundle: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle(
      obj.clusterTrustBundle,
    ),
    configMap: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    downwardAPI: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    secret: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret(obj.secret),
    serviceAccountToken: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(
      obj.serviceAccountToken,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesRbdSecretRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesRbdSecretRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesRbdSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIoSecretRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIoSecretRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesScaleIoSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesSecretItems
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesSecretItems(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesStorageosSecretRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesStorageosSecretRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesStorageosSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromConfigMapKeyRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromFieldRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromFieldRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromSecretKeyRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromSecretKeyRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartSleep
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartSleep(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopSleep
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopSleep(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromFieldRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromFieldRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartSleep
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartSleep(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopSleep
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopSleep(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromFieldRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromFieldRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromSecretKeyRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartSleep
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartSleep(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopExec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopExec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopSleep
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopSleep(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocket(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsFieldRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsFieldRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC
 * when creating it. No other fields are allowed and will be rejected during
 * validation.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    finalizers: obj.finalizers?.map((y) => y),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessModes: obj.accessModes?.map((y) => y),
    dataSource: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
      obj.dataSource,
    ),
    dataSourceRef:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    resources: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
      obj.resources,
    ),
    selector: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
      obj.selector,
    ),
    storageClassName: obj.storageClassName,
    volumeAttributesClassName: obj.volumeAttributesClassName,
    volumeMode: obj.volumeMode,
    volumeName: obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(
        obj.labelSelector,
      ),
    name: obj.name,
    optional: obj.optional,
    path: obj.path,
    signerName: obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMap
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMap(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMapItems(y),
    ),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApi
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApi(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItems(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecret
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecret(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecretItems(y),
    ),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesServiceAccountToken(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesServiceAccountToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audience: obj.audience,
    expirationSeconds: obj.expirationSeconds,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartSleep
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartSleep(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopSleep
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopSleep(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartSleep
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartSleep(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopSleep
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopSleep(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC
 * when creating it. No other fields are allowed and will be rejected during
 * validation.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    finalizers: obj.finalizers?.map((y) => y),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessModes: obj.accessModes?.map((y) => y),
    dataSource: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
      obj.dataSource,
    ),
    dataSourceRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
      obj.dataSourceRef,
    ),
    resources: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
      obj.resources,
    ),
    selector: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    storageClassName: obj.storageClassName,
    volumeAttributesClassName: obj.volumeAttributesClassName,
    volumeMode: obj.volumeMode,
    volumeName: obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(
      obj.labelSelector,
    ),
    name: obj.name,
    optional: obj.optional,
    path: obj.path,
    signerName: obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(y)),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) => toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems(y)),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audience: obj.audience,
    expirationSeconds: obj.expirationSeconds,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMapItems
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMapItems(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItems(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fieldRef: toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
      obj.fieldRef,
    ),
    mode: obj.mode,
    path: obj.path,
    resourceFieldRef:
      toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
        obj.resourceFieldRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecretItems
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecretItems(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new AutoscalingRunnerSetSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecTemplateSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fieldRef: toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    mode: obj.mode,
    path: obj.path,
    resourceFieldRef:
      toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
        obj.resourceFieldRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
  obj: AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(
  obj:
    | AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
  obj: AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecListenerTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new AutoscalingRunnerSetSpecTemplateSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * EphemeralRunner is the Schema for the ephemeralrunners API
 *
 * @schema EphemeralRunner
 */
export class EphemeralRunner extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EphemeralRunner"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "actions.github.com/v1alpha1",
    kind: "EphemeralRunner",
  };

  /**
   * Renders a Kubernetes manifest for "EphemeralRunner".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EphemeralRunnerProps = {}): any {
    return {
      ...EphemeralRunner.GVK,
      ...toJson_EphemeralRunnerProps(props),
    };
  }

  /**
   * Defines a "EphemeralRunner" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EphemeralRunnerProps = {}) {
    super(scope, id, {
      ...EphemeralRunner.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...EphemeralRunner.GVK,
      ...toJson_EphemeralRunnerProps(resolved),
    };
  }
}

/**
 * EphemeralRunner is the Schema for the ephemeralrunners API
 *
 * @schema EphemeralRunner
 */
export interface EphemeralRunnerProps {
  /**
   * @schema EphemeralRunner#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EphemeralRunnerSpec defines the desired state of EphemeralRunner
   *
   * @schema EphemeralRunner#spec
   */
  readonly spec?: EphemeralRunnerSpec;
}

/**
 * Converts an object of type 'EphemeralRunnerProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerProps(obj: EphemeralRunnerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_EphemeralRunnerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EphemeralRunnerSpec defines the desired state of EphemeralRunner
 *
 * @schema EphemeralRunnerSpec
 */
export interface EphemeralRunnerSpec {
  /**
   * @schema EphemeralRunnerSpec#githubConfigSecret
   */
  readonly githubConfigSecret: string;

  /**
   * @schema EphemeralRunnerSpec#githubConfigUrl
   */
  readonly githubConfigUrl: string;

  /**
   * @schema EphemeralRunnerSpec#githubServerTLS
   */
  readonly githubServerTls?: EphemeralRunnerSpecGithubServerTls;

  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema EphemeralRunnerSpec#metadata
   */
  readonly metadata?: EphemeralRunnerSpecMetadata;

  /**
   * @schema EphemeralRunnerSpec#proxy
   */
  readonly proxy?: EphemeralRunnerSpecProxy;

  /**
   * @schema EphemeralRunnerSpec#proxySecretRef
   */
  readonly proxySecretRef?: string;

  /**
   * @schema EphemeralRunnerSpec#runnerScaleSetId
   */
  readonly runnerScaleSetId: number;

  /**
   * Specification of the desired behavior of the pod.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema EphemeralRunnerSpec#spec
   */
  readonly spec?: EphemeralRunnerSpecSpec;

  /**
   * @schema EphemeralRunnerSpec#vaultConfig
   */
  readonly vaultConfig?: EphemeralRunnerSpecVaultConfig;
}

/**
 * Converts an object of type 'EphemeralRunnerSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpec(obj: EphemeralRunnerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    githubConfigSecret: obj.githubConfigSecret,
    githubConfigUrl: obj.githubConfigUrl,
    githubServerTLS: toJson_EphemeralRunnerSpecGithubServerTls(obj.githubServerTls),
    metadata: toJson_EphemeralRunnerSpecMetadata(obj.metadata),
    proxy: toJson_EphemeralRunnerSpecProxy(obj.proxy),
    proxySecretRef: obj.proxySecretRef,
    runnerScaleSetId: obj.runnerScaleSetId,
    spec: toJson_EphemeralRunnerSpecSpec(obj.spec),
    vaultConfig: toJson_EphemeralRunnerSpecVaultConfig(obj.vaultConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecGithubServerTls
 */
export interface EphemeralRunnerSpecGithubServerTls {
  /**
   * Required
   *
   * @schema EphemeralRunnerSpecGithubServerTls#certificateFrom
   */
  readonly certificateFrom?: EphemeralRunnerSpecGithubServerTlsCertificateFrom;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecGithubServerTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecGithubServerTls(
  obj: EphemeralRunnerSpecGithubServerTls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certificateFrom: toJson_EphemeralRunnerSpecGithubServerTlsCertificateFrom(obj.certificateFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Standard object's metadata.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema EphemeralRunnerSpecMetadata
 */
export interface EphemeralRunnerSpecMetadata {
  /**
   * @schema EphemeralRunnerSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema EphemeralRunnerSpecMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema EphemeralRunnerSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema EphemeralRunnerSpecMetadata#name
   */
  readonly name?: string;

  /**
   * @schema EphemeralRunnerSpecMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecMetadata(
  obj: EphemeralRunnerSpecMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    finalizers: obj.finalizers?.map((y) => y),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecProxy
 */
export interface EphemeralRunnerSpecProxy {
  /**
   * @schema EphemeralRunnerSpecProxy#http
   */
  readonly http?: EphemeralRunnerSpecProxyHttp;

  /**
   * @schema EphemeralRunnerSpecProxy#https
   */
  readonly https?: EphemeralRunnerSpecProxyHttps;

  /**
   * @schema EphemeralRunnerSpecProxy#noProxy
   */
  readonly noProxy?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecProxy(
  obj: EphemeralRunnerSpecProxy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_EphemeralRunnerSpecProxyHttp(obj.http),
    https: toJson_EphemeralRunnerSpecProxyHttps(obj.https),
    noProxy: obj.noProxy?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the desired behavior of the pod.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema EphemeralRunnerSpecSpec
 */
export interface EphemeralRunnerSpecSpec {
  /**
   * Optional duration in seconds the pod may be active on the node relative to
   * StartTime before the system will actively try to mark it failed and kill associated containers.
   * Value must be a positive integer.
   *
   * @schema EphemeralRunnerSpecSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema EphemeralRunnerSpecSpec#affinity
   */
  readonly affinity?: EphemeralRunnerSpecSpecAffinity;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   *
   * @schema EphemeralRunnerSpecSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * List of containers belonging to the pod.
   * Containers cannot currently be added or removed.
   * There must be at least one container in a Pod.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpec#containers
   */
  readonly containers: EphemeralRunnerSpecSpecContainers[];

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema EphemeralRunnerSpecSpec#dnsConfig
   */
  readonly dnsConfig?: EphemeralRunnerSpecSpecDnsConfig;

  /**
   * Set DNS policy for the pod.
   * Defaults to "ClusterFirst".
   * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
   * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
   * To have DNS options set along with hostNetwork, you have to specify DNS policy
   * explicitly to 'ClusterFirstWithHostNet'.
   *
   * @default ClusterFirst".
   * @schema EphemeralRunnerSpecSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's
   * environment variables, matching the syntax of Docker links.
   * Optional: Defaults to true.
   *
   * @default true.
   * @schema EphemeralRunnerSpecSpec#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
   * pod to perform user-initiated actions such as debugging. This list cannot be specified when
   * creating a pod, and it cannot be modified by updating the pod spec. In order to add an
   * ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
   *
   * @schema EphemeralRunnerSpecSpec#ephemeralContainers
   */
  readonly ephemeralContainers?: EphemeralRunnerSpecSpecEphemeralContainers[];

  /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
   * file if specified.
   *
   * @schema EphemeralRunnerSpecSpec#hostAliases
   */
  readonly hostAliases?: EphemeralRunnerSpecSpecHostAliases[];

  /**
   * Use the host's ipc namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpec#hostIPC
   */
  readonly hostIpc?: boolean;

  /**
   * Host networking requested for this pod. Use the host's network namespace.
   * If this option is set, the ports that will be used must be specified.
   * Default to false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Use the host's pid namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpec#hostPID
   */
  readonly hostPid?: boolean;

  /**
   * Use the host's user namespace.
   * Optional: Default to true.
   * If set to true or not present, the pod will be run in the host user namespace, useful
   * for when the pod needs a feature only available to the host user namespace, such as
   * loading a kernel module with CAP_SYS_MODULE.
   * When set to false, a new userns is created for the pod. Setting false is useful for
   * mitigating container breakout vulnerabilities even allowing users to run their
   * containers as root without actually having root privileges on the host.
   * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
   *
   * @default true.
   * @schema EphemeralRunnerSpecSpec#hostUsers
   */
  readonly hostUsers?: boolean;

  /**
   * Specifies the hostname of the Pod
   * If not specified, the pod's hostname will be set to a system-defined value.
   *
   * @schema EphemeralRunnerSpecSpec#hostname
   */
  readonly hostname?: string;

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
   * If specified, these secrets will be passed to individual puller implementations for them to use.
   * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema EphemeralRunnerSpecSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: EphemeralRunnerSpecSpecImagePullSecrets[];

  /**
   * List of initialization containers belonging to the pod.
   * Init containers are executed in order prior to containers being started. If any
   * init container fails, the pod is considered to have failed and is handled according
   * to its restartPolicy. The name for an init container or normal container must be
   * unique among all containers.
   * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
   * The resourceRequirements of an init container are taken into account during scheduling
   * by finding the highest request/limit for each resource type, and then using the max of
   * of that value or the sum of the normal containers. Limits are applied to init containers
   * in a similar fashion.
   * Init containers cannot currently be added or removed.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema EphemeralRunnerSpecSpec#initContainers
   */
  readonly initContainers?: EphemeralRunnerSpecSpecInitContainers[];

  /**
   * NodeName indicates in which node this pod is scheduled.
   * If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName.
   * Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod.
   * This field should not be used to express a desire for the pod to be scheduled on a specific node.
   * https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename
   *
   * @schema EphemeralRunnerSpecSpec#nodeName
   */
  readonly nodeName?: string;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema EphemeralRunnerSpecSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specifies the OS of the containers in the pod.
   * Some pod and container fields are restricted if this is set.
   *
   * If the OS field is set to linux, the following fields must be unset:
   * -securityContext.windowsOptions
   *
   * If the OS field is set to windows, following fields must be unset:
   * - spec.hostPID
   * - spec.hostIPC
   * - spec.hostUsers
   * - spec.securityContext.appArmorProfile
   * - spec.securityContext.seLinuxOptions
   * - spec.securityContext.seccompProfile
   * - spec.securityContext.fsGroup
   * - spec.securityContext.fsGroupChangePolicy
   * - spec.securityContext.sysctls
   * - spec.shareProcessNamespace
   * - spec.securityContext.runAsUser
   * - spec.securityContext.runAsGroup
   * - spec.securityContext.supplementalGroups
   * - spec.securityContext.supplementalGroupsPolicy
   * - spec.containers[*].securityContext.appArmorProfile
   * - spec.containers[*].securityContext.seLinuxOptions
   * - spec.containers[*].securityContext.seccompProfile
   * - spec.containers[*].securityContext.capabilities
   * - spec.containers[*].securityContext.readOnlyRootFilesystem
   * - spec.containers[*].securityContext.privileged
   * - spec.containers[*].securityContext.allowPrivilegeEscalation
   * - spec.containers[*].securityContext.procMount
   * - spec.containers[*].securityContext.runAsUser
   * - spec.containers[*].securityContext.runAsGroup
   *
   * @schema EphemeralRunnerSpecSpec#os
   */
  readonly os?: EphemeralRunnerSpecSpecOs;

  /**
   * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
   * This field will be autopopulated at admission time by the RuntimeClass admission controller. If
   * the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
   * The RuntimeClass admission controller will reject Pod create requests which have the overhead already
   * set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
   * defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
   *
   * @schema EphemeralRunnerSpecSpec#overhead
   */
  readonly overhead?: { [key: string]: EphemeralRunnerSpecSpecOverhead };

  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority.
   * One of Never, PreemptLowerPriority.
   * Defaults to PreemptLowerPriority if unset.
   *
   * @default PreemptLowerPriority if unset.
   * @schema EphemeralRunnerSpecSpec#preemptionPolicy
   */
  readonly preemptionPolicy?: string;

  /**
   * The priority value. Various system components use this field to find the
   * priority of the pod. When Priority Admission Controller is enabled, it
   * prevents users from setting this field. The admission controller populates
   * this field from PriorityClassName.
   * The higher the value, the higher the priority.
   *
   * @schema EphemeralRunnerSpecSpec#priority
   */
  readonly priority?: number;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and
   * "system-cluster-critical" are two special keywords which indicate the
   * highest priorities with the former being the highest priority. Any other
   * name must be defined by creating a PriorityClass object with that name.
   * If not specified, the pod priority will be default or zero if there is no
   * default.
   *
   * @schema EphemeralRunnerSpecSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, all readiness gates will be evaluated for pod readiness.
   * A pod is ready when all its containers are ready AND
   * all conditions specified in the readiness gates have status equal to "True"
   * More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
   *
   * @schema EphemeralRunnerSpecSpec#readinessGates
   */
  readonly readinessGates?: EphemeralRunnerSpecSpecReadinessGates[];

  /**
   * ResourceClaims defines which ResourceClaims must be allocated
   * and reserved before the Pod is allowed to start. The resources
   * will be made available to those containers which consume them
   * by name.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable.
   *
   * @schema EphemeralRunnerSpecSpec#resourceClaims
   */
  readonly resourceClaims?: EphemeralRunnerSpecSpecResourceClaims[];

  /**
   * Resources is the total amount of CPU and Memory resources required by all
   * containers in the pod. It supports specifying Requests and Limits for
   * "cpu" and "memory" resource names only. ResourceClaims are not supported.
   *
   * This field enables fine-grained control over resource allocation for the
   * entire pod, allowing resource sharing among containers in a pod.
   *
   * This is an alpha field and requires enabling the PodLevelResources feature
   * gate.
   *
   * @schema EphemeralRunnerSpecSpec#resources
   */
  readonly resources?: EphemeralRunnerSpecSpecResources;

  /**
   * Restart policy for all containers within the pod.
   * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
   * Default to Always.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   *
   * @default Always.
   * @schema EphemeralRunnerSpecSpec#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
   * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
   * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
   * empty definition that uses the default runtime handler.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   *
   * @schema EphemeralRunnerSpecSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * If specified, the pod will be dispatched by specified scheduler.
   * If not specified, the pod will be dispatched by default scheduler.
   *
   * @schema EphemeralRunnerSpecSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * SchedulingGates is an opaque list of values that if specified will block scheduling the pod.
   * If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the
   * scheduler will not attempt to schedule the pod.
   *
   * SchedulingGates can only be set at pod creation time, and be removed only afterwards.
   *
   * @schema EphemeralRunnerSpecSpec#schedulingGates
   */
  readonly schedulingGates?: EphemeralRunnerSpecSpecSchedulingGates[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * Optional: Defaults to empty.  See type description for default values of each field.
   *
   * @default empty.  See type description for default values of each field.
   * @schema EphemeralRunnerSpecSpec#securityContext
   */
  readonly securityContext?: EphemeralRunnerSpecSpecSecurityContext;

  /**
   * DeprecatedServiceAccount is a deprecated alias for ServiceAccountName.
   * Deprecated: Use serviceAccountName instead.
   *
   * @schema EphemeralRunnerSpecSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @schema EphemeralRunnerSpecSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
   * In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
   * In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
   * If a pod does not have FQDN, this has no effect.
   * Default to false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpec#setHostnameAsFQDN
   */
  readonly setHostnameAsFqdn?: boolean;

  /**
   * Share a single process namespace between all of the containers in a pod.
   * When this is set containers will be able to view and signal processes from other containers
   * in the same pod, and the first process in each container will not be assigned PID 1.
   * HostPID and ShareProcessNamespace cannot both be set.
   * Optional: Default to false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpec#shareProcessNamespace
   */
  readonly shareProcessNamespace?: boolean;

  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
   * If not specified, the pod will not have a domainname at all.
   *
   * @schema EphemeralRunnerSpecSpec#subdomain
   */
  readonly subdomain?: string;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * If this value is nil, the default grace period will be used instead.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema EphemeralRunnerSpecSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema EphemeralRunnerSpecSpec#tolerations
   */
  readonly tolerations?: EphemeralRunnerSpecSpecTolerations[];

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology
   * domains. Scheduler will schedule pods in a way which abides by the constraints.
   * All topologySpreadConstraints are ANDed.
   *
   * @schema EphemeralRunnerSpecSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: EphemeralRunnerSpecSpecTopologySpreadConstraints[];

  /**
   * List of volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema EphemeralRunnerSpecSpec#volumes
   */
  readonly volumes?: EphemeralRunnerSpecSpecVolumes[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpec(
  obj: EphemeralRunnerSpecSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    activeDeadlineSeconds: obj.activeDeadlineSeconds,
    affinity: toJson_EphemeralRunnerSpecSpecAffinity(obj.affinity),
    automountServiceAccountToken: obj.automountServiceAccountToken,
    containers: obj.containers?.map((y) => toJson_EphemeralRunnerSpecSpecContainers(y)),
    dnsConfig: toJson_EphemeralRunnerSpecSpecDnsConfig(obj.dnsConfig),
    dnsPolicy: obj.dnsPolicy,
    enableServiceLinks: obj.enableServiceLinks,
    ephemeralContainers: obj.ephemeralContainers?.map((y) => toJson_EphemeralRunnerSpecSpecEphemeralContainers(y)),
    hostAliases: obj.hostAliases?.map((y) => toJson_EphemeralRunnerSpecSpecHostAliases(y)),
    hostIPC: obj.hostIpc,
    hostNetwork: obj.hostNetwork,
    hostPID: obj.hostPid,
    hostUsers: obj.hostUsers,
    hostname: obj.hostname,
    imagePullSecrets: obj.imagePullSecrets?.map((y) => toJson_EphemeralRunnerSpecSpecImagePullSecrets(y)),
    initContainers: obj.initContainers?.map((y) => toJson_EphemeralRunnerSpecSpecInitContainers(y)),
    nodeName: obj.nodeName,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    os: toJson_EphemeralRunnerSpecSpecOs(obj.os),
    overhead:
      obj.overhead === undefined
        ? undefined
        : Object.entries(obj.overhead).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    preemptionPolicy: obj.preemptionPolicy,
    priority: obj.priority,
    priorityClassName: obj.priorityClassName,
    readinessGates: obj.readinessGates?.map((y) => toJson_EphemeralRunnerSpecSpecReadinessGates(y)),
    resourceClaims: obj.resourceClaims?.map((y) => toJson_EphemeralRunnerSpecSpecResourceClaims(y)),
    resources: toJson_EphemeralRunnerSpecSpecResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    runtimeClassName: obj.runtimeClassName,
    schedulerName: obj.schedulerName,
    schedulingGates: obj.schedulingGates?.map((y) => toJson_EphemeralRunnerSpecSpecSchedulingGates(y)),
    securityContext: toJson_EphemeralRunnerSpecSpecSecurityContext(obj.securityContext),
    serviceAccount: obj.serviceAccount,
    serviceAccountName: obj.serviceAccountName,
    setHostnameAsFQDN: obj.setHostnameAsFqdn,
    shareProcessNamespace: obj.shareProcessNamespace,
    subdomain: obj.subdomain,
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    tolerations: obj.tolerations?.map((y) => toJson_EphemeralRunnerSpecSpecTolerations(y)),
    topologySpreadConstraints: obj.topologySpreadConstraints?.map((y) =>
      toJson_EphemeralRunnerSpecSpecTopologySpreadConstraints(y),
    ),
    volumes: obj.volumes?.map((y) => toJson_EphemeralRunnerSpecSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecVaultConfig
 */
export interface EphemeralRunnerSpecVaultConfig {
  /**
   * @schema EphemeralRunnerSpecVaultConfig#azureKeyVault
   */
  readonly azureKeyVault?: EphemeralRunnerSpecVaultConfigAzureKeyVault;

  /**
   * @schema EphemeralRunnerSpecVaultConfig#proxy
   */
  readonly proxy?: EphemeralRunnerSpecVaultConfigProxy;

  /**
   * VaultType represents the type of vault that can be used in the application.
   * It is used to identify which vault integration should be used to resolve secrets.
   *
   * @schema EphemeralRunnerSpecVaultConfig#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecVaultConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecVaultConfig(
  obj: EphemeralRunnerSpecVaultConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    azureKeyVault: toJson_EphemeralRunnerSpecVaultConfigAzureKeyVault(obj.azureKeyVault),
    proxy: toJson_EphemeralRunnerSpecVaultConfigProxy(obj.proxy),
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required
 *
 * @schema EphemeralRunnerSpecGithubServerTlsCertificateFrom
 */
export interface EphemeralRunnerSpecGithubServerTlsCertificateFrom {
  /**
   * Required
   *
   * @schema EphemeralRunnerSpecGithubServerTlsCertificateFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecGithubServerTlsCertificateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecGithubServerTlsCertificateFrom(
  obj: EphemeralRunnerSpecGithubServerTlsCertificateFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_EphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecProxyHttp
 */
export interface EphemeralRunnerSpecProxyHttp {
  /**
   * @schema EphemeralRunnerSpecProxyHttp#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema EphemeralRunnerSpecProxyHttp#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecProxyHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecProxyHttp(
  obj: EphemeralRunnerSpecProxyHttp | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecProxyHttps
 */
export interface EphemeralRunnerSpecProxyHttps {
  /**
   * @schema EphemeralRunnerSpecProxyHttps#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema EphemeralRunnerSpecProxyHttps#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecProxyHttps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecProxyHttps(
  obj: EphemeralRunnerSpecProxyHttps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If specified, the pod's scheduling constraints
 *
 * @schema EphemeralRunnerSpecSpecAffinity
 */
export interface EphemeralRunnerSpecSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema EphemeralRunnerSpecSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: EphemeralRunnerSpecSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema EphemeralRunnerSpecSpecAffinity#podAffinity
   */
  readonly podAffinity?: EphemeralRunnerSpecSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema EphemeralRunnerSpecSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: EphemeralRunnerSpecSpecAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinity(
  obj: EphemeralRunnerSpecSpecAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeAffinity: toJson_EphemeralRunnerSpecSpecAffinityNodeAffinity(obj.nodeAffinity),
    podAffinity: toJson_EphemeralRunnerSpecSpecAffinityPodAffinity(obj.podAffinity),
    podAntiAffinity: toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema EphemeralRunnerSpecSpecContainers
 */
export interface EphemeralRunnerSpecSpecContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSpecSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSpecSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecContainers#env
   */
  readonly env?: EphemeralRunnerSpecSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecContainers#envFrom
   */
  readonly envFrom?: EphemeralRunnerSpecSpecContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema EphemeralRunnerSpecSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema EphemeralRunnerSpecSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecContainers#lifecycle
   */
  readonly lifecycle?: EphemeralRunnerSpecSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecContainers#livenessProbe
   */
  readonly livenessProbe?: EphemeralRunnerSpecSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecContainers#ports
   */
  readonly ports?: EphemeralRunnerSpecSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecContainers#readinessProbe
   */
  readonly readinessProbe?: EphemeralRunnerSpecSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema EphemeralRunnerSpecSpecContainers#resizePolicy
   */
  readonly resizePolicy?: EphemeralRunnerSpecSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecContainers#resources
   */
  readonly resources?: EphemeralRunnerSpecSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema EphemeralRunnerSpecSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema EphemeralRunnerSpecSpecContainers#securityContext
   */
  readonly securityContext?: EphemeralRunnerSpecSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecContainers#startupProbe
   */
  readonly startupProbe?: EphemeralRunnerSpecSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema EphemeralRunnerSpecSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema EphemeralRunnerSpecSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema EphemeralRunnerSpecSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema EphemeralRunnerSpecSpecContainers#volumeDevices
   */
  readonly volumeDevices?: EphemeralRunnerSpecSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecContainers#volumeMounts
   */
  readonly volumeMounts?: EphemeralRunnerSpecSpecContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainers(
  obj: EphemeralRunnerSpecSpecContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_EphemeralRunnerSpecSpecContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_EphemeralRunnerSpecSpecContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_EphemeralRunnerSpecSpecContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_EphemeralRunnerSpecSpecContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_EphemeralRunnerSpecSpecContainersPorts(y)),
    readinessProbe: toJson_EphemeralRunnerSpecSpecContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) => toJson_EphemeralRunnerSpecSpecContainersResizePolicy(y)),
    resources: toJson_EphemeralRunnerSpecSpecContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_EphemeralRunnerSpecSpecContainersSecurityContext(obj.securityContext),
    startupProbe: toJson_EphemeralRunnerSpecSpecContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) => toJson_EphemeralRunnerSpecSpecContainersVolumeDevices(y)),
    volumeMounts: obj.volumeMounts?.map((y) => toJson_EphemeralRunnerSpecSpecContainersVolumeMounts(y)),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema EphemeralRunnerSpecSpecDnsConfig
 */
export interface EphemeralRunnerSpecSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema EphemeralRunnerSpecSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema EphemeralRunnerSpecSpecDnsConfig#options
   */
  readonly options?: EphemeralRunnerSpecSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema EphemeralRunnerSpecSpecDnsConfig#searches
   */
  readonly searches?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecDnsConfig(
  obj: EphemeralRunnerSpecSpecDnsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nameservers: obj.nameservers?.map((y) => y),
    options: obj.options?.map((y) => toJson_EphemeralRunnerSpecSpecDnsConfigOptions(y)),
    searches: obj.searches?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for
 * user-initiated activities such as debugging. Ephemeral containers have no resource or
 * scheduling guarantees, and they will not be restarted when they exit or when a Pod is
 * removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the
 * Pod to exceed its resource allocation.
 *
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing
 * Pod. Ephemeral containers may not be removed or restarted.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainers
 */
export interface EphemeralRunnerSpecSpecEphemeralContainers {
  /**
   * Arguments to the entrypoint.
   * The image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#env
   */
  readonly env?: EphemeralRunnerSpecSpecEphemeralContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#envFrom
   */
  readonly envFrom?: EphemeralRunnerSpecSpecEphemeralContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#lifecycle
   */
  readonly lifecycle?: EphemeralRunnerSpecSpecEphemeralContainersLifecycle;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#livenessProbe
   */
  readonly livenessProbe?: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe;

  /**
   * Name of the ephemeral container specified as a DNS_LABEL.
   * This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#name
   */
  readonly name: string;

  /**
   * Ports are not allowed for ephemeral containers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#ports
   */
  readonly ports?: EphemeralRunnerSpecSpecEphemeralContainersPorts[];

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#readinessProbe
   */
  readonly readinessProbe?: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#resizePolicy
   */
  readonly resizePolicy?: EphemeralRunnerSpecSpecEphemeralContainersResizePolicy[];

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
   * already allocated to the pod.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#resources
   */
  readonly resources?: EphemeralRunnerSpecSpecEphemeralContainersResources;

  /**
   * Restart policy for the container to manage the restart behavior of each
   * container within a pod.
   * This may only be set for init containers. You cannot set this field on
   * ephemeral containers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#securityContext
   */
  readonly securityContext?: EphemeralRunnerSpecSpecEphemeralContainersSecurityContext;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#startupProbe
   */
  readonly startupProbe?: EphemeralRunnerSpecSpecEphemeralContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets.
   * The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
   * If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   *
   * The container runtime must implement support for this feature. If the runtime does not
   * support namespace targeting then the result of setting this field is undefined.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#targetContainerName
   */
  readonly targetContainerName?: string;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#volumeDevices
   */
  readonly volumeDevices?: EphemeralRunnerSpecSpecEphemeralContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#volumeMounts
   */
  readonly volumeMounts?: EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainers(
  obj: EphemeralRunnerSpecSpecEphemeralContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_EphemeralRunnerSpecSpecEphemeralContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_EphemeralRunnerSpecSpecEphemeralContainersPorts(y)),
    readinessProbe: toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) => toJson_EphemeralRunnerSpecSpecEphemeralContainersResizePolicy(y)),
    resources: toJson_EphemeralRunnerSpecSpecEphemeralContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContext(obj.securityContext),
    startupProbe: toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    targetContainerName: obj.targetContainerName,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) => toJson_EphemeralRunnerSpecSpecEphemeralContainersVolumeDevices(y)),
    volumeMounts: obj.volumeMounts?.map((y) => toJson_EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts(y)),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema EphemeralRunnerSpecSpecHostAliases
 */
export interface EphemeralRunnerSpecSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema EphemeralRunnerSpecSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema EphemeralRunnerSpecSpecHostAliases#ip
   */
  readonly ip: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecHostAliases(
  obj: EphemeralRunnerSpecSpecHostAliases | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    hostnames: obj.hostnames?.map((y) => y),
    ip: obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema EphemeralRunnerSpecSpecImagePullSecrets
 */
export interface EphemeralRunnerSpecSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecImagePullSecrets(
  obj: EphemeralRunnerSpecSpecImagePullSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema EphemeralRunnerSpecSpecInitContainers
 */
export interface EphemeralRunnerSpecSpecInitContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#env
   */
  readonly env?: EphemeralRunnerSpecSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#envFrom
   */
  readonly envFrom?: EphemeralRunnerSpecSpecInitContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema EphemeralRunnerSpecSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#lifecycle
   */
  readonly lifecycle?: EphemeralRunnerSpecSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: EphemeralRunnerSpecSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#ports
   */
  readonly ports?: EphemeralRunnerSpecSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: EphemeralRunnerSpecSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: EphemeralRunnerSpecSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#resources
   */
  readonly resources?: EphemeralRunnerSpecSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#securityContext
   */
  readonly securityContext?: EphemeralRunnerSpecSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#startupProbe
   */
  readonly startupProbe?: EphemeralRunnerSpecSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema EphemeralRunnerSpecSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema EphemeralRunnerSpecSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema EphemeralRunnerSpecSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: EphemeralRunnerSpecSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: EphemeralRunnerSpecSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSpecSpecInitContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainers(
  obj: EphemeralRunnerSpecSpecInitContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_EphemeralRunnerSpecSpecInitContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_EphemeralRunnerSpecSpecInitContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_EphemeralRunnerSpecSpecInitContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_EphemeralRunnerSpecSpecInitContainersPorts(y)),
    readinessProbe: toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) => toJson_EphemeralRunnerSpecSpecInitContainersResizePolicy(y)),
    resources: toJson_EphemeralRunnerSpecSpecInitContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_EphemeralRunnerSpecSpecInitContainersSecurityContext(obj.securityContext),
    startupProbe: toJson_EphemeralRunnerSpecSpecInitContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) => toJson_EphemeralRunnerSpecSpecInitContainersVolumeDevices(y)),
    volumeMounts: obj.volumeMounts?.map((y) => toJson_EphemeralRunnerSpecSpecInitContainersVolumeMounts(y)),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the OS of the containers in the pod.
 * Some pod and container fields are restricted if this is set.
 *
 * If the OS field is set to linux, the following fields must be unset:
 * -securityContext.windowsOptions
 *
 * If the OS field is set to windows, following fields must be unset:
 * - spec.hostPID
 * - spec.hostIPC
 * - spec.hostUsers
 * - spec.securityContext.appArmorProfile
 * - spec.securityContext.seLinuxOptions
 * - spec.securityContext.seccompProfile
 * - spec.securityContext.fsGroup
 * - spec.securityContext.fsGroupChangePolicy
 * - spec.securityContext.sysctls
 * - spec.shareProcessNamespace
 * - spec.securityContext.runAsUser
 * - spec.securityContext.runAsGroup
 * - spec.securityContext.supplementalGroups
 * - spec.securityContext.supplementalGroupsPolicy
 * - spec.containers[*].securityContext.appArmorProfile
 * - spec.containers[*].securityContext.seLinuxOptions
 * - spec.containers[*].securityContext.seccompProfile
 * - spec.containers[*].securityContext.capabilities
 * - spec.containers[*].securityContext.readOnlyRootFilesystem
 * - spec.containers[*].securityContext.privileged
 * - spec.containers[*].securityContext.allowPrivilegeEscalation
 * - spec.containers[*].securityContext.procMount
 * - spec.containers[*].securityContext.runAsUser
 * - spec.containers[*].securityContext.runAsGroup
 *
 * @schema EphemeralRunnerSpecSpecOs
 */
export interface EphemeralRunnerSpecSpecOs {
  /**
   * Name is the name of the operating system. The currently supported values are linux and windows.
   * Additional value may be defined in future and can be one of:
   * https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
   * Clients should expect to handle additional values and treat unrecognized values in this field as os: null
   *
   * @schema EphemeralRunnerSpecSpecOs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecOs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecOs(
  obj: EphemeralRunnerSpecSpecOs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecSpecOverhead
 */
export class EphemeralRunnerSpecSpecOverhead {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecOverhead {
    return new EphemeralRunnerSpecSpecOverhead(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecOverhead {
    return new EphemeralRunnerSpecSpecOverhead(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema EphemeralRunnerSpecSpecReadinessGates
 */
export interface EphemeralRunnerSpecSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema EphemeralRunnerSpecSpecReadinessGates#conditionType
   */
  readonly conditionType: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecReadinessGates(
  obj: EphemeralRunnerSpecSpecReadinessGates | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conditionType: obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodResourceClaim references exactly one ResourceClaim, either directly
 * or by naming a ResourceClaimTemplate which is then turned into a ResourceClaim
 * for the pod.
 *
 * It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
 * Containers that need access to the ResourceClaim reference it with this name.
 *
 * @schema EphemeralRunnerSpecSpecResourceClaims
 */
export interface EphemeralRunnerSpecSpecResourceClaims {
  /**
   * Name uniquely identifies this resource claim inside the pod.
   * This must be a DNS_LABEL.
   *
   * @schema EphemeralRunnerSpecSpecResourceClaims#name
   */
  readonly name: string;

  /**
   * ResourceClaimName is the name of a ResourceClaim object in the same
   * namespace as this pod.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema EphemeralRunnerSpecSpecResourceClaims#resourceClaimName
   */
  readonly resourceClaimName?: string;

  /**
   * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
   * object in the same namespace as this pod.
   *
   * The template will be used to create a new ResourceClaim, which will
   * be bound to this pod. When this pod is deleted, the ResourceClaim
   * will also be deleted. The pod name and resource name, along with a
   * generated component, will be used to form a unique name for the
   * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
   *
   * This field is immutable and no changes will be made to the
   * corresponding ResourceClaim by the control plane after creating the
   * ResourceClaim.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema EphemeralRunnerSpecSpecResourceClaims#resourceClaimTemplateName
   */
  readonly resourceClaimTemplateName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecResourceClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecResourceClaims(
  obj: EphemeralRunnerSpecSpecResourceClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    resourceClaimName: obj.resourceClaimName,
    resourceClaimTemplateName: obj.resourceClaimTemplateName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources is the total amount of CPU and Memory resources required by all
 * containers in the pod. It supports specifying Requests and Limits for
 * "cpu" and "memory" resource names only. ResourceClaims are not supported.
 *
 * This field enables fine-grained control over resource allocation for the
 * entire pod, allowing resource sharing among containers in a pod.
 *
 * This is an alpha field and requires enabling the PodLevelResources feature
 * gate.
 *
 * @schema EphemeralRunnerSpecSpecResources
 */
export interface EphemeralRunnerSpecSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EphemeralRunnerSpecSpecResources#claims
   */
  readonly claims?: EphemeralRunnerSpecSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecResources#limits
   */
  readonly limits?: { [key: string]: EphemeralRunnerSpecSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecResources#requests
   */
  readonly requests?: {
    [key: string]: EphemeralRunnerSpecSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecResources(
  obj: EphemeralRunnerSpecSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_EphemeralRunnerSpecSpecResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodSchedulingGate is associated to a Pod to guard its scheduling.
 *
 * @schema EphemeralRunnerSpecSpecSchedulingGates
 */
export interface EphemeralRunnerSpecSpecSchedulingGates {
  /**
   * Name of the scheduling gate.
   * Each scheduling gate must have a unique name field.
   *
   * @schema EphemeralRunnerSpecSpecSchedulingGates#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecSchedulingGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecSchedulingGates(
  obj: EphemeralRunnerSpecSpecSchedulingGates | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings.
 * Optional: Defaults to empty.  See type description for default values of each field.
 *
 * @default empty.  See type description for default values of each field.
 * @schema EphemeralRunnerSpecSpecSecurityContext
 */
export interface EphemeralRunnerSpecSpecSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EphemeralRunnerSpecSpecSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSpecSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EphemeralRunnerSpecSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EphemeralRunnerSpecSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#sysctls
   */
  readonly sysctls?: EphemeralRunnerSpecSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EphemeralRunnerSpecSpecSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecSecurityContext(
  obj: EphemeralRunnerSpecSpecSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    appArmorProfile: toJson_EphemeralRunnerSpecSpecSecurityContextAppArmorProfile(obj.appArmorProfile),
    fsGroup: obj.fsGroup,
    fsGroupChangePolicy: obj.fsGroupChangePolicy,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxChangePolicy: obj.seLinuxChangePolicy,
    seLinuxOptions: toJson_EphemeralRunnerSpecSpecSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    seccompProfile: toJson_EphemeralRunnerSpecSpecSecurityContextSeccompProfile(obj.seccompProfile),
    supplementalGroups: obj.supplementalGroups?.map((y) => y),
    supplementalGroupsPolicy: obj.supplementalGroupsPolicy,
    sysctls: obj.sysctls?.map((y) => toJson_EphemeralRunnerSpecSpecSecurityContextSysctls(y)),
    windowsOptions: toJson_EphemeralRunnerSpecSpecSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema EphemeralRunnerSpecSpecTolerations
 */
export interface EphemeralRunnerSpecSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema EphemeralRunnerSpecSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema EphemeralRunnerSpecSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema EphemeralRunnerSpecSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema EphemeralRunnerSpecSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema EphemeralRunnerSpecSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecTolerations(
  obj: EphemeralRunnerSpecSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema EphemeralRunnerSpecSpecTopologySpreadConstraints
 */
export interface EphemeralRunnerSpecSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecTopologySpreadConstraints(
  obj: EphemeralRunnerSpecSpecTopologySpreadConstraints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector: toJson_EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    maxSkew: obj.maxSkew,
    minDomains: obj.minDomains,
    nodeAffinityPolicy: obj.nodeAffinityPolicy,
    nodeTaintsPolicy: obj.nodeTaintsPolicy,
    topologyKey: obj.topologyKey,
    whenUnsatisfiable: obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema EphemeralRunnerSpecSpecVolumes
 */
export interface EphemeralRunnerSpecSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
   * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EphemeralRunnerSpecSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: EphemeralRunnerSpecSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
   * are redirected to the disk.csi.azure.com CSI driver.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#azureDisk
   */
  readonly azureDisk?: EphemeralRunnerSpecSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
   * are redirected to the file.csi.azure.com CSI driver.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#azureFile
   */
  readonly azureFile?: EphemeralRunnerSpecSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
   * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#cephfs
   */
  readonly cephfs?: EphemeralRunnerSpecSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
   * are redirected to the cinder.csi.openstack.org CSI driver.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EphemeralRunnerSpecSpecVolumes#cinder
   */
  readonly cinder?: EphemeralRunnerSpecSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema EphemeralRunnerSpecSpecVolumes#configMap
   */
  readonly configMap?: EphemeralRunnerSpecSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#csi
   */
  readonly csi?: EphemeralRunnerSpecSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema EphemeralRunnerSpecSpecVolumes#downwardAPI
   */
  readonly downwardApi?: EphemeralRunnerSpecSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EphemeralRunnerSpecSpecVolumes#emptyDir
   */
  readonly emptyDir?: EphemeralRunnerSpecSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#ephemeral
   */
  readonly ephemeral?: EphemeralRunnerSpecSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#fc
   */
  readonly fc?: EphemeralRunnerSpecSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#flexVolume
   */
  readonly flexVolume?: EphemeralRunnerSpecSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
   * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#flocker
   */
  readonly flocker?: EphemeralRunnerSpecSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
   * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EphemeralRunnerSpecSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: EphemeralRunnerSpecSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#gitRepo
   */
  readonly gitRepo?: EphemeralRunnerSpecSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema EphemeralRunnerSpecSpecVolumes#glusterfs
   */
  readonly glusterfs?: EphemeralRunnerSpecSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema EphemeralRunnerSpecSpecVolumes#hostPath
   */
  readonly hostPath?: EphemeralRunnerSpecSpecVolumesHostPath;

  /**
   * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
   * The volume is resolved at pod startup depending on which PullPolicy value is provided:
   *
   * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   *
   * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
   * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
   * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
   * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
   * The volume will be mounted read-only (ro) and non-executable files (noexec).
   * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
   * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#image
   */
  readonly image?: EphemeralRunnerSpecSpecVolumesImage;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema EphemeralRunnerSpecSpecVolumes#iscsi
   */
  readonly iscsi?: EphemeralRunnerSpecSpecVolumesIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EphemeralRunnerSpecSpecVolumes#nfs
   */
  readonly nfs?: EphemeralRunnerSpecSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema EphemeralRunnerSpecSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: EphemeralRunnerSpecSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
   * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: EphemeralRunnerSpecSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
   * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
   * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
   * is on.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: EphemeralRunnerSpecSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema EphemeralRunnerSpecSpecVolumes#projected
   */
  readonly projected?: EphemeralRunnerSpecSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
   * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#quobyte
   */
  readonly quobyte?: EphemeralRunnerSpecSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema EphemeralRunnerSpecSpecVolumes#rbd
   */
  readonly rbd?: EphemeralRunnerSpecSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#scaleIO
   */
  readonly scaleIo?: EphemeralRunnerSpecSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema EphemeralRunnerSpecSpecVolumes#secret
   */
  readonly secret?: EphemeralRunnerSpecSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#storageos
   */
  readonly storageos?: EphemeralRunnerSpecSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
   * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
   * are redirected to the csi.vsphere.vmware.com CSI driver.
   *
   * @schema EphemeralRunnerSpecSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: EphemeralRunnerSpecSpecVolumesVsphereVolume;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumes(
  obj: EphemeralRunnerSpecSpecVolumes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    awsElasticBlockStore: toJson_EphemeralRunnerSpecSpecVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    azureDisk: toJson_EphemeralRunnerSpecSpecVolumesAzureDisk(obj.azureDisk),
    azureFile: toJson_EphemeralRunnerSpecSpecVolumesAzureFile(obj.azureFile),
    cephfs: toJson_EphemeralRunnerSpecSpecVolumesCephfs(obj.cephfs),
    cinder: toJson_EphemeralRunnerSpecSpecVolumesCinder(obj.cinder),
    configMap: toJson_EphemeralRunnerSpecSpecVolumesConfigMap(obj.configMap),
    csi: toJson_EphemeralRunnerSpecSpecVolumesCsi(obj.csi),
    downwardAPI: toJson_EphemeralRunnerSpecSpecVolumesDownwardApi(obj.downwardApi),
    emptyDir: toJson_EphemeralRunnerSpecSpecVolumesEmptyDir(obj.emptyDir),
    ephemeral: toJson_EphemeralRunnerSpecSpecVolumesEphemeral(obj.ephemeral),
    fc: toJson_EphemeralRunnerSpecSpecVolumesFc(obj.fc),
    flexVolume: toJson_EphemeralRunnerSpecSpecVolumesFlexVolume(obj.flexVolume),
    flocker: toJson_EphemeralRunnerSpecSpecVolumesFlocker(obj.flocker),
    gcePersistentDisk: toJson_EphemeralRunnerSpecSpecVolumesGcePersistentDisk(obj.gcePersistentDisk),
    gitRepo: toJson_EphemeralRunnerSpecSpecVolumesGitRepo(obj.gitRepo),
    glusterfs: toJson_EphemeralRunnerSpecSpecVolumesGlusterfs(obj.glusterfs),
    hostPath: toJson_EphemeralRunnerSpecSpecVolumesHostPath(obj.hostPath),
    image: toJson_EphemeralRunnerSpecSpecVolumesImage(obj.image),
    iscsi: toJson_EphemeralRunnerSpecSpecVolumesIscsi(obj.iscsi),
    name: obj.name,
    nfs: toJson_EphemeralRunnerSpecSpecVolumesNfs(obj.nfs),
    persistentVolumeClaim: toJson_EphemeralRunnerSpecSpecVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    photonPersistentDisk: toJson_EphemeralRunnerSpecSpecVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    portworxVolume: toJson_EphemeralRunnerSpecSpecVolumesPortworxVolume(obj.portworxVolume),
    projected: toJson_EphemeralRunnerSpecSpecVolumesProjected(obj.projected),
    quobyte: toJson_EphemeralRunnerSpecSpecVolumesQuobyte(obj.quobyte),
    rbd: toJson_EphemeralRunnerSpecSpecVolumesRbd(obj.rbd),
    scaleIO: toJson_EphemeralRunnerSpecSpecVolumesScaleIo(obj.scaleIo),
    secret: toJson_EphemeralRunnerSpecSpecVolumesSecret(obj.secret),
    storageos: toJson_EphemeralRunnerSpecSpecVolumesStorageos(obj.storageos),
    vsphereVolume: toJson_EphemeralRunnerSpecSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecVaultConfigAzureKeyVault
 */
export interface EphemeralRunnerSpecVaultConfigAzureKeyVault {
  /**
   * @schema EphemeralRunnerSpecVaultConfigAzureKeyVault#certificatePath
   */
  readonly certificatePath: string;

  /**
   * @schema EphemeralRunnerSpecVaultConfigAzureKeyVault#clientId
   */
  readonly clientId: string;

  /**
   * @schema EphemeralRunnerSpecVaultConfigAzureKeyVault#tenantId
   */
  readonly tenantId: string;

  /**
   * @schema EphemeralRunnerSpecVaultConfigAzureKeyVault#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecVaultConfigAzureKeyVault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecVaultConfigAzureKeyVault(
  obj: EphemeralRunnerSpecVaultConfigAzureKeyVault | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certificatePath: obj.certificatePath,
    clientId: obj.clientId,
    tenantId: obj.tenantId,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecVaultConfigProxy
 */
export interface EphemeralRunnerSpecVaultConfigProxy {
  /**
   * @schema EphemeralRunnerSpecVaultConfigProxy#http
   */
  readonly http?: EphemeralRunnerSpecVaultConfigProxyHttp;

  /**
   * @schema EphemeralRunnerSpecVaultConfigProxy#https
   */
  readonly https?: EphemeralRunnerSpecVaultConfigProxyHttps;

  /**
   * @schema EphemeralRunnerSpecVaultConfigProxy#noProxy
   */
  readonly noProxy?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecVaultConfigProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecVaultConfigProxy(
  obj: EphemeralRunnerSpecVaultConfigProxy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_EphemeralRunnerSpecVaultConfigProxyHttp(obj.http),
    https: toJson_EphemeralRunnerSpecVaultConfigProxyHttps(obj.https),
    noProxy: obj.noProxy?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required
 *
 * @schema EphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef
 */
export interface EphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef(
  obj: EphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema EphemeralRunnerSpecSpecAffinityNodeAffinity
 */
export interface EphemeralRunnerSpecSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityNodeAffinity(
  obj: EphemeralRunnerSpecSpecAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y),
    ),
    requiredDuringSchedulingIgnoredDuringExecution:
      toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinity
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinity(
  obj: EphemeralRunnerSpecSpecAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y),
    ),
    requiredDuringSchedulingIgnoredDuringExecution: obj.requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinity
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinity(
  obj: EphemeralRunnerSpecSpecAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y),
    ),
    requiredDuringSchedulingIgnoredDuringExecution: obj.requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema EphemeralRunnerSpecSpecContainersEnv
 */
export interface EphemeralRunnerSpecSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSpecSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema EphemeralRunnerSpecSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema EphemeralRunnerSpecSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: EphemeralRunnerSpecSpecContainersEnvValueFrom;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersEnv(
  obj: EphemeralRunnerSpecSpecContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_EphemeralRunnerSpecSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema EphemeralRunnerSpecSpecContainersEnvFrom
 */
export interface EphemeralRunnerSpecSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: EphemeralRunnerSpecSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: EphemeralRunnerSpecSpecContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersEnvFrom(
  obj: EphemeralRunnerSpecSpecContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_EphemeralRunnerSpecSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    prefix: obj.prefix,
    secretRef: toJson_EphemeralRunnerSpecSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecycle
 */
export interface EphemeralRunnerSpecSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecycle#postStart
   */
  readonly postStart?: EphemeralRunnerSpecSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecycle#preStop
   */
  readonly preStop?: EphemeralRunnerSpecSpecContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecycle(
  obj: EphemeralRunnerSpecSpecContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSpecSpecContainersLivenessProbe
 */
export interface EphemeralRunnerSpecSpecContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbe#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSpecSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLivenessProbe(
  obj: EphemeralRunnerSpecSpecContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSpecSpecContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema EphemeralRunnerSpecSpecContainersPorts
 */
export interface EphemeralRunnerSpecSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema EphemeralRunnerSpecSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema EphemeralRunnerSpecSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema EphemeralRunnerSpecSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema EphemeralRunnerSpecSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema EphemeralRunnerSpecSpecContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersPorts(
  obj: EphemeralRunnerSpecSpecContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSpecSpecContainersReadinessProbe
 */
export interface EphemeralRunnerSpecSpecContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbe#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSpecSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersReadinessProbe(
  obj: EphemeralRunnerSpecSpecContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSpecSpecContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema EphemeralRunnerSpecSpecContainersResizePolicy
 */
export interface EphemeralRunnerSpecSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema EphemeralRunnerSpecSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema EphemeralRunnerSpecSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersResizePolicy(
  obj: EphemeralRunnerSpecSpecContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema EphemeralRunnerSpecSpecContainersResources
 */
export interface EphemeralRunnerSpecSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EphemeralRunnerSpecSpecContainersResources#claims
   */
  readonly claims?: EphemeralRunnerSpecSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecContainersResources#limits
   */
  readonly limits?: {
    [key: string]: EphemeralRunnerSpecSpecContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecContainersResources#requests
   */
  readonly requests?: {
    [key: string]: EphemeralRunnerSpecSpecContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersResources(
  obj: EphemeralRunnerSpecSpecContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_EphemeralRunnerSpecSpecContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema EphemeralRunnerSpecSpecContainersSecurityContext
 */
export interface EphemeralRunnerSpecSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: EphemeralRunnerSpecSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersSecurityContext(
  obj: EphemeralRunnerSpecSpecContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_EphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile(obj.appArmorProfile),
    capabilities: toJson_EphemeralRunnerSpecSpecContainersSecurityContextCapabilities(obj.capabilities),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_EphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    seccompProfile: toJson_EphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile(obj.seccompProfile),
    windowsOptions: toJson_EphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSpecSpecContainersStartupProbe
 */
export interface EphemeralRunnerSpecSpecContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbe#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSpecSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersStartupProbe(
  obj: EphemeralRunnerSpecSpecContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSpecSpecContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSpecSpecContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSpecSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema EphemeralRunnerSpecSpecContainersVolumeDevices
 */
export interface EphemeralRunnerSpecSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema EphemeralRunnerSpecSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema EphemeralRunnerSpecSpecContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersVolumeDevices(
  obj: EphemeralRunnerSpecSpecContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema EphemeralRunnerSpecSpecContainersVolumeMounts
 */
export interface EphemeralRunnerSpecSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema EphemeralRunnerSpecSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema EphemeralRunnerSpecSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema EphemeralRunnerSpecSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema EphemeralRunnerSpecSpecContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema EphemeralRunnerSpecSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema EphemeralRunnerSpecSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersVolumeMounts(
  obj: EphemeralRunnerSpecSpecContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema EphemeralRunnerSpecSpecDnsConfigOptions
 */
export interface EphemeralRunnerSpecSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema EphemeralRunnerSpecSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema EphemeralRunnerSpecSpecDnsConfigOptions#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecDnsConfigOptions(
  obj: EphemeralRunnerSpecSpecDnsConfigOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersEnv
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnv#valueFrom
   */
  readonly valueFrom?: EphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersEnv(
  obj: EphemeralRunnerSpecSpecEphemeralContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvFrom
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: EphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvFrom#secretRef
   */
  readonly secretRef?: EphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvFrom(
  obj: EphemeralRunnerSpecSpecEphemeralContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef(obj.configMapRef),
    prefix: obj.prefix,
    secretRef: toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Lifecycle is not allowed for ephemeral containers.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecycle
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecycle#postStart
   */
  readonly postStart?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecycle#preStop
   */
  readonly preStop?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecycle(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersPorts
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema EphemeralRunnerSpecSpecEphemeralContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersPorts(
  obj: EphemeralRunnerSpecSpecEphemeralContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe(
  obj: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersResizePolicy
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersResizePolicy(
  obj: EphemeralRunnerSpecSpecEphemeralContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
 * already allocated to the pod.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersResources
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersResources#claims
   */
  readonly claims?: EphemeralRunnerSpecSpecEphemeralContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersResources#limits
   */
  readonly limits?: {
    [key: string]: EphemeralRunnerSpecSpecEphemeralContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersResources#requests
   */
  readonly requests?: {
    [key: string]: EphemeralRunnerSpecSpecEphemeralContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersResources(
  obj: EphemeralRunnerSpecSpecEphemeralContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_EphemeralRunnerSpecSpecEphemeralContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#capabilities
   */
  readonly capabilities?: EphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContext(
  obj: EphemeralRunnerSpecSpecEphemeralContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    capabilities: toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities(obj.capabilities),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    seccompProfile: toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile(obj.seccompProfile),
    windowsOptions: toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbe
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbe#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbe(
  obj: EphemeralRunnerSpecSpecEphemeralContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersVolumeDevices
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersVolumeDevices(
  obj: EphemeralRunnerSpecSpecEphemeralContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts(
  obj: EphemeralRunnerSpecSpecEphemeralContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersEnv
 */
export interface EphemeralRunnerSpecSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema EphemeralRunnerSpecSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: EphemeralRunnerSpecSpecInitContainersEnvValueFrom;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersEnv(
  obj: EphemeralRunnerSpecSpecInitContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_EphemeralRunnerSpecSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema EphemeralRunnerSpecSpecInitContainersEnvFrom
 */
export interface EphemeralRunnerSpecSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: EphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: EphemeralRunnerSpecSpecInitContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersEnvFrom(
  obj: EphemeralRunnerSpecSpecInitContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_EphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef(obj.configMapRef),
    prefix: obj.prefix,
    secretRef: toJson_EphemeralRunnerSpecSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecycle
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: EphemeralRunnerSpecSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: EphemeralRunnerSpecSpecInitContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecycle(
  obj: EphemeralRunnerSpecSpecInitContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbe
 */
export interface EphemeralRunnerSpecSpecInitContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbe(
  obj: EphemeralRunnerSpecSpecInitContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersPorts
 */
export interface EphemeralRunnerSpecSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema EphemeralRunnerSpecSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersPorts(
  obj: EphemeralRunnerSpecSpecInitContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbe
 */
export interface EphemeralRunnerSpecSpecInitContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbe(
  obj: EphemeralRunnerSpecSpecInitContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersResizePolicy
 */
export interface EphemeralRunnerSpecSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersResizePolicy(
  obj: EphemeralRunnerSpecSpecInitContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema EphemeralRunnerSpecSpecInitContainersResources
 */
export interface EphemeralRunnerSpecSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersResources#claims
   */
  readonly claims?: EphemeralRunnerSpecSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecInitContainersResources#limits
   */
  readonly limits?: {
    [key: string]: EphemeralRunnerSpecSpecInitContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecInitContainersResources#requests
   */
  readonly requests?: {
    [key: string]: EphemeralRunnerSpecSpecInitContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersResources(
  obj: EphemeralRunnerSpecSpecInitContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_EphemeralRunnerSpecSpecInitContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext
 */
export interface EphemeralRunnerSpecSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: EphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersSecurityContext(
  obj: EphemeralRunnerSpecSpecInitContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_EphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile(obj.appArmorProfile),
    capabilities: toJson_EphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities(obj.capabilities),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_EphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    seccompProfile: toJson_EphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile(obj.seccompProfile),
    windowsOptions: toJson_EphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSpecSpecInitContainersStartupProbe
 */
export interface EphemeralRunnerSpecSpecInitContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbe#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSpecSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersStartupProbe(
  obj: EphemeralRunnerSpecSpecInitContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecInitContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSpecSpecInitContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersVolumeDevices
 */
export interface EphemeralRunnerSpecSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema EphemeralRunnerSpecSpecInitContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersVolumeDevices(
  obj: EphemeralRunnerSpecSpecInitContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersVolumeMounts
 */
export interface EphemeralRunnerSpecSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema EphemeralRunnerSpecSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema EphemeralRunnerSpecSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema EphemeralRunnerSpecSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersVolumeMounts(
  obj: EphemeralRunnerSpecSpecInitContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EphemeralRunnerSpecSpecResourcesClaims
 */
export interface EphemeralRunnerSpecSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EphemeralRunnerSpecSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EphemeralRunnerSpecSpecResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecResourcesClaims(
  obj: EphemeralRunnerSpecSpecResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecSpecResourcesLimits
 */
export class EphemeralRunnerSpecSpecResourcesLimits {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecResourcesLimits {
    return new EphemeralRunnerSpecSpecResourcesLimits(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecResourcesLimits {
    return new EphemeralRunnerSpecSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema EphemeralRunnerSpecSpecResourcesRequests
 */
export class EphemeralRunnerSpecSpecResourcesRequests {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecResourcesRequests {
    return new EphemeralRunnerSpecSpecResourcesRequests(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecResourcesRequests {
    return new EphemeralRunnerSpecSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecSecurityContextAppArmorProfile
 */
export interface EphemeralRunnerSpecSpecSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecSecurityContextAppArmorProfile(
  obj: EphemeralRunnerSpecSpecSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecSecurityContextSeLinuxOptions
 */
export interface EphemeralRunnerSpecSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecSecurityContextSeLinuxOptions(
  obj: EphemeralRunnerSpecSpecSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecSecurityContextSeccompProfile
 */
export interface EphemeralRunnerSpecSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecSecurityContextSeccompProfile(
  obj: EphemeralRunnerSpecSpecSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema EphemeralRunnerSpecSpecSecurityContextSysctls
 */
export interface EphemeralRunnerSpecSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecSecurityContextSysctls(
  obj: EphemeralRunnerSpecSpecSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EphemeralRunnerSpecSpecSecurityContextWindowsOptions
 */
export interface EphemeralRunnerSpecSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EphemeralRunnerSpecSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSpecSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecSecurityContextWindowsOptions(
  obj: EphemeralRunnerSpecSpecSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector
 */
export interface EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector(
  obj: EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
 * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema EphemeralRunnerSpecSpecVolumesAwsElasticBlockStore
 */
export interface EphemeralRunnerSpecSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EphemeralRunnerSpecSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema EphemeralRunnerSpecSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EphemeralRunnerSpecSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EphemeralRunnerSpecSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesAwsElasticBlockStore(
  obj: EphemeralRunnerSpecSpecVolumesAwsElasticBlockStore | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    partition: obj.partition,
    readOnly: obj.readOnly,
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
 * are redirected to the disk.csi.azure.com CSI driver.
 *
 * @schema EphemeralRunnerSpecSpecVolumesAzureDisk
 */
export interface EphemeralRunnerSpecSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema EphemeralRunnerSpecSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema EphemeralRunnerSpecSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema EphemeralRunnerSpecSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSpecSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema EphemeralRunnerSpecSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EphemeralRunnerSpecSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesAzureDisk(
  obj: EphemeralRunnerSpecSpecVolumesAzureDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cachingMode: obj.cachingMode,
    diskName: obj.diskName,
    diskURI: obj.diskUri,
    fsType: obj.fsType,
    kind: obj.kind,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
 * are redirected to the file.csi.azure.com CSI driver.
 *
 * @schema EphemeralRunnerSpecSpecVolumesAzureFile
 */
export interface EphemeralRunnerSpecSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EphemeralRunnerSpecSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema EphemeralRunnerSpecSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema EphemeralRunnerSpecSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesAzureFile(
  obj: EphemeralRunnerSpecSpecVolumesAzureFile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    readOnly: obj.readOnly,
    secretName: obj.secretName,
    shareName: obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
 * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
 *
 * @schema EphemeralRunnerSpecSpecVolumesCephfs
 */
export interface EphemeralRunnerSpecSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSpecSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema EphemeralRunnerSpecSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EphemeralRunnerSpecSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSpecSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSpecSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: EphemeralRunnerSpecSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSpecSpecVolumesCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesCephfs(
  obj: EphemeralRunnerSpecSpecVolumesCephfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    monitors: obj.monitors?.map((y) => y),
    path: obj.path,
    readOnly: obj.readOnly,
    secretFile: obj.secretFile,
    secretRef: toJson_EphemeralRunnerSpecSpecVolumesCephfsSecretRef(obj.secretRef),
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
 * are redirected to the cinder.csi.openstack.org CSI driver.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema EphemeralRunnerSpecSpecVolumesCinder
 */
export interface EphemeralRunnerSpecSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EphemeralRunnerSpecSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EphemeralRunnerSpecSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema EphemeralRunnerSpecSpecVolumesCinder#secretRef
   */
  readonly secretRef?: EphemeralRunnerSpecSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EphemeralRunnerSpecSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesCinder(
  obj: EphemeralRunnerSpecSpecVolumesCinder | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSpecSpecVolumesCinderSecretRef(obj.secretRef),
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema EphemeralRunnerSpecSpecVolumesConfigMap
 */
export interface EphemeralRunnerSpecSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EphemeralRunnerSpecSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EphemeralRunnerSpecSpecVolumesConfigMap#items
   */
  readonly items?: EphemeralRunnerSpecSpecVolumesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema EphemeralRunnerSpecSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesConfigMap(
  obj: EphemeralRunnerSpecSpecVolumesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_EphemeralRunnerSpecSpecVolumesConfigMapItems(y)),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
 *
 * @schema EphemeralRunnerSpecSpecVolumesCsi
 */
export interface EphemeralRunnerSpecSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema EphemeralRunnerSpecSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema EphemeralRunnerSpecSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema EphemeralRunnerSpecSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: EphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema EphemeralRunnerSpecSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema EphemeralRunnerSpecSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesCsi(
  obj: EphemeralRunnerSpecSpecVolumesCsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    driver: obj.driver,
    fsType: obj.fsType,
    nodePublishSecretRef: toJson_EphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    readOnly: obj.readOnly,
    volumeAttributes:
      obj.volumeAttributes === undefined
        ? undefined
        : Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema EphemeralRunnerSpecSpecVolumesDownwardApi
 */
export interface EphemeralRunnerSpecSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EphemeralRunnerSpecSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema EphemeralRunnerSpecSpecVolumesDownwardApi#items
   */
  readonly items?: EphemeralRunnerSpecSpecVolumesDownwardApiItems[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesDownwardApi(
  obj: EphemeralRunnerSpecSpecVolumesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_EphemeralRunnerSpecSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema EphemeralRunnerSpecSpecVolumesEmptyDir
 */
export interface EphemeralRunnerSpecSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EphemeralRunnerSpecSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EphemeralRunnerSpecSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: EphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesEmptyDir(
  obj: EphemeralRunnerSpecSpecVolumesEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    medium: obj.medium,
    sizeLimit: obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema EphemeralRunnerSpecSpecVolumesEphemeral
 */
export interface EphemeralRunnerSpecSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesEphemeral(
  obj: EphemeralRunnerSpecSpecVolumesEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    volumeClaimTemplate: toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema EphemeralRunnerSpecSpecVolumesFc
 */
export interface EphemeralRunnerSpecSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSpecSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema EphemeralRunnerSpecSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EphemeralRunnerSpecSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema EphemeralRunnerSpecSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema EphemeralRunnerSpecSpecVolumesFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesFc(
  obj: EphemeralRunnerSpecSpecVolumesFc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    lun: obj.lun,
    readOnly: obj.readOnly,
    targetWWNs: obj.targetWwNs?.map((y) => y),
    wwids: obj.wwids?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
 *
 * @schema EphemeralRunnerSpecSpecVolumesFlexVolume
 */
export interface EphemeralRunnerSpecSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema EphemeralRunnerSpecSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema EphemeralRunnerSpecSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema EphemeralRunnerSpecSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EphemeralRunnerSpecSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema EphemeralRunnerSpecSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: EphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesFlexVolume(
  obj: EphemeralRunnerSpecSpecVolumesFlexVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    driver: obj.driver,
    fsType: obj.fsType,
    options:
      obj.options === undefined
        ? undefined
        : Object.entries(obj.options).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
 * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
 *
 * @schema EphemeralRunnerSpecSpecVolumesFlocker
 */
export interface EphemeralRunnerSpecSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema EphemeralRunnerSpecSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema EphemeralRunnerSpecSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesFlocker(
  obj: EphemeralRunnerSpecSpecVolumesFlocker | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    datasetName: obj.datasetName,
    datasetUUID: obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
 * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema EphemeralRunnerSpecSpecVolumesGcePersistentDisk
 */
export interface EphemeralRunnerSpecSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EphemeralRunnerSpecSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EphemeralRunnerSpecSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EphemeralRunnerSpecSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesGcePersistentDisk(
  obj: EphemeralRunnerSpecSpecVolumesGcePersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    partition: obj.partition,
    pdName: obj.pdName,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema EphemeralRunnerSpecSpecVolumesGitRepo
 */
export interface EphemeralRunnerSpecSpecVolumesGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema EphemeralRunnerSpecSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema EphemeralRunnerSpecSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema EphemeralRunnerSpecSpecVolumesGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesGitRepo(
  obj: EphemeralRunnerSpecSpecVolumesGitRepo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    directory: obj.directory,
    repository: obj.repository,
    revision: obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema EphemeralRunnerSpecSpecVolumesGlusterfs
 */
export interface EphemeralRunnerSpecSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema EphemeralRunnerSpecSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema EphemeralRunnerSpecSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesGlusterfs(
  obj: EphemeralRunnerSpecSpecVolumesGlusterfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    endpoints: obj.endpoints,
    path: obj.path,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 *
 * @schema EphemeralRunnerSpecSpecVolumesHostPath
 */
export interface EphemeralRunnerSpecSpecVolumesHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema EphemeralRunnerSpecSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema EphemeralRunnerSpecSpecVolumesHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesHostPath(
  obj: EphemeralRunnerSpecSpecVolumesHostPath | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
 * The volume is resolved at pod startup depending on which PullPolicy value is provided:
 *
 * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
 * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
 * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
 *
 * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
 * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
 * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
 * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
 * The volume will be mounted read-only (ro) and non-executable files (noexec).
 * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
 * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
 *
 * @schema EphemeralRunnerSpecSpecVolumesImage
 */
export interface EphemeralRunnerSpecSpecVolumesImage {
  /**
   * Policy for pulling OCI objects. Possible values are:
   * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema EphemeralRunnerSpecSpecVolumesImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Required: Image or artifact reference to be used.
   * Behaves in the same way as pod.spec.containers[*].image.
   * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema EphemeralRunnerSpecSpecVolumesImage#reference
   */
  readonly reference?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesImage(
  obj: EphemeralRunnerSpecSpecVolumesImage | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    pullPolicy: obj.pullPolicy,
    reference: obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema EphemeralRunnerSpecSpecVolumesIscsi
 */
export interface EphemeralRunnerSpecSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema EphemeralRunnerSpecSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema EphemeralRunnerSpecSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema EphemeralRunnerSpecSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema EphemeralRunnerSpecSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema EphemeralRunnerSpecSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema EphemeralRunnerSpecSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema EphemeralRunnerSpecSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema EphemeralRunnerSpecSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema EphemeralRunnerSpecSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: EphemeralRunnerSpecSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema EphemeralRunnerSpecSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesIscsi(
  obj: EphemeralRunnerSpecSpecVolumesIscsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    chapAuthDiscovery: obj.chapAuthDiscovery,
    chapAuthSession: obj.chapAuthSession,
    fsType: obj.fsType,
    initiatorName: obj.initiatorName,
    iqn: obj.iqn,
    iscsiInterface: obj.iscsiInterface,
    lun: obj.lun,
    portals: obj.portals?.map((y) => y),
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSpecSpecVolumesIscsiSecretRef(obj.secretRef),
    targetPortal: obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema EphemeralRunnerSpecSpecVolumesNfs
 */
export interface EphemeralRunnerSpecSpecVolumesNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EphemeralRunnerSpecSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EphemeralRunnerSpecSpecVolumesNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesNfs(
  obj: EphemeralRunnerSpecSpecVolumesNfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    readOnly: obj.readOnly,
    server: obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema EphemeralRunnerSpecSpecVolumesPersistentVolumeClaim
 */
export interface EphemeralRunnerSpecSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema EphemeralRunnerSpecSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema EphemeralRunnerSpecSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesPersistentVolumeClaim(
  obj: EphemeralRunnerSpecSpecVolumesPersistentVolumeClaim | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claimName: obj.claimName,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
 * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
 *
 * @schema EphemeralRunnerSpecSpecVolumesPhotonPersistentDisk
 */
export interface EphemeralRunnerSpecSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSpecSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema EphemeralRunnerSpecSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesPhotonPersistentDisk(
  obj: EphemeralRunnerSpecSpecVolumesPhotonPersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    pdID: obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
 * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
 * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
 * is on.
 *
 * @schema EphemeralRunnerSpecSpecVolumesPortworxVolume
 */
export interface EphemeralRunnerSpecSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSpecSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EphemeralRunnerSpecSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema EphemeralRunnerSpecSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesPortworxVolume(
  obj: EphemeralRunnerSpecSpecVolumesPortworxVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjected
 */
export interface EphemeralRunnerSpecSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections. Each entry in this list
   * handles one source.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjected#sources
   */
  readonly sources?: EphemeralRunnerSpecSpecVolumesProjectedSources[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjected(
  obj: EphemeralRunnerSpecSpecVolumesProjected | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    sources: obj.sources?.map((y) => toJson_EphemeralRunnerSpecSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
 * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
 *
 * @schema EphemeralRunnerSpecSpecVolumesQuobyte
 */
export interface EphemeralRunnerSpecSpecVolumesQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema EphemeralRunnerSpecSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema EphemeralRunnerSpecSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema EphemeralRunnerSpecSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema EphemeralRunnerSpecSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema EphemeralRunnerSpecSpecVolumesQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesQuobyte(
  obj: EphemeralRunnerSpecSpecVolumesQuobyte | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    group: obj.group,
    readOnly: obj.readOnly,
    registry: obj.registry,
    tenant: obj.tenant,
    user: obj.user,
    volume: obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema EphemeralRunnerSpecSpecVolumesRbd
 */
export interface EphemeralRunnerSpecSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema EphemeralRunnerSpecSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSpecSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema EphemeralRunnerSpecSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSpecSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema EphemeralRunnerSpecSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema EphemeralRunnerSpecSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema EphemeralRunnerSpecSpecVolumesRbd#secretRef
   */
  readonly secretRef?: EphemeralRunnerSpecSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema EphemeralRunnerSpecSpecVolumesRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesRbd(
  obj: EphemeralRunnerSpecSpecVolumesRbd | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    image: obj.image,
    keyring: obj.keyring,
    monitors: obj.monitors?.map((y) => y),
    pool: obj.pool,
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSpecSpecVolumesRbdSecretRef(obj.secretRef),
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
 *
 * @schema EphemeralRunnerSpecSpecVolumesScaleIo
 */
export interface EphemeralRunnerSpecSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema EphemeralRunnerSpecSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema EphemeralRunnerSpecSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema EphemeralRunnerSpecSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EphemeralRunnerSpecSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema EphemeralRunnerSpecSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: EphemeralRunnerSpecSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema EphemeralRunnerSpecSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema EphemeralRunnerSpecSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema EphemeralRunnerSpecSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema EphemeralRunnerSpecSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema EphemeralRunnerSpecSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesScaleIo(
  obj: EphemeralRunnerSpecSpecVolumesScaleIo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    gateway: obj.gateway,
    protectionDomain: obj.protectionDomain,
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSpecSpecVolumesScaleIoSecretRef(obj.secretRef),
    sslEnabled: obj.sslEnabled,
    storageMode: obj.storageMode,
    storagePool: obj.storagePool,
    system: obj.system,
    volumeName: obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema EphemeralRunnerSpecSpecVolumesSecret
 */
export interface EphemeralRunnerSpecSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EphemeralRunnerSpecSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EphemeralRunnerSpecSpecVolumesSecret#items
   */
  readonly items?: EphemeralRunnerSpecSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema EphemeralRunnerSpecSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema EphemeralRunnerSpecSpecVolumesSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesSecret(
  obj: EphemeralRunnerSpecSpecVolumesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_EphemeralRunnerSpecSpecVolumesSecretItems(y)),
    optional: obj.optional,
    secretName: obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
 *
 * @schema EphemeralRunnerSpecSpecVolumesStorageos
 */
export interface EphemeralRunnerSpecSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSpecSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EphemeralRunnerSpecSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema EphemeralRunnerSpecSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: EphemeralRunnerSpecSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema EphemeralRunnerSpecSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema EphemeralRunnerSpecSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesStorageos(
  obj: EphemeralRunnerSpecSpecVolumesStorageos | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSpecSpecVolumesStorageosSecretRef(obj.secretRef),
    volumeName: obj.volumeName,
    volumeNamespace: obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
 * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
 * are redirected to the csi.vsphere.vmware.com CSI driver.
 *
 * @schema EphemeralRunnerSpecSpecVolumesVsphereVolume
 */
export interface EphemeralRunnerSpecSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSpecSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema EphemeralRunnerSpecSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema EphemeralRunnerSpecSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema EphemeralRunnerSpecSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesVsphereVolume(
  obj: EphemeralRunnerSpecSpecVolumesVsphereVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    storagePolicyID: obj.storagePolicyId,
    storagePolicyName: obj.storagePolicyName,
    volumePath: obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecVaultConfigProxyHttp
 */
export interface EphemeralRunnerSpecVaultConfigProxyHttp {
  /**
   * @schema EphemeralRunnerSpecVaultConfigProxyHttp#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema EphemeralRunnerSpecVaultConfigProxyHttp#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecVaultConfigProxyHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecVaultConfigProxyHttp(
  obj: EphemeralRunnerSpecVaultConfigProxyHttp | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecVaultConfigProxyHttps
 */
export interface EphemeralRunnerSpecVaultConfigProxyHttps {
  /**
   * @schema EphemeralRunnerSpecVaultConfigProxyHttps#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema EphemeralRunnerSpecVaultConfigProxyHttps#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecVaultConfigProxyHttps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecVaultConfigProxyHttps(
  obj: EphemeralRunnerSpecVaultConfigProxyHttps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj: EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preference:
      toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj: EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeSelectorTerms: obj.nodeSelectorTerms?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj: EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    podAffinityTerm:
      toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj: EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj: EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    podAffinityTerm:
      toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj: EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema EphemeralRunnerSpecSpecContainersEnvValueFrom
 */
export interface EphemeralRunnerSpecSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: EphemeralRunnerSpecSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: EphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersEnvValueFrom(
  obj: EphemeralRunnerSpecSpecContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_EphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    fieldRef: toJson_EphemeralRunnerSpecSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    secretKeyRef: toJson_EphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema EphemeralRunnerSpecSpecContainersEnvFromConfigMapRef
 */
export interface EphemeralRunnerSpecSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersEnvFromConfigMapRef(
  obj: EphemeralRunnerSpecSpecContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema EphemeralRunnerSpecSpecContainersEnvFromSecretRef
 */
export interface EphemeralRunnerSpecSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersEnvFromSecretRef(
  obj: EphemeralRunnerSpecSpecContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStart
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStart#sleep
   */
  readonly sleep?: EphemeralRunnerSpecSpecContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStart(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStop
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStop#sleep
   */
  readonly sleep?: EphemeralRunnerSpecSpecContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStop(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecContainersLivenessProbeExec
 */
export interface EphemeralRunnerSpecSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLivenessProbeExec(
  obj: EphemeralRunnerSpecSpecContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSpecSpecContainersLivenessProbeGrpc
 */
export interface EphemeralRunnerSpecSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLivenessProbeGrpc(
  obj: EphemeralRunnerSpecSpecContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet
 */
export interface EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet(
  obj: EphemeralRunnerSpecSpecContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket
 */
export interface EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket(
  obj: EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecContainersReadinessProbeExec
 */
export interface EphemeralRunnerSpecSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersReadinessProbeExec(
  obj: EphemeralRunnerSpecSpecContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSpecSpecContainersReadinessProbeGrpc
 */
export interface EphemeralRunnerSpecSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersReadinessProbeGrpc(
  obj: EphemeralRunnerSpecSpecContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet
 */
export interface EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet(
  obj: EphemeralRunnerSpecSpecContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket
 */
export interface EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket(
  obj: EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EphemeralRunnerSpecSpecContainersResourcesClaims
 */
export interface EphemeralRunnerSpecSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EphemeralRunnerSpecSpecContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EphemeralRunnerSpecSpecContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersResourcesClaims(
  obj: EphemeralRunnerSpecSpecContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecSpecContainersResourcesLimits
 */
export class EphemeralRunnerSpecSpecContainersResourcesLimits {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersResourcesLimits {
    return new EphemeralRunnerSpecSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersResourcesLimits {
    return new EphemeralRunnerSpecSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema EphemeralRunnerSpecSpecContainersResourcesRequests
 */
export class EphemeralRunnerSpecSpecContainersResourcesRequests {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersResourcesRequests {
    return new EphemeralRunnerSpecSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersResourcesRequests {
    return new EphemeralRunnerSpecSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile
 */
export interface EphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile(
  obj: EphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema EphemeralRunnerSpecSpecContainersSecurityContextCapabilities
 */
export interface EphemeralRunnerSpecSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersSecurityContextCapabilities(
  obj: EphemeralRunnerSpecSpecContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions
 */
export interface EphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions(
  obj: EphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile
 */
export interface EphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile(
  obj: EphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions
 */
export interface EphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions(
  obj: EphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecContainersStartupProbeExec
 */
export interface EphemeralRunnerSpecSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersStartupProbeExec(
  obj: EphemeralRunnerSpecSpecContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSpecSpecContainersStartupProbeGrpc
 */
export interface EphemeralRunnerSpecSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersStartupProbeGrpc(
  obj: EphemeralRunnerSpecSpecContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecContainersStartupProbeHttpGet
 */
export interface EphemeralRunnerSpecSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersStartupProbeHttpGet(
  obj: EphemeralRunnerSpecSpecContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) => toJson_EphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders(y)),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSpecSpecContainersStartupProbeTcpSocket
 */
export interface EphemeralRunnerSpecSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersStartupProbeTcpSocket(
  obj: EphemeralRunnerSpecSpecContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom(
  obj: EphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    fieldRef: toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef(
      obj.resourceFieldRef,
    ),
    secretKeyRef: toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef(
  obj: EphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef(
  obj: EphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart#sleep
   */
  readonly sleep?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop#sleep
   */
  readonly sleep?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec(
  obj: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc(
  obj: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet(
  obj: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket(
  obj: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersResourcesClaims
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersResourcesClaims(
  obj: EphemeralRunnerSpecSpecEphemeralContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecSpecEphemeralContainersResourcesLimits
 */
export class EphemeralRunnerSpecSpecEphemeralContainersResourcesLimits {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersResourcesLimits {
    return new EphemeralRunnerSpecSpecEphemeralContainersResourcesLimits(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersResourcesLimits {
    return new EphemeralRunnerSpecSpecEphemeralContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema EphemeralRunnerSpecSpecEphemeralContainersResourcesRequests
 */
export class EphemeralRunnerSpecSpecEphemeralContainersResourcesRequests {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersResourcesRequests {
    return new EphemeralRunnerSpecSpecEphemeralContainersResourcesRequests(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersResourcesRequests {
    return new EphemeralRunnerSpecSpecEphemeralContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile(
  obj: EphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities(
  obj: EphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions(
  obj: EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile(
  obj: EphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions(
  obj: EphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec(
  obj: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc(
  obj: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet(
  obj: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket(
  obj: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFrom
 */
export interface EphemeralRunnerSpecSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: EphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: EphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersEnvValueFrom(
  obj: EphemeralRunnerSpecSpecInitContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_EphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    fieldRef: toJson_EphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    secretKeyRef: toJson_EphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema EphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef
 */
export interface EphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef(
  obj: EphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema EphemeralRunnerSpecSpecInitContainersEnvFromSecretRef
 */
export interface EphemeralRunnerSpecSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersEnvFromSecretRef(
  obj: EphemeralRunnerSpecSpecInitContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStart
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStart#sleep
   */
  readonly sleep?: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStart(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStop
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStop#sleep
   */
  readonly sleep?: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStop(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeExec
 */
export interface EphemeralRunnerSpecSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbeExec(
  obj: EphemeralRunnerSpecSpecInitContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc
 */
export interface EphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc(
  obj: EphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet
 */
export interface EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet(
  obj: EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket
 */
export interface EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket(
  obj: EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeExec
 */
export interface EphemeralRunnerSpecSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbeExec(
  obj: EphemeralRunnerSpecSpecInitContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc
 */
export interface EphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc(
  obj: EphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet
 */
export interface EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet(
  obj: EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket
 */
export interface EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket(
  obj: EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersResourcesClaims
 */
export interface EphemeralRunnerSpecSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersResourcesClaims(
  obj: EphemeralRunnerSpecSpecInitContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecSpecInitContainersResourcesLimits
 */
export class EphemeralRunnerSpecSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersResourcesLimits {
    return new EphemeralRunnerSpecSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersResourcesLimits {
    return new EphemeralRunnerSpecSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema EphemeralRunnerSpecSpecInitContainersResourcesRequests
 */
export class EphemeralRunnerSpecSpecInitContainersResourcesRequests {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersResourcesRequests {
    return new EphemeralRunnerSpecSpecInitContainersResourcesRequests(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersResourcesRequests {
    return new EphemeralRunnerSpecSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile
 */
export interface EphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile(
  obj: EphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities
 */
export interface EphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities(
  obj: EphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface EphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions(
  obj: EphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile
 */
export interface EphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile(
  obj: EphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions
 */
export interface EphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions(
  obj: EphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeExec
 */
export interface EphemeralRunnerSpecSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersStartupProbeExec(
  obj: EphemeralRunnerSpecSpecInitContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeGrpc
 */
export interface EphemeralRunnerSpecSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersStartupProbeGrpc(
  obj: EphemeralRunnerSpecSpecInitContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet
 */
export interface EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet(
  obj: EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket
 */
export interface EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket(
  obj: EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
  obj: EphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema EphemeralRunnerSpecSpecVolumesCephfsSecretRef
 */
export interface EphemeralRunnerSpecSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesCephfsSecretRef(
  obj: EphemeralRunnerSpecSpecVolumesCephfsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema EphemeralRunnerSpecSpecVolumesCinderSecretRef
 */
export interface EphemeralRunnerSpecSpecVolumesCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesCinderSecretRef(
  obj: EphemeralRunnerSpecSpecVolumesCinderSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EphemeralRunnerSpecSpecVolumesConfigMapItems
 */
export interface EphemeralRunnerSpecSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema EphemeralRunnerSpecSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSpecSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EphemeralRunnerSpecSpecVolumesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesConfigMapItems(
  obj: EphemeralRunnerSpecSpecVolumesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema EphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef
 */
export interface EphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef(
  obj: EphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItems
 */
export interface EphemeralRunnerSpecSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: EphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesDownwardApiItems(
  obj: EphemeralRunnerSpecSpecVolumesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fieldRef: toJson_EphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    mode: obj.mode,
    path: obj.path,
    resourceFieldRef: toJson_EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema EphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit
 */
export class EphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit {
    return new EphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit {
    return new EphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 * Required, must not be nil.
 *
 * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate(
  obj: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata(obj.metadata),
    spec: toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema EphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef
 */
export interface EphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef(
  obj: EphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema EphemeralRunnerSpecSpecVolumesIscsiSecretRef
 */
export interface EphemeralRunnerSpecSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesIscsiSecretRef(
  obj: EphemeralRunnerSpecSpecVolumesIscsiSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types.
 * Exactly one of these fields must be set.
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSources
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSources#secret
   */
  readonly secret?: EphemeralRunnerSpecSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: EphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSources(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clusterTrustBundle: toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle(obj.clusterTrustBundle),
    configMap: toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    downwardAPI: toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    secret: toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesSecret(obj.secret),
    serviceAccountToken: toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken(
      obj.serviceAccountToken,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema EphemeralRunnerSpecSpecVolumesRbdSecretRef
 */
export interface EphemeralRunnerSpecSpecVolumesRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesRbdSecretRef(
  obj: EphemeralRunnerSpecSpecVolumesRbdSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema EphemeralRunnerSpecSpecVolumesScaleIoSecretRef
 */
export interface EphemeralRunnerSpecSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesScaleIoSecretRef(
  obj: EphemeralRunnerSpecSpecVolumesScaleIoSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EphemeralRunnerSpecSpecVolumesSecretItems
 */
export interface EphemeralRunnerSpecSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema EphemeralRunnerSpecSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSpecSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EphemeralRunnerSpecSpecVolumesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesSecretItems(
  obj: EphemeralRunnerSpecSpecVolumesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema EphemeralRunnerSpecSpecVolumesStorageosSecretRef
 */
export interface EphemeralRunnerSpecSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesStorageosSecretRef(
  obj: EphemeralRunnerSpecSpecVolumesStorageosSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj: EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema EphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface EphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef(
  obj: EphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema EphemeralRunnerSpecSpecContainersEnvValueFromFieldRef
 */
export interface EphemeralRunnerSpecSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersEnvValueFromFieldRef(
  obj: EphemeralRunnerSpecSpecContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef
 */
export interface EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef(
  obj: EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema EphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef
 */
export interface EphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema EphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef(
  obj: EphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartExec
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStartExec(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartSleep
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStartSleep(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopExec
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStopExec(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopSleep
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStopSleep(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort
 */
export class EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort
 */
export class EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort
 */
export class EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort
 */
export class EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort
 */
export class EphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort
 */
export class EphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef(
  obj: EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef(
  obj: EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef(
  obj: EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef(
  obj: EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort
 */
export class EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort
 */
export class EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort
 */
export class EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort
 */
export class EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort
 */
export class EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort
 */
export class EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface EphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef(
  obj: EphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef
 */
export interface EphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef(
  obj: EphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef(
  obj: EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface EphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef(
  obj: EphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort
 */
export class EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort
 */
export class EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort
 */
export class EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort
 */
export class EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort
 */
export class EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort
 */
export class EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef
 */
export interface EphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef(
  obj: EphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef(
  obj: EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC
 * when creating it. No other fields are allowed and will be rejected during
 * validation.
 *
 * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata
 */
export interface EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata(
  obj: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    finalizers: obj.finalizers?.map((y) => y),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec(
  obj: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessModes: obj.accessModes?.map((y) => y),
    dataSource: toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    dataSourceRef: toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
      obj.dataSourceRef,
    ),
    resources: toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    selector: toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    storageClassName: obj.storageClassName,
    volumeAttributesClassName: obj.volumeAttributesClassName,
    volumeMode: obj.volumeMode,
    volumeName: obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector: toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(
      obj.labelSelector,
    ),
    name: obj.name,
    optional: obj.optional,
    path: obj.path,
    signerName: obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) => toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems(y)),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) => toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesSecret
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: EphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesSecret(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) => toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems(y)),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audience: obj.audience,
    expirationSeconds: obj.expirationSeconds,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | EphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | EphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort
 */
export class EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort
 */
export class EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort
 */
export class EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort
 */
export class EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor
 */
export class EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort
 */
export class EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort
 */
export class EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort
 */
export class EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort
 */
export class EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new EphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
  obj: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
  obj: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
  obj: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fieldRef: toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    mode: obj.mode,
    path: obj.path,
    resourceFieldRef: toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
      obj.resourceFieldRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj: EphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
  obj: EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new EphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * EphemeralRunnerSet is the Schema for the ephemeralrunnersets API
 *
 * @schema EphemeralRunnerSet
 */
export class EphemeralRunnerSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EphemeralRunnerSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "actions.github.com/v1alpha1",
    kind: "EphemeralRunnerSet",
  };

  /**
   * Renders a Kubernetes manifest for "EphemeralRunnerSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EphemeralRunnerSetProps = {}): any {
    return {
      ...EphemeralRunnerSet.GVK,
      ...toJson_EphemeralRunnerSetProps(props),
    };
  }

  /**
   * Defines a "EphemeralRunnerSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EphemeralRunnerSetProps = {}) {
    super(scope, id, {
      ...EphemeralRunnerSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...EphemeralRunnerSet.GVK,
      ...toJson_EphemeralRunnerSetProps(resolved),
    };
  }
}

/**
 * EphemeralRunnerSet is the Schema for the ephemeralrunnersets API
 *
 * @schema EphemeralRunnerSet
 */
export interface EphemeralRunnerSetProps {
  /**
   * @schema EphemeralRunnerSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EphemeralRunnerSetSpec defines the desired state of EphemeralRunnerSet
   *
   * @schema EphemeralRunnerSet#spec
   */
  readonly spec?: EphemeralRunnerSetSpec;
}

/**
 * Converts an object of type 'EphemeralRunnerSetProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetProps(
  obj: EphemeralRunnerSetProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_EphemeralRunnerSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EphemeralRunnerSetSpec defines the desired state of EphemeralRunnerSet
 *
 * @schema EphemeralRunnerSetSpec
 */
export interface EphemeralRunnerSetSpec {
  /**
   * EphemeralRunnerSpec is the spec of the ephemeral runner
   *
   * @schema EphemeralRunnerSetSpec#ephemeralRunnerSpec
   */
  readonly ephemeralRunnerSpec?: EphemeralRunnerSetSpecEphemeralRunnerSpec;

  /**
   * PatchID is the unique identifier for the patch issued by the listener app
   *
   * @schema EphemeralRunnerSetSpec#patchID
   */
  readonly patchId: number;

  /**
   * Replicas is the number of desired EphemeralRunner resources in the k8s namespace.
   *
   * @schema EphemeralRunnerSetSpec#replicas
   */
  readonly replicas?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpec(
  obj: EphemeralRunnerSetSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    ephemeralRunnerSpec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpec(obj.ephemeralRunnerSpec),
    patchID: obj.patchId,
    replicas: obj.replicas,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EphemeralRunnerSpec is the spec of the ephemeral runner
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpec {
  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpec#githubConfigSecret
   */
  readonly githubConfigSecret: string;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpec#githubConfigUrl
   */
  readonly githubConfigUrl: string;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpec#githubServerTLS
   */
  readonly githubServerTls?: EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTls;

  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpec#metadata
   */
  readonly metadata?: EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpec#proxy
   */
  readonly proxy?: EphemeralRunnerSetSpecEphemeralRunnerSpecProxy;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpec#proxySecretRef
   */
  readonly proxySecretRef?: string;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpec#runnerScaleSetId
   */
  readonly runnerScaleSetId: number;

  /**
   * Specification of the desired behavior of the pod.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpec#spec
   */
  readonly spec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpec;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpec#vaultConfig
   */
  readonly vaultConfig?: EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfig;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    githubConfigSecret: obj.githubConfigSecret,
    githubConfigUrl: obj.githubConfigUrl,
    githubServerTLS: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTls(obj.githubServerTls),
    metadata: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata(obj.metadata),
    proxy: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecProxy(obj.proxy),
    proxySecretRef: obj.proxySecretRef,
    runnerScaleSetId: obj.runnerScaleSetId,
    spec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpec(obj.spec),
    vaultConfig: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfig(obj.vaultConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTls
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTls {
  /**
   * Required
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTls#certificateFrom
   */
  readonly certificateFrom?: EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFrom;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTls(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certificateFrom: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFrom(
      obj.certificateFrom,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Standard object's metadata.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata {
  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata#name
   */
  readonly name?: string;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    finalizers: obj.finalizers?.map((y) => y),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecProxy
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecProxy {
  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecProxy#http
   */
  readonly http?: EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttp;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecProxy#https
   */
  readonly https?: EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttps;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecProxy#noProxy
   */
  readonly noProxy?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecProxy(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecProxy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttp(obj.http),
    https: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttps(obj.https),
    noProxy: obj.noProxy?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specification of the desired behavior of the pod.
 * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpec {
  /**
   * Optional duration in seconds the pod may be active on the node relative to
   * StartTime before the system will actively try to mark it failed and kill associated containers.
   * Value must be a positive integer.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#activeDeadlineSeconds
   */
  readonly activeDeadlineSeconds?: number;

  /**
   * If specified, the pod's scheduling constraints
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#affinity
   */
  readonly affinity?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinity;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * List of containers belonging to the pod.
   * Containers cannot currently be added or removed.
   * There must be at least one container in a Pod.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#containers
   */
  readonly containers: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers[];

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#dnsConfig
   */
  readonly dnsConfig?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfig;

  /**
   * Set DNS policy for the pod.
   * Defaults to "ClusterFirst".
   * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
   * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
   * To have DNS options set along with hostNetwork, you have to specify DNS policy
   * explicitly to 'ClusterFirstWithHostNet'.
   *
   * @default ClusterFirst".
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's
   * environment variables, matching the syntax of Docker links.
   * Optional: Defaults to true.
   *
   * @default true.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
   * pod to perform user-initiated actions such as debugging. This list cannot be specified when
   * creating a pod, and it cannot be modified by updating the pod spec. In order to add an
   * ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#ephemeralContainers
   */
  readonly ephemeralContainers?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers[];

  /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
   * file if specified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#hostAliases
   */
  readonly hostAliases?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecHostAliases[];

  /**
   * Use the host's ipc namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#hostIPC
   */
  readonly hostIpc?: boolean;

  /**
   * Host networking requested for this pod. Use the host's network namespace.
   * If this option is set, the ports that will be used must be specified.
   * Default to false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Use the host's pid namespace.
   * Optional: Default to false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#hostPID
   */
  readonly hostPid?: boolean;

  /**
   * Use the host's user namespace.
   * Optional: Default to true.
   * If set to true or not present, the pod will be run in the host user namespace, useful
   * for when the pod needs a feature only available to the host user namespace, such as
   * loading a kernel module with CAP_SYS_MODULE.
   * When set to false, a new userns is created for the pod. Setting false is useful for
   * mitigating container breakout vulnerabilities even allowing users to run their
   * containers as root without actually having root privileges on the host.
   * This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
   *
   * @default true.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#hostUsers
   */
  readonly hostUsers?: boolean;

  /**
   * Specifies the hostname of the Pod
   * If not specified, the pod's hostname will be set to a system-defined value.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#hostname
   */
  readonly hostname?: string;

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
   * If specified, these secrets will be passed to individual puller implementations for them to use.
   * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecImagePullSecrets[];

  /**
   * List of initialization containers belonging to the pod.
   * Init containers are executed in order prior to containers being started. If any
   * init container fails, the pod is considered to have failed and is handled according
   * to its restartPolicy. The name for an init container or normal container must be
   * unique among all containers.
   * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
   * The resourceRequirements of an init container are taken into account during scheduling
   * by finding the highest request/limit for each resource type, and then using the max of
   * of that value or the sum of the normal containers. Limits are applied to init containers
   * in a similar fashion.
   * Init containers cannot currently be added or removed.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#initContainers
   */
  readonly initContainers?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers[];

  /**
   * NodeName indicates in which node this pod is scheduled.
   * If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName.
   * Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod.
   * This field should not be used to express a desire for the pod to be scheduled on a specific node.
   * https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#nodeName
   */
  readonly nodeName?: string;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specifies the OS of the containers in the pod.
   * Some pod and container fields are restricted if this is set.
   *
   * If the OS field is set to linux, the following fields must be unset:
   * -securityContext.windowsOptions
   *
   * If the OS field is set to windows, following fields must be unset:
   * - spec.hostPID
   * - spec.hostIPC
   * - spec.hostUsers
   * - spec.securityContext.appArmorProfile
   * - spec.securityContext.seLinuxOptions
   * - spec.securityContext.seccompProfile
   * - spec.securityContext.fsGroup
   * - spec.securityContext.fsGroupChangePolicy
   * - spec.securityContext.sysctls
   * - spec.shareProcessNamespace
   * - spec.securityContext.runAsUser
   * - spec.securityContext.runAsGroup
   * - spec.securityContext.supplementalGroups
   * - spec.securityContext.supplementalGroupsPolicy
   * - spec.containers[*].securityContext.appArmorProfile
   * - spec.containers[*].securityContext.seLinuxOptions
   * - spec.containers[*].securityContext.seccompProfile
   * - spec.containers[*].securityContext.capabilities
   * - spec.containers[*].securityContext.readOnlyRootFilesystem
   * - spec.containers[*].securityContext.privileged
   * - spec.containers[*].securityContext.allowPrivilegeEscalation
   * - spec.containers[*].securityContext.procMount
   * - spec.containers[*].securityContext.runAsUser
   * - spec.containers[*].securityContext.runAsGroup
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#os
   */
  readonly os?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOs;

  /**
   * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
   * This field will be autopopulated at admission time by the RuntimeClass admission controller. If
   * the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
   * The RuntimeClass admission controller will reject Pod create requests which have the overhead already
   * set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
   * defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#overhead
   */
  readonly overhead?: {
    [key: string]: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOverhead;
  };

  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority.
   * One of Never, PreemptLowerPriority.
   * Defaults to PreemptLowerPriority if unset.
   *
   * @default PreemptLowerPriority if unset.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#preemptionPolicy
   */
  readonly preemptionPolicy?: string;

  /**
   * The priority value. Various system components use this field to find the
   * priority of the pod. When Priority Admission Controller is enabled, it
   * prevents users from setting this field. The admission controller populates
   * this field from PriorityClassName.
   * The higher the value, the higher the priority.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#priority
   */
  readonly priority?: number;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and
   * "system-cluster-critical" are two special keywords which indicate the
   * highest priorities with the former being the highest priority. Any other
   * name must be defined by creating a PriorityClass object with that name.
   * If not specified, the pod priority will be default or zero if there is no
   * default.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * If specified, all readiness gates will be evaluated for pod readiness.
   * A pod is ready when all its containers are ready AND
   * all conditions specified in the readiness gates have status equal to "True"
   * More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#readinessGates
   */
  readonly readinessGates?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecReadinessGates[];

  /**
   * ResourceClaims defines which ResourceClaims must be allocated
   * and reserved before the Pod is allowed to start. The resources
   * will be made available to those containers which consume them
   * by name.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#resourceClaims
   */
  readonly resourceClaims?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourceClaims[];

  /**
   * Resources is the total amount of CPU and Memory resources required by all
   * containers in the pod. It supports specifying Requests and Limits for
   * "cpu" and "memory" resource names only. ResourceClaims are not supported.
   *
   * This field enables fine-grained control over resource allocation for the
   * entire pod, allowing resource sharing among containers in a pod.
   *
   * This is an alpha field and requires enabling the PodLevelResources feature
   * gate.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#resources
   */
  readonly resources?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResources;

  /**
   * Restart policy for all containers within the pod.
   * One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
   * Default to Always.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   *
   * @default Always.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
   * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
   * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
   * empty definition that uses the default runtime handler.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#runtimeClassName
   */
  readonly runtimeClassName?: string;

  /**
   * If specified, the pod will be dispatched by specified scheduler.
   * If not specified, the pod will be dispatched by default scheduler.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * SchedulingGates is an opaque list of values that if specified will block scheduling the pod.
   * If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the
   * scheduler will not attempt to schedule the pod.
   *
   * SchedulingGates can only be set at pod creation time, and be removed only afterwards.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#schedulingGates
   */
  readonly schedulingGates?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSchedulingGates[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * Optional: Defaults to empty.  See type description for default values of each field.
   *
   * @default empty.  See type description for default values of each field.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#securityContext
   */
  readonly securityContext?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext;

  /**
   * DeprecatedServiceAccount is a deprecated alias for ServiceAccountName.
   * Deprecated: Use serviceAccountName instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
   * In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
   * In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
   * If a pod does not have FQDN, this has no effect.
   * Default to false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#setHostnameAsFQDN
   */
  readonly setHostnameAsFqdn?: boolean;

  /**
   * Share a single process namespace between all of the containers in a pod.
   * When this is set containers will be able to view and signal processes from other containers
   * in the same pod, and the first process in each container will not be assigned PID 1.
   * HostPID and ShareProcessNamespace cannot both be set.
   * Optional: Default to false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#shareProcessNamespace
   */
  readonly shareProcessNamespace?: boolean;

  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
   * If not specified, the pod will not have a domainname at all.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#subdomain
   */
  readonly subdomain?: string;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * If this value is nil, the default grace period will be used instead.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#tolerations
   */
  readonly tolerations?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations[];

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology
   * domains. Scheduler will schedule pods in a way which abides by the constraints.
   * All topologySpreadConstraints are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints[];

  /**
   * List of volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpec#volumes
   */
  readonly volumes?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    activeDeadlineSeconds: obj.activeDeadlineSeconds,
    affinity: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinity(obj.affinity),
    automountServiceAccountToken: obj.automountServiceAccountToken,
    containers: obj.containers?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers(y)),
    dnsConfig: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfig(obj.dnsConfig),
    dnsPolicy: obj.dnsPolicy,
    enableServiceLinks: obj.enableServiceLinks,
    ephemeralContainers: obj.ephemeralContainers?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers(y),
    ),
    hostAliases: obj.hostAliases?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecHostAliases(y)),
    hostIPC: obj.hostIpc,
    hostNetwork: obj.hostNetwork,
    hostPID: obj.hostPid,
    hostUsers: obj.hostUsers,
    hostname: obj.hostname,
    imagePullSecrets: obj.imagePullSecrets?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecImagePullSecrets(y),
    ),
    initContainers: obj.initContainers?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers(y),
    ),
    nodeName: obj.nodeName,
    nodeSelector:
      obj.nodeSelector === undefined
        ? undefined
        : Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    os: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOs(obj.os),
    overhead:
      obj.overhead === undefined
        ? undefined
        : Object.entries(obj.overhead).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    preemptionPolicy: obj.preemptionPolicy,
    priority: obj.priority,
    priorityClassName: obj.priorityClassName,
    readinessGates: obj.readinessGates?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecReadinessGates(y),
    ),
    resourceClaims: obj.resourceClaims?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourceClaims(y),
    ),
    resources: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    runtimeClassName: obj.runtimeClassName,
    schedulerName: obj.schedulerName,
    schedulingGates: obj.schedulingGates?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSchedulingGates(y),
    ),
    securityContext: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext(obj.securityContext),
    serviceAccount: obj.serviceAccount,
    serviceAccountName: obj.serviceAccountName,
    setHostnameAsFQDN: obj.setHostnameAsFqdn,
    shareProcessNamespace: obj.shareProcessNamespace,
    subdomain: obj.subdomain,
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    tolerations: obj.tolerations?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations(y)),
    topologySpreadConstraints: obj.topologySpreadConstraints?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints(y),
    ),
    volumes: obj.volumes?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfig
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfig {
  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfig#azureKeyVault
   */
  readonly azureKeyVault?: EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigAzureKeyVault;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfig#proxy
   */
  readonly proxy?: EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxy;

  /**
   * VaultType represents the type of vault that can be used in the application.
   * It is used to identify which vault integration should be used to resolve secrets.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfig#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfig(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    azureKeyVault: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigAzureKeyVault(obj.azureKeyVault),
    proxy: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxy(obj.proxy),
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFrom
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFrom {
  /**
   * Required
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFrom(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttp
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttp {
  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttp#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttp#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttp(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttp | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttps
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttps {
  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttps#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttps#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttps(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecProxyHttps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If specified, the pod's scheduling constraints
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinity
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinity#podAffinity
   */
  readonly podAffinity?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinity(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeAffinity: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinity(obj.nodeAffinity),
    podAffinity: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinity(obj.podAffinity),
    podAntiAffinity: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#env
   */
  readonly env?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#envFrom
   */
  readonly envFrom?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#lifecycle
   */
  readonly lifecycle?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#livenessProbe
   */
  readonly livenessProbe?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#ports
   */
  readonly ports?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#readinessProbe
   */
  readonly readinessProbe?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#resizePolicy
   */
  readonly resizePolicy?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#resources
   */
  readonly resources?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#securityContext
   */
  readonly securityContext?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#startupProbe
   */
  readonly startupProbe?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#volumeDevices
   */
  readonly volumeDevices?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#volumeMounts
   */
  readonly volumeMounts?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts(y)),
    readinessProbe: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe(obj.readinessProbe),
    resizePolicy: obj.resizePolicy?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResizePolicy(y),
    ),
    resources: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext(obj.securityContext),
    startupProbe: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeDevices(y),
    ),
    volumeMounts: obj.volumeMounts?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts(y),
    ),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the DNS parameters of a pod.
 * Parameters specified here will be merged to the generated DNS
 * configuration based on DNSPolicy.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfig
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfig {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfig#options
   */
  readonly options?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfig#searches
   */
  readonly searches?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfig(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nameservers: obj.nameservers?.map((y) => y),
    options: obj.options?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfigOptions(y)),
    searches: obj.searches?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for
 * user-initiated activities such as debugging. Ephemeral containers have no resource or
 * scheduling guarantees, and they will not be restarted when they exit or when a Pod is
 * removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the
 * Pod to exceed its resource allocation.
 *
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing
 * Pod. Ephemeral containers may not be removed or restarted.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers {
  /**
   * Arguments to the entrypoint.
   * The image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#env
   */
  readonly env?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#envFrom
   */
  readonly envFrom?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#lifecycle
   */
  readonly lifecycle?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecycle;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#livenessProbe
   */
  readonly livenessProbe?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe;

  /**
   * Name of the ephemeral container specified as a DNS_LABEL.
   * This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#name
   */
  readonly name: string;

  /**
   * Ports are not allowed for ephemeral containers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#ports
   */
  readonly ports?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts[];

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#readinessProbe
   */
  readonly readinessProbe?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#resizePolicy
   */
  readonly resizePolicy?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResizePolicy[];

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
   * already allocated to the pod.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#resources
   */
  readonly resources?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResources;

  /**
   * Restart policy for the container to manage the restart behavior of each
   * container within a pod.
   * This may only be set for init containers. You cannot set this field on
   * ephemeral containers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#securityContext
   */
  readonly securityContext?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext;

  /**
   * Probes are not allowed for ephemeral containers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#startupProbe
   */
  readonly startupProbe?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets.
   * The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
   * If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   *
   * The container runtime must implement support for this feature. If the runtime does not
   * support namespace targeting then the result of setting this field is undefined.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#targetContainerName
   */
  readonly targetContainerName?: string;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#volumeDevices
   */
  readonly volumeDevices?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#volumeMounts
   */
  readonly volumeMounts?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe(
      obj.livenessProbe,
    ),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts(y)),
    readinessProbe: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe(
      obj.readinessProbe,
    ),
    resizePolicy: obj.resizePolicy?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResizePolicy(y),
    ),
    resources: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext(
      obj.securityContext,
    ),
    startupProbe: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    targetContainerName: obj.targetContainerName,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeDevices(y),
    ),
    volumeMounts: obj.volumeMounts?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts(y),
    ),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecHostAliases
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecHostAliases#ip
   */
  readonly ip: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecHostAliases(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecHostAliases | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    hostnames: obj.hostnames?.map((y) => y),
    ip: obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecImagePullSecrets
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecImagePullSecrets {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecImagePullSecrets(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecImagePullSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers {
  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#env
   */
  readonly env?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#envFrom
   */
  readonly envFrom?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFrom[];

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#lifecycle
   */
  readonly lifecycle?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Modifying this array with strategic merge patch may corrupt the data.
   * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#ports
   */
  readonly ports?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#resources
   */
  readonly resources?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod.
   * This field may only be set for init containers, and the only allowed value is "Always".
   * For non-init containers or when this field is not specified,
   * the restart behavior is defined by the Pod's restart policy and the container type.
   * Setting the RestartPolicy as "Always" for the init container will have the following effect:
   * this init container will be continually restarted on
   * exit until all regular containers have terminated. Once all regular
   * containers have completed, all init containers with restartPolicy "Always"
   * will be shut down. This lifecycle differs from normal init containers and
   * is often referred to as a "sidecar" container. Although this init
   * container still starts in the init container sequence, it does not wait
   * for the container to complete before proceeding to the next init
   * container. Instead, the next init container starts immediately after this
   * init container is started, or after any startupProbe has successfully
   * completed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#securityContext
   */
  readonly securityContext?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#startupProbe
   */
  readonly startupProbe?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   *
   * @default false
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   *
   * @default dev/termination-log.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   *
   * @default File.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    args: obj.args?.map((y) => y),
    command: obj.command?.map((y) => y),
    env: obj.env?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnv(y)),
    envFrom: obj.envFrom?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFrom(y)),
    image: obj.image,
    imagePullPolicy: obj.imagePullPolicy,
    lifecycle: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecycle(obj.lifecycle),
    livenessProbe: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe(obj.livenessProbe),
    name: obj.name,
    ports: obj.ports?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts(y)),
    readinessProbe: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe(
      obj.readinessProbe,
    ),
    resizePolicy: obj.resizePolicy?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResizePolicy(y),
    ),
    resources: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResources(obj.resources),
    restartPolicy: obj.restartPolicy,
    securityContext: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext(
      obj.securityContext,
    ),
    startupProbe: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe(obj.startupProbe),
    stdin: obj.stdin,
    stdinOnce: obj.stdinOnce,
    terminationMessagePath: obj.terminationMessagePath,
    terminationMessagePolicy: obj.terminationMessagePolicy,
    tty: obj.tty,
    volumeDevices: obj.volumeDevices?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeDevices(y),
    ),
    volumeMounts: obj.volumeMounts?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts(y),
    ),
    workingDir: obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the OS of the containers in the pod.
 * Some pod and container fields are restricted if this is set.
 *
 * If the OS field is set to linux, the following fields must be unset:
 * -securityContext.windowsOptions
 *
 * If the OS field is set to windows, following fields must be unset:
 * - spec.hostPID
 * - spec.hostIPC
 * - spec.hostUsers
 * - spec.securityContext.appArmorProfile
 * - spec.securityContext.seLinuxOptions
 * - spec.securityContext.seccompProfile
 * - spec.securityContext.fsGroup
 * - spec.securityContext.fsGroupChangePolicy
 * - spec.securityContext.sysctls
 * - spec.shareProcessNamespace
 * - spec.securityContext.runAsUser
 * - spec.securityContext.runAsGroup
 * - spec.securityContext.supplementalGroups
 * - spec.securityContext.supplementalGroupsPolicy
 * - spec.containers[*].securityContext.appArmorProfile
 * - spec.containers[*].securityContext.seLinuxOptions
 * - spec.containers[*].securityContext.seccompProfile
 * - spec.containers[*].securityContext.capabilities
 * - spec.containers[*].securityContext.readOnlyRootFilesystem
 * - spec.containers[*].securityContext.privileged
 * - spec.containers[*].securityContext.allowPrivilegeEscalation
 * - spec.containers[*].securityContext.procMount
 * - spec.containers[*].securityContext.runAsUser
 * - spec.containers[*].securityContext.runAsGroup
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOs
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOs {
  /**
   * Name is the name of the operating system. The currently supported values are linux and windows.
   * Additional value may be defined in future and can be one of:
   * https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
   * Clients should expect to handle additional values and treat unrecognized values in this field as os: null
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOs#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOs(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOverhead
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOverhead {
  public static fromNumber(value: number): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOverhead {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOverhead(value);
  }
  public static fromString(value: string): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOverhead {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecOverhead(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecReadinessGates
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecReadinessGates {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecReadinessGates#conditionType
   */
  readonly conditionType: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecReadinessGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecReadinessGates(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecReadinessGates | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    conditionType: obj.conditionType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodResourceClaim references exactly one ResourceClaim, either directly
 * or by naming a ResourceClaimTemplate which is then turned into a ResourceClaim
 * for the pod.
 *
 * It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
 * Containers that need access to the ResourceClaim reference it with this name.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourceClaims
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourceClaims {
  /**
   * Name uniquely identifies this resource claim inside the pod.
   * This must be a DNS_LABEL.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourceClaims#name
   */
  readonly name: string;

  /**
   * ResourceClaimName is the name of a ResourceClaim object in the same
   * namespace as this pod.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourceClaims#resourceClaimName
   */
  readonly resourceClaimName?: string;

  /**
   * ResourceClaimTemplateName is the name of a ResourceClaimTemplate
   * object in the same namespace as this pod.
   *
   * The template will be used to create a new ResourceClaim, which will
   * be bound to this pod. When this pod is deleted, the ResourceClaim
   * will also be deleted. The pod name and resource name, along with a
   * generated component, will be used to form a unique name for the
   * ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.
   *
   * This field is immutable and no changes will be made to the
   * corresponding ResourceClaim by the control plane after creating the
   * ResourceClaim.
   *
   * Exactly one of ResourceClaimName and ResourceClaimTemplateName must
   * be set.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourceClaims#resourceClaimTemplateName
   */
  readonly resourceClaimTemplateName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourceClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourceClaims(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourceClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    resourceClaimName: obj.resourceClaimName,
    resourceClaimTemplateName: obj.resourceClaimTemplateName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources is the total amount of CPU and Memory resources required by all
 * containers in the pod. It supports specifying Requests and Limits for
 * "cpu" and "memory" resource names only. ResourceClaims are not supported.
 *
 * This field enables fine-grained control over resource allocation for the
 * entire pod, allowing resource sharing among containers in a pod.
 *
 * This is an alpha field and requires enabling the PodLevelResources feature
 * gate.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResources
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResources#claims
   */
  readonly claims?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResources#limits
   */
  readonly limits?: {
    [key: string]: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResources#requests
   */
  readonly requests?: {
    [key: string]: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResources(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodSchedulingGate is associated to a Pod to guard its scheduling.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSchedulingGates
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSchedulingGates {
  /**
   * Name of the scheduling gate.
   * Each scheduling gate must have a unique name field.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSchedulingGates#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSchedulingGates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSchedulingGates(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSchedulingGates | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings.
 * Optional: Defaults to empty.  See type description for default values of each field.
 *
 * @default empty.  See type description for default values of each field.
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext {
  /**
   * appArmorProfile is the AppArmor options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextAppArmorProfile;

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
   * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
   * Valid values are "MountOption" and "Recursive".
   *
   * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
   * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
   *
   * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
   * This requires all Pods that share the same volume to use the same SELinux label.
   * It is not possible to share the same volume among privileged and unprivileged Pods.
   * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
   * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
   * CSIDriver instance. Other volumes are always re-labelled recursively.
   * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
   *
   * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
   * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
   * and "Recursive" for all other volumes.
   *
   * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
   *
   * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#seLinuxChangePolicy
   */
  readonly seLinuxChangePolicy?: string;

  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in
   * addition to the container's primary GID and fsGroup (if specified).  If
   * the SupplementalGroupsPolicy feature is enabled, the
   * supplementalGroupsPolicy field determines whether these are in addition
   * to or instead of any group memberships defined in the container image.
   * If unspecified, no additional groups are added, though group memberships
   * defined in the container image may still be used, depending on the
   * supplementalGroupsPolicy field.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Defines how supplemental groups of the first container processes are calculated.
   * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
   * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
   * and the container runtime must implement support for this feature.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#supplementalGroupsPolicy
   */
  readonly supplementalGroupsPolicy?: string;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#sysctls
   */
  readonly sysctls?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    appArmorProfile: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    fsGroup: obj.fsGroup,
    fsGroupChangePolicy: obj.fsGroupChangePolicy,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxChangePolicy: obj.seLinuxChangePolicy,
    seLinuxOptions: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    supplementalGroups: obj.supplementalGroups?.map((y) => y),
    supplementalGroupsPolicy: obj.supplementalGroupsPolicy,
    sysctls: obj.sysctls?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSysctls(y)),
    windowsOptions: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which
   * spreading will be calculated. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are ANDed with labelSelector
   * to select the group of existing pods over which spreading will be calculated
   * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
   * MatchLabelKeys cannot be set when LabelSelector isn't set.
   * Keys that don't exist in the incoming pod labels will
   * be ignored. A null or empty list means only match against labelSelector.
   *
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * The global minimum is the minimum number of matching pods in an eligible domain
   * or zero if the number of eligible domains is less than MinDomains.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 2/2/1:
   * In this case, the global minimum is 1.
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |   P   |
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
   * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains.
   * When the number of eligible domains with matching topology keys is less than minDomains,
   * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
   * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
   * this value has no effect on scheduling.
   * As a result, when the number of eligible domains is less than minDomains,
   * scheduler won't schedule more than maxSkew Pods to those domains.
   * If value is nil, the constraint behaves as if MinDomains is equal to 1.
   * Valid values are integers greater than 0.
   * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   *
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
   * labelSelector spread as 2/2/2:
   * | zone1 | zone2 | zone3 |
   * |  P P  |  P P  |  P P  |
   * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
   * In this situation, new pod with the same labelSelector cannot be scheduled,
   * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
   * it will violate MaxSkew.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
   * when calculating pod topology spread skew. Options are:
   * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
   * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   *
   * If this value is nil, the behavior is equivalent to the Honor policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating
   * pod topology spread skew. Options are:
   * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
   * has a toleration, are included.
   * - Ignore: node taints are ignored. All nodes are included.
   *
   * If this value is nil, the behavior is equivalent to the Ignore policy.
   * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * We define a domain as a particular instance of a topology.
   * Also, we define an eligible domain as a domain whose nodes meet the requirements of
   * nodeAffinityPolicy and nodeTaintsPolicy.
   * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
   * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
   * It's a required field.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   * but giving higher precedence to topologies that would help reduce the
   * skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * | zone1 | zone2 | zone3 |
   * | P P P |   P   |   P   |
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector(
      obj.labelSelector,
    ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    maxSkew: obj.maxSkew,
    minDomains: obj.minDomains,
    nodeAffinityPolicy: obj.nodeAffinityPolicy,
    nodeTaintsPolicy: obj.nodeTaintsPolicy,
    topologyKey: obj.topologyKey,
    whenUnsatisfiable: obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
   * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
   * are redirected to the disk.csi.azure.com CSI driver.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#azureDisk
   */
  readonly azureDisk?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
   * are redirected to the file.csi.azure.com CSI driver.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#azureFile
   */
  readonly azureFile?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
   * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#cephfs
   */
  readonly cephfs?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
   * are redirected to the cinder.csi.openstack.org CSI driver.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#cinder
   */
  readonly cinder?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#configMap
   */
  readonly configMap?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#csi
   */
  readonly csi?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#downwardAPI
   */
  readonly downwardApi?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#emptyDir
   */
  readonly emptyDir?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   * tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   * a PersistentVolumeClaim (see EphemeralVolumeSource for more
   * information on the connection between this volume type
   * and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#ephemeral
   */
  readonly ephemeral?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#fc
   */
  readonly fc?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#flexVolume
   */
  readonly flexVolume?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
   * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#flocker
   */
  readonly flocker?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
   * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision.
   * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#gitRepo
   */
  readonly gitRepo?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#glusterfs
   */
  readonly glusterfs?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#hostPath
   */
  readonly hostPath?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesHostPath;

  /**
   * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
   * The volume is resolved at pod startup depending on which PullPolicy value is provided:
   *
   * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   *
   * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
   * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
   * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
   * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
   * The volume will be mounted read-only (ro) and non-executable files (noexec).
   * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
   * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#image
   */
  readonly image?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesImage;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#iscsi
   */
  readonly iscsi?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi;

  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#nfs
   */
  readonly nfs?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
   * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
   * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
   * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
   * is on.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#projected
   */
  readonly projected?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
   * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#quobyte
   */
  readonly quobyte?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#rbd
   */
  readonly rbd?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#scaleIO
   */
  readonly scaleIo?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#secret
   */
  readonly secret?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#storageos
   */
  readonly storageos?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
   * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
   * are redirected to the csi.vsphere.vmware.com CSI driver.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesVsphereVolume;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    awsElasticBlockStore: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAwsElasticBlockStore(
      obj.awsElasticBlockStore,
    ),
    azureDisk: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk(obj.azureDisk),
    azureFile: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureFile(obj.azureFile),
    cephfs: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs(obj.cephfs),
    cinder: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinder(obj.cinder),
    configMap: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMap(obj.configMap),
    csi: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi(obj.csi),
    downwardAPI: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApi(obj.downwardApi),
    emptyDir: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDir(obj.emptyDir),
    ephemeral: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeral(obj.ephemeral),
    fc: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc(obj.fc),
    flexVolume: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume(obj.flexVolume),
    flocker: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlocker(obj.flocker),
    gcePersistentDisk: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGcePersistentDisk(
      obj.gcePersistentDisk,
    ),
    gitRepo: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGitRepo(obj.gitRepo),
    glusterfs: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGlusterfs(obj.glusterfs),
    hostPath: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesHostPath(obj.hostPath),
    image: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesImage(obj.image),
    iscsi: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi(obj.iscsi),
    name: obj.name,
    nfs: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesNfs(obj.nfs),
    persistentVolumeClaim: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPersistentVolumeClaim(
      obj.persistentVolumeClaim,
    ),
    photonPersistentDisk: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPhotonPersistentDisk(
      obj.photonPersistentDisk,
    ),
    portworxVolume: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPortworxVolume(obj.portworxVolume),
    projected: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjected(obj.projected),
    quobyte: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte(obj.quobyte),
    rbd: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd(obj.rbd),
    scaleIO: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo(obj.scaleIo),
    secret: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecret(obj.secret),
    storageos: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos(obj.storageos),
    vsphereVolume: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigAzureKeyVault
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigAzureKeyVault {
  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigAzureKeyVault#certificatePath
   */
  readonly certificatePath: string;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigAzureKeyVault#clientId
   */
  readonly clientId: string;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigAzureKeyVault#tenantId
   */
  readonly tenantId: string;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigAzureKeyVault#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigAzureKeyVault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigAzureKeyVault(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigAzureKeyVault | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    certificatePath: obj.certificatePath,
    clientId: obj.clientId,
    tenantId: obj.tenantId,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxy
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxy {
  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxy#http
   */
  readonly http?: EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttp;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxy#https
   */
  readonly https?: EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttps;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxy#noProxy
   */
  readonly noProxy?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxy(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    http: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttp(obj.http),
    https: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttps(obj.https),
    noProxy: obj.noProxy?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecGithubServerTlsCertificateFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinity
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinity(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
    requiredDuringSchedulingIgnoredDuringExecution:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinity
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinity(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
    requiredDuringSchedulingIgnoredDuringExecution: obj.requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinity
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinity(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preferredDuringSchedulingIgnoredDuringExecution: obj.preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
    requiredDuringSchedulingIgnoredDuringExecution: obj.requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnv
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFrom;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnv(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFrom
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFrom(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromConfigMapRef(obj.configMapRef),
    prefix: obj.prefix,
    secretRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecycle
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecycle#postStart
   */
  readonly postStart?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecycle#preStop
   */
  readonly preStop?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecycle(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResizePolicy
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResizePolicy(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResources
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResources#claims
   */
  readonly claims?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResources#limits
   */
  readonly limits?: {
    [key: string]: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResources#requests
   */
  readonly requests?: {
    [key: string]: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResources(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesClaims(y)),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    capabilities: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextCapabilities(
      obj.capabilities,
    ),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    windowsOptions: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeDevices
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeDevices(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfigOptions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfigOptions {
  /**
   * Name is this DNS resolver option's name.
   * Required.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * Value is this DNS resolver option's value.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfigOptions#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfigOptions(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecDnsConfigOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnv
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnv#valueFrom
   */
  readonly valueFrom?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnv(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFrom
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFrom#secretRef
   */
  readonly secretRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFrom(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    prefix: obj.prefix,
    secretRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Lifecycle is not allowed for ephemeral containers.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecycle
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecycle#postStart
   */
  readonly postStart?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecycle#preStop
   */
  readonly preStop?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecycle(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket(
      obj.tcpSocket,
    ),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket(
      obj.tcpSocket,
    ),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResizePolicy
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResizePolicy(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
 * already allocated to the pod.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResources
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResources#claims
   */
  readonly claims?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResources#limits
   */
  readonly limits?: {
    [key: string]: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResources#requests
   */
  readonly requests?: {
    [key: string]: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResources(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesClaims(y),
    ),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#capabilities
   */
  readonly capabilities?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile(
        obj.appArmorProfile,
      ),
    capabilities: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities(
      obj.capabilities,
    ),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    seccompProfile:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    windowsOptions:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Probes are not allowed for ephemeral containers.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket(
      obj.tcpSocket,
    ),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeDevices
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeDevices(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnv
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   *
   * @default .
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFrom;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnv(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
    valueFrom: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFrom
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFrom(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    prefix: obj.prefix,
    secretRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events.
 * Cannot be updated.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecycle
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecycle(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    postStart: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStart(obj.postStart),
    preStop: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container liveness.
 * Container will be restarted if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   *
   * @default TCP".
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerPort: obj.containerPort,
    hostIP: obj.hostIp,
    hostPort: obj.hostPort,
    name: obj.name,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Periodic probe of container service readiness.
 * Container will be removed from service endpoints if the probe fails.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResizePolicy
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies.
   * Supported values: cpu, memory.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized.
   * If not specified, it defaults to NotRequired.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResizePolicy(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resourceName: obj.resourceName,
    restartPolicy: obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Compute Resources required by this container.
 * Cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResources
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims,
   * that are used by this container.
   *
   * This is an alpha field and requires enabling the
   * DynamicResourceAllocation feature gate.
   *
   * This field is immutable. It can only be set for containers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResources#claims
   */
  readonly claims?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResources#limits
   */
  readonly limits?: {
    [key: string]: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResources#requests
   */
  readonly requests?: {
    [key: string]: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResources(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claims: obj.claims?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesClaims(y),
    ),
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecurityContext defines the security options the container should be run with.
 * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * appArmorProfile is the AppArmor options to use by this container. If set, this profile
   * overrides the pod's appArmorProfile.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#appArmorProfile
   */
  readonly appArmorProfile?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile;

  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default value is Default which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    allowPrivilegeEscalation: obj.allowPrivilegeEscalation,
    appArmorProfile: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile(
      obj.appArmorProfile,
    ),
    capabilities: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities(
      obj.capabilities,
    ),
    privileged: obj.privileged,
    procMount: obj.procMount,
    readOnlyRootFilesystem: obj.readOnlyRootFilesystem,
    runAsGroup: obj.runAsGroup,
    runAsNonRoot: obj.runAsNonRoot,
    runAsUser: obj.runAsUser,
    seLinuxOptions: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    seccompProfile: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    windowsOptions: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized.
 * If specified, no other probes are executed until this completes successfully.
 * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
 * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
 * when it might take a long time to load data or warm a cache, than during steady-state operation.
 * This cannot be updated.
 * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies a GRPC HealthCheckRequest.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies a connection to a TCP port.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeExec(obj.exec),
    failureThreshold: obj.failureThreshold,
    grpc: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeGrpc(obj.grpc),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet(obj.httpGet),
    initialDelaySeconds: obj.initialDelaySeconds,
    periodSeconds: obj.periodSeconds,
    successThreshold: obj.successThreshold,
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket(obj.tcpSocket),
    terminationGracePeriodSeconds: obj.terminationGracePeriodSeconds,
    timeoutSeconds: obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeDevices
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeDevices(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    devicePath: obj.devicePath,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
   * (which defaults to None).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * RecursiveReadOnly specifies whether read-only mounts should be handled
   * recursively.
   *
   * If ReadOnly is false, this field has no meaning and must be unspecified.
   *
   * If ReadOnly is true, and this field is set to Disabled, the mount is not made
   * recursively read-only.  If this field is set to IfPossible, the mount is made
   * recursively read-only, if it is supported by the container runtime.  If this
   * field is set to Enabled, the mount is made recursively read-only if it is
   * supported by the container runtime, otherwise the pod will not be started and
   * an error will be generated to indicate the reason.
   *
   * If this field is set to IfPossible or Enabled, MountPropagation must be set to
   * None (or be unspecified, which defaults to None).
   *
   * If this field is not specified, it is treated as an equivalent of Disabled.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts#recursiveReadOnly
   */
  readonly recursiveReadOnly?: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root).
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    mountPath: obj.mountPath,
    mountPropagation: obj.mountPropagation,
    name: obj.name,
    readOnly: obj.readOnly,
    recursiveReadOnly: obj.recursiveReadOnly,
    subPath: obj.subPath,
    subPathExpr: obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesClaims
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesClaims(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesLimits
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesLimits {
  public static fromNumber(value: number): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesLimits {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesLimits(value);
  }
  public static fromString(value: string): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesLimits {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesRequests
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesRequests {
  public static fromNumber(value: number): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesRequests {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesRequests(value);
  }
  public static fromString(value: string): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesRequests {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextAppArmorProfile
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextAppArmorProfile(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to all containers.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in SecurityContext.  If set in
 * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
 * takes precedence for that container.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeLinuxOptions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeLinuxOptions(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by the containers in this pod.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeccompProfile
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeccompProfile(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSysctls
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSysctls(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options within a container's SecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextWindowsOptions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextWindowsOptions(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is used to find matching pods.
 * Pods that match this label selector are counted to determine the number of pods
 * in their corresponding topology domain.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
 * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAwsElasticBlockStore
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAwsElasticBlockStore(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAwsElasticBlockStore | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    partition: obj.partition,
    readOnly: obj.readOnly,
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
 * are redirected to the disk.csi.azure.com CSI driver.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cachingMode: obj.cachingMode,
    diskName: obj.diskName,
    diskURI: obj.diskUri,
    fsType: obj.fsType,
    kind: obj.kind,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
 * are redirected to the file.csi.azure.com CSI driver.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureFile
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureFile(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesAzureFile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    readOnly: obj.readOnly,
    secretName: obj.secretName,
    shareName: obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
 * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    monitors: obj.monitors?.map((y) => y),
    path: obj.path,
    readOnly: obj.readOnly,
    secretFile: obj.secretFile,
    secretRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfsSecretRef(obj.secretRef),
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine.
 * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
 * are redirected to the cinder.csi.openstack.org CSI driver.
 * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinder
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinder#secretRef
   */
  readonly secretRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinder(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinder | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinderSecretRef(obj.secretRef),
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMap
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMap#items
   */
  readonly items?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMap(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMapItems(y)),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    driver: obj.driver,
    fsType: obj.fsType,
    nodePublishSecretRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef(
      obj.nodePublishSecretRef,
    ),
    readOnly: obj.readOnly,
    volumeAttributes:
      obj.volumeAttributes === undefined
        ? undefined
        : Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApi
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApi#items
   */
  readonly items?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItems[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApi(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDir
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDir(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    medium: obj.medium,
    sizeLimit: obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver.
 * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
 * and deleted when the pod is removed.
 *
 * Use this if:
 * a) the volume is only needed while the pod runs,
 * b) features of normal volumes like restoring from snapshot or capacity
 * tracking are needed,
 * c) the storage driver is specified through a storage class, and
 * d) the storage driver supports dynamic volume provisioning through
 * a PersistentVolumeClaim (see EphemeralVolumeSource for more
 * information on the connection between this volume type
 * and PersistentVolumeClaim).
 *
 * Use PersistentVolumeClaim or one of the vendor-specific
 * APIs for volumes that persist for longer than the lifecycle
 * of an individual pod.
 *
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
 * be used that way - see the documentation of the driver for
 * more information.
 *
 * A pod can use both types of ephemeral volumes and
 * persistent volumes at the same time.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeral
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeral(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    volumeClaimTemplate: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate(
      obj.volumeClaimTemplate,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    lun: obj.lun,
    readOnly: obj.readOnly,
    targetWWNs: obj.targetWwNs?.map((y) => y),
    wwids: obj.wwids?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    driver: obj.driver,
    fsType: obj.fsType,
    options:
      obj.options === undefined
        ? undefined
        : Object.entries(obj.options).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
 * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlocker
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlocker(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlocker | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    datasetName: obj.datasetName,
    datasetUUID: obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
 * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGcePersistentDisk
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGcePersistentDisk(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGcePersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    partition: obj.partition,
    pdName: obj.pdName,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * gitRepo represents a git repository at a particular revision.
 * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGitRepo
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGitRepo {
  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGitRepo(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGitRepo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    directory: obj.directory,
    repository: obj.repository,
    revision: obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
 * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
 * More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGlusterfs
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGlusterfs(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesGlusterfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    endpoints: obj.endpoints,
    path: obj.path,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host
 * machine that is directly exposed to the container. This is generally
 * used for system agents or other privileged things that are allowed
 * to see the host machine. Most containers will NOT need this.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesHostPath
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesHostPath {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesHostPath(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesHostPath | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
 * The volume is resolved at pod startup depending on which PullPolicy value is provided:
 *
 * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
 * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
 * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
 *
 * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
 * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
 * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
 * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
 * The volume will be mounted read-only (ro) and non-executable files (noexec).
 * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
 * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesImage
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesImage {
  /**
   * Policy for pulling OCI objects. Possible values are:
   * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
   * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
   * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * Required: Image or artifact reference to be used.
   * Behaves in the same way as pod.spec.containers[*].image.
   * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesImage#reference
   */
  readonly reference?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesImage(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesImage | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    pullPolicy: obj.pullPolicy,
    reference: obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a
 * kubelet's host machine and then exposed to the pod.
 * More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    chapAuthDiscovery: obj.chapAuthDiscovery,
    chapAuthSession: obj.chapAuthSession,
    fsType: obj.fsType,
    initiatorName: obj.initiatorName,
    iqn: obj.iqn,
    iscsiInterface: obj.iscsiInterface,
    lun: obj.lun,
    portals: obj.portals?.map((y) => y),
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsiSecretRef(obj.secretRef),
    targetPortal: obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesNfs
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesNfs {
  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesNfs(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesNfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    path: obj.path,
    readOnly: obj.readOnly,
    server: obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a
 * PersistentVolumeClaim in the same namespace.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPersistentVolumeClaim
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPersistentVolumeClaim(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPersistentVolumeClaim | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    claimName: obj.claimName,
    readOnly: obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
 * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPhotonPersistentDisk
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPhotonPersistentDisk(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPhotonPersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    pdID: obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
 * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
 * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
 * is on.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPortworxVolume
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPortworxVolume(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesPortworxVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    volumeID: obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjected
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections. Each entry in this list
   * handles one source.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjected#sources
   */
  readonly sources?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjected(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjected | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    sources: obj.sources?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
 * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte {
  /**
   * group to map volume access to
   * Default is no group
   *
   * @default no group
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesQuobyte | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    group: obj.group,
    readOnly: obj.readOnly,
    registry: obj.registry,
    tenant: obj.tenant,
    user: obj.user,
    volume: obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
 * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
 * More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd#secretRef
   */
  readonly secretRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbd | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    image: obj.image,
    keyring: obj.keyring,
    monitors: obj.monitors?.map((y) => y),
    pool: obj.pool,
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbdSecretRef(obj.secretRef),
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   *
   * @default xfs".
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    gateway: obj.gateway,
    protectionDomain: obj.protectionDomain,
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIoSecretRef(obj.secretRef),
    sslEnabled: obj.sslEnabled,
    storageMode: obj.storageMode,
    storagePool: obj.storagePool,
    system: obj.system,
    volumeName: obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret represents a secret that should populate this volume.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecret
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecret#items
   */
  readonly items?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecret(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    defaultMode: obj.defaultMode,
    items: obj.items?.map((y) => toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecretItems(y)),
    optional: obj.optional,
    secretName: obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageos | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    readOnly: obj.readOnly,
    secretRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageosSecretRef(obj.secretRef),
    volumeName: obj.volumeName,
    volumeNamespace: obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
 * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
 * are redirected to the csi.vsphere.vmware.com CSI driver.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesVsphereVolume
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesVsphereVolume(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesVsphereVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fsType: obj.fsType,
    storagePolicyID: obj.storagePolicyId,
    storagePolicyName: obj.storagePolicyName,
    volumePath: obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttp
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttp {
  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttp#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttp#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttp(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttp | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttps
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttps {
  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttps#credentialSecretRef
   */
  readonly credentialSecretRef?: string;

  /**
   * Required
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttps#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttps(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecVaultConfigProxyHttps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    credentialSecretRef: obj.credentialSecretRef,
    url: obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    preference:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If the affinity requirements specified by this field are not met at
 * scheduling time, the pod will not be scheduled onto the node.
 * If the affinity requirements specified by this field cease to be met
 * at some point during pod execution (e.g. due to an update), the system
 * may or may not try to eventually evict the pod from its node.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    nodeSelectorTerms: obj.nodeSelectorTerms?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    podAffinityTerm:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    podAffinityTerm:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    weight: obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFrom
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFrom(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef(
      obj.resourceFieldRef,
    ),
    secretKeyRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromConfigMapRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromConfigMapRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromSecretRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromSecretRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStart
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStart#sleep
   */
  readonly sleep?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStart(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStop
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStop#sleep
   */
  readonly sleep?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStop(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket(obj.tcpSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeGrpc
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeGrpc(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeGrpc
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeGrpc(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesClaims
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesClaims(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesLimits
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesLimits {
  public static fromNumber(value: number): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesLimits {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesLimits(value);
  }
  public static fromString(value: string): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesLimits {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesRequests
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesRequests {
  public static fromNumber(value: number): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesRequests {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesRequests(value);
  }
  public static fromString(value: string): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesRequests {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextCapabilities
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextCapabilities(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeGrpc
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeGrpc(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef(
        obj.resourceFieldRef,
      ),
    secretKeyRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart#sleep
   */
  readonly sleep?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet(
      obj.httpGet,
    ),
    sleep: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop#sleep
   */
  readonly sleep?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet(
      obj.httpGet,
    ),
    sleep: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesClaims
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesClaims(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesLimits
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesLimits {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesLimits {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesLimits {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesRequests
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesRequests {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesRequests {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesRequests {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFrom
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFrom(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    configMapKeyRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef(
      obj.configMapKeyRef,
    ),
    fieldRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef(obj.fieldRef),
    resourceFieldRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef(
      obj.resourceFieldRef,
    ),
    secretKeyRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Secret to select from
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromSecretRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromSecretRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails,
 * the container is terminated and restarted according to its restart policy.
 * Other management of the container blocks until the hook completes.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStart
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStart#sleep
   */
  readonly sleep?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStart(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet(obj.httpGet),
    sleep: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an
 * API request or management event such as liveness/startup probe failure,
 * preemption, resource contention, etc. The handler is not called if the
 * container crashes or exits. The Pod's termination grace period countdown begins before the
 * PreStop hook is executed. Regardless of the outcome of the handler, the
 * container will eventually terminate within the Pod's termination grace
 * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
 * or until the termination grace period is reached.
 * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStop
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies a command to execute in the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies an HTTP GET request to perform.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Sleep represents a duration that the container should sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStop#sleep
   */
  readonly sleep?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for backward compatibility. There is no validation of this field and
   * lifecycle hooks will fail at runtime when it is specified.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStop(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec(obj.exec),
    httpGet: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet(obj.httpGet),
    sleep: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep(obj.sleep),
    tcpSocket: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesClaims
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of
   * the Pod where this field is used. It makes that resource available
   * inside a container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesClaims#name
   */
  readonly name: string;

  /**
   * Request is the name chosen for a request in the referenced claim.
   * If empty, everything from the claim is made available, otherwise
   * only the result of this request.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesClaims#request
   */
  readonly request?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesClaims(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    request: obj.request,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesLimits
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesLimits {
  public static fromNumber(value: number): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesLimits {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesLimits(value);
  }
  public static fromString(value: string): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesLimits {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesRequests
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesRequests {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesRequests {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesRequests {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * appArmorProfile is the AppArmor options to use by this container. If set, this profile
 * overrides the pod's appArmorProfile.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile {
  /**
   * localhostProfile indicates a profile loaded on the node that should be used.
   * The profile must be preconfigured on the node to work.
   * Must match the loaded name of the profile.
   * Must be set if and only if type is "Localhost".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of AppArmor profile will be applied.
   * Valid options are:
   * Localhost - a profile pre-loaded on the node.
   * RuntimeDefault - the container runtime's default profile.
   * Unconfined - no AppArmor enforcement.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextAppArmorProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The capabilities to add/drop when running containers.
 * Defaults to the default set of capabilities granted by the container runtime.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime.
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    add: obj.add?.map((y) => y),
    drop: obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SELinux context to be applied to the container.
 * If unspecified, the container runtime will allocate a random SELinux context for each
 * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
 * PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    level: obj.level,
    role: obj.role,
    type: obj.type,
    user: obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are
 * provided at both the pod & container level, the container options
 * override the pod options.
 * Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    localhostProfile: obj.localhostProfile,
    type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Windows specific settings applied to all containers.
 * If unspecified, the options from the PodSecurityContext will be used.
 * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
 * Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * All of a Pod's containers must have the same effective HostProcess value
   * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
   * In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    gmsaCredentialSpec: obj.gmsaCredentialSpec,
    gmsaCredentialSpecName: obj.gmsaCredentialSpecName,
    hostProcess: obj.hostProcess,
    runAsUserName: obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC specifies a GRPC HealthCheckRequest.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeGrpc
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeGrpc(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    port: obj.port,
    service: obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TCPSocket specifies a connection to a TCP port.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
 * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfsSecretRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfsSecretRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCephfsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect
 * to OpenStack.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinderSecretRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinderSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinderSecretRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCinderSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMapItems
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMapItems(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing
 * sensitive information to pass to the CSI driver to complete the CSI
 * NodePublishVolume and NodeUnpublishVolume calls.
 * This field is optional, and  may be empty if no secret is required. If the
 * secret object contains more than one secret, all secret references are passed.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesCsiNodePublishSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItems
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItems(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fieldRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    mode: obj.mode,
    path: obj.path,
    resourceFieldRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef(
      obj.resourceFieldRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume.
 * The size limit is also applicable for memory medium.
 * The maximum usage on memory medium EmptyDir would be the minimum value between
 * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
 * The default is nil which means that the limit is undefined.
 * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Will be used to create a stand-alone PVC to provision the volume.
 * The pod in which this EphemeralVolumeSource is embedded will be the
 * owner of the PVC, i.e. the PVC will be deleted together with the
 * pod.  The name of the PVC will be `<pod name>-<volume name>` where
 * `<volume name>` is the name from the `PodSpec.Volumes` array
 * entry. Pod validation will reject the pod if the concatenated name
 * is not valid for a PVC (for example, too long).
 *
 * An existing PVC with that name that is not owned by the pod
 * will *not* be used for the pod to avoid using an unrelated
 * volume by mistake. Starting the pod is then blocked until
 * the unrelated PVC is removed. If such a pre-created PVC is
 * meant to be used by the pod, the PVC has to updated with an
 * owner reference to the pod once the pod exists. Normally
 * this should not be necessary, but it may be useful when
 * manually reconstructing a broken cluster.
 *
 * This field is read-only and no changes will be made by Kubernetes
 * to the PVC after it has been created.
 *
 * Required, must not be nil.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata(
      obj.metadata,
    ),
    spec: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing
 * sensitive information to pass to the plugin scripts. This may be
 * empty if no secret object is specified. If the secret object
 * contains more than one secret, all secrets are passed to the plugin
 * scripts.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesFlexVolumeSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsiSecretRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsiSecretRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesIscsiSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Projection that may be projected along with other supported volume types.
 * Exactly one of these fields must be set.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources {
  /**
   * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
   * of ClusterTrustBundle objects in an auto-updating file.
   *
   * Alpha, gated by the ClusterTrustBundleProjection feature gate.
   *
   * ClusterTrustBundle objects can either be selected by name, or by the
   * combination of signer name and a label selector.
   *
   * Kubelet performs aggressive normalization of the PEM contents written
   * into the pod filesystem.  Esoteric PEM features such as inter-block
   * comments and block headers are stripped.  Certificates are deduplicated.
   * The ordering of certificates within the file is arbitrary, and Kubelet
   * may change the order over time.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources#clusterTrustBundle
   */
  readonly clusterTrustBundle?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle;

  /**
   * configMap information about the configMap data to project
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources#secret
   */
  readonly secret?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    clusterTrustBundle: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle(
      obj.clusterTrustBundle,
    ),
    configMap: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap(obj.configMap),
    downwardAPI: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi(
      obj.downwardApi,
    ),
    secret: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecret(obj.secret),
    serviceAccountToken: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken(
      obj.serviceAccountToken,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided
 * overrides keyring.
 * Default is nil.
 * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil.
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbdSecretRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbdSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbdSecretRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesRbdSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other
 * sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIoSecretRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIoSecretRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesScaleIoSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecretItems
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecretItems(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API
 * credentials.  If not specified, default values will be attempted.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageosSecretRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageosSecretRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesStorageosSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      ),
    ),
    matchFields: obj.matchFields?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      ),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   * If it's null, this PodAffinityTerm matches with no Pods.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
   * Also, matchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MismatchLabelKeys is a set of pod label keys to select which pods will
   * be taken into consideration. The keys are used to lookup values from the
   * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
   * to select the group of existing pods which pods will be taken into consideration
   * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
   * pod labels will be ignored. The default value is empty.
   * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
   * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
   * This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#mismatchLabelKeys
   */
  readonly mismatchLabelKeys?: string[];

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    matchLabelKeys: obj.matchLabelKeys?.map((y) => y),
    mismatchLabelKeys: obj.mismatchLabelKeys?.map((y) => y),
    namespaceSelector:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    namespaces: obj.namespaces?.map((y) => y),
    topologyKey: obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromFieldRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromFieldRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartSleep
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartSleep(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopSleep
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopSleep(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
 * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec specifies a command to execute in the container.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPGet specifies an HTTP GET request to perform.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   *
   * @default HTTP.
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    httpHeaders: obj.httpHeaders?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y),
    ),
    path: obj.path,
    port: obj.port?.value,
    scheme: obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sleep represents a duration that the container should sleep.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep {
  /**
   * Seconds is the number of seconds to sleep.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep#seconds
   */
  readonly seconds: number;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopSleep | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    seconds: obj.seconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
 * for backward compatibility. There is no validation of this field and
 * lifecycle hooks will fail at runtime when it is specified.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    host: obj.host,
    port: obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * May contain labels and annotations that will be copied into the PVC
 * when creating it. No other fields are allowed and will be rejected during
 * validation.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata {
  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;

  /**
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    annotations:
      obj.annotations === undefined
        ? undefined
        : Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    finalizers: obj.finalizers?.map((y) => y),
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is
 * copied unchanged into the PVC that gets created from this
 * template. The same fields as in a PersistentVolumeClaim
 * are also valid here.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
   * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
   * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the dataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, when namespace isn't specified in dataSourceRef,
   * both fields (dataSource and dataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * When namespace is specified in dataSourceRef,
   * dataSource isn't set to the same value and must be empty.
   * There are three important differences between dataSource and dataSourceRef:
   * * While dataSource only allows two specific types of objects, dataSourceRef
   * allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While dataSource ignores disallowed values (dropping them), dataSourceRef
   * preserves all values, and generates an error if a disallowed value is
   * specified.
   * * While dataSource only allows local objects, dataSourceRef allows objects
   * in any namespaces.
   * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
   * If specified, the CSI driver will create or update the volume with the attributes defined
   * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
   * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
   * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
   * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
   * will be set by the persistentvolume controller if it exists.
   * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
   * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
   * exists.
   * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
   * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeAttributesClassName
   */
  readonly volumeAttributesClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessModes: obj.accessModes?.map((y) => y),
    dataSource: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
      obj.dataSource,
    ),
    dataSourceRef:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    resources: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
      obj.resources,
    ),
    selector: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
      obj.selector,
    ),
    storageClassName: obj.storageClassName,
    volumeAttributesClassName: obj.volumeAttributesClassName,
    volumeMode: obj.volumeMode,
    volumeName: obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
 * of ClusterTrustBundle objects in an auto-updating file.
 *
 * Alpha, gated by the ClusterTrustBundleProjection feature gate.
 *
 * ClusterTrustBundle objects can either be selected by name, or by the
 * combination of signer name and a label selector.
 *
 * Kubelet performs aggressive normalization of the PEM contents written
 * into the pod filesystem.  Esoteric PEM features such as inter-block
 * comments and block headers are stripped.  Certificates are deduplicated.
 * The ordering of certificates within the file is arbitrary, and Kubelet
 * may change the order over time.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle {
  /**
   * Select all ClusterTrustBundles that match this label selector.  Only has
   * effect if signerName is set.  Mutually-exclusive with name.  If unset,
   * interpreted as "match nothing".  If set but empty, interpreted as "match
   * everything".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle#labelSelector
   */
  readonly labelSelector?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector;

  /**
   * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
   * with signerName and labelSelector.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle#name
   */
  readonly name?: string;

  /**
   * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
   * aren't available.  If using name, then the named ClusterTrustBundle is
   * allowed not to exist.  If using signerName, then the combination of
   * signerName and labelSelector is allowed to match zero
   * ClusterTrustBundles.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle#optional
   */
  readonly optional?: boolean;

  /**
   * Relative path from the volume root to write the bundle.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle#path
   */
  readonly path: string;

  /**
   * Select all ClusterTrustBundles that match this signer name.
   * Mutually-exclusive with name.  The contents of all selected
   * ClusterTrustBundles will be unified and deduplicated.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle#signerName
   */
  readonly signerName?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labelSelector:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(
        obj.labelSelector,
      ),
    name: obj.name,
    optional: obj.optional,
    path: obj.path,
    signerName: obj.signerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems(y),
    ),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems(y),
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecret
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecret(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    items: obj.items?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems(y),
    ),
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   *
   * @default 1 hour
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesServiceAccountToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    audience: obj.audience,
    expirationSeconds: obj.expirationSeconds,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over a set of resources, in this case pods.
 * If it's null, this PodAffinityTerm matches with no Pods.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label query over the set of namespaces that the term applies to.
 * The term is applied to the union of the namespaces selected by this field
 * and the ones listed in the namespaces field.
 * null selector and null or empty namespaces list means "this pod's namespace".
 * An empty selector ({}) matches all namespaces.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecEphemeralContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name.
   * This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Name or number of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Number or name of the port to access on the container.
 * Number must be in the range 1 to 65535.
 * Name must be an IANA_SVC_NAME.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * dataSource field can be used to specify either:
 * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
 * * An existing PVC (PersistentVolumeClaim)
 * If the provisioner or an external controller can support the specified data source,
 * it will create a new volume based on the contents of the specified data source.
 * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
 * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
 * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
 * volume is desired. This may be any object from a non-empty API group (non
 * core object) or a PersistentVolumeClaim object.
 * When this field is specified, volume binding will only succeed if the type of
 * the specified object matches some installed volume populator or dynamic
 * provisioner.
 * This field will replace the functionality of the dataSource field and as such
 * if both fields are non-empty, they must have the same value. For backwards
 * compatibility, when namespace isn't specified in dataSourceRef,
 * both fields (dataSource and dataSourceRef) will be set to the same
 * value automatically if one of them is empty and the other is non-empty.
 * When namespace is specified in dataSourceRef,
 * dataSource isn't set to the same value and must be empty.
 * There are three important differences between dataSource and dataSourceRef:
 * * While dataSource only allows two specific types of objects, dataSourceRef
 * allows any non-core object, as well as PersistentVolumeClaim objects.
 * * While dataSource ignores disallowed values (dropping them), dataSourceRef
 * preserves all values, and generates an error if a disallowed value is
 * specified.
 * * While dataSource only allows local objects, dataSourceRef allows objects
 * in any namespaces.
 * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced
   * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
   * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * resources represents the minimum resources the volume should have.
 * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
 * that are lower than previous value but must still be higher than capacity recorded in the
 * status field of the claim.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value. Requests cannot exceed Limits.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [
      key: string
    ]: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    limits:
      obj.limits === undefined
        ? undefined
        : Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
    requests:
      obj.requests === undefined
        ? undefined
        : Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1]?.value }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Select all ClusterTrustBundles that match this label selector.  Only has
 * effect if signerName is set.  Mutually-exclusive with name.  If unset,
 * interpreted as "match nothing".  If set but empty, interpreted as "match
 * everything".
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchExpressions
   */
  readonly matchExpressions?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(
        y,
      ),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fieldRef: toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
      obj.fieldRef,
    ),
    mode: obj.mode,
    path: obj.path,
    resourceFieldRef:
      toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
        obj.resourceFieldRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    mode: obj.mode,
    path: obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {}
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions(
  obj:
    | EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selects a resource of the container: only resources limits and requests
 * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
  obj: EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    containerName: obj.containerName,
    divisor: obj.divisor?.value,
    resource: obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new EphemeralRunnerSetSpecEphemeralRunnerSpecSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {}
}
