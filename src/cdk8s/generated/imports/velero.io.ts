// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "cdk8s";
import { Construct } from "constructs";

/**
 * Backup is a Velero resource that represents the capture of Kubernetes
cluster state at a point in time (API objects and associated volume state).
 *
 * @schema Backup
 */
export class Backup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Backup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v1",
    kind: "Backup",
  };

  /**
   * Renders a Kubernetes manifest for "Backup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupProps = {}): any {
    return {
      ...Backup.GVK,
      ...toJson_BackupProps(props),
    };
  }

  /**
   * Defines a "Backup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupProps = {}) {
    super(scope, id, {
      ...Backup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Backup.GVK,
      ...toJson_BackupProps(resolved),
    };
  }
}

/**
 * Backup is a Velero resource that represents the capture of Kubernetes
 * cluster state at a point in time (API objects and associated volume state).
 *
 * @schema Backup
 */
export interface BackupProps {
  /**
   * @schema Backup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupSpec defines the specification for a Velero backup.
   *
   * @schema Backup#spec
   */
  readonly spec?: BackupSpec;
}

/**
 * Converts an object of type 'BackupProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupProps(obj: BackupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_BackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackupSpec defines the specification for a Velero backup.
 *
 * @schema BackupSpec
 */
export interface BackupSpec {
  /**
   * CSISnapshotTimeout specifies the time used to wait for CSI VolumeSnapshot status turns to
   * ReadyToUse during creation, before returning error as timeout.
   * The default value is 10 minute.
   *
   * @schema BackupSpec#csiSnapshotTimeout
   */
  readonly csiSnapshotTimeout?: string;

  /**
   * DataMover specifies the data mover to be used by the backup.
   * If DataMover is "" or "velero", the built-in data mover will be used.
   *
   * @schema BackupSpec#datamover
   */
  readonly datamover?: string;

  /**
   * DefaultVolumesToFsBackup specifies whether pod volume file system backup should be used
   * for all volumes by default.
   *
   * @schema BackupSpec#defaultVolumesToFsBackup
   */
  readonly defaultVolumesToFsBackup?: boolean;

  /**
   * DefaultVolumesToRestic specifies whether restic should be used to take a
   * backup of all pod volumes by default.
   *
   * Deprecated: this field is no longer used and will be removed entirely in future. Use DefaultVolumesToFsBackup instead.
   *
   * @schema BackupSpec#defaultVolumesToRestic
   */
  readonly defaultVolumesToRestic?: boolean;

  /**
   * ExcludedClusterScopedResources is a slice of cluster-scoped
   * resource type names to exclude from the backup.
   * If set to "*", all cluster-scoped resource types are excluded.
   * The default value is empty.
   *
   * @schema BackupSpec#excludedClusterScopedResources
   */
  readonly excludedClusterScopedResources?: string[];

  /**
   * ExcludedNamespaceScopedResources is a slice of namespace-scoped
   * resource type names to exclude from the backup.
   * If set to "*", all namespace-scoped resource types are excluded.
   * The default value is empty.
   *
   * @schema BackupSpec#excludedNamespaceScopedResources
   */
  readonly excludedNamespaceScopedResources?: string[];

  /**
   * ExcludedNamespaces contains a list of namespaces that are not
   * included in the backup.
   *
   * @schema BackupSpec#excludedNamespaces
   */
  readonly excludedNamespaces?: string[];

  /**
   * ExcludedResources is a slice of resource names that are not
   * included in the backup.
   *
   * @schema BackupSpec#excludedResources
   */
  readonly excludedResources?: string[];

  /**
   * Hooks represent custom behaviors that should be executed at different phases of the backup.
   *
   * @schema BackupSpec#hooks
   */
  readonly hooks?: BackupSpecHooks;

  /**
   * IncludeClusterResources specifies whether cluster-scoped resources
   * should be included for consideration in the backup.
   *
   * @schema BackupSpec#includeClusterResources
   */
  readonly includeClusterResources?: boolean;

  /**
   * IncludedClusterScopedResources is a slice of cluster-scoped
   * resource type names to include in the backup.
   * If set to "*", all cluster-scoped resource types are included.
   * The default value is empty, which means only related
   * cluster-scoped resources are included.
   *
   * @schema BackupSpec#includedClusterScopedResources
   */
  readonly includedClusterScopedResources?: string[];

  /**
   * IncludedNamespaceScopedResources is a slice of namespace-scoped
   * resource type names to include in the backup.
   * The default value is "*".
   *
   * @schema BackupSpec#includedNamespaceScopedResources
   */
  readonly includedNamespaceScopedResources?: string[];

  /**
   * IncludedNamespaces is a slice of namespace names to include objects
   * from. If empty, all namespaces are included.
   *
   * @schema BackupSpec#includedNamespaces
   */
  readonly includedNamespaces?: string[];

  /**
   * IncludedResources is a slice of resource names to include
   * in the backup. If empty, all resources are included.
   *
   * @schema BackupSpec#includedResources
   */
  readonly includedResources?: string[];

  /**
   * ItemOperationTimeout specifies the time used to wait for asynchronous BackupItemAction operations
   * The default value is 4 hour.
   *
   * @schema BackupSpec#itemOperationTimeout
   */
  readonly itemOperationTimeout?: string;

  /**
   * LabelSelector is a metav1.LabelSelector to filter with
   * when adding individual objects to the backup. If empty
   * or nil, all objects are included. Optional.
   *
   * @schema BackupSpec#labelSelector
   */
  readonly labelSelector?: BackupSpecLabelSelector;

  /**
   * @schema BackupSpec#metadata
   */
  readonly metadata?: BackupSpecMetadata;

  /**
   * OrLabelSelectors is list of metav1.LabelSelector to filter with
   * when adding individual objects to the backup. If multiple provided
   * they will be joined by the OR operator. LabelSelector as well as
   * OrLabelSelectors cannot co-exist in backup request, only one of them
   * can be used.
   *
   * @schema BackupSpec#orLabelSelectors
   */
  readonly orLabelSelectors?: BackupSpecOrLabelSelectors[];

  /**
   * OrderedResources specifies the backup order of resources of specific Kind.
   * The map key is the resource name and value is a list of object names separated by commas.
   * Each resource name has format "namespace/objectname".  For cluster resources, simply use "objectname".
   *
   * @schema BackupSpec#orderedResources
   */
  readonly orderedResources?: { [key: string]: string };

  /**
   * ResourcePolicy specifies the referenced resource policies that backup should follow
   *
   * @schema BackupSpec#resourcePolicy
   */
  readonly resourcePolicy?: BackupSpecResourcePolicy;

  /**
   * SnapshotMoveData specifies whether snapshot data should be moved
   *
   * @schema BackupSpec#snapshotMoveData
   */
  readonly snapshotMoveData?: boolean;

  /**
   * SnapshotVolumes specifies whether to take snapshots
   * of any PV's referenced in the set of objects included
   * in the Backup.
   *
   * @schema BackupSpec#snapshotVolumes
   */
  readonly snapshotVolumes?: boolean;

  /**
   * StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
   *
   * @schema BackupSpec#storageLocation
   */
  readonly storageLocation?: string;

  /**
   * TTL is a time.Duration-parseable string describing how long
   * the Backup should be retained for.
   *
   * @schema BackupSpec#ttl
   */
  readonly ttl?: string;

  /**
   * UploaderConfig specifies the configuration for the uploader.
   *
   * @schema BackupSpec#uploaderConfig
   */
  readonly uploaderConfig?: BackupSpecUploaderConfig;

  /**
   * VolumeGroupSnapshotLabelKey specifies the label key to group PVCs under a VGS.
   *
   * @schema BackupSpec#volumeGroupSnapshotLabelKey
   */
  readonly volumeGroupSnapshotLabelKey?: string;

  /**
   * VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
   *
   * @schema BackupSpec#volumeSnapshotLocations
   */
  readonly volumeSnapshotLocations?: string[];
}

/**
 * Converts an object of type 'BackupSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpec(obj: BackupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    csiSnapshotTimeout: obj.csiSnapshotTimeout,
    datamover: obj.datamover,
    defaultVolumesToFsBackup: obj.defaultVolumesToFsBackup,
    defaultVolumesToRestic: obj.defaultVolumesToRestic,
    excludedClusterScopedResources: obj.excludedClusterScopedResources?.map((y) => y),
    excludedNamespaceScopedResources: obj.excludedNamespaceScopedResources?.map((y) => y),
    excludedNamespaces: obj.excludedNamespaces?.map((y) => y),
    excludedResources: obj.excludedResources?.map((y) => y),
    hooks: toJson_BackupSpecHooks(obj.hooks),
    includeClusterResources: obj.includeClusterResources,
    includedClusterScopedResources: obj.includedClusterScopedResources?.map((y) => y),
    includedNamespaceScopedResources: obj.includedNamespaceScopedResources?.map((y) => y),
    includedNamespaces: obj.includedNamespaces?.map((y) => y),
    includedResources: obj.includedResources?.map((y) => y),
    itemOperationTimeout: obj.itemOperationTimeout,
    labelSelector: toJson_BackupSpecLabelSelector(obj.labelSelector),
    metadata: toJson_BackupSpecMetadata(obj.metadata),
    orLabelSelectors: obj.orLabelSelectors?.map((y) => toJson_BackupSpecOrLabelSelectors(y)),
    orderedResources:
      obj.orderedResources === undefined
        ? undefined
        : Object.entries(obj.orderedResources).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    resourcePolicy: toJson_BackupSpecResourcePolicy(obj.resourcePolicy),
    snapshotMoveData: obj.snapshotMoveData,
    snapshotVolumes: obj.snapshotVolumes,
    storageLocation: obj.storageLocation,
    ttl: obj.ttl,
    uploaderConfig: toJson_BackupSpecUploaderConfig(obj.uploaderConfig),
    volumeGroupSnapshotLabelKey: obj.volumeGroupSnapshotLabelKey,
    volumeSnapshotLocations: obj.volumeSnapshotLocations?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hooks represent custom behaviors that should be executed at different phases of the backup.
 *
 * @schema BackupSpecHooks
 */
export interface BackupSpecHooks {
  /**
   * Resources are hooks that should be executed when backing up individual instances of a resource.
   *
   * @schema BackupSpecHooks#resources
   */
  readonly resources?: BackupSpecHooksResources[];
}

/**
 * Converts an object of type 'BackupSpecHooks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecHooks(obj: BackupSpecHooks | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resources: obj.resources?.map((y) => toJson_BackupSpecHooksResources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a metav1.LabelSelector to filter with
 * when adding individual objects to the backup. If empty
 * or nil, all objects are included. Optional.
 *
 * @schema BackupSpecLabelSelector
 */
export interface BackupSpecLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema BackupSpecLabelSelector#matchExpressions
   */
  readonly matchExpressions?: BackupSpecLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BackupSpecLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'BackupSpecLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecLabelSelector(
  obj: BackupSpecLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) => toJson_BackupSpecLabelSelectorMatchExpressions(y)),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema BackupSpecMetadata
 */
export interface BackupSpecMetadata {
  /**
   * @schema BackupSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'BackupSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecMetadata(obj: BackupSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema BackupSpecOrLabelSelectors
 */
export interface BackupSpecOrLabelSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema BackupSpecOrLabelSelectors#matchExpressions
   */
  readonly matchExpressions?: BackupSpecOrLabelSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BackupSpecOrLabelSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'BackupSpecOrLabelSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecOrLabelSelectors(
  obj: BackupSpecOrLabelSelectors | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) => toJson_BackupSpecOrLabelSelectorsMatchExpressions(y)),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourcePolicy specifies the referenced resource policies that backup should follow
 *
 * @schema BackupSpecResourcePolicy
 */
export interface BackupSpecResourcePolicy {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema BackupSpecResourcePolicy#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema BackupSpecResourcePolicy#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema BackupSpecResourcePolicy#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'BackupSpecResourcePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecResourcePolicy(
  obj: BackupSpecResourcePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UploaderConfig specifies the configuration for the uploader.
 *
 * @schema BackupSpecUploaderConfig
 */
export interface BackupSpecUploaderConfig {
  /**
   * ParallelFilesUpload is the number of files parallel uploads to perform when using the uploader.
   *
   * @schema BackupSpecUploaderConfig#parallelFilesUpload
   */
  readonly parallelFilesUpload?: number;
}

/**
 * Converts an object of type 'BackupSpecUploaderConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecUploaderConfig(
  obj: BackupSpecUploaderConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    parallelFilesUpload: obj.parallelFilesUpload,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on
 * the rules defined for namespaces, resources, and label selector.
 *
 * @schema BackupSpecHooksResources
 */
export interface BackupSpecHooksResources {
  /**
   * ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
   *
   * @schema BackupSpecHooksResources#excludedNamespaces
   */
  readonly excludedNamespaces?: string[];

  /**
   * ExcludedResources specifies the resources to which this hook spec does not apply.
   *
   * @schema BackupSpecHooksResources#excludedResources
   */
  readonly excludedResources?: string[];

  /**
   * IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies
   * to all namespaces.
   *
   * @schema BackupSpecHooksResources#includedNamespaces
   */
  readonly includedNamespaces?: string[];

  /**
   * IncludedResources specifies the resources to which this hook spec applies. If empty, it applies
   * to all resources.
   *
   * @schema BackupSpecHooksResources#includedResources
   */
  readonly includedResources?: string[];

  /**
   * LabelSelector, if specified, filters the resources to which this hook spec applies.
   *
   * @schema BackupSpecHooksResources#labelSelector
   */
  readonly labelSelector?: BackupSpecHooksResourcesLabelSelector;

  /**
   * Name is the name of this hook.
   *
   * @schema BackupSpecHooksResources#name
   */
  readonly name: string;

  /**
   * PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup.
   * These are executed after all "additional items" from item actions are processed.
   *
   * @schema BackupSpecHooksResources#post
   */
  readonly post?: BackupSpecHooksResourcesPost[];

  /**
   * PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup.
   * These are executed before any "additional items" from item actions are processed.
   *
   * @schema BackupSpecHooksResources#pre
   */
  readonly pre?: BackupSpecHooksResourcesPre[];
}

/**
 * Converts an object of type 'BackupSpecHooksResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecHooksResources(
  obj: BackupSpecHooksResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    excludedNamespaces: obj.excludedNamespaces?.map((y) => y),
    excludedResources: obj.excludedResources?.map((y) => y),
    includedNamespaces: obj.includedNamespaces?.map((y) => y),
    includedResources: obj.includedResources?.map((y) => y),
    labelSelector: toJson_BackupSpecHooksResourcesLabelSelector(obj.labelSelector),
    name: obj.name,
    post: obj.post?.map((y) => toJson_BackupSpecHooksResourcesPost(y)),
    pre: obj.pre?.map((y) => toJson_BackupSpecHooksResourcesPre(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema BackupSpecLabelSelectorMatchExpressions
 */
export interface BackupSpecLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema BackupSpecLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema BackupSpecLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema BackupSpecLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'BackupSpecLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecLabelSelectorMatchExpressions(
  obj: BackupSpecLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema BackupSpecOrLabelSelectorsMatchExpressions
 */
export interface BackupSpecOrLabelSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema BackupSpecOrLabelSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema BackupSpecOrLabelSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema BackupSpecOrLabelSelectorsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'BackupSpecOrLabelSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecOrLabelSelectorsMatchExpressions(
  obj: BackupSpecOrLabelSelectorsMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector, if specified, filters the resources to which this hook spec applies.
 *
 * @schema BackupSpecHooksResourcesLabelSelector
 */
export interface BackupSpecHooksResourcesLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema BackupSpecHooksResourcesLabelSelector#matchExpressions
   */
  readonly matchExpressions?: BackupSpecHooksResourcesLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BackupSpecHooksResourcesLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'BackupSpecHooksResourcesLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecHooksResourcesLabelSelector(
  obj: BackupSpecHooksResourcesLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) => toJson_BackupSpecHooksResourcesLabelSelectorMatchExpressions(y)),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackupResourceHook defines a hook for a resource.
 *
 * @schema BackupSpecHooksResourcesPost
 */
export interface BackupSpecHooksResourcesPost {
  /**
   * Exec defines an exec hook.
   *
   * @schema BackupSpecHooksResourcesPost#exec
   */
  readonly exec: BackupSpecHooksResourcesPostExec;
}

/**
 * Converts an object of type 'BackupSpecHooksResourcesPost' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecHooksResourcesPost(
  obj: BackupSpecHooksResourcesPost | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_BackupSpecHooksResourcesPostExec(obj.exec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackupResourceHook defines a hook for a resource.
 *
 * @schema BackupSpecHooksResourcesPre
 */
export interface BackupSpecHooksResourcesPre {
  /**
   * Exec defines an exec hook.
   *
   * @schema BackupSpecHooksResourcesPre#exec
   */
  readonly exec: BackupSpecHooksResourcesPreExec;
}

/**
 * Converts an object of type 'BackupSpecHooksResourcesPre' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecHooksResourcesPre(
  obj: BackupSpecHooksResourcesPre | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_BackupSpecHooksResourcesPreExec(obj.exec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema BackupSpecHooksResourcesLabelSelectorMatchExpressions
 */
export interface BackupSpecHooksResourcesLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema BackupSpecHooksResourcesLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema BackupSpecHooksResourcesLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema BackupSpecHooksResourcesLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'BackupSpecHooksResourcesLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecHooksResourcesLabelSelectorMatchExpressions(
  obj: BackupSpecHooksResourcesLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec defines an exec hook.
 *
 * @schema BackupSpecHooksResourcesPostExec
 */
export interface BackupSpecHooksResourcesPostExec {
  /**
   * Command is the command and arguments to execute.
   *
   * @schema BackupSpecHooksResourcesPostExec#command
   */
  readonly command: string[];

  /**
   * Container is the container in the pod where the command should be executed. If not specified,
   * the pod's first container is used.
   *
   * @schema BackupSpecHooksResourcesPostExec#container
   */
  readonly container?: string;

  /**
   * OnError specifies how Velero should behave if it encounters an error executing this hook.
   *
   * @schema BackupSpecHooksResourcesPostExec#onError
   */
  readonly onError?: BackupSpecHooksResourcesPostExecOnError;

  /**
   * Timeout defines the maximum amount of time Velero should wait for the hook to complete before
   * considering the execution a failure.
   *
   * @schema BackupSpecHooksResourcesPostExec#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'BackupSpecHooksResourcesPostExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecHooksResourcesPostExec(
  obj: BackupSpecHooksResourcesPostExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
    container: obj.container,
    onError: obj.onError,
    timeout: obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec defines an exec hook.
 *
 * @schema BackupSpecHooksResourcesPreExec
 */
export interface BackupSpecHooksResourcesPreExec {
  /**
   * Command is the command and arguments to execute.
   *
   * @schema BackupSpecHooksResourcesPreExec#command
   */
  readonly command: string[];

  /**
   * Container is the container in the pod where the command should be executed. If not specified,
   * the pod's first container is used.
   *
   * @schema BackupSpecHooksResourcesPreExec#container
   */
  readonly container?: string;

  /**
   * OnError specifies how Velero should behave if it encounters an error executing this hook.
   *
   * @schema BackupSpecHooksResourcesPreExec#onError
   */
  readonly onError?: BackupSpecHooksResourcesPreExecOnError;

  /**
   * Timeout defines the maximum amount of time Velero should wait for the hook to complete before
   * considering the execution a failure.
   *
   * @schema BackupSpecHooksResourcesPreExec#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'BackupSpecHooksResourcesPreExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupSpecHooksResourcesPreExec(
  obj: BackupSpecHooksResourcesPreExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
    container: obj.container,
    onError: obj.onError,
    timeout: obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnError specifies how Velero should behave if it encounters an error executing this hook.
 *
 * @schema BackupSpecHooksResourcesPostExecOnError
 */
export enum BackupSpecHooksResourcesPostExecOnError {
  /** Continue */
  CONTINUE = "Continue",
  /** Fail */
  FAIL = "Fail",
}

/**
 * OnError specifies how Velero should behave if it encounters an error executing this hook.
 *
 * @schema BackupSpecHooksResourcesPreExecOnError
 */
export enum BackupSpecHooksResourcesPreExecOnError {
  /** Continue */
  CONTINUE = "Continue",
  /** Fail */
  FAIL = "Fail",
}

/**
 *
 *
 * @schema BackupRepository
 */
export class BackupRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v1",
    kind: "BackupRepository",
  };

  /**
   * Renders a Kubernetes manifest for "BackupRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupRepositoryProps = {}): any {
    return {
      ...BackupRepository.GVK,
      ...toJson_BackupRepositoryProps(props),
    };
  }

  /**
   * Defines a "BackupRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupRepositoryProps = {}) {
    super(scope, id, {
      ...BackupRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupRepository.GVK,
      ...toJson_BackupRepositoryProps(resolved),
    };
  }
}

/**
 * @schema BackupRepository
 */
export interface BackupRepositoryProps {
  /**
   * @schema BackupRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupRepositorySpec is the specification for a BackupRepository.
   *
   * @schema BackupRepository#spec
   */
  readonly spec?: BackupRepositorySpec;
}

/**
 * Converts an object of type 'BackupRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupRepositoryProps(obj: BackupRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_BackupRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackupRepositorySpec is the specification for a BackupRepository.
 *
 * @schema BackupRepositorySpec
 */
export interface BackupRepositorySpec {
  /**
   * BackupStorageLocation is the name of the BackupStorageLocation
   * that should contain this repository.
   *
   * @schema BackupRepositorySpec#backupStorageLocation
   */
  readonly backupStorageLocation: string;

  /**
   * MaintenanceFrequency is how often maintenance should be run.
   *
   * @schema BackupRepositorySpec#maintenanceFrequency
   */
  readonly maintenanceFrequency: string;

  /**
   * RepositoryConfig is for repository-specific configuration fields.
   *
   * @schema BackupRepositorySpec#repositoryConfig
   */
  readonly repositoryConfig?: { [key: string]: string };

  /**
   * RepositoryType indicates the type of the backend repository
   *
   * @schema BackupRepositorySpec#repositoryType
   */
  readonly repositoryType?: BackupRepositorySpecRepositoryType;

  /**
   * ResticIdentifier is the full restic-compatible string for identifying
   * this repository. This field is only used when RepositoryType is "restic".
   *
   * @schema BackupRepositorySpec#resticIdentifier
   */
  readonly resticIdentifier?: string;

  /**
   * VolumeNamespace is the namespace this backup repository contains
   * pod volume backups for.
   *
   * @schema BackupRepositorySpec#volumeNamespace
   */
  readonly volumeNamespace: string;
}

/**
 * Converts an object of type 'BackupRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupRepositorySpec(obj: BackupRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    backupStorageLocation: obj.backupStorageLocation,
    maintenanceFrequency: obj.maintenanceFrequency,
    repositoryConfig:
      obj.repositoryConfig === undefined
        ? undefined
        : Object.entries(obj.repositoryConfig).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    repositoryType: obj.repositoryType,
    resticIdentifier: obj.resticIdentifier,
    volumeNamespace: obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RepositoryType indicates the type of the backend repository
 *
 * @schema BackupRepositorySpecRepositoryType
 */
export enum BackupRepositorySpecRepositoryType {
  /** kopia */
  KOPIA = "kopia",
  /** restic */
  RESTIC = "restic",
}

/**
 * BackupStorageLocation is a location where Velero stores backup objects
 *
 * @schema BackupStorageLocation
 */
export class BackupStorageLocation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BackupStorageLocation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v1",
    kind: "BackupStorageLocation",
  };

  /**
   * Renders a Kubernetes manifest for "BackupStorageLocation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BackupStorageLocationProps = {}): any {
    return {
      ...BackupStorageLocation.GVK,
      ...toJson_BackupStorageLocationProps(props),
    };
  }

  /**
   * Defines a "BackupStorageLocation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BackupStorageLocationProps = {}) {
    super(scope, id, {
      ...BackupStorageLocation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...BackupStorageLocation.GVK,
      ...toJson_BackupStorageLocationProps(resolved),
    };
  }
}

/**
 * BackupStorageLocation is a location where Velero stores backup objects
 *
 * @schema BackupStorageLocation
 */
export interface BackupStorageLocationProps {
  /**
   * @schema BackupStorageLocation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BackupStorageLocationSpec defines the desired state of a Velero BackupStorageLocation
   *
   * @schema BackupStorageLocation#spec
   */
  readonly spec?: BackupStorageLocationSpec;
}

/**
 * Converts an object of type 'BackupStorageLocationProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupStorageLocationProps(
  obj: BackupStorageLocationProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_BackupStorageLocationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackupStorageLocationSpec defines the desired state of a Velero BackupStorageLocation
 *
 * @schema BackupStorageLocationSpec
 */
export interface BackupStorageLocationSpec {
  /**
   * AccessMode defines the permissions for the backup storage location.
   *
   * @schema BackupStorageLocationSpec#accessMode
   */
  readonly accessMode?: BackupStorageLocationSpecAccessMode;

  /**
   * BackupSyncPeriod defines how frequently to sync backup API objects from object storage. A value of 0 disables sync.
   *
   * @schema BackupStorageLocationSpec#backupSyncPeriod
   */
  readonly backupSyncPeriod?: string;

  /**
   * Config is for provider-specific configuration fields.
   *
   * @schema BackupStorageLocationSpec#config
   */
  readonly config?: { [key: string]: string };

  /**
   * Credential contains the credential information intended to be used with this location
   *
   * @schema BackupStorageLocationSpec#credential
   */
  readonly credential?: BackupStorageLocationSpecCredential;

  /**
   * Default indicates this location is the default backup storage location.
   *
   * @schema BackupStorageLocationSpec#default
   */
  readonly default?: boolean;

  /**
   * ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.
   *
   * @schema BackupStorageLocationSpec#objectStorage
   */
  readonly objectStorage: BackupStorageLocationSpecObjectStorage;

  /**
   * Provider is the provider of the backup storage.
   *
   * @schema BackupStorageLocationSpec#provider
   */
  readonly provider: string;

  /**
   * ValidationFrequency defines how frequently to validate the corresponding object storage. A value of 0 disables validation.
   *
   * @schema BackupStorageLocationSpec#validationFrequency
   */
  readonly validationFrequency?: string;
}

/**
 * Converts an object of type 'BackupStorageLocationSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupStorageLocationSpec(
  obj: BackupStorageLocationSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    accessMode: obj.accessMode,
    backupSyncPeriod: obj.backupSyncPeriod,
    config:
      obj.config === undefined
        ? undefined
        : Object.entries(obj.config).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    credential: toJson_BackupStorageLocationSpecCredential(obj.credential),
    default: obj.default,
    objectStorage: toJson_BackupStorageLocationSpecObjectStorage(obj.objectStorage),
    provider: obj.provider,
    validationFrequency: obj.validationFrequency,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessMode defines the permissions for the backup storage location.
 *
 * @schema BackupStorageLocationSpecAccessMode
 */
export enum BackupStorageLocationSpecAccessMode {
  /** ReadOnly */
  READ_ONLY = "ReadOnly",
  /** ReadWrite */
  READ_WRITE = "ReadWrite",
}

/**
 * Credential contains the credential information intended to be used with this location
 *
 * @schema BackupStorageLocationSpecCredential
 */
export interface BackupStorageLocationSpecCredential {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema BackupStorageLocationSpecCredential#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema BackupStorageLocationSpecCredential#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema BackupStorageLocationSpecCredential#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'BackupStorageLocationSpecCredential' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupStorageLocationSpecCredential(
  obj: BackupStorageLocationSpecCredential | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.
 *
 * @schema BackupStorageLocationSpecObjectStorage
 */
export interface BackupStorageLocationSpecObjectStorage {
  /**
   * Bucket is the bucket to use for object storage.
   *
   * @schema BackupStorageLocationSpecObjectStorage#bucket
   */
  readonly bucket: string;

  /**
   * CACert defines a CA bundle to use when verifying TLS connections to the provider.
   *
   * @schema BackupStorageLocationSpecObjectStorage#caCert
   */
  readonly caCert?: string;

  /**
   * Prefix is the path inside a bucket to use for Velero storage. Optional.
   *
   * @schema BackupStorageLocationSpecObjectStorage#prefix
   */
  readonly prefix?: string;
}

/**
 * Converts an object of type 'BackupStorageLocationSpecObjectStorage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_BackupStorageLocationSpecObjectStorage(
  obj: BackupStorageLocationSpecObjectStorage | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    bucket: obj.bucket,
    caCert: obj.caCert,
    prefix: obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DataDownload acts as the protocol between data mover plugins and data mover controller for the datamover restore operation
 *
 * @schema DataDownload
 */
export class DataDownload extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DataDownload"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v2alpha1",
    kind: "DataDownload",
  };

  /**
   * Renders a Kubernetes manifest for "DataDownload".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DataDownloadProps = {}): any {
    return {
      ...DataDownload.GVK,
      ...toJson_DataDownloadProps(props),
    };
  }

  /**
   * Defines a "DataDownload" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DataDownloadProps = {}) {
    super(scope, id, {
      ...DataDownload.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...DataDownload.GVK,
      ...toJson_DataDownloadProps(resolved),
    };
  }
}

/**
 * DataDownload acts as the protocol between data mover plugins and data mover controller for the datamover restore operation
 *
 * @schema DataDownload
 */
export interface DataDownloadProps {
  /**
   * @schema DataDownload#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DataDownloadSpec is the specification for a DataDownload.
   *
   * @schema DataDownload#spec
   */
  readonly spec?: DataDownloadSpec;
}

/**
 * Converts an object of type 'DataDownloadProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DataDownloadProps(obj: DataDownloadProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_DataDownloadSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DataDownloadSpec is the specification for a DataDownload.
 *
 * @schema DataDownloadSpec
 */
export interface DataDownloadSpec {
  /**
   * BackupStorageLocation is the name of the backup storage location
   * where the backup repository is stored.
   *
   * @schema DataDownloadSpec#backupStorageLocation
   */
  readonly backupStorageLocation: string;

  /**
   * Cancel indicates request to cancel the ongoing DataDownload. It can be set
   * when the DataDownload is in InProgress phase
   *
   * @schema DataDownloadSpec#cancel
   */
  readonly cancel?: boolean;

  /**
   * DataMoverConfig is for data-mover-specific configuration fields.
   *
   * @schema DataDownloadSpec#dataMoverConfig
   */
  readonly dataMoverConfig?: { [key: string]: string };

  /**
   * DataMover specifies the data mover to be used by the backup.
   * If DataMover is "" or "velero", the built-in data mover will be used.
   *
   * @schema DataDownloadSpec#datamover
   */
  readonly datamover?: string;

  /**
   * NodeOS is OS of the node where the DataDownload is processed.
   *
   * @schema DataDownloadSpec#nodeOS
   */
  readonly nodeOs?: DataDownloadSpecNodeOs;

  /**
   * OperationTimeout specifies the time used to wait internal operations,
   * before returning error as timeout.
   *
   * @schema DataDownloadSpec#operationTimeout
   */
  readonly operationTimeout: string;

  /**
   * SnapshotID is the ID of the Velero backup snapshot to be restored from.
   *
   * @schema DataDownloadSpec#snapshotID
   */
  readonly snapshotId: string;

  /**
   * SourceNamespace is the original namespace where the volume is backed up from.
   * It may be different from SourcePVC's namespace if namespace is remapped during restore.
   *
   * @schema DataDownloadSpec#sourceNamespace
   */
  readonly sourceNamespace: string;

  /**
   * TargetVolume is the information of the target PVC and PV.
   *
   * @schema DataDownloadSpec#targetVolume
   */
  readonly targetVolume: DataDownloadSpecTargetVolume;
}

/**
 * Converts an object of type 'DataDownloadSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DataDownloadSpec(obj: DataDownloadSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    backupStorageLocation: obj.backupStorageLocation,
    cancel: obj.cancel,
    dataMoverConfig:
      obj.dataMoverConfig === undefined
        ? undefined
        : Object.entries(obj.dataMoverConfig).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    datamover: obj.datamover,
    nodeOS: obj.nodeOs,
    operationTimeout: obj.operationTimeout,
    snapshotID: obj.snapshotId,
    sourceNamespace: obj.sourceNamespace,
    targetVolume: toJson_DataDownloadSpecTargetVolume(obj.targetVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeOS is OS of the node where the DataDownload is processed.
 *
 * @schema DataDownloadSpecNodeOs
 */
export enum DataDownloadSpecNodeOs {
  /** auto */
  AUTO = "auto",
  /** linux */
  LINUX = "linux",
  /** windows */
  WINDOWS = "windows",
}

/**
 * TargetVolume is the information of the target PVC and PV.
 *
 * @schema DataDownloadSpecTargetVolume
 */
export interface DataDownloadSpecTargetVolume {
  /**
   * Namespace is the target namespace
   *
   * @schema DataDownloadSpecTargetVolume#namespace
   */
  readonly namespace: string;

  /**
   * PV is the name of the target PV that is created by Velero restore
   *
   * @schema DataDownloadSpecTargetVolume#pv
   */
  readonly pv: string;

  /**
   * PVC is the name of the target PVC that is created by Velero restore
   *
   * @schema DataDownloadSpecTargetVolume#pvc
   */
  readonly pvc: string;
}

/**
 * Converts an object of type 'DataDownloadSpecTargetVolume' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DataDownloadSpecTargetVolume(
  obj: DataDownloadSpecTargetVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    namespace: obj.namespace,
    pv: obj.pv,
    pvc: obj.pvc,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DataUpload acts as the protocol between data mover plugins and data mover controller for the datamover backup operation
 *
 * @schema DataUpload
 */
export class DataUpload extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DataUpload"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v2alpha1",
    kind: "DataUpload",
  };

  /**
   * Renders a Kubernetes manifest for "DataUpload".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DataUploadProps = {}): any {
    return {
      ...DataUpload.GVK,
      ...toJson_DataUploadProps(props),
    };
  }

  /**
   * Defines a "DataUpload" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DataUploadProps = {}) {
    super(scope, id, {
      ...DataUpload.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...DataUpload.GVK,
      ...toJson_DataUploadProps(resolved),
    };
  }
}

/**
 * DataUpload acts as the protocol between data mover plugins and data mover controller for the datamover backup operation
 *
 * @schema DataUpload
 */
export interface DataUploadProps {
  /**
   * @schema DataUpload#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DataUploadSpec is the specification for a DataUpload.
   *
   * @schema DataUpload#spec
   */
  readonly spec?: DataUploadSpec;
}

/**
 * Converts an object of type 'DataUploadProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DataUploadProps(obj: DataUploadProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_DataUploadSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DataUploadSpec is the specification for a DataUpload.
 *
 * @schema DataUploadSpec
 */
export interface DataUploadSpec {
  /**
   * BackupStorageLocation is the name of the backup storage location
   * where the backup repository is stored.
   *
   * @schema DataUploadSpec#backupStorageLocation
   */
  readonly backupStorageLocation: string;

  /**
   * Cancel indicates request to cancel the ongoing DataUpload. It can be set
   * when the DataUpload is in InProgress phase
   *
   * @schema DataUploadSpec#cancel
   */
  readonly cancel?: boolean;

  /**
   * If SnapshotType is CSI, CSISnapshot provides the information of the CSI snapshot.
   *
   * @schema DataUploadSpec#csiSnapshot
   */
  readonly csiSnapshot?: DataUploadSpecCsiSnapshot;

  /**
   * DataMoverConfig is for data-mover-specific configuration fields.
   *
   * @schema DataUploadSpec#dataMoverConfig
   */
  readonly dataMoverConfig?: { [key: string]: string };

  /**
   * DataMover specifies the data mover to be used by the backup.
   * If DataMover is "" or "velero", the built-in data mover will be used.
   *
   * @schema DataUploadSpec#datamover
   */
  readonly datamover?: string;

  /**
   * OperationTimeout specifies the time used to wait internal operations,
   * before returning error as timeout.
   *
   * @schema DataUploadSpec#operationTimeout
   */
  readonly operationTimeout: string;

  /**
   * SnapshotType is the type of the snapshot to be backed up.
   *
   * @schema DataUploadSpec#snapshotType
   */
  readonly snapshotType: string;

  /**
   * SourceNamespace is the original namespace where the volume is backed up from.
   * It is the same namespace for SourcePVC and CSI namespaced objects.
   *
   * @schema DataUploadSpec#sourceNamespace
   */
  readonly sourceNamespace: string;

  /**
   * SourcePVC is the name of the PVC which the snapshot is taken for.
   *
   * @schema DataUploadSpec#sourcePVC
   */
  readonly sourcePvc: string;
}

/**
 * Converts an object of type 'DataUploadSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DataUploadSpec(obj: DataUploadSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    backupStorageLocation: obj.backupStorageLocation,
    cancel: obj.cancel,
    csiSnapshot: toJson_DataUploadSpecCsiSnapshot(obj.csiSnapshot),
    dataMoverConfig:
      obj.dataMoverConfig === undefined
        ? undefined
        : Object.entries(obj.dataMoverConfig).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    datamover: obj.datamover,
    operationTimeout: obj.operationTimeout,
    snapshotType: obj.snapshotType,
    sourceNamespace: obj.sourceNamespace,
    sourcePVC: obj.sourcePvc,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * If SnapshotType is CSI, CSISnapshot provides the information of the CSI snapshot.
 *
 * @schema DataUploadSpecCsiSnapshot
 */
export interface DataUploadSpecCsiSnapshot {
  /**
   * Driver is the driver used by the VolumeSnapshotContent
   *
   * @schema DataUploadSpecCsiSnapshot#driver
   */
  readonly driver?: string;

  /**
   * SnapshotClass is the name of the snapshot class that the volume snapshot is created with
   *
   * @schema DataUploadSpecCsiSnapshot#snapshotClass
   */
  readonly snapshotClass?: string;

  /**
   * StorageClass is the name of the storage class of the PVC that the volume snapshot is created from
   *
   * @schema DataUploadSpecCsiSnapshot#storageClass
   */
  readonly storageClass: string;

  /**
   * VolumeSnapshot is the name of the volume snapshot to be backed up
   *
   * @schema DataUploadSpecCsiSnapshot#volumeSnapshot
   */
  readonly volumeSnapshot: string;
}

/**
 * Converts an object of type 'DataUploadSpecCsiSnapshot' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DataUploadSpecCsiSnapshot(
  obj: DataUploadSpecCsiSnapshot | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    driver: obj.driver,
    snapshotClass: obj.snapshotClass,
    storageClass: obj.storageClass,
    volumeSnapshot: obj.volumeSnapshot,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeleteBackupRequest is a request to delete one or more backups.
 *
 * @schema DeleteBackupRequest
 */
export class DeleteBackupRequest extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DeleteBackupRequest"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v1",
    kind: "DeleteBackupRequest",
  };

  /**
   * Renders a Kubernetes manifest for "DeleteBackupRequest".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeleteBackupRequestProps = {}): any {
    return {
      ...DeleteBackupRequest.GVK,
      ...toJson_DeleteBackupRequestProps(props),
    };
  }

  /**
   * Defines a "DeleteBackupRequest" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeleteBackupRequestProps = {}) {
    super(scope, id, {
      ...DeleteBackupRequest.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...DeleteBackupRequest.GVK,
      ...toJson_DeleteBackupRequestProps(resolved),
    };
  }
}

/**
 * DeleteBackupRequest is a request to delete one or more backups.
 *
 * @schema DeleteBackupRequest
 */
export interface DeleteBackupRequestProps {
  /**
   * @schema DeleteBackupRequest#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeleteBackupRequestSpec is the specification for which backups to delete.
   *
   * @schema DeleteBackupRequest#spec
   */
  readonly spec?: DeleteBackupRequestSpec;
}

/**
 * Converts an object of type 'DeleteBackupRequestProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DeleteBackupRequestProps(
  obj: DeleteBackupRequestProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_DeleteBackupRequestSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeleteBackupRequestSpec is the specification for which backups to delete.
 *
 * @schema DeleteBackupRequestSpec
 */
export interface DeleteBackupRequestSpec {
  /**
   * @schema DeleteBackupRequestSpec#backupName
   */
  readonly backupName: string;
}

/**
 * Converts an object of type 'DeleteBackupRequestSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DeleteBackupRequestSpec(
  obj: DeleteBackupRequestSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    backupName: obj.backupName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownloadRequest is a request to download an artifact from backup object storage, such as a backup
log file.
 *
 * @schema DownloadRequest
 */
export class DownloadRequest extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DownloadRequest"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v1",
    kind: "DownloadRequest",
  };

  /**
   * Renders a Kubernetes manifest for "DownloadRequest".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DownloadRequestProps = {}): any {
    return {
      ...DownloadRequest.GVK,
      ...toJson_DownloadRequestProps(props),
    };
  }

  /**
   * Defines a "DownloadRequest" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DownloadRequestProps = {}) {
    super(scope, id, {
      ...DownloadRequest.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...DownloadRequest.GVK,
      ...toJson_DownloadRequestProps(resolved),
    };
  }
}

/**
 * DownloadRequest is a request to download an artifact from backup object storage, such as a backup
 * log file.
 *
 * @schema DownloadRequest
 */
export interface DownloadRequestProps {
  /**
   * @schema DownloadRequest#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DownloadRequestSpec is the specification for a download request.
   *
   * @schema DownloadRequest#spec
   */
  readonly spec?: DownloadRequestSpec;
}

/**
 * Converts an object of type 'DownloadRequestProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DownloadRequestProps(obj: DownloadRequestProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_DownloadRequestSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DownloadRequestSpec is the specification for a download request.
 *
 * @schema DownloadRequestSpec
 */
export interface DownloadRequestSpec {
  /**
   * Target is what to download (e.g. logs for a backup).
   *
   * @schema DownloadRequestSpec#target
   */
  readonly target: DownloadRequestSpecTarget;
}

/**
 * Converts an object of type 'DownloadRequestSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DownloadRequestSpec(obj: DownloadRequestSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    target: toJson_DownloadRequestSpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Target is what to download (e.g. logs for a backup).
 *
 * @schema DownloadRequestSpecTarget
 */
export interface DownloadRequestSpecTarget {
  /**
   * Kind is the type of file to download.
   *
   * @schema DownloadRequestSpecTarget#kind
   */
  readonly kind: DownloadRequestSpecTargetKind;

  /**
   * Name is the name of the Kubernetes resource with which the file is associated.
   *
   * @schema DownloadRequestSpecTarget#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'DownloadRequestSpecTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DownloadRequestSpecTarget(
  obj: DownloadRequestSpecTarget | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind is the type of file to download.
 *
 * @schema DownloadRequestSpecTargetKind
 */
export enum DownloadRequestSpecTargetKind {
  /** BackupLog */
  BACKUP_LOG = "BackupLog",
  /** BackupContents */
  BACKUP_CONTENTS = "BackupContents",
  /** BackupVolumeSnapshots */
  BACKUP_VOLUME_SNAPSHOTS = "BackupVolumeSnapshots",
  /** BackupItemOperations */
  BACKUP_ITEM_OPERATIONS = "BackupItemOperations",
  /** BackupResourceList */
  BACKUP_RESOURCE_LIST = "BackupResourceList",
  /** BackupResults */
  BACKUP_RESULTS = "BackupResults",
  /** RestoreLog */
  RESTORE_LOG = "RestoreLog",
  /** RestoreResults */
  RESTORE_RESULTS = "RestoreResults",
  /** RestoreResourceList */
  RESTORE_RESOURCE_LIST = "RestoreResourceList",
  /** RestoreItemOperations */
  RESTORE_ITEM_OPERATIONS = "RestoreItemOperations",
  /** CSIBackupVolumeSnapshots */
  CSI_BACKUP_VOLUME_SNAPSHOTS = "CSIBackupVolumeSnapshots",
  /** CSIBackupVolumeSnapshotContents */
  CSI_BACKUP_VOLUME_SNAPSHOT_CONTENTS = "CSIBackupVolumeSnapshotContents",
  /** BackupVolumeInfos */
  BACKUP_VOLUME_INFOS = "BackupVolumeInfos",
  /** RestoreVolumeInfo */
  RESTORE_VOLUME_INFO = "RestoreVolumeInfo",
}

/**
 *
 *
 * @schema PodVolumeBackup
 */
export class PodVolumeBackup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PodVolumeBackup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v1",
    kind: "PodVolumeBackup",
  };

  /**
   * Renders a Kubernetes manifest for "PodVolumeBackup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PodVolumeBackupProps = {}): any {
    return {
      ...PodVolumeBackup.GVK,
      ...toJson_PodVolumeBackupProps(props),
    };
  }

  /**
   * Defines a "PodVolumeBackup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PodVolumeBackupProps = {}) {
    super(scope, id, {
      ...PodVolumeBackup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...PodVolumeBackup.GVK,
      ...toJson_PodVolumeBackupProps(resolved),
    };
  }
}

/**
 * @schema PodVolumeBackup
 */
export interface PodVolumeBackupProps {
  /**
   * @schema PodVolumeBackup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PodVolumeBackupSpec is the specification for a PodVolumeBackup.
   *
   * @schema PodVolumeBackup#spec
   */
  readonly spec?: PodVolumeBackupSpec;
}

/**
 * Converts an object of type 'PodVolumeBackupProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PodVolumeBackupProps(obj: PodVolumeBackupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_PodVolumeBackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodVolumeBackupSpec is the specification for a PodVolumeBackup.
 *
 * @schema PodVolumeBackupSpec
 */
export interface PodVolumeBackupSpec {
  /**
   * BackupStorageLocation is the name of the backup storage location
   * where the backup repository is stored.
   *
   * @schema PodVolumeBackupSpec#backupStorageLocation
   */
  readonly backupStorageLocation: string;

  /**
   * Cancel indicates request to cancel the ongoing PodVolumeBackup. It can be set
   * when the PodVolumeBackup is in InProgress phase
   *
   * @schema PodVolumeBackupSpec#cancel
   */
  readonly cancel?: boolean;

  /**
   * Node is the name of the node that the Pod is running on.
   *
   * @schema PodVolumeBackupSpec#node
   */
  readonly node: string;

  /**
   * Pod is a reference to the pod containing the volume to be backed up.
   *
   * @schema PodVolumeBackupSpec#pod
   */
  readonly pod: PodVolumeBackupSpecPod;

  /**
   * RepoIdentifier is the backup repository identifier.
   *
   * @schema PodVolumeBackupSpec#repoIdentifier
   */
  readonly repoIdentifier: string;

  /**
   * Tags are a map of key-value pairs that should be applied to the
   * volume backup as tags.
   *
   * @schema PodVolumeBackupSpec#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * UploaderSettings are a map of key-value pairs that should be applied to the
   * uploader configuration.
   *
   * @schema PodVolumeBackupSpec#uploaderSettings
   */
  readonly uploaderSettings?: { [key: string]: string };

  /**
   * UploaderType is the type of the uploader to handle the data transfer.
   *
   * @schema PodVolumeBackupSpec#uploaderType
   */
  readonly uploaderType?: PodVolumeBackupSpecUploaderType;

  /**
   * Volume is the name of the volume within the Pod to be backed
   * up.
   *
   * @schema PodVolumeBackupSpec#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'PodVolumeBackupSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PodVolumeBackupSpec(obj: PodVolumeBackupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    backupStorageLocation: obj.backupStorageLocation,
    cancel: obj.cancel,
    node: obj.node,
    pod: toJson_PodVolumeBackupSpecPod(obj.pod),
    repoIdentifier: obj.repoIdentifier,
    tags:
      obj.tags === undefined
        ? undefined
        : Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    uploaderSettings:
      obj.uploaderSettings === undefined
        ? undefined
        : Object.entries(obj.uploaderSettings).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    uploaderType: obj.uploaderType,
    volume: obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Pod is a reference to the pod containing the volume to be backed up.
 *
 * @schema PodVolumeBackupSpecPod
 */
export interface PodVolumeBackupSpecPod {
  /**
   * API version of the referent.
   *
   * @schema PodVolumeBackupSpecPod#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * If referring to a piece of an object instead of an entire object, this string
   * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
   * For example, if the object reference is to a container within a pod, this would take on a value like:
   * "spec.containers{name}" (where "name" refers to the name of the container that triggered
   * the event) or if no container name is specified "spec.containers[2]" (container with
   * index 2 in this pod). This syntax is chosen only to have some well-defined way of
   * referencing a part of an object.
   *
   * @schema PodVolumeBackupSpecPod#fieldPath
   */
  readonly fieldPath?: string;

  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema PodVolumeBackupSpecPod#kind
   */
  readonly kind?: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodVolumeBackupSpecPod#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema PodVolumeBackupSpecPod#namespace
   */
  readonly namespace?: string;

  /**
   * Specific resourceVersion to which this reference is made, if any.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   *
   * @schema PodVolumeBackupSpecPod#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * UID of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
   *
   * @schema PodVolumeBackupSpecPod#uid
   */
  readonly uid?: string;
}

/**
 * Converts an object of type 'PodVolumeBackupSpecPod' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PodVolumeBackupSpecPod(
  obj: PodVolumeBackupSpecPod | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
    resourceVersion: obj.resourceVersion,
    uid: obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UploaderType is the type of the uploader to handle the data transfer.
 *
 * @schema PodVolumeBackupSpecUploaderType
 */
export enum PodVolumeBackupSpecUploaderType {
  /** kopia */
  KOPIA = "kopia",
  /** restic */
  RESTIC = "restic",
}

/**
 *
 *
 * @schema PodVolumeRestore
 */
export class PodVolumeRestore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PodVolumeRestore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v1",
    kind: "PodVolumeRestore",
  };

  /**
   * Renders a Kubernetes manifest for "PodVolumeRestore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PodVolumeRestoreProps = {}): any {
    return {
      ...PodVolumeRestore.GVK,
      ...toJson_PodVolumeRestoreProps(props),
    };
  }

  /**
   * Defines a "PodVolumeRestore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PodVolumeRestoreProps = {}) {
    super(scope, id, {
      ...PodVolumeRestore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...PodVolumeRestore.GVK,
      ...toJson_PodVolumeRestoreProps(resolved),
    };
  }
}

/**
 * @schema PodVolumeRestore
 */
export interface PodVolumeRestoreProps {
  /**
   * @schema PodVolumeRestore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PodVolumeRestoreSpec is the specification for a PodVolumeRestore.
   *
   * @schema PodVolumeRestore#spec
   */
  readonly spec?: PodVolumeRestoreSpec;
}

/**
 * Converts an object of type 'PodVolumeRestoreProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PodVolumeRestoreProps(obj: PodVolumeRestoreProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_PodVolumeRestoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PodVolumeRestoreSpec is the specification for a PodVolumeRestore.
 *
 * @schema PodVolumeRestoreSpec
 */
export interface PodVolumeRestoreSpec {
  /**
   * BackupStorageLocation is the name of the backup storage location
   * where the backup repository is stored.
   *
   * @schema PodVolumeRestoreSpec#backupStorageLocation
   */
  readonly backupStorageLocation: string;

  /**
   * Cancel indicates request to cancel the ongoing PodVolumeRestore. It can be set
   * when the PodVolumeRestore is in InProgress phase
   *
   * @schema PodVolumeRestoreSpec#cancel
   */
  readonly cancel?: boolean;

  /**
   * Pod is a reference to the pod containing the volume to be restored.
   *
   * @schema PodVolumeRestoreSpec#pod
   */
  readonly pod: PodVolumeRestoreSpecPod;

  /**
   * RepoIdentifier is the backup repository identifier.
   *
   * @schema PodVolumeRestoreSpec#repoIdentifier
   */
  readonly repoIdentifier: string;

  /**
   * SnapshotID is the ID of the volume snapshot to be restored.
   *
   * @schema PodVolumeRestoreSpec#snapshotID
   */
  readonly snapshotId: string;

  /**
   * SourceNamespace is the original namespace for namaspace mapping.
   *
   * @schema PodVolumeRestoreSpec#sourceNamespace
   */
  readonly sourceNamespace: string;

  /**
   * UploaderSettings are a map of key-value pairs that should be applied to the
   * uploader configuration.
   *
   * @schema PodVolumeRestoreSpec#uploaderSettings
   */
  readonly uploaderSettings?: { [key: string]: string };

  /**
   * UploaderType is the type of the uploader to handle the data transfer.
   *
   * @schema PodVolumeRestoreSpec#uploaderType
   */
  readonly uploaderType?: PodVolumeRestoreSpecUploaderType;

  /**
   * Volume is the name of the volume within the Pod to be restored.
   *
   * @schema PodVolumeRestoreSpec#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'PodVolumeRestoreSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PodVolumeRestoreSpec(obj: PodVolumeRestoreSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    backupStorageLocation: obj.backupStorageLocation,
    cancel: obj.cancel,
    pod: toJson_PodVolumeRestoreSpecPod(obj.pod),
    repoIdentifier: obj.repoIdentifier,
    snapshotID: obj.snapshotId,
    sourceNamespace: obj.sourceNamespace,
    uploaderSettings:
      obj.uploaderSettings === undefined
        ? undefined
        : Object.entries(obj.uploaderSettings).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    uploaderType: obj.uploaderType,
    volume: obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Pod is a reference to the pod containing the volume to be restored.
 *
 * @schema PodVolumeRestoreSpecPod
 */
export interface PodVolumeRestoreSpecPod {
  /**
   * API version of the referent.
   *
   * @schema PodVolumeRestoreSpecPod#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * If referring to a piece of an object instead of an entire object, this string
   * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
   * For example, if the object reference is to a container within a pod, this would take on a value like:
   * "spec.containers{name}" (where "name" refers to the name of the container that triggered
   * the event) or if no container name is specified "spec.containers[2]" (container with
   * index 2 in this pod). This syntax is chosen only to have some well-defined way of
   * referencing a part of an object.
   *
   * @schema PodVolumeRestoreSpecPod#fieldPath
   */
  readonly fieldPath?: string;

  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema PodVolumeRestoreSpecPod#kind
   */
  readonly kind?: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PodVolumeRestoreSpecPod#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema PodVolumeRestoreSpecPod#namespace
   */
  readonly namespace?: string;

  /**
   * Specific resourceVersion to which this reference is made, if any.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   *
   * @schema PodVolumeRestoreSpecPod#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * UID of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
   *
   * @schema PodVolumeRestoreSpecPod#uid
   */
  readonly uid?: string;
}

/**
 * Converts an object of type 'PodVolumeRestoreSpecPod' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PodVolumeRestoreSpecPod(
  obj: PodVolumeRestoreSpecPod | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiVersion: obj.apiVersion,
    fieldPath: obj.fieldPath,
    kind: obj.kind,
    name: obj.name,
    namespace: obj.namespace,
    resourceVersion: obj.resourceVersion,
    uid: obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UploaderType is the type of the uploader to handle the data transfer.
 *
 * @schema PodVolumeRestoreSpecUploaderType
 */
export enum PodVolumeRestoreSpecUploaderType {
  /** kopia */
  KOPIA = "kopia",
  /** restic */
  RESTIC = "restic",
}

/**
 * Restore is a Velero resource that represents the application of
resources from a Velero backup to a target Kubernetes cluster.
 *
 * @schema Restore
 */
export class Restore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Restore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v1",
    kind: "Restore",
  };

  /**
   * Renders a Kubernetes manifest for "Restore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RestoreProps = {}): any {
    return {
      ...Restore.GVK,
      ...toJson_RestoreProps(props),
    };
  }

  /**
   * Defines a "Restore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RestoreProps = {}) {
    super(scope, id, {
      ...Restore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Restore.GVK,
      ...toJson_RestoreProps(resolved),
    };
  }
}

/**
 * Restore is a Velero resource that represents the application of
 * resources from a Velero backup to a target Kubernetes cluster.
 *
 * @schema Restore
 */
export interface RestoreProps {
  /**
   * @schema Restore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RestoreSpec defines the specification for a Velero restore.
   *
   * @schema Restore#spec
   */
  readonly spec?: RestoreSpec;
}

/**
 * Converts an object of type 'RestoreProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreProps(obj: RestoreProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_RestoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RestoreSpec defines the specification for a Velero restore.
 *
 * @schema RestoreSpec
 */
export interface RestoreSpec {
  /**
   * BackupName is the unique name of the Velero backup to restore
   * from.
   *
   * @schema RestoreSpec#backupName
   */
  readonly backupName?: string;

  /**
   * ExcludedNamespaces contains a list of namespaces that are not
   * included in the restore.
   *
   * @schema RestoreSpec#excludedNamespaces
   */
  readonly excludedNamespaces?: string[];

  /**
   * ExcludedResources is a slice of resource names that are not
   * included in the restore.
   *
   * @schema RestoreSpec#excludedResources
   */
  readonly excludedResources?: string[];

  /**
   * ExistingResourcePolicy specifies the restore behavior for the Kubernetes resource to be restored
   *
   * @schema RestoreSpec#existingResourcePolicy
   */
  readonly existingResourcePolicy?: string;

  /**
   * Hooks represent custom behaviors that should be executed during or post restore.
   *
   * @schema RestoreSpec#hooks
   */
  readonly hooks?: RestoreSpecHooks;

  /**
   * IncludeClusterResources specifies whether cluster-scoped resources
   * should be included for consideration in the restore. If null, defaults
   * to true.
   *
   * @schema RestoreSpec#includeClusterResources
   */
  readonly includeClusterResources?: boolean;

  /**
   * IncludedNamespaces is a slice of namespace names to include objects
   * from. If empty, all namespaces are included.
   *
   * @schema RestoreSpec#includedNamespaces
   */
  readonly includedNamespaces?: string[];

  /**
   * IncludedResources is a slice of resource names to include
   * in the restore. If empty, all resources in the backup are included.
   *
   * @schema RestoreSpec#includedResources
   */
  readonly includedResources?: string[];

  /**
   * ItemOperationTimeout specifies the time used to wait for RestoreItemAction operations
   * The default value is 4 hour.
   *
   * @schema RestoreSpec#itemOperationTimeout
   */
  readonly itemOperationTimeout?: string;

  /**
   * LabelSelector is a metav1.LabelSelector to filter with
   * when restoring individual objects from the backup. If empty
   * or nil, all objects are included. Optional.
   *
   * @schema RestoreSpec#labelSelector
   */
  readonly labelSelector?: RestoreSpecLabelSelector;

  /**
   * NamespaceMapping is a map of source namespace names
   * to target namespace names to restore into. Any source
   * namespaces not included in the map will be restored into
   * namespaces of the same name.
   *
   * @schema RestoreSpec#namespaceMapping
   */
  readonly namespaceMapping?: { [key: string]: string };

  /**
   * OrLabelSelectors is list of metav1.LabelSelector to filter with
   * when restoring individual objects from the backup. If multiple provided
   * they will be joined by the OR operator. LabelSelector as well as
   * OrLabelSelectors cannot co-exist in restore request, only one of them
   * can be used
   *
   * @schema RestoreSpec#orLabelSelectors
   */
  readonly orLabelSelectors?: RestoreSpecOrLabelSelectors[];

  /**
   * PreserveNodePorts specifies whether to restore old nodePorts from backup.
   *
   * @schema RestoreSpec#preserveNodePorts
   */
  readonly preserveNodePorts?: boolean;

  /**
   * ResourceModifier specifies the reference to JSON resource patches that should be applied to resources before restoration.
   *
   * @schema RestoreSpec#resourceModifier
   */
  readonly resourceModifier?: RestoreSpecResourceModifier;

  /**
   * RestorePVs specifies whether to restore all included
   * PVs from snapshot
   *
   * @schema RestoreSpec#restorePVs
   */
  readonly restorePVs?: boolean;

  /**
   * RestoreStatus specifies which resources we should restore the status
   * field. If nil, no objects are included. Optional.
   *
   * @schema RestoreSpec#restoreStatus
   */
  readonly restoreStatus?: RestoreSpecRestoreStatus;

  /**
   * ScheduleName is the unique name of the Velero schedule to restore
   * from. If specified, and BackupName is empty, Velero will restore
   * from the most recent successful backup created from this schedule.
   *
   * @schema RestoreSpec#scheduleName
   */
  readonly scheduleName?: string;

  /**
   * UploaderConfig specifies the configuration for the restore.
   *
   * @schema RestoreSpec#uploaderConfig
   */
  readonly uploaderConfig?: RestoreSpecUploaderConfig;
}

/**
 * Converts an object of type 'RestoreSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpec(obj: RestoreSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    backupName: obj.backupName,
    excludedNamespaces: obj.excludedNamespaces?.map((y) => y),
    excludedResources: obj.excludedResources?.map((y) => y),
    existingResourcePolicy: obj.existingResourcePolicy,
    hooks: toJson_RestoreSpecHooks(obj.hooks),
    includeClusterResources: obj.includeClusterResources,
    includedNamespaces: obj.includedNamespaces?.map((y) => y),
    includedResources: obj.includedResources?.map((y) => y),
    itemOperationTimeout: obj.itemOperationTimeout,
    labelSelector: toJson_RestoreSpecLabelSelector(obj.labelSelector),
    namespaceMapping:
      obj.namespaceMapping === undefined
        ? undefined
        : Object.entries(obj.namespaceMapping).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    orLabelSelectors: obj.orLabelSelectors?.map((y) => toJson_RestoreSpecOrLabelSelectors(y)),
    preserveNodePorts: obj.preserveNodePorts,
    resourceModifier: toJson_RestoreSpecResourceModifier(obj.resourceModifier),
    restorePVs: obj.restorePVs,
    restoreStatus: toJson_RestoreSpecRestoreStatus(obj.restoreStatus),
    scheduleName: obj.scheduleName,
    uploaderConfig: toJson_RestoreSpecUploaderConfig(obj.uploaderConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hooks represent custom behaviors that should be executed during or post restore.
 *
 * @schema RestoreSpecHooks
 */
export interface RestoreSpecHooks {
  /**
   * @schema RestoreSpecHooks#resources
   */
  readonly resources?: RestoreSpecHooksResources[];
}

/**
 * Converts an object of type 'RestoreSpecHooks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecHooks(obj: RestoreSpecHooks | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resources: obj.resources?.map((y) => toJson_RestoreSpecHooksResources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a metav1.LabelSelector to filter with
 * when restoring individual objects from the backup. If empty
 * or nil, all objects are included. Optional.
 *
 * @schema RestoreSpecLabelSelector
 */
export interface RestoreSpecLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RestoreSpecLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RestoreSpecLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RestoreSpecLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'RestoreSpecLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecLabelSelector(
  obj: RestoreSpecLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) => toJson_RestoreSpecLabelSelectorMatchExpressions(y)),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema RestoreSpecOrLabelSelectors
 */
export interface RestoreSpecOrLabelSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RestoreSpecOrLabelSelectors#matchExpressions
   */
  readonly matchExpressions?: RestoreSpecOrLabelSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RestoreSpecOrLabelSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'RestoreSpecOrLabelSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecOrLabelSelectors(
  obj: RestoreSpecOrLabelSelectors | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) => toJson_RestoreSpecOrLabelSelectorsMatchExpressions(y)),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourceModifier specifies the reference to JSON resource patches that should be applied to resources before restoration.
 *
 * @schema RestoreSpecResourceModifier
 */
export interface RestoreSpecResourceModifier {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema RestoreSpecResourceModifier#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RestoreSpecResourceModifier#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RestoreSpecResourceModifier#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'RestoreSpecResourceModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecResourceModifier(
  obj: RestoreSpecResourceModifier | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RestoreStatus specifies which resources we should restore the status
 * field. If nil, no objects are included. Optional.
 *
 * @schema RestoreSpecRestoreStatus
 */
export interface RestoreSpecRestoreStatus {
  /**
   * ExcludedResources specifies the resources to which will not restore the status.
   *
   * @schema RestoreSpecRestoreStatus#excludedResources
   */
  readonly excludedResources?: string[];

  /**
   * IncludedResources specifies the resources to which will restore the status.
   * If empty, it applies to all resources.
   *
   * @schema RestoreSpecRestoreStatus#includedResources
   */
  readonly includedResources?: string[];
}

/**
 * Converts an object of type 'RestoreSpecRestoreStatus' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecRestoreStatus(
  obj: RestoreSpecRestoreStatus | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    excludedResources: obj.excludedResources?.map((y) => y),
    includedResources: obj.includedResources?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UploaderConfig specifies the configuration for the restore.
 *
 * @schema RestoreSpecUploaderConfig
 */
export interface RestoreSpecUploaderConfig {
  /**
   * ParallelFilesDownload is the concurrency number setting for restore.
   *
   * @schema RestoreSpecUploaderConfig#parallelFilesDownload
   */
  readonly parallelFilesDownload?: number;

  /**
   * WriteSparseFiles is a flag to indicate whether write files sparsely or not.
   *
   * @schema RestoreSpecUploaderConfig#writeSparseFiles
   */
  readonly writeSparseFiles?: boolean;
}

/**
 * Converts an object of type 'RestoreSpecUploaderConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecUploaderConfig(
  obj: RestoreSpecUploaderConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    parallelFilesDownload: obj.parallelFilesDownload,
    writeSparseFiles: obj.writeSparseFiles,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RestoreResourceHookSpec defines one or more RestoreResrouceHooks that should be executed based on
 * the rules defined for namespaces, resources, and label selector.
 *
 * @schema RestoreSpecHooksResources
 */
export interface RestoreSpecHooksResources {
  /**
   * ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
   *
   * @schema RestoreSpecHooksResources#excludedNamespaces
   */
  readonly excludedNamespaces?: string[];

  /**
   * ExcludedResources specifies the resources to which this hook spec does not apply.
   *
   * @schema RestoreSpecHooksResources#excludedResources
   */
  readonly excludedResources?: string[];

  /**
   * IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies
   * to all namespaces.
   *
   * @schema RestoreSpecHooksResources#includedNamespaces
   */
  readonly includedNamespaces?: string[];

  /**
   * IncludedResources specifies the resources to which this hook spec applies. If empty, it applies
   * to all resources.
   *
   * @schema RestoreSpecHooksResources#includedResources
   */
  readonly includedResources?: string[];

  /**
   * LabelSelector, if specified, filters the resources to which this hook spec applies.
   *
   * @schema RestoreSpecHooksResources#labelSelector
   */
  readonly labelSelector?: RestoreSpecHooksResourcesLabelSelector;

  /**
   * Name is the name of this hook.
   *
   * @schema RestoreSpecHooksResources#name
   */
  readonly name: string;

  /**
   * PostHooks is a list of RestoreResourceHooks to execute during and after restoring a resource.
   *
   * @schema RestoreSpecHooksResources#postHooks
   */
  readonly postHooks?: RestoreSpecHooksResourcesPostHooks[];
}

/**
 * Converts an object of type 'RestoreSpecHooksResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecHooksResources(
  obj: RestoreSpecHooksResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    excludedNamespaces: obj.excludedNamespaces?.map((y) => y),
    excludedResources: obj.excludedResources?.map((y) => y),
    includedNamespaces: obj.includedNamespaces?.map((y) => y),
    includedResources: obj.includedResources?.map((y) => y),
    labelSelector: toJson_RestoreSpecHooksResourcesLabelSelector(obj.labelSelector),
    name: obj.name,
    postHooks: obj.postHooks?.map((y) => toJson_RestoreSpecHooksResourcesPostHooks(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema RestoreSpecLabelSelectorMatchExpressions
 */
export interface RestoreSpecLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RestoreSpecLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RestoreSpecLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema RestoreSpecLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'RestoreSpecLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecLabelSelectorMatchExpressions(
  obj: RestoreSpecLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema RestoreSpecOrLabelSelectorsMatchExpressions
 */
export interface RestoreSpecOrLabelSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RestoreSpecOrLabelSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RestoreSpecOrLabelSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema RestoreSpecOrLabelSelectorsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'RestoreSpecOrLabelSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecOrLabelSelectorsMatchExpressions(
  obj: RestoreSpecOrLabelSelectorsMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector, if specified, filters the resources to which this hook spec applies.
 *
 * @schema RestoreSpecHooksResourcesLabelSelector
 */
export interface RestoreSpecHooksResourcesLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RestoreSpecHooksResourcesLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RestoreSpecHooksResourcesLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RestoreSpecHooksResourcesLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'RestoreSpecHooksResourcesLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecHooksResourcesLabelSelector(
  obj: RestoreSpecHooksResourcesLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_RestoreSpecHooksResourcesLabelSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RestoreResourceHook defines a restore hook for a resource.
 *
 * @schema RestoreSpecHooksResourcesPostHooks
 */
export interface RestoreSpecHooksResourcesPostHooks {
  /**
   * Exec defines an exec restore hook.
   *
   * @schema RestoreSpecHooksResourcesPostHooks#exec
   */
  readonly exec?: RestoreSpecHooksResourcesPostHooksExec;

  /**
   * Init defines an init restore hook.
   *
   * @schema RestoreSpecHooksResourcesPostHooks#init
   */
  readonly init?: RestoreSpecHooksResourcesPostHooksInit;
}

/**
 * Converts an object of type 'RestoreSpecHooksResourcesPostHooks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecHooksResourcesPostHooks(
  obj: RestoreSpecHooksResourcesPostHooks | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_RestoreSpecHooksResourcesPostHooksExec(obj.exec),
    init: toJson_RestoreSpecHooksResourcesPostHooksInit(obj.init),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema RestoreSpecHooksResourcesLabelSelectorMatchExpressions
 */
export interface RestoreSpecHooksResourcesLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RestoreSpecHooksResourcesLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RestoreSpecHooksResourcesLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema RestoreSpecHooksResourcesLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'RestoreSpecHooksResourcesLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecHooksResourcesLabelSelectorMatchExpressions(
  obj: RestoreSpecHooksResourcesLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec defines an exec restore hook.
 *
 * @schema RestoreSpecHooksResourcesPostHooksExec
 */
export interface RestoreSpecHooksResourcesPostHooksExec {
  /**
   * Command is the command and arguments to execute from within a container after a pod has been restored.
   *
   * @schema RestoreSpecHooksResourcesPostHooksExec#command
   */
  readonly command: string[];

  /**
   * Container is the container in the pod where the command should be executed. If not specified,
   * the pod's first container is used.
   *
   * @schema RestoreSpecHooksResourcesPostHooksExec#container
   */
  readonly container?: string;

  /**
   * ExecTimeout defines the maximum amount of time Velero should wait for the hook to complete before
   * considering the execution a failure.
   *
   * @schema RestoreSpecHooksResourcesPostHooksExec#execTimeout
   */
  readonly execTimeout?: string;

  /**
   * OnError specifies how Velero should behave if it encounters an error executing this hook.
   *
   * @schema RestoreSpecHooksResourcesPostHooksExec#onError
   */
  readonly onError?: RestoreSpecHooksResourcesPostHooksExecOnError;

  /**
   * WaitForReady ensures command will be launched when container is Ready instead of Running.
   *
   * @schema RestoreSpecHooksResourcesPostHooksExec#waitForReady
   */
  readonly waitForReady?: boolean;

  /**
   * WaitTimeout defines the maximum amount of time Velero should wait for the container to be Ready
   * before attempting to run the command.
   *
   * @schema RestoreSpecHooksResourcesPostHooksExec#waitTimeout
   */
  readonly waitTimeout?: string;
}

/**
 * Converts an object of type 'RestoreSpecHooksResourcesPostHooksExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecHooksResourcesPostHooksExec(
  obj: RestoreSpecHooksResourcesPostHooksExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
    container: obj.container,
    execTimeout: obj.execTimeout,
    onError: obj.onError,
    waitForReady: obj.waitForReady,
    waitTimeout: obj.waitTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Init defines an init restore hook.
 *
 * @schema RestoreSpecHooksResourcesPostHooksInit
 */
export interface RestoreSpecHooksResourcesPostHooksInit {
  /**
   * InitContainers is list of init containers to be added to a pod during its restore.
   *
   * @schema RestoreSpecHooksResourcesPostHooksInit#initContainers
   */
  readonly initContainers?: any[];

  /**
   * Timeout defines the maximum amount of time Velero should wait for the initContainers to complete.
   *
   * @schema RestoreSpecHooksResourcesPostHooksInit#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'RestoreSpecHooksResourcesPostHooksInit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_RestoreSpecHooksResourcesPostHooksInit(
  obj: RestoreSpecHooksResourcesPostHooksInit | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    initContainers: obj.initContainers?.map((y) => y),
    timeout: obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnError specifies how Velero should behave if it encounters an error executing this hook.
 *
 * @schema RestoreSpecHooksResourcesPostHooksExecOnError
 */
export enum RestoreSpecHooksResourcesPostHooksExecOnError {
  /** Continue */
  CONTINUE = "Continue",
  /** Fail */
  FAIL = "Fail",
}

/**
 * Schedule is a Velero resource that represents a pre-scheduled or
periodic Backup that should be run.
 *
 * @schema Schedule
 */
export class Schedule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Schedule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v1",
    kind: "Schedule",
  };

  /**
   * Renders a Kubernetes manifest for "Schedule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScheduleProps = {}): any {
    return {
      ...Schedule.GVK,
      ...toJson_ScheduleProps(props),
    };
  }

  /**
   * Defines a "Schedule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScheduleProps = {}) {
    super(scope, id, {
      ...Schedule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Schedule.GVK,
      ...toJson_ScheduleProps(resolved),
    };
  }
}

/**
 * Schedule is a Velero resource that represents a pre-scheduled or
 * periodic Backup that should be run.
 *
 * @schema Schedule
 */
export interface ScheduleProps {
  /**
   * @schema Schedule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScheduleSpec defines the specification for a Velero schedule
   *
   * @schema Schedule#spec
   */
  readonly spec?: ScheduleSpec;
}

/**
 * Converts an object of type 'ScheduleProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleProps(obj: ScheduleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ScheduleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ScheduleSpec defines the specification for a Velero schedule
 *
 * @schema ScheduleSpec
 */
export interface ScheduleSpec {
  /**
   * Paused specifies whether the schedule is paused or not
   *
   * @schema ScheduleSpec#paused
   */
  readonly paused?: boolean;

  /**
   * Schedule is a Cron expression defining when to run
   * the Backup.
   *
   * @schema ScheduleSpec#schedule
   */
  readonly schedule: string;

  /**
   * SkipImmediately specifies whether to skip backup if schedule is due immediately from `schedule.status.lastBackup` timestamp when schedule is unpaused or if schedule is new.
   * If true, backup will be skipped immediately when schedule is unpaused if it is due based on .Status.LastBackupTimestamp or schedule is new, and will run at next schedule time.
   * If false, backup will not be skipped immediately when schedule is unpaused, but will run at next schedule time.
   * If empty, will follow server configuration (default: false).
   *
   * @schema ScheduleSpec#skipImmediately
   */
  readonly skipImmediately?: boolean;

  /**
   * Template is the definition of the Backup to be run
   * on the provided schedule
   *
   * @schema ScheduleSpec#template
   */
  readonly template: ScheduleSpecTemplate;

  /**
   * UseOwnerReferencesBackup specifies whether to use
   * OwnerReferences on backups created by this Schedule.
   *
   * @schema ScheduleSpec#useOwnerReferencesInBackup
   */
  readonly useOwnerReferencesInBackup?: boolean;
}

/**
 * Converts an object of type 'ScheduleSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpec(obj: ScheduleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    paused: obj.paused,
    schedule: obj.schedule,
    skipImmediately: obj.skipImmediately,
    template: toJson_ScheduleSpecTemplate(obj.template),
    useOwnerReferencesInBackup: obj.useOwnerReferencesInBackup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template is the definition of the Backup to be run
 * on the provided schedule
 *
 * @schema ScheduleSpecTemplate
 */
export interface ScheduleSpecTemplate {
  /**
   * CSISnapshotTimeout specifies the time used to wait for CSI VolumeSnapshot status turns to
   * ReadyToUse during creation, before returning error as timeout.
   * The default value is 10 minute.
   *
   * @schema ScheduleSpecTemplate#csiSnapshotTimeout
   */
  readonly csiSnapshotTimeout?: string;

  /**
   * DataMover specifies the data mover to be used by the backup.
   * If DataMover is "" or "velero", the built-in data mover will be used.
   *
   * @schema ScheduleSpecTemplate#datamover
   */
  readonly datamover?: string;

  /**
   * DefaultVolumesToFsBackup specifies whether pod volume file system backup should be used
   * for all volumes by default.
   *
   * @schema ScheduleSpecTemplate#defaultVolumesToFsBackup
   */
  readonly defaultVolumesToFsBackup?: boolean;

  /**
   * DefaultVolumesToRestic specifies whether restic should be used to take a
   * backup of all pod volumes by default.
   *
   * Deprecated: this field is no longer used and will be removed entirely in future. Use DefaultVolumesToFsBackup instead.
   *
   * @schema ScheduleSpecTemplate#defaultVolumesToRestic
   */
  readonly defaultVolumesToRestic?: boolean;

  /**
   * ExcludedClusterScopedResources is a slice of cluster-scoped
   * resource type names to exclude from the backup.
   * If set to "*", all cluster-scoped resource types are excluded.
   * The default value is empty.
   *
   * @schema ScheduleSpecTemplate#excludedClusterScopedResources
   */
  readonly excludedClusterScopedResources?: string[];

  /**
   * ExcludedNamespaceScopedResources is a slice of namespace-scoped
   * resource type names to exclude from the backup.
   * If set to "*", all namespace-scoped resource types are excluded.
   * The default value is empty.
   *
   * @schema ScheduleSpecTemplate#excludedNamespaceScopedResources
   */
  readonly excludedNamespaceScopedResources?: string[];

  /**
   * ExcludedNamespaces contains a list of namespaces that are not
   * included in the backup.
   *
   * @schema ScheduleSpecTemplate#excludedNamespaces
   */
  readonly excludedNamespaces?: string[];

  /**
   * ExcludedResources is a slice of resource names that are not
   * included in the backup.
   *
   * @schema ScheduleSpecTemplate#excludedResources
   */
  readonly excludedResources?: string[];

  /**
   * Hooks represent custom behaviors that should be executed at different phases of the backup.
   *
   * @schema ScheduleSpecTemplate#hooks
   */
  readonly hooks?: ScheduleSpecTemplateHooks;

  /**
   * IncludeClusterResources specifies whether cluster-scoped resources
   * should be included for consideration in the backup.
   *
   * @schema ScheduleSpecTemplate#includeClusterResources
   */
  readonly includeClusterResources?: boolean;

  /**
   * IncludedClusterScopedResources is a slice of cluster-scoped
   * resource type names to include in the backup.
   * If set to "*", all cluster-scoped resource types are included.
   * The default value is empty, which means only related
   * cluster-scoped resources are included.
   *
   * @schema ScheduleSpecTemplate#includedClusterScopedResources
   */
  readonly includedClusterScopedResources?: string[];

  /**
   * IncludedNamespaceScopedResources is a slice of namespace-scoped
   * resource type names to include in the backup.
   * The default value is "*".
   *
   * @schema ScheduleSpecTemplate#includedNamespaceScopedResources
   */
  readonly includedNamespaceScopedResources?: string[];

  /**
   * IncludedNamespaces is a slice of namespace names to include objects
   * from. If empty, all namespaces are included.
   *
   * @schema ScheduleSpecTemplate#includedNamespaces
   */
  readonly includedNamespaces?: string[];

  /**
   * IncludedResources is a slice of resource names to include
   * in the backup. If empty, all resources are included.
   *
   * @schema ScheduleSpecTemplate#includedResources
   */
  readonly includedResources?: string[];

  /**
   * ItemOperationTimeout specifies the time used to wait for asynchronous BackupItemAction operations
   * The default value is 4 hour.
   *
   * @schema ScheduleSpecTemplate#itemOperationTimeout
   */
  readonly itemOperationTimeout?: string;

  /**
   * LabelSelector is a metav1.LabelSelector to filter with
   * when adding individual objects to the backup. If empty
   * or nil, all objects are included. Optional.
   *
   * @schema ScheduleSpecTemplate#labelSelector
   */
  readonly labelSelector?: ScheduleSpecTemplateLabelSelector;

  /**
   * @schema ScheduleSpecTemplate#metadata
   */
  readonly metadata?: ScheduleSpecTemplateMetadata;

  /**
   * OrLabelSelectors is list of metav1.LabelSelector to filter with
   * when adding individual objects to the backup. If multiple provided
   * they will be joined by the OR operator. LabelSelector as well as
   * OrLabelSelectors cannot co-exist in backup request, only one of them
   * can be used.
   *
   * @schema ScheduleSpecTemplate#orLabelSelectors
   */
  readonly orLabelSelectors?: ScheduleSpecTemplateOrLabelSelectors[];

  /**
   * OrderedResources specifies the backup order of resources of specific Kind.
   * The map key is the resource name and value is a list of object names separated by commas.
   * Each resource name has format "namespace/objectname".  For cluster resources, simply use "objectname".
   *
   * @schema ScheduleSpecTemplate#orderedResources
   */
  readonly orderedResources?: { [key: string]: string };

  /**
   * ResourcePolicy specifies the referenced resource policies that backup should follow
   *
   * @schema ScheduleSpecTemplate#resourcePolicy
   */
  readonly resourcePolicy?: ScheduleSpecTemplateResourcePolicy;

  /**
   * SnapshotMoveData specifies whether snapshot data should be moved
   *
   * @schema ScheduleSpecTemplate#snapshotMoveData
   */
  readonly snapshotMoveData?: boolean;

  /**
   * SnapshotVolumes specifies whether to take snapshots
   * of any PV's referenced in the set of objects included
   * in the Backup.
   *
   * @schema ScheduleSpecTemplate#snapshotVolumes
   */
  readonly snapshotVolumes?: boolean;

  /**
   * StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
   *
   * @schema ScheduleSpecTemplate#storageLocation
   */
  readonly storageLocation?: string;

  /**
   * TTL is a time.Duration-parseable string describing how long
   * the Backup should be retained for.
   *
   * @schema ScheduleSpecTemplate#ttl
   */
  readonly ttl?: string;

  /**
   * UploaderConfig specifies the configuration for the uploader.
   *
   * @schema ScheduleSpecTemplate#uploaderConfig
   */
  readonly uploaderConfig?: ScheduleSpecTemplateUploaderConfig;

  /**
   * VolumeGroupSnapshotLabelKey specifies the label key to group PVCs under a VGS.
   *
   * @schema ScheduleSpecTemplate#volumeGroupSnapshotLabelKey
   */
  readonly volumeGroupSnapshotLabelKey?: string;

  /**
   * VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
   *
   * @schema ScheduleSpecTemplate#volumeSnapshotLocations
   */
  readonly volumeSnapshotLocations?: string[];
}

/**
 * Converts an object of type 'ScheduleSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplate(obj: ScheduleSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    csiSnapshotTimeout: obj.csiSnapshotTimeout,
    datamover: obj.datamover,
    defaultVolumesToFsBackup: obj.defaultVolumesToFsBackup,
    defaultVolumesToRestic: obj.defaultVolumesToRestic,
    excludedClusterScopedResources: obj.excludedClusterScopedResources?.map((y) => y),
    excludedNamespaceScopedResources: obj.excludedNamespaceScopedResources?.map((y) => y),
    excludedNamespaces: obj.excludedNamespaces?.map((y) => y),
    excludedResources: obj.excludedResources?.map((y) => y),
    hooks: toJson_ScheduleSpecTemplateHooks(obj.hooks),
    includeClusterResources: obj.includeClusterResources,
    includedClusterScopedResources: obj.includedClusterScopedResources?.map((y) => y),
    includedNamespaceScopedResources: obj.includedNamespaceScopedResources?.map((y) => y),
    includedNamespaces: obj.includedNamespaces?.map((y) => y),
    includedResources: obj.includedResources?.map((y) => y),
    itemOperationTimeout: obj.itemOperationTimeout,
    labelSelector: toJson_ScheduleSpecTemplateLabelSelector(obj.labelSelector),
    metadata: toJson_ScheduleSpecTemplateMetadata(obj.metadata),
    orLabelSelectors: obj.orLabelSelectors?.map((y) => toJson_ScheduleSpecTemplateOrLabelSelectors(y)),
    orderedResources:
      obj.orderedResources === undefined
        ? undefined
        : Object.entries(obj.orderedResources).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    resourcePolicy: toJson_ScheduleSpecTemplateResourcePolicy(obj.resourcePolicy),
    snapshotMoveData: obj.snapshotMoveData,
    snapshotVolumes: obj.snapshotVolumes,
    storageLocation: obj.storageLocation,
    ttl: obj.ttl,
    uploaderConfig: toJson_ScheduleSpecTemplateUploaderConfig(obj.uploaderConfig),
    volumeGroupSnapshotLabelKey: obj.volumeGroupSnapshotLabelKey,
    volumeSnapshotLocations: obj.volumeSnapshotLocations?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hooks represent custom behaviors that should be executed at different phases of the backup.
 *
 * @schema ScheduleSpecTemplateHooks
 */
export interface ScheduleSpecTemplateHooks {
  /**
   * Resources are hooks that should be executed when backing up individual instances of a resource.
   *
   * @schema ScheduleSpecTemplateHooks#resources
   */
  readonly resources?: ScheduleSpecTemplateHooksResources[];
}

/**
 * Converts an object of type 'ScheduleSpecTemplateHooks' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateHooks(
  obj: ScheduleSpecTemplateHooks | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    resources: obj.resources?.map((y) => toJson_ScheduleSpecTemplateHooksResources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector is a metav1.LabelSelector to filter with
 * when adding individual objects to the backup. If empty
 * or nil, all objects are included. Optional.
 *
 * @schema ScheduleSpecTemplateLabelSelector
 */
export interface ScheduleSpecTemplateLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ScheduleSpecTemplateLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ScheduleSpecTemplateLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ScheduleSpecTemplateLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ScheduleSpecTemplateLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateLabelSelector(
  obj: ScheduleSpecTemplateLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) => toJson_ScheduleSpecTemplateLabelSelectorMatchExpressions(y)),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ScheduleSpecTemplateMetadata
 */
export interface ScheduleSpecTemplateMetadata {
  /**
   * @schema ScheduleSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ScheduleSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateMetadata(
  obj: ScheduleSpecTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    labels:
      obj.labels === undefined
        ? undefined
        : Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and
 * matchExpressions are ANDed. An empty label selector matches all objects. A null
 * label selector matches no objects.
 *
 * @schema ScheduleSpecTemplateOrLabelSelectors
 */
export interface ScheduleSpecTemplateOrLabelSelectors {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ScheduleSpecTemplateOrLabelSelectors#matchExpressions
   */
  readonly matchExpressions?: ScheduleSpecTemplateOrLabelSelectorsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ScheduleSpecTemplateOrLabelSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ScheduleSpecTemplateOrLabelSelectors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateOrLabelSelectors(
  obj: ScheduleSpecTemplateOrLabelSelectors | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) => toJson_ScheduleSpecTemplateOrLabelSelectorsMatchExpressions(y)),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ResourcePolicy specifies the referenced resource policies that backup should follow
 *
 * @schema ScheduleSpecTemplateResourcePolicy
 */
export interface ScheduleSpecTemplateResourcePolicy {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   *
   * @schema ScheduleSpecTemplateResourcePolicy#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ScheduleSpecTemplateResourcePolicy#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ScheduleSpecTemplateResourcePolicy#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ScheduleSpecTemplateResourcePolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateResourcePolicy(
  obj: ScheduleSpecTemplateResourcePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    apiGroup: obj.apiGroup,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UploaderConfig specifies the configuration for the uploader.
 *
 * @schema ScheduleSpecTemplateUploaderConfig
 */
export interface ScheduleSpecTemplateUploaderConfig {
  /**
   * ParallelFilesUpload is the number of files parallel uploads to perform when using the uploader.
   *
   * @schema ScheduleSpecTemplateUploaderConfig#parallelFilesUpload
   */
  readonly parallelFilesUpload?: number;
}

/**
 * Converts an object of type 'ScheduleSpecTemplateUploaderConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateUploaderConfig(
  obj: ScheduleSpecTemplateUploaderConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    parallelFilesUpload: obj.parallelFilesUpload,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on
 * the rules defined for namespaces, resources, and label selector.
 *
 * @schema ScheduleSpecTemplateHooksResources
 */
export interface ScheduleSpecTemplateHooksResources {
  /**
   * ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
   *
   * @schema ScheduleSpecTemplateHooksResources#excludedNamespaces
   */
  readonly excludedNamespaces?: string[];

  /**
   * ExcludedResources specifies the resources to which this hook spec does not apply.
   *
   * @schema ScheduleSpecTemplateHooksResources#excludedResources
   */
  readonly excludedResources?: string[];

  /**
   * IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies
   * to all namespaces.
   *
   * @schema ScheduleSpecTemplateHooksResources#includedNamespaces
   */
  readonly includedNamespaces?: string[];

  /**
   * IncludedResources specifies the resources to which this hook spec applies. If empty, it applies
   * to all resources.
   *
   * @schema ScheduleSpecTemplateHooksResources#includedResources
   */
  readonly includedResources?: string[];

  /**
   * LabelSelector, if specified, filters the resources to which this hook spec applies.
   *
   * @schema ScheduleSpecTemplateHooksResources#labelSelector
   */
  readonly labelSelector?: ScheduleSpecTemplateHooksResourcesLabelSelector;

  /**
   * Name is the name of this hook.
   *
   * @schema ScheduleSpecTemplateHooksResources#name
   */
  readonly name: string;

  /**
   * PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup.
   * These are executed after all "additional items" from item actions are processed.
   *
   * @schema ScheduleSpecTemplateHooksResources#post
   */
  readonly post?: ScheduleSpecTemplateHooksResourcesPost[];

  /**
   * PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup.
   * These are executed before any "additional items" from item actions are processed.
   *
   * @schema ScheduleSpecTemplateHooksResources#pre
   */
  readonly pre?: ScheduleSpecTemplateHooksResourcesPre[];
}

/**
 * Converts an object of type 'ScheduleSpecTemplateHooksResources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateHooksResources(
  obj: ScheduleSpecTemplateHooksResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    excludedNamespaces: obj.excludedNamespaces?.map((y) => y),
    excludedResources: obj.excludedResources?.map((y) => y),
    includedNamespaces: obj.includedNamespaces?.map((y) => y),
    includedResources: obj.includedResources?.map((y) => y),
    labelSelector: toJson_ScheduleSpecTemplateHooksResourcesLabelSelector(obj.labelSelector),
    name: obj.name,
    post: obj.post?.map((y) => toJson_ScheduleSpecTemplateHooksResourcesPost(y)),
    pre: obj.pre?.map((y) => toJson_ScheduleSpecTemplateHooksResourcesPre(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ScheduleSpecTemplateLabelSelectorMatchExpressions
 */
export interface ScheduleSpecTemplateLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ScheduleSpecTemplateLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ScheduleSpecTemplateLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ScheduleSpecTemplateLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ScheduleSpecTemplateLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateLabelSelectorMatchExpressions(
  obj: ScheduleSpecTemplateLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ScheduleSpecTemplateOrLabelSelectorsMatchExpressions
 */
export interface ScheduleSpecTemplateOrLabelSelectorsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ScheduleSpecTemplateOrLabelSelectorsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ScheduleSpecTemplateOrLabelSelectorsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ScheduleSpecTemplateOrLabelSelectorsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ScheduleSpecTemplateOrLabelSelectorsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateOrLabelSelectorsMatchExpressions(
  obj: ScheduleSpecTemplateOrLabelSelectorsMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * LabelSelector, if specified, filters the resources to which this hook spec applies.
 *
 * @schema ScheduleSpecTemplateHooksResourcesLabelSelector
 */
export interface ScheduleSpecTemplateHooksResourcesLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ScheduleSpecTemplateHooksResourcesLabelSelector#matchExpressions
   */
  readonly matchExpressions?: ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ScheduleSpecTemplateHooksResourcesLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ScheduleSpecTemplateHooksResourcesLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateHooksResourcesLabelSelector(
  obj: ScheduleSpecTemplateHooksResourcesLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    matchExpressions: obj.matchExpressions?.map((y) =>
      toJson_ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions(y),
    ),
    matchLabels:
      obj.matchLabels === undefined
        ? undefined
        : Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackupResourceHook defines a hook for a resource.
 *
 * @schema ScheduleSpecTemplateHooksResourcesPost
 */
export interface ScheduleSpecTemplateHooksResourcesPost {
  /**
   * Exec defines an exec hook.
   *
   * @schema ScheduleSpecTemplateHooksResourcesPost#exec
   */
  readonly exec: ScheduleSpecTemplateHooksResourcesPostExec;
}

/**
 * Converts an object of type 'ScheduleSpecTemplateHooksResourcesPost' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateHooksResourcesPost(
  obj: ScheduleSpecTemplateHooksResourcesPost | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_ScheduleSpecTemplateHooksResourcesPostExec(obj.exec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BackupResourceHook defines a hook for a resource.
 *
 * @schema ScheduleSpecTemplateHooksResourcesPre
 */
export interface ScheduleSpecTemplateHooksResourcesPre {
  /**
   * Exec defines an exec hook.
   *
   * @schema ScheduleSpecTemplateHooksResourcesPre#exec
   */
  readonly exec: ScheduleSpecTemplateHooksResourcesPreExec;
}

/**
 * Converts an object of type 'ScheduleSpecTemplateHooksResourcesPre' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateHooksResourcesPre(
  obj: ScheduleSpecTemplateHooksResourcesPre | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    exec: toJson_ScheduleSpecTemplateHooksResourcesPreExec(obj.exec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions
 */
export interface ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions(
  obj: ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    operator: obj.operator,
    values: obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec defines an exec hook.
 *
 * @schema ScheduleSpecTemplateHooksResourcesPostExec
 */
export interface ScheduleSpecTemplateHooksResourcesPostExec {
  /**
   * Command is the command and arguments to execute.
   *
   * @schema ScheduleSpecTemplateHooksResourcesPostExec#command
   */
  readonly command: string[];

  /**
   * Container is the container in the pod where the command should be executed. If not specified,
   * the pod's first container is used.
   *
   * @schema ScheduleSpecTemplateHooksResourcesPostExec#container
   */
  readonly container?: string;

  /**
   * OnError specifies how Velero should behave if it encounters an error executing this hook.
   *
   * @schema ScheduleSpecTemplateHooksResourcesPostExec#onError
   */
  readonly onError?: ScheduleSpecTemplateHooksResourcesPostExecOnError;

  /**
   * Timeout defines the maximum amount of time Velero should wait for the hook to complete before
   * considering the execution a failure.
   *
   * @schema ScheduleSpecTemplateHooksResourcesPostExec#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'ScheduleSpecTemplateHooksResourcesPostExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateHooksResourcesPostExec(
  obj: ScheduleSpecTemplateHooksResourcesPostExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
    container: obj.container,
    onError: obj.onError,
    timeout: obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Exec defines an exec hook.
 *
 * @schema ScheduleSpecTemplateHooksResourcesPreExec
 */
export interface ScheduleSpecTemplateHooksResourcesPreExec {
  /**
   * Command is the command and arguments to execute.
   *
   * @schema ScheduleSpecTemplateHooksResourcesPreExec#command
   */
  readonly command: string[];

  /**
   * Container is the container in the pod where the command should be executed. If not specified,
   * the pod's first container is used.
   *
   * @schema ScheduleSpecTemplateHooksResourcesPreExec#container
   */
  readonly container?: string;

  /**
   * OnError specifies how Velero should behave if it encounters an error executing this hook.
   *
   * @schema ScheduleSpecTemplateHooksResourcesPreExec#onError
   */
  readonly onError?: ScheduleSpecTemplateHooksResourcesPreExecOnError;

  /**
   * Timeout defines the maximum amount of time Velero should wait for the hook to complete before
   * considering the execution a failure.
   *
   * @schema ScheduleSpecTemplateHooksResourcesPreExec#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'ScheduleSpecTemplateHooksResourcesPreExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ScheduleSpecTemplateHooksResourcesPreExec(
  obj: ScheduleSpecTemplateHooksResourcesPreExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    command: obj.command?.map((y) => y),
    container: obj.container,
    onError: obj.onError,
    timeout: obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnError specifies how Velero should behave if it encounters an error executing this hook.
 *
 * @schema ScheduleSpecTemplateHooksResourcesPostExecOnError
 */
export enum ScheduleSpecTemplateHooksResourcesPostExecOnError {
  /** Continue */
  CONTINUE = "Continue",
  /** Fail */
  FAIL = "Fail",
}

/**
 * OnError specifies how Velero should behave if it encounters an error executing this hook.
 *
 * @schema ScheduleSpecTemplateHooksResourcesPreExecOnError
 */
export enum ScheduleSpecTemplateHooksResourcesPreExecOnError {
  /** Continue */
  CONTINUE = "Continue",
  /** Fail */
  FAIL = "Fail",
}

/**
 * ServerStatusRequest is a request to access current status information about
the Velero server.
 *
 * @schema ServerStatusRequest
 */
export class ServerStatusRequest extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServerStatusRequest"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v1",
    kind: "ServerStatusRequest",
  };

  /**
   * Renders a Kubernetes manifest for "ServerStatusRequest".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServerStatusRequestProps = {}): any {
    return {
      ...ServerStatusRequest.GVK,
      ...toJson_ServerStatusRequestProps(props),
    };
  }

  /**
   * Defines a "ServerStatusRequest" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServerStatusRequestProps = {}) {
    super(scope, id, {
      ...ServerStatusRequest.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServerStatusRequest.GVK,
      ...toJson_ServerStatusRequestProps(resolved),
    };
  }
}

/**
 * ServerStatusRequest is a request to access current status information about
 * the Velero server.
 *
 * @schema ServerStatusRequest
 */
export interface ServerStatusRequestProps {
  /**
   * @schema ServerStatusRequest#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServerStatusRequestSpec is the specification for a ServerStatusRequest.
   *
   * @schema ServerStatusRequest#spec
   */
  readonly spec?: any;
}

/**
 * Converts an object of type 'ServerStatusRequestProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServerStatusRequestProps(
  obj: ServerStatusRequestProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: obj.spec,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeSnapshotLocation is a location where Velero stores volume snapshots.
 *
 * @schema VolumeSnapshotLocation
 */
export class VolumeSnapshotLocation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VolumeSnapshotLocation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "velero.io/v1",
    kind: "VolumeSnapshotLocation",
  };

  /**
   * Renders a Kubernetes manifest for "VolumeSnapshotLocation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VolumeSnapshotLocationProps = {}): any {
    return {
      ...VolumeSnapshotLocation.GVK,
      ...toJson_VolumeSnapshotLocationProps(props),
    };
  }

  /**
   * Defines a "VolumeSnapshotLocation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VolumeSnapshotLocationProps = {}) {
    super(scope, id, {
      ...VolumeSnapshotLocation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VolumeSnapshotLocation.GVK,
      ...toJson_VolumeSnapshotLocationProps(resolved),
    };
  }
}

/**
 * VolumeSnapshotLocation is a location where Velero stores volume snapshots.
 *
 * @schema VolumeSnapshotLocation
 */
export interface VolumeSnapshotLocationProps {
  /**
   * @schema VolumeSnapshotLocation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VolumeSnapshotLocationSpec defines the specification for a Velero VolumeSnapshotLocation.
   *
   * @schema VolumeSnapshotLocation#spec
   */
  readonly spec?: VolumeSnapshotLocationSpec;
}

/**
 * Converts an object of type 'VolumeSnapshotLocationProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeSnapshotLocationProps(
  obj: VolumeSnapshotLocationProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_VolumeSnapshotLocationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeSnapshotLocationSpec defines the specification for a Velero VolumeSnapshotLocation.
 *
 * @schema VolumeSnapshotLocationSpec
 */
export interface VolumeSnapshotLocationSpec {
  /**
   * Config is for provider-specific configuration fields.
   *
   * @schema VolumeSnapshotLocationSpec#config
   */
  readonly config?: { [key: string]: string };

  /**
   * Credential contains the credential information intended to be used with this location
   *
   * @schema VolumeSnapshotLocationSpec#credential
   */
  readonly credential?: VolumeSnapshotLocationSpecCredential;

  /**
   * Provider is the provider of the volume storage.
   *
   * @schema VolumeSnapshotLocationSpec#provider
   */
  readonly provider: string;
}

/**
 * Converts an object of type 'VolumeSnapshotLocationSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeSnapshotLocationSpec(
  obj: VolumeSnapshotLocationSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    config:
      obj.config === undefined
        ? undefined
        : Object.entries(obj.config).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    credential: toJson_VolumeSnapshotLocationSpecCredential(obj.credential),
    provider: obj.provider,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Credential contains the credential information intended to be used with this location
 *
 * @schema VolumeSnapshotLocationSpecCredential
 */
export interface VolumeSnapshotLocationSpecCredential {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema VolumeSnapshotLocationSpecCredential#key
   */
  readonly key: string;

  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VolumeSnapshotLocationSpecCredential#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema VolumeSnapshotLocationSpecCredential#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'VolumeSnapshotLocationSpecCredential' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeSnapshotLocationSpecCredential(
  obj: VolumeSnapshotLocationSpecCredential | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    key: obj.key,
    name: obj.name,
    optional: obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
