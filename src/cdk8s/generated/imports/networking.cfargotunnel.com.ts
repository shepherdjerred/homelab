// @ts-nocheck
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "cdk8s";
import { Construct } from "constructs";

/**
 * AccessTunnel is the Schema for the accesstunnels API
 *
 * @schema AccessTunnel
 */
export class AccessTunnel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessTunnel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "networking.cfargotunnel.com/v1alpha1",
    kind: "AccessTunnel",
  };

  /**
   * Renders a Kubernetes manifest for "AccessTunnel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessTunnelProps = {}): any {
    return {
      ...AccessTunnel.GVK,
      ...toJson_AccessTunnelProps(props),
    };
  }

  /**
   * Defines a "AccessTunnel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessTunnelProps = {}) {
    super(scope, id, {
      ...AccessTunnel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessTunnel.GVK,
      ...toJson_AccessTunnelProps(resolved),
    };
  }
}

/**
 * AccessTunnel is the Schema for the accesstunnels API
 *
 * @schema AccessTunnel
 */
export interface AccessTunnelProps {
  /**
   * @schema AccessTunnel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessTunnelServiceToken defines the access auth if needed
   *
   * @schema AccessTunnel#serviceToken
   */
  readonly serviceToken?: AccessTunnelServiceToken;

  /**
   * AccessTunnelTarget defines the desired state of Access
   *
   * @schema AccessTunnel#target
   */
  readonly target?: AccessTunnelTarget;
}

/**
 * Converts an object of type 'AccessTunnelProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessTunnelProps(obj: AccessTunnelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    serviceToken: toJson_AccessTunnelServiceToken(obj.serviceToken),
    target: toJson_AccessTunnelTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessTunnelServiceToken defines the access auth if needed
 *
 * @schema AccessTunnelServiceToken
 */
export interface AccessTunnelServiceToken {
  /**
   * Key in the secret to use for Access Service Token ID, defaults to CLOUDFLARE_ACCESS_SERVICE_TOKEN_ID
   *
   * @schema AccessTunnelServiceToken#CLOUDFLARE_ACCESS_SERVICE_TOKEN_ID
   */
  readonly cloudflareAccessServiceTokenId?: string;

  /**
   * Key in the secret to use for Access Service Token Token, defaults to CLOUDFLARE_ACCESS_SERVICE_TOKEN_TOKEN
   *
   * @schema AccessTunnelServiceToken#CLOUDFLARE_ACCESS_SERVICE_TOKEN_TOKEN
   */
  readonly cloudflareAccessServiceTokenToken?: string;

  /**
   * Access Service Token Secret
   *
   * @schema AccessTunnelServiceToken#secretRef
   */
  readonly secretRef: string;
}

/**
 * Converts an object of type 'AccessTunnelServiceToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessTunnelServiceToken(
  obj: AccessTunnelServiceToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    CLOUDFLARE_ACCESS_SERVICE_TOKEN_ID: obj.cloudflareAccessServiceTokenId,
    CLOUDFLARE_ACCESS_SERVICE_TOKEN_TOKEN: obj.cloudflareAccessServiceTokenToken,
    secretRef: obj.secretRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessTunnelTarget defines the desired state of Access
 *
 * @schema AccessTunnelTarget
 */
export interface AccessTunnelTarget {
  /**
   * Fqdn specifies the DNS name to access
   * This is not validated and used as provided
   *
   * @schema AccessTunnelTarget#fqdn
   */
  readonly fqdn: string;

  /**
   * cloudflared image to use
   *
   * @schema AccessTunnelTarget#image
   */
  readonly image?: string;

  /**
   * Protocol to forward, better to use TCP?
   *
   * @schema AccessTunnelTarget#protocol
   */
  readonly protocol?: AccessTunnelTargetProtocol;

  /**
   * Service Config
   *
   * @schema AccessTunnelTarget#svc
   */
  readonly svc?: AccessTunnelTargetSvc;
}

/**
 * Converts an object of type 'AccessTunnelTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessTunnelTarget(obj: AccessTunnelTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    fqdn: obj.fqdn,
    image: obj.image,
    protocol: obj.protocol,
    svc: toJson_AccessTunnelTargetSvc(obj.svc),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Protocol to forward, better to use TCP?
 *
 * @schema AccessTunnelTargetProtocol
 */
export enum AccessTunnelTargetProtocol {
  /** tcp */
  TCP = "tcp",
  /** rdp */
  RDP = "rdp",
  /** smb */
  SMB = "smb",
  /** ssh */
  SSH = "ssh",
}

/**
 * Service Config
 *
 * @schema AccessTunnelTargetSvc
 */
export interface AccessTunnelTargetSvc {
  /**
   * Name of the new service to create
   * Defaults to the name of the Access object
   *
   * @default the name of the Access object
   * @schema AccessTunnelTargetSvc#name
   */
  readonly name?: string;

  /**
   * Service port to expose with
   * Defaults to 8000
   *
   * @default 8000
   * @schema AccessTunnelTargetSvc#port
   */
  readonly port?: number;
}

/**
 * Converts an object of type 'AccessTunnelTargetSvc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AccessTunnelTargetSvc(obj: AccessTunnelTargetSvc | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
    port: obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTunnel is the Schema for the clustertunnels API
 *
 * @schema ClusterTunnel
 */
export class ClusterTunnel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterTunnel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "networking.cfargotunnel.com/v1alpha1",
    kind: "ClusterTunnel",
  };

  /**
   * Renders a Kubernetes manifest for "ClusterTunnel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterTunnelProps = {}): any {
    return {
      ...ClusterTunnel.GVK,
      ...toJson_ClusterTunnelProps(props),
    };
  }

  /**
   * Defines a "ClusterTunnel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterTunnelProps = {}) {
    super(scope, id, {
      ...ClusterTunnel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterTunnel.GVK,
      ...toJson_ClusterTunnelProps(resolved),
    };
  }
}

/**
 * ClusterTunnel is the Schema for the clustertunnels API
 *
 * @schema ClusterTunnel
 */
export interface ClusterTunnelProps {
  /**
   * @schema ClusterTunnel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TunnelSpec defines the desired state of Tunnel
   *
   * @schema ClusterTunnel#spec
   */
  readonly spec?: ClusterTunnelSpec;
}

/**
 * Converts an object of type 'ClusterTunnelProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterTunnelProps(obj: ClusterTunnelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ClusterTunnelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TunnelSpec defines the desired state of Tunnel
 *
 * @schema ClusterTunnelSpec
 */
export interface ClusterTunnelSpec {
  /**
   * Cloudflare Credentials
   *
   * @schema ClusterTunnelSpec#cloudflare
   */
  readonly cloudflare: ClusterTunnelSpecCloudflare;

  /**
   * Existing tunnel object.
   * ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema ClusterTunnelSpec#existingTunnel
   */
  readonly existingTunnel?: ClusterTunnelSpecExistingTunnel;

  /**
   * FallbackTarget speficies the target for requests that do not match an ingress. Defaults to http_status:404
   *
   * @default http_status:404
   * @schema ClusterTunnelSpec#fallbackTarget
   */
  readonly fallbackTarget?: string;

  /**
   * Image sets the Cloudflared Image to use. Defaults to the image set during the release of the operator.
   *
   * @default the image set during the release of the operator.
   * @schema ClusterTunnelSpec#image
   */
  readonly image?: string;

  /**
   * New tunnel object.
   * NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema ClusterTunnelSpec#newTunnel
   */
  readonly newTunnel?: ClusterTunnelSpecNewTunnel;

  /**
   * NoTlsVerify disables origin TLS certificate checks when the endpoint is HTTPS.
   *
   * @schema ClusterTunnelSpec#noTlsVerify
   */
  readonly noTlsVerify?: boolean;

  /**
   * NodeSelectors specifies the nodeSelectors to apply to the cloudflared tunnel deployment
   *
   * @schema ClusterTunnelSpec#nodeSelectors
   */
  readonly nodeSelectors?: { [key: string]: string };

  /**
   * OriginCaPool speficies the secret with tls.crt (and other certs as needed to be referred in the service annotation) of the Root CA to be trusted when sending traffic to HTTPS endpoints
   *
   * @schema ClusterTunnelSpec#originCaPool
   */
  readonly originCaPool?: string;

  /**
   * Protocol specifies the protocol to use for the tunnel. Defaults to auto. Options are "auto", "quic" and "http2"
   *
   * @default auto. Options are "auto", "quic" and "http2"
   * @schema ClusterTunnelSpec#protocol
   */
  readonly protocol?: ClusterTunnelSpecProtocol;

  /**
   * Size defines the number of Daemon pods to run for this tunnel
   *
   * @schema ClusterTunnelSpec#size
   */
  readonly size?: number;

  /**
   * Tolerations specifies the tolerations to apply to the cloudflared tunnel deployment
   *
   * @schema ClusterTunnelSpec#tolerations
   */
  readonly tolerations?: ClusterTunnelSpecTolerations[];
}

/**
 * Converts an object of type 'ClusterTunnelSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterTunnelSpec(obj: ClusterTunnelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cloudflare: toJson_ClusterTunnelSpecCloudflare(obj.cloudflare),
    existingTunnel: toJson_ClusterTunnelSpecExistingTunnel(obj.existingTunnel),
    fallbackTarget: obj.fallbackTarget,
    image: obj.image,
    newTunnel: toJson_ClusterTunnelSpecNewTunnel(obj.newTunnel),
    noTlsVerify: obj.noTlsVerify,
    nodeSelectors:
      obj.nodeSelectors === undefined
        ? undefined
        : Object.entries(obj.nodeSelectors).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    originCaPool: obj.originCaPool,
    protocol: obj.protocol,
    size: obj.size,
    tolerations: obj.tolerations?.map((y) => toJson_ClusterTunnelSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cloudflare Credentials
 *
 * @schema ClusterTunnelSpecCloudflare
 */
export interface ClusterTunnelSpecCloudflare {
  /**
   * Key in the secret to use for Cloudflare API Key, defaults to CLOUDFLARE_API_KEY. Needs Email also to be provided.
   * For Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_API_KEY
   */
  readonly cloudflareApiKey?: string;

  /**
   * Key in the secret to use for Cloudflare API token, defaults to CLOUDFLARE_API_TOKEN
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_API_TOKEN
   */
  readonly cloudflareApiToken?: string;

  /**
   * Key in the secret to use as credentials.json for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   */
  readonly cloudflareTunnelCredentialFile?: string;

  /**
   * Key in the secret to use as tunnel secret for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   *
   * @schema ClusterTunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   */
  readonly cloudflareTunnelCredentialSecret?: string;

  /**
   * Account ID in Cloudflare. AccountId and AccountName cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema ClusterTunnelSpecCloudflare#accountId
   */
  readonly accountId?: string;

  /**
   * Account Name in Cloudflare. AccountName and AccountId cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema ClusterTunnelSpecCloudflare#accountName
   */
  readonly accountName?: string;

  /**
   * Cloudflare Domain to which this tunnel belongs to
   *
   * @schema ClusterTunnelSpecCloudflare#domain
   */
  readonly domain: string;

  /**
   * Email to use along with API Key for Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema ClusterTunnelSpecCloudflare#email
   */
  readonly email?: string;

  /**
   * Secret containing Cloudflare API key/token
   *
   * @schema ClusterTunnelSpecCloudflare#secret
   */
  readonly secret: string;
}

/**
 * Converts an object of type 'ClusterTunnelSpecCloudflare' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterTunnelSpecCloudflare(
  obj: ClusterTunnelSpecCloudflare | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    CLOUDFLARE_API_KEY: obj.cloudflareApiKey,
    CLOUDFLARE_API_TOKEN: obj.cloudflareApiToken,
    CLOUDFLARE_TUNNEL_CREDENTIAL_FILE: obj.cloudflareTunnelCredentialFile,
    CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET: obj.cloudflareTunnelCredentialSecret,
    accountId: obj.accountId,
    accountName: obj.accountName,
    domain: obj.domain,
    email: obj.email,
    secret: obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Existing tunnel object.
 * ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema ClusterTunnelSpecExistingTunnel
 */
export interface ClusterTunnelSpecExistingTunnel {
  /**
   * Existing Tunnel ID to run on. Tunnel ID and Tunnel Name cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema ClusterTunnelSpecExistingTunnel#id
   */
  readonly id?: string;

  /**
   * Existing Tunnel name to run on. Tunnel Name and Tunnel ID cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema ClusterTunnelSpecExistingTunnel#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterTunnelSpecExistingTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterTunnelSpecExistingTunnel(
  obj: ClusterTunnelSpecExistingTunnel | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    id: obj.id,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * New tunnel object.
 * NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema ClusterTunnelSpecNewTunnel
 */
export interface ClusterTunnelSpecNewTunnel {
  /**
   * Tunnel name to create on Cloudflare.
   *
   * @schema ClusterTunnelSpecNewTunnel#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterTunnelSpecNewTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterTunnelSpecNewTunnel(
  obj: ClusterTunnelSpecNewTunnel | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Protocol specifies the protocol to use for the tunnel. Defaults to auto. Options are "auto", "quic" and "http2"
 *
 * @default auto. Options are "auto", "quic" and "http2"
 * @schema ClusterTunnelSpecProtocol
 */
export enum ClusterTunnelSpecProtocol {
  /** auto */
  AUTO = "auto",
  /** quic */
  QUIC = "quic",
  /** http2 */
  HTTP2 = "http2",
}

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ClusterTunnelSpecTolerations
 */
export interface ClusterTunnelSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ClusterTunnelSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ClusterTunnelSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema ClusterTunnelSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ClusterTunnelSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ClusterTunnelSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ClusterTunnelSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterTunnelSpecTolerations(
  obj: ClusterTunnelSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterTunnel is the Schema for the clustertunnels API
 *
 * @schema ClusterTunnelV1Alpha2
 */
export class ClusterTunnelV1Alpha2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterTunnelV1Alpha2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "networking.cfargotunnel.com/v1alpha2",
    kind: "ClusterTunnel",
  };

  /**
   * Renders a Kubernetes manifest for "ClusterTunnelV1Alpha2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterTunnelV1Alpha2Props = {}): any {
    return {
      ...ClusterTunnelV1Alpha2.GVK,
      ...toJson_ClusterTunnelV1Alpha2Props(props),
    };
  }

  /**
   * Defines a "ClusterTunnelV1Alpha2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterTunnelV1Alpha2Props = {}) {
    super(scope, id, {
      ...ClusterTunnelV1Alpha2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterTunnelV1Alpha2.GVK,
      ...toJson_ClusterTunnelV1Alpha2Props(resolved),
    };
  }
}

/**
 * ClusterTunnel is the Schema for the clustertunnels API
 *
 * @schema ClusterTunnelV1Alpha2
 */
export interface ClusterTunnelV1Alpha2Props {
  /**
   * @schema ClusterTunnelV1Alpha2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TunnelSpec defines the desired state of Tunnel
   *
   * @schema ClusterTunnelV1Alpha2#spec
   */
  readonly spec?: ClusterTunnelV1Alpha2Spec;
}

/**
 * Converts an object of type 'ClusterTunnelV1Alpha2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterTunnelV1Alpha2Props(
  obj: ClusterTunnelV1Alpha2Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_ClusterTunnelV1Alpha2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TunnelSpec defines the desired state of Tunnel
 *
 * @schema ClusterTunnelV1Alpha2Spec
 */
export interface ClusterTunnelV1Alpha2Spec {
  /**
   * Cloudflare Credentials
   *
   * @schema ClusterTunnelV1Alpha2Spec#cloudflare
   */
  readonly cloudflare: ClusterTunnelV1Alpha2SpecCloudflare;

  /**
   * Deployment patch for the cloudflared deployment.
   * Follows https://kubernetes.io/docs/reference/kubectl/generated/kubectl_patch/
   *
   * @schema ClusterTunnelV1Alpha2Spec#deployPatch
   */
  readonly deployPatch?: string;

  /**
   * Existing tunnel object.
   * ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema ClusterTunnelV1Alpha2Spec#existingTunnel
   */
  readonly existingTunnel?: ClusterTunnelV1Alpha2SpecExistingTunnel;

  /**
   * FallbackTarget speficies the target for requests that do not match an ingress. Defaults to http_status:404
   *
   * @default http_status:404
   * @schema ClusterTunnelV1Alpha2Spec#fallbackTarget
   */
  readonly fallbackTarget?: string;

  /**
   * New tunnel object.
   * NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema ClusterTunnelV1Alpha2Spec#newTunnel
   */
  readonly newTunnel?: ClusterTunnelV1Alpha2SpecNewTunnel;

  /**
   * NoTlsVerify disables origin TLS certificate checks when the endpoint is HTTPS.
   *
   * @schema ClusterTunnelV1Alpha2Spec#noTlsVerify
   */
  readonly noTlsVerify?: boolean;

  /**
   * OriginCaPool speficies the secret with tls.crt (and other certs as needed to be referred in the service annotation) of the Root CA to be trusted when sending traffic to HTTPS endpoints
   *
   * @schema ClusterTunnelV1Alpha2Spec#originCaPool
   */
  readonly originCaPool?: string;

  /**
   * Protocol specifies the protocol to use for the tunnel. Defaults to auto. Options are "auto", "quic" and "http2"
   *
   * @default auto. Options are "auto", "quic" and "http2"
   * @schema ClusterTunnelV1Alpha2Spec#protocol
   */
  readonly protocol?: ClusterTunnelV1Alpha2SpecProtocol;
}

/**
 * Converts an object of type 'ClusterTunnelV1Alpha2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterTunnelV1Alpha2Spec(
  obj: ClusterTunnelV1Alpha2Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cloudflare: toJson_ClusterTunnelV1Alpha2SpecCloudflare(obj.cloudflare),
    deployPatch: obj.deployPatch,
    existingTunnel: toJson_ClusterTunnelV1Alpha2SpecExistingTunnel(obj.existingTunnel),
    fallbackTarget: obj.fallbackTarget,
    newTunnel: toJson_ClusterTunnelV1Alpha2SpecNewTunnel(obj.newTunnel),
    noTlsVerify: obj.noTlsVerify,
    originCaPool: obj.originCaPool,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cloudflare Credentials
 *
 * @schema ClusterTunnelV1Alpha2SpecCloudflare
 */
export interface ClusterTunnelV1Alpha2SpecCloudflare {
  /**
   * Key in the secret to use for Cloudflare API Key, defaults to CLOUDFLARE_API_KEY. Needs Email also to be provided.
   * For Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema ClusterTunnelV1Alpha2SpecCloudflare#CLOUDFLARE_API_KEY
   */
  readonly cloudflareApiKey?: string;

  /**
   * Key in the secret to use for Cloudflare API token, defaults to CLOUDFLARE_API_TOKEN
   *
   * @schema ClusterTunnelV1Alpha2SpecCloudflare#CLOUDFLARE_API_TOKEN
   */
  readonly cloudflareApiToken?: string;

  /**
   * Key in the secret to use as credentials.json for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   *
   * @schema ClusterTunnelV1Alpha2SpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   */
  readonly cloudflareTunnelCredentialFile?: string;

  /**
   * Key in the secret to use as tunnel secret for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   *
   * @schema ClusterTunnelV1Alpha2SpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   */
  readonly cloudflareTunnelCredentialSecret?: string;

  /**
   * Account ID in Cloudflare. AccountId and AccountName cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema ClusterTunnelV1Alpha2SpecCloudflare#accountId
   */
  readonly accountId?: string;

  /**
   * Account Name in Cloudflare. AccountName and AccountId cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema ClusterTunnelV1Alpha2SpecCloudflare#accountName
   */
  readonly accountName?: string;

  /**
   * Cloudflare Domain to which this tunnel belongs to
   *
   * @schema ClusterTunnelV1Alpha2SpecCloudflare#domain
   */
  readonly domain: string;

  /**
   * Email to use along with API Key for Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema ClusterTunnelV1Alpha2SpecCloudflare#email
   */
  readonly email?: string;

  /**
   * Secret containing Cloudflare API key/token
   *
   * @schema ClusterTunnelV1Alpha2SpecCloudflare#secret
   */
  readonly secret: string;
}

/**
 * Converts an object of type 'ClusterTunnelV1Alpha2SpecCloudflare' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterTunnelV1Alpha2SpecCloudflare(
  obj: ClusterTunnelV1Alpha2SpecCloudflare | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    CLOUDFLARE_API_KEY: obj.cloudflareApiKey,
    CLOUDFLARE_API_TOKEN: obj.cloudflareApiToken,
    CLOUDFLARE_TUNNEL_CREDENTIAL_FILE: obj.cloudflareTunnelCredentialFile,
    CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET: obj.cloudflareTunnelCredentialSecret,
    accountId: obj.accountId,
    accountName: obj.accountName,
    domain: obj.domain,
    email: obj.email,
    secret: obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Existing tunnel object.
 * ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema ClusterTunnelV1Alpha2SpecExistingTunnel
 */
export interface ClusterTunnelV1Alpha2SpecExistingTunnel {
  /**
   * Existing Tunnel ID to run on. Tunnel ID and Tunnel Name cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema ClusterTunnelV1Alpha2SpecExistingTunnel#id
   */
  readonly id?: string;

  /**
   * Existing Tunnel name to run on. Tunnel Name and Tunnel ID cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema ClusterTunnelV1Alpha2SpecExistingTunnel#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ClusterTunnelV1Alpha2SpecExistingTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterTunnelV1Alpha2SpecExistingTunnel(
  obj: ClusterTunnelV1Alpha2SpecExistingTunnel | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    id: obj.id,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * New tunnel object.
 * NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema ClusterTunnelV1Alpha2SpecNewTunnel
 */
export interface ClusterTunnelV1Alpha2SpecNewTunnel {
  /**
   * Tunnel name to create on Cloudflare.
   *
   * @schema ClusterTunnelV1Alpha2SpecNewTunnel#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ClusterTunnelV1Alpha2SpecNewTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterTunnelV1Alpha2SpecNewTunnel(
  obj: ClusterTunnelV1Alpha2SpecNewTunnel | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Protocol specifies the protocol to use for the tunnel. Defaults to auto. Options are "auto", "quic" and "http2"
 *
 * @default auto. Options are "auto", "quic" and "http2"
 * @schema ClusterTunnelV1Alpha2SpecProtocol
 */
export enum ClusterTunnelV1Alpha2SpecProtocol {
  /** auto */
  AUTO = "auto",
  /** quic */
  QUIC = "quic",
  /** http2 */
  HTTP2 = "http2",
}

/**
 * Tunnel is the Schema for the tunnels API
 *
 * @schema Tunnel
 */
export class Tunnel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Tunnel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "networking.cfargotunnel.com/v1alpha1",
    kind: "Tunnel",
  };

  /**
   * Renders a Kubernetes manifest for "Tunnel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TunnelProps = {}): any {
    return {
      ...Tunnel.GVK,
      ...toJson_TunnelProps(props),
    };
  }

  /**
   * Defines a "Tunnel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TunnelProps = {}) {
    super(scope, id, {
      ...Tunnel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Tunnel.GVK,
      ...toJson_TunnelProps(resolved),
    };
  }
}

/**
 * Tunnel is the Schema for the tunnels API
 *
 * @schema Tunnel
 */
export interface TunnelProps {
  /**
   * @schema Tunnel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TunnelSpec defines the desired state of Tunnel
   *
   * @schema Tunnel#spec
   */
  readonly spec?: TunnelSpec;
}

/**
 * Converts an object of type 'TunnelProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelProps(obj: TunnelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_TunnelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TunnelSpec defines the desired state of Tunnel
 *
 * @schema TunnelSpec
 */
export interface TunnelSpec {
  /**
   * Cloudflare Credentials
   *
   * @schema TunnelSpec#cloudflare
   */
  readonly cloudflare: TunnelSpecCloudflare;

  /**
   * Existing tunnel object.
   * ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema TunnelSpec#existingTunnel
   */
  readonly existingTunnel?: TunnelSpecExistingTunnel;

  /**
   * FallbackTarget speficies the target for requests that do not match an ingress. Defaults to http_status:404
   *
   * @default http_status:404
   * @schema TunnelSpec#fallbackTarget
   */
  readonly fallbackTarget?: string;

  /**
   * Image sets the Cloudflared Image to use. Defaults to the image set during the release of the operator.
   *
   * @default the image set during the release of the operator.
   * @schema TunnelSpec#image
   */
  readonly image?: string;

  /**
   * New tunnel object.
   * NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema TunnelSpec#newTunnel
   */
  readonly newTunnel?: TunnelSpecNewTunnel;

  /**
   * NoTlsVerify disables origin TLS certificate checks when the endpoint is HTTPS.
   *
   * @schema TunnelSpec#noTlsVerify
   */
  readonly noTlsVerify?: boolean;

  /**
   * NodeSelectors specifies the nodeSelectors to apply to the cloudflared tunnel deployment
   *
   * @schema TunnelSpec#nodeSelectors
   */
  readonly nodeSelectors?: { [key: string]: string };

  /**
   * OriginCaPool speficies the secret with tls.crt (and other certs as needed to be referred in the service annotation) of the Root CA to be trusted when sending traffic to HTTPS endpoints
   *
   * @schema TunnelSpec#originCaPool
   */
  readonly originCaPool?: string;

  /**
   * Protocol specifies the protocol to use for the tunnel. Defaults to auto. Options are "auto", "quic" and "http2"
   *
   * @default auto. Options are "auto", "quic" and "http2"
   * @schema TunnelSpec#protocol
   */
  readonly protocol?: TunnelSpecProtocol;

  /**
   * Size defines the number of Daemon pods to run for this tunnel
   *
   * @schema TunnelSpec#size
   */
  readonly size?: number;

  /**
   * Tolerations specifies the tolerations to apply to the cloudflared tunnel deployment
   *
   * @schema TunnelSpec#tolerations
   */
  readonly tolerations?: TunnelSpecTolerations[];
}

/**
 * Converts an object of type 'TunnelSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelSpec(obj: TunnelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cloudflare: toJson_TunnelSpecCloudflare(obj.cloudflare),
    existingTunnel: toJson_TunnelSpecExistingTunnel(obj.existingTunnel),
    fallbackTarget: obj.fallbackTarget,
    image: obj.image,
    newTunnel: toJson_TunnelSpecNewTunnel(obj.newTunnel),
    noTlsVerify: obj.noTlsVerify,
    nodeSelectors:
      obj.nodeSelectors === undefined
        ? undefined
        : Object.entries(obj.nodeSelectors).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {}),
    originCaPool: obj.originCaPool,
    protocol: obj.protocol,
    size: obj.size,
    tolerations: obj.tolerations?.map((y) => toJson_TunnelSpecTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cloudflare Credentials
 *
 * @schema TunnelSpecCloudflare
 */
export interface TunnelSpecCloudflare {
  /**
   * Key in the secret to use for Cloudflare API Key, defaults to CLOUDFLARE_API_KEY. Needs Email also to be provided.
   * For Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_API_KEY
   */
  readonly cloudflareApiKey?: string;

  /**
   * Key in the secret to use for Cloudflare API token, defaults to CLOUDFLARE_API_TOKEN
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_API_TOKEN
   */
  readonly cloudflareApiToken?: string;

  /**
   * Key in the secret to use as credentials.json for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   */
  readonly cloudflareTunnelCredentialFile?: string;

  /**
   * Key in the secret to use as tunnel secret for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   *
   * @schema TunnelSpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   */
  readonly cloudflareTunnelCredentialSecret?: string;

  /**
   * Account ID in Cloudflare. AccountId and AccountName cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema TunnelSpecCloudflare#accountId
   */
  readonly accountId?: string;

  /**
   * Account Name in Cloudflare. AccountName and AccountId cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema TunnelSpecCloudflare#accountName
   */
  readonly accountName?: string;

  /**
   * Cloudflare Domain to which this tunnel belongs to
   *
   * @schema TunnelSpecCloudflare#domain
   */
  readonly domain: string;

  /**
   * Email to use along with API Key for Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema TunnelSpecCloudflare#email
   */
  readonly email?: string;

  /**
   * Secret containing Cloudflare API key/token
   *
   * @schema TunnelSpecCloudflare#secret
   */
  readonly secret: string;
}

/**
 * Converts an object of type 'TunnelSpecCloudflare' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelSpecCloudflare(obj: TunnelSpecCloudflare | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    CLOUDFLARE_API_KEY: obj.cloudflareApiKey,
    CLOUDFLARE_API_TOKEN: obj.cloudflareApiToken,
    CLOUDFLARE_TUNNEL_CREDENTIAL_FILE: obj.cloudflareTunnelCredentialFile,
    CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET: obj.cloudflareTunnelCredentialSecret,
    accountId: obj.accountId,
    accountName: obj.accountName,
    domain: obj.domain,
    email: obj.email,
    secret: obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Existing tunnel object.
 * ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema TunnelSpecExistingTunnel
 */
export interface TunnelSpecExistingTunnel {
  /**
   * Existing Tunnel ID to run on. Tunnel ID and Tunnel Name cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema TunnelSpecExistingTunnel#id
   */
  readonly id?: string;

  /**
   * Existing Tunnel name to run on. Tunnel Name and Tunnel ID cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema TunnelSpecExistingTunnel#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'TunnelSpecExistingTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelSpecExistingTunnel(
  obj: TunnelSpecExistingTunnel | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    id: obj.id,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * New tunnel object.
 * NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema TunnelSpecNewTunnel
 */
export interface TunnelSpecNewTunnel {
  /**
   * Tunnel name to create on Cloudflare.
   *
   * @schema TunnelSpecNewTunnel#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'TunnelSpecNewTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelSpecNewTunnel(obj: TunnelSpecNewTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Protocol specifies the protocol to use for the tunnel. Defaults to auto. Options are "auto", "quic" and "http2"
 *
 * @default auto. Options are "auto", "quic" and "http2"
 * @schema TunnelSpecProtocol
 */
export enum TunnelSpecProtocol {
  /** auto */
  AUTO = "auto",
  /** quic */
  QUIC = "quic",
  /** http2 */
  HTTP2 = "http2",
}

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema TunnelSpecTolerations
 */
export interface TunnelSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema TunnelSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema TunnelSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema TunnelSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema TunnelSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema TunnelSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'TunnelSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelSpecTolerations(obj: TunnelSpecTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    effect: obj.effect,
    key: obj.key,
    operator: obj.operator,
    tolerationSeconds: obj.tolerationSeconds,
    value: obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Tunnel is the Schema for the tunnels API
 *
 * @schema TunnelV1Alpha2
 */
export class TunnelV1Alpha2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TunnelV1Alpha2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "networking.cfargotunnel.com/v1alpha2",
    kind: "Tunnel",
  };

  /**
   * Renders a Kubernetes manifest for "TunnelV1Alpha2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TunnelV1Alpha2Props = {}): any {
    return {
      ...TunnelV1Alpha2.GVK,
      ...toJson_TunnelV1Alpha2Props(props),
    };
  }

  /**
   * Defines a "TunnelV1Alpha2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TunnelV1Alpha2Props = {}) {
    super(scope, id, {
      ...TunnelV1Alpha2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...TunnelV1Alpha2.GVK,
      ...toJson_TunnelV1Alpha2Props(resolved),
    };
  }
}

/**
 * Tunnel is the Schema for the tunnels API
 *
 * @schema TunnelV1Alpha2
 */
export interface TunnelV1Alpha2Props {
  /**
   * @schema TunnelV1Alpha2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TunnelSpec defines the desired state of Tunnel
   *
   * @schema TunnelV1Alpha2#spec
   */
  readonly spec?: TunnelV1Alpha2Spec;
}

/**
 * Converts an object of type 'TunnelV1Alpha2Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelV1Alpha2Props(obj: TunnelV1Alpha2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    spec: toJson_TunnelV1Alpha2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TunnelSpec defines the desired state of Tunnel
 *
 * @schema TunnelV1Alpha2Spec
 */
export interface TunnelV1Alpha2Spec {
  /**
   * Cloudflare Credentials
   *
   * @schema TunnelV1Alpha2Spec#cloudflare
   */
  readonly cloudflare: TunnelV1Alpha2SpecCloudflare;

  /**
   * Deployment patch for the cloudflared deployment.
   * Follows https://kubernetes.io/docs/reference/kubectl/generated/kubectl_patch/
   *
   * @schema TunnelV1Alpha2Spec#deployPatch
   */
  readonly deployPatch?: string;

  /**
   * Existing tunnel object.
   * ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema TunnelV1Alpha2Spec#existingTunnel
   */
  readonly existingTunnel?: TunnelV1Alpha2SpecExistingTunnel;

  /**
   * FallbackTarget speficies the target for requests that do not match an ingress. Defaults to http_status:404
   *
   * @default http_status:404
   * @schema TunnelV1Alpha2Spec#fallbackTarget
   */
  readonly fallbackTarget?: string;

  /**
   * New tunnel object.
   * NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
   *
   * @schema TunnelV1Alpha2Spec#newTunnel
   */
  readonly newTunnel?: TunnelV1Alpha2SpecNewTunnel;

  /**
   * NoTlsVerify disables origin TLS certificate checks when the endpoint is HTTPS.
   *
   * @schema TunnelV1Alpha2Spec#noTlsVerify
   */
  readonly noTlsVerify?: boolean;

  /**
   * OriginCaPool speficies the secret with tls.crt (and other certs as needed to be referred in the service annotation) of the Root CA to be trusted when sending traffic to HTTPS endpoints
   *
   * @schema TunnelV1Alpha2Spec#originCaPool
   */
  readonly originCaPool?: string;

  /**
   * Protocol specifies the protocol to use for the tunnel. Defaults to auto. Options are "auto", "quic" and "http2"
   *
   * @default auto. Options are "auto", "quic" and "http2"
   * @schema TunnelV1Alpha2Spec#protocol
   */
  readonly protocol?: TunnelV1Alpha2SpecProtocol;
}

/**
 * Converts an object of type 'TunnelV1Alpha2Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelV1Alpha2Spec(obj: TunnelV1Alpha2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    cloudflare: toJson_TunnelV1Alpha2SpecCloudflare(obj.cloudflare),
    deployPatch: obj.deployPatch,
    existingTunnel: toJson_TunnelV1Alpha2SpecExistingTunnel(obj.existingTunnel),
    fallbackTarget: obj.fallbackTarget,
    newTunnel: toJson_TunnelV1Alpha2SpecNewTunnel(obj.newTunnel),
    noTlsVerify: obj.noTlsVerify,
    originCaPool: obj.originCaPool,
    protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cloudflare Credentials
 *
 * @schema TunnelV1Alpha2SpecCloudflare
 */
export interface TunnelV1Alpha2SpecCloudflare {
  /**
   * Key in the secret to use for Cloudflare API Key, defaults to CLOUDFLARE_API_KEY. Needs Email also to be provided.
   * For Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema TunnelV1Alpha2SpecCloudflare#CLOUDFLARE_API_KEY
   */
  readonly cloudflareApiKey?: string;

  /**
   * Key in the secret to use for Cloudflare API token, defaults to CLOUDFLARE_API_TOKEN
   *
   * @schema TunnelV1Alpha2SpecCloudflare#CLOUDFLARE_API_TOKEN
   */
  readonly cloudflareApiToken?: string;

  /**
   * Key in the secret to use as credentials.json for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   *
   * @schema TunnelV1Alpha2SpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_FILE
   */
  readonly cloudflareTunnelCredentialFile?: string;

  /**
   * Key in the secret to use as tunnel secret for an existing tunnel, defaults to CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   *
   * @schema TunnelV1Alpha2SpecCloudflare#CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET
   */
  readonly cloudflareTunnelCredentialSecret?: string;

  /**
   * Account ID in Cloudflare. AccountId and AccountName cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema TunnelV1Alpha2SpecCloudflare#accountId
   */
  readonly accountId?: string;

  /**
   * Account Name in Cloudflare. AccountName and AccountId cannot be both empty. If both are provided, Account ID is used if valid, else falls back to Account Name.
   *
   * @schema TunnelV1Alpha2SpecCloudflare#accountName
   */
  readonly accountName?: string;

  /**
   * Cloudflare Domain to which this tunnel belongs to
   *
   * @schema TunnelV1Alpha2SpecCloudflare#domain
   */
  readonly domain: string;

  /**
   * Email to use along with API Key for Delete operations for new tunnels only, or as an alternate to API Token
   *
   * @schema TunnelV1Alpha2SpecCloudflare#email
   */
  readonly email?: string;

  /**
   * Secret containing Cloudflare API key/token
   *
   * @schema TunnelV1Alpha2SpecCloudflare#secret
   */
  readonly secret: string;
}

/**
 * Converts an object of type 'TunnelV1Alpha2SpecCloudflare' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelV1Alpha2SpecCloudflare(
  obj: TunnelV1Alpha2SpecCloudflare | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    CLOUDFLARE_API_KEY: obj.cloudflareApiKey,
    CLOUDFLARE_API_TOKEN: obj.cloudflareApiToken,
    CLOUDFLARE_TUNNEL_CREDENTIAL_FILE: obj.cloudflareTunnelCredentialFile,
    CLOUDFLARE_TUNNEL_CREDENTIAL_SECRET: obj.cloudflareTunnelCredentialSecret,
    accountId: obj.accountId,
    accountName: obj.accountName,
    domain: obj.domain,
    email: obj.email,
    secret: obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Existing tunnel object.
 * ExistingTunnel and NewTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema TunnelV1Alpha2SpecExistingTunnel
 */
export interface TunnelV1Alpha2SpecExistingTunnel {
  /**
   * Existing Tunnel ID to run on. Tunnel ID and Tunnel Name cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema TunnelV1Alpha2SpecExistingTunnel#id
   */
  readonly id?: string;

  /**
   * Existing Tunnel name to run on. Tunnel Name and Tunnel ID cannot be both empty. If both are provided, ID is used if valid, else falls back to Name.
   *
   * @schema TunnelV1Alpha2SpecExistingTunnel#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'TunnelV1Alpha2SpecExistingTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelV1Alpha2SpecExistingTunnel(
  obj: TunnelV1Alpha2SpecExistingTunnel | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    id: obj.id,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * New tunnel object.
 * NewTunnel and ExistingTunnel cannot be both empty and are mutually exclusive.
 *
 * @schema TunnelV1Alpha2SpecNewTunnel
 */
export interface TunnelV1Alpha2SpecNewTunnel {
  /**
   * Tunnel name to create on Cloudflare.
   *
   * @schema TunnelV1Alpha2SpecNewTunnel#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'TunnelV1Alpha2SpecNewTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelV1Alpha2SpecNewTunnel(
  obj: TunnelV1Alpha2SpecNewTunnel | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Protocol specifies the protocol to use for the tunnel. Defaults to auto. Options are "auto", "quic" and "http2"
 *
 * @default auto. Options are "auto", "quic" and "http2"
 * @schema TunnelV1Alpha2SpecProtocol
 */
export enum TunnelV1Alpha2SpecProtocol {
  /** auto */
  AUTO = "auto",
  /** quic */
  QUIC = "quic",
  /** http2 */
  HTTP2 = "http2",
}

/**
 * TunnelBinding is the Schema for the tunnelbindings API
 *
 * @schema TunnelBinding
 */
export class TunnelBinding extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TunnelBinding"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "networking.cfargotunnel.com/v1alpha1",
    kind: "TunnelBinding",
  };

  /**
   * Renders a Kubernetes manifest for "TunnelBinding".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TunnelBindingProps): any {
    return {
      ...TunnelBinding.GVK,
      ...toJson_TunnelBindingProps(props),
    };
  }

  /**
   * Defines a "TunnelBinding" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TunnelBindingProps) {
    super(scope, id, {
      ...TunnelBinding.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...TunnelBinding.GVK,
      ...toJson_TunnelBindingProps(resolved),
    };
  }
}

/**
 * TunnelBinding is the Schema for the tunnelbindings API
 *
 * @schema TunnelBinding
 */
export interface TunnelBindingProps {
  /**
   * @schema TunnelBinding#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema TunnelBinding#subjects
   */
  readonly subjects: TunnelBindingSubjects[];

  /**
   * TunnelRef defines the Tunnel TunnelBinding connects to
   *
   * @schema TunnelBinding#tunnelRef
   */
  readonly tunnelRef: TunnelBindingTunnelRef;
}

/**
 * Converts an object of type 'TunnelBindingProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelBindingProps(obj: TunnelBindingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    metadata: obj.metadata,
    subjects: obj.subjects?.map((y) => toJson_TunnelBindingSubjects(y)),
    tunnelRef: toJson_TunnelBindingTunnelRef(obj.tunnelRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TunnelBindingSubject defines the subject TunnelBinding connects to the Tunnel
 *
 * @schema TunnelBindingSubjects
 */
export interface TunnelBindingSubjects {
  /**
   * Kind can be Service
   *
   * @schema TunnelBindingSubjects#kind
   */
  readonly kind?: string;

  /**
   * @schema TunnelBindingSubjects#name
   */
  readonly name: string;

  /**
   * @schema TunnelBindingSubjects#spec
   */
  readonly spec?: TunnelBindingSubjectsSpec;
}

/**
 * Converts an object of type 'TunnelBindingSubjects' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelBindingSubjects(obj: TunnelBindingSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    kind: obj.kind,
    name: obj.name,
    spec: toJson_TunnelBindingSubjectsSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TunnelRef defines the Tunnel TunnelBinding connects to
 *
 * @schema TunnelBindingTunnelRef
 */
export interface TunnelBindingTunnelRef {
  /**
   * DisableDNSUpdates disables the DNS updates on Cloudflare, just managing the configs. Assumes the DNS entries are manually added.
   *
   * @schema TunnelBindingTunnelRef#disableDNSUpdates
   */
  readonly disableDnsUpdates?: boolean;

  /**
   * Kind can be Tunnel or ClusterTunnel
   *
   * @schema TunnelBindingTunnelRef#kind
   */
  readonly kind: TunnelBindingTunnelRefKind;

  /**
   * Name of the tunnel resource
   *
   * @schema TunnelBindingTunnelRef#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'TunnelBindingTunnelRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelBindingTunnelRef(
  obj: TunnelBindingTunnelRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    disableDNSUpdates: obj.disableDnsUpdates,
    kind: obj.kind,
    name: obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TunnelBindingSubjectsSpec
 */
export interface TunnelBindingSubjectsSpec {
  /**
   * CaPool trusts the CA certificate referenced by the key in the secret specified in tunnel.spec.originCaPool.
   * tls.crt is trusted globally and does not need to be specified. Only useful if the protocol is HTTPS.
   *
   * @schema TunnelBindingSubjectsSpec#caPool
   */
  readonly caPool?: string;

  /**
   * Fqdn specifies the DNS name to access this service from.
   * Defaults to the service.metadata.name + tunnel.spec.domain.
   * If specifying this, make sure to use the same domain that the tunnel belongs to.
   * This is not validated and used as provided
   *
   * @default the service.metadata.name + tunnel.spec.domain.
   * @schema TunnelBindingSubjectsSpec#fqdn
   */
  readonly fqdn?: string;

  /**
   * Http2Origin makes the service attempt to connect to origin using HTTP2.
   * Origin must be configured as https.
   *
   * @schema TunnelBindingSubjectsSpec#http2Origin
   */
  readonly http2Origin?: boolean;

  /**
   * NoTlsVerify disables TLS verification for this service.
   * Only useful if the protocol is HTTPS.
   *
   * @schema TunnelBindingSubjectsSpec#noTlsVerify
   */
  readonly noTlsVerify?: boolean;

  /**
   * Path specifies a regular expression for to match on the request for http/https services
   * If a rule does not specify a path, all paths will be matched.
   *
   * @schema TunnelBindingSubjectsSpec#path
   */
  readonly path?: string;

  /**
   * Protocol specifies the protocol for the service. Should be one of http, https, tcp, udp, ssh or rdp.
   * Defaults to http, with the exceptions of https for 443, smb for 139 and 445, rdp for 3389 and ssh for 22 if the service has a TCP port.
   * The only available option for a UDP port is udp, which is default.
   *
   * @default http, with the exceptions of https for 443, smb for 139 and 445, rdp for 3389 and ssh for 22 if the service has a TCP port.
   * @schema TunnelBindingSubjectsSpec#protocol
   */
  readonly protocol?: string;

  /**
   * ProxyAddress configures the listen address for that proxy
   *
   * @schema TunnelBindingSubjectsSpec#proxyAddress
   */
  readonly proxyAddress?: string;

  /**
   * ProxyPort configures the listen port for that proxy
   *
   * @schema TunnelBindingSubjectsSpec#proxyPort
   */
  readonly proxyPort?: number;

  /**
   * ProxyType configures the proxy type.
   *
   * @schema TunnelBindingSubjectsSpec#proxyType
   */
  readonly proxyType?: TunnelBindingSubjectsSpecProxyType;

  /**
   * Target specified where the tunnel should proxy to.
   * Defaults to the form of <protocol>://<service.metadata.name>.<service.metadata.namespace>.svc:<port>
   *
   * @default the form of <protocol>://<service.metadata.name>.<service.metadata.namespace>.svc:<port>
   * @schema TunnelBindingSubjectsSpec#target
   */
  readonly target?: string;
}

/**
 * Converts an object of type 'TunnelBindingSubjectsSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TunnelBindingSubjectsSpec(
  obj: TunnelBindingSubjectsSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    caPool: obj.caPool,
    fqdn: obj.fqdn,
    http2Origin: obj.http2Origin,
    noTlsVerify: obj.noTlsVerify,
    path: obj.path,
    protocol: obj.protocol,
    proxyAddress: obj.proxyAddress,
    proxyPort: obj.proxyPort,
    proxyType: obj.proxyType,
    target: obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind can be Tunnel or ClusterTunnel
 *
 * @schema TunnelBindingTunnelRefKind
 */
export enum TunnelBindingTunnelRefKind {
  /** ClusterTunnel */
  CLUSTER_TUNNEL = "ClusterTunnel",
  /** Tunnel */
  TUNNEL = "Tunnel",
}

/**
 * ProxyType configures the proxy type.
 *
 * @schema TunnelBindingSubjectsSpecProxyType
 */
export enum TunnelBindingSubjectsSpecProxyType {
  /** socks */
  SOCKS = "socks",
}
