// deno-lint-ignore-file

// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "cdk8s";
import { Construct } from "constructs";

/**
 * Alertmanager describes an Alertmanager cluster.
 *
 * @schema Alertmanager
 */
export class Alertmanager extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Alertmanager"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "monitoring.coreos.com/v1",
    kind: "Alertmanager",
  };

  /**
   * Renders a Kubernetes manifest for "Alertmanager".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AlertmanagerProps): any {
    return {
      ...Alertmanager.GVK,
      ...toJson_AlertmanagerProps(props),
    };
  }

  /**
   * Defines a "Alertmanager" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AlertmanagerProps) {
    super(scope, id, {
      ...Alertmanager.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Alertmanager.GVK,
      ...toJson_AlertmanagerProps(resolved),
    };
  }
}

/**
 * Alertmanager describes an Alertmanager cluster.
 *
 * @schema Alertmanager
 */
export interface AlertmanagerProps {
  /**
   * @schema Alertmanager#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the Alertmanager cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema Alertmanager#spec
   */
  readonly spec: AlertmanagerSpec;
}

/**
 * Converts an object of type 'AlertmanagerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerProps(
  obj: AlertmanagerProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_AlertmanagerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired behavior of the Alertmanager cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema AlertmanagerSpec
 */
export interface AlertmanagerSpec {
  /**
   * AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.
   *
   * @schema AlertmanagerSpec#additionalPeers
   */
  readonly additionalPeers?: string[];

  /**
   * If specified, the pod's scheduling constraints.
   *
   * @schema AlertmanagerSpec#affinity
   */
  readonly affinity?: AlertmanagerSpecAffinity;

  /**
   * The AlertmanagerConfigMatcherStrategy defines how AlertmanagerConfig objects match the alerts. In the future more options may be added.
   *
   * @schema AlertmanagerSpec#alertmanagerConfigMatcherStrategy
   */
  readonly alertmanagerConfigMatcherStrategy?:
    AlertmanagerSpecAlertmanagerConfigMatcherStrategy;

  /**
   * Namespaces to be selected for AlertmanagerConfig discovery. If nil, only check own namespace.
   *
   * @schema AlertmanagerSpec#alertmanagerConfigNamespaceSelector
   */
  readonly alertmanagerConfigNamespaceSelector?:
    AlertmanagerSpecAlertmanagerConfigNamespaceSelector;

  /**
   * AlertmanagerConfigs to be selected for to merge and configure Alertmanager with.
   *
   * @schema AlertmanagerSpec#alertmanagerConfigSelector
   */
  readonly alertmanagerConfigSelector?:
    AlertmanagerSpecAlertmanagerConfigSelector;

  /**
   * EXPERIMENTAL: alertmanagerConfiguration specifies the configuration of Alertmanager. If defined, it takes precedence over the `configSecret` field. This field may change in future releases.
   *
   * @schema AlertmanagerSpec#alertmanagerConfiguration
   */
  readonly alertmanagerConfiguration?:
    AlertmanagerSpecAlertmanagerConfiguration;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in the pod. If the service account has `automountServiceAccountToken: true`, set the field to `false` to opt out of automounting API credentials.
   *
   * @schema AlertmanagerSpec#automountServiceAccountToken
   */
  readonly automountServiceAccountToken?: boolean;

  /**
   * Base image that is used to deploy pods, without tag. Deprecated: use 'image' instead.
   *
   * @schema AlertmanagerSpec#baseImage
   */
  readonly baseImage?: string;

  /**
   * ClusterAdvertiseAddress is the explicit address to advertise in cluster. Needs to be provided for non RFC1918 [1] (public) addresses. [1] RFC1918: https://tools.ietf.org/html/rfc1918
   *
   * @schema AlertmanagerSpec#clusterAdvertiseAddress
   */
  readonly clusterAdvertiseAddress?: string;

  /**
   * Interval between gossip attempts.
   *
   * @schema AlertmanagerSpec#clusterGossipInterval
   */
  readonly clusterGossipInterval?: string;

  /**
   * Defines the identifier that uniquely identifies the Alertmanager cluster. You should only set it when the Alertmanager cluster includes Alertmanager instances which are external to this Alertmanager resource. In practice, the addresses of the external instances are provided via the `.spec.additionalPeers` field.
   *
   * @schema AlertmanagerSpec#clusterLabel
   */
  readonly clusterLabel?: string;

  /**
   * Timeout for cluster peering.
   *
   * @schema AlertmanagerSpec#clusterPeerTimeout
   */
  readonly clusterPeerTimeout?: string;

  /**
   * Interval between pushpull attempts.
   *
   * @schema AlertmanagerSpec#clusterPushpullInterval
   */
  readonly clusterPushpullInterval?: string;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`. The ConfigMaps are mounted into `/etc/alertmanager/configmaps/<configmap-name>` in the 'alertmanager' container.
   *
   * @schema AlertmanagerSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * ConfigSecret is the name of a Kubernetes Secret in the same namespace as the Alertmanager object, which contains the configuration for this Alertmanager instance. If empty, it defaults to `alertmanager-<alertmanager-name>`.
   * The Alertmanager configuration should be available under the `alertmanager.yaml` key. Additional keys from the original secret are copied to the generated secret and mounted into the `/etc/alertmanager/config` directory in the `alertmanager` container.
   * If either the secret or the `alertmanager.yaml` key is missing, the operator provisions a minimal Alertmanager configuration with one empty receiver (effectively dropping alert notifications).
   *
   * @schema AlertmanagerSpec#configSecret
   */
  readonly configSecret?: string;

  /**
   * Containers allows injecting additional containers. This is meant to allow adding an authentication proxy to an Alertmanager pod. Containers described here modify an operator generated container if they share the same name and modifications are done via a strategic merge patch. The current container names are: `alertmanager` and `config-reloader`. Overriding containers is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   *
   * @schema AlertmanagerSpec#containers
   */
  readonly containers?: AlertmanagerSpecContainers[];

  /**
   * The external URL the Alertmanager instances will be available under. This is necessary to generate correct URLs. This is necessary if Alertmanager is not served from root of a DNS name.
   *
   * @schema AlertmanagerSpec#externalUrl
   */
  readonly externalUrl?: string;

  /**
   * ForceEnableClusterMode ensures Alertmanager does not deactivate the cluster mode when running with a single replica. Use case is e.g. spanning an Alertmanager cluster across Kubernetes clusters with a single replica in each.
   *
   * @schema AlertmanagerSpec#forceEnableClusterMode
   */
  readonly forceEnableClusterMode?: boolean;

  /**
   * Pods' hostAliases configuration
   *
   * @schema AlertmanagerSpec#hostAliases
   */
  readonly hostAliases?: AlertmanagerSpecHostAliases[];

  /**
   * Image if specified has precedence over baseImage, tag and sha combinations. Specifying the version is still necessary to ensure the Prometheus Operator knows what version of Alertmanager is being configured.
   *
   * @schema AlertmanagerSpec#image
   */
  readonly image?: string;

  /**
   * Image pull policy for the 'alertmanager', 'init-config-reloader' and 'config-reloader' containers. See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
   *
   * @schema AlertmanagerSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: AlertmanagerSpecImagePullPolicy;

  /**
   * An optional list of references to secrets in the same namespace to use for pulling prometheus and alertmanager images from registries see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema AlertmanagerSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: AlertmanagerSpecImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition. Those can be used to e.g. fetch secrets for injection into the Alertmanager configuration from external sources. Any errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ InitContainers described here modify an operator generated init containers if they share the same name and modifications are done via a strategic merge patch. The current init container name is: `init-config-reloader`. Overriding init containers is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   *
   * @schema AlertmanagerSpec#initContainers
   */
  readonly initContainers?: AlertmanagerSpecInitContainers[];

  /**
   * ListenLocal makes the Alertmanager server listen on loopback, so that it does not bind against the Pod IP. Note this is only for the Alertmanager UI, not the gossip communication.
   *
   * @schema AlertmanagerSpec#listenLocal
   */
  readonly listenLocal?: boolean;

  /**
   * Log format for Alertmanager to be configured with.
   *
   * @schema AlertmanagerSpec#logFormat
   */
  readonly logFormat?: AlertmanagerSpecLogFormat;

  /**
   * Log level for Alertmanager to be configured with.
   *
   * @schema AlertmanagerSpec#logLevel
   */
  readonly logLevel?: AlertmanagerSpecLogLevel;

  /**
   * Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
   *
   * @default 0 (pod will be considered available as soon as it is ready) This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
   * @schema AlertmanagerSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * Define which Nodes the Pods are scheduled on.
   *
   * @schema AlertmanagerSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If set to true all actions on the underlying managed objects are not goint to be performed, except for delete actions.
   *
   * @schema AlertmanagerSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PodMetadata configures labels and annotations which are propagated to the Alertmanager pods.
   * The following items are reserved and cannot be overridden: * "alertmanager" label, set to the name of the Alertmanager instance. * "app.kubernetes.io/instance" label, set to the name of the Alertmanager instance. * "app.kubernetes.io/managed-by" label, set to "prometheus-operator". * "app.kubernetes.io/name" label, set to "alertmanager". * "app.kubernetes.io/version" label, set to the Alertmanager version. * "kubectl.kubernetes.io/default-container" annotation, set to "alertmanager".
   *
   * @schema AlertmanagerSpec#podMetadata
   */
  readonly podMetadata?: AlertmanagerSpecPodMetadata;

  /**
   * Port name used for the pods and governing service. Defaults to `web`.
   *
   * @default web`.
   * @schema AlertmanagerSpec#portName
   */
  readonly portName?: string;

  /**
   * Priority class assigned to the Pods
   *
   * @schema AlertmanagerSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Size is the expected size of the alertmanager cluster. The controller will eventually make the size of the running cluster equal to the expected size.
   *
   * @schema AlertmanagerSpec#replicas
   */
  readonly replicas?: number;

  /**
   * Define resources requests and limits for single Pods.
   *
   * @schema AlertmanagerSpec#resources
   */
  readonly resources?: AlertmanagerSpecResources;

  /**
   * Time duration Alertmanager shall retain data for. Default is '120h', and must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).
   *
   * @default 120h', and must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).
   * @schema AlertmanagerSpec#retention
   */
  readonly retention?: string;

  /**
   * The route prefix Alertmanager registers HTTP handlers for. This is useful, if using ExternalURL and a proxy is rewriting HTTP routes of a request, and the actual ExternalURL is still true, but the server serves requests under a different route prefix. For example for use with `kubectl proxy`.
   *
   * @schema AlertmanagerSpec#routePrefix
   */
  readonly routePrefix?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`. The Secrets are mounted into `/etc/alertmanager/secrets/<secret-name>` in the 'alertmanager' container.
   *
   * @schema AlertmanagerSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.
   *
   * @schema AlertmanagerSpec#securityContext
   */
  readonly securityContext?: AlertmanagerSpecSecurityContext;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the Prometheus Pods.
   *
   * @schema AlertmanagerSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * SHA of Alertmanager container image to be deployed. Defaults to the value of `version`. Similar to a tag, but the SHA explicitly deploys an immutable container image. Version and Tag are ignored if SHA is set. Deprecated: use 'image' instead. The image digest can be specified as part of the image URL.
   *
   * @default the value of `version`. Similar to a tag, but the SHA explicitly deploys an immutable container image. Version and Tag are ignored if SHA is set. Deprecated: use 'image' instead. The image digest can be specified as part of the image URL.
   * @schema AlertmanagerSpec#sha
   */
  readonly sha?: string;

  /**
   * Storage is the definition of how storage will be used by the Alertmanager instances.
   *
   * @schema AlertmanagerSpec#storage
   */
  readonly storage?: AlertmanagerSpecStorage;

  /**
   * Tag of Alertmanager container image to be deployed. Defaults to the value of `version`. Version is ignored if Tag is set. Deprecated: use 'image' instead. The image tag can be specified as part of the image URL.
   *
   * @default the value of `version`. Version is ignored if Tag is set. Deprecated: use 'image' instead. The image tag can be specified as part of the image URL.
   * @schema AlertmanagerSpec#tag
   */
  readonly tag?: string;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema AlertmanagerSpec#tolerations
   */
  readonly tolerations?: AlertmanagerSpecTolerations[];

  /**
   * If specified, the pod's topology spread constraints.
   *
   * @schema AlertmanagerSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?:
    AlertmanagerSpecTopologySpreadConstraints[];

  /**
   * Version the cluster should be on.
   *
   * @schema AlertmanagerSpec#version
   */
  readonly version?: string;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition. VolumeMounts specified will be appended to other VolumeMounts in the alertmanager container, that are generated as a result of StorageSpec objects.
   *
   * @schema AlertmanagerSpec#volumeMounts
   */
  readonly volumeMounts?: AlertmanagerSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will be appended to other volumes that are generated as a result of StorageSpec objects.
   *
   * @schema AlertmanagerSpec#volumes
   */
  readonly volumes?: AlertmanagerSpecVolumes[];

  /**
   * Defines the web command line flags when starting Alertmanager.
   *
   * @schema AlertmanagerSpec#web
   */
  readonly web?: AlertmanagerSpecWeb;
}

/**
 * Converts an object of type 'AlertmanagerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpec(
  obj: AlertmanagerSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "additionalPeers": obj.additionalPeers?.map((y) => y),
    "affinity": toJson_AlertmanagerSpecAffinity(obj.affinity),
    "alertmanagerConfigMatcherStrategy":
      toJson_AlertmanagerSpecAlertmanagerConfigMatcherStrategy(
        obj.alertmanagerConfigMatcherStrategy,
      ),
    "alertmanagerConfigNamespaceSelector":
      toJson_AlertmanagerSpecAlertmanagerConfigNamespaceSelector(
        obj.alertmanagerConfigNamespaceSelector,
      ),
    "alertmanagerConfigSelector":
      toJson_AlertmanagerSpecAlertmanagerConfigSelector(
        obj.alertmanagerConfigSelector,
      ),
    "alertmanagerConfiguration":
      toJson_AlertmanagerSpecAlertmanagerConfiguration(
        obj.alertmanagerConfiguration,
      ),
    "automountServiceAccountToken": obj.automountServiceAccountToken,
    "baseImage": obj.baseImage,
    "clusterAdvertiseAddress": obj.clusterAdvertiseAddress,
    "clusterGossipInterval": obj.clusterGossipInterval,
    "clusterLabel": obj.clusterLabel,
    "clusterPeerTimeout": obj.clusterPeerTimeout,
    "clusterPushpullInterval": obj.clusterPushpullInterval,
    "configMaps": obj.configMaps?.map((y) => y),
    "configSecret": obj.configSecret,
    "containers": obj.containers?.map((y) =>
      toJson_AlertmanagerSpecContainers(y)
    ),
    "externalUrl": obj.externalUrl,
    "forceEnableClusterMode": obj.forceEnableClusterMode,
    "hostAliases": obj.hostAliases?.map((y) =>
      toJson_AlertmanagerSpecHostAliases(y)
    ),
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "imagePullSecrets": obj.imagePullSecrets?.map((y) =>
      toJson_AlertmanagerSpecImagePullSecrets(y)
    ),
    "initContainers": obj.initContainers?.map((y) =>
      toJson_AlertmanagerSpecInitContainers(y)
    ),
    "listenLocal": obj.listenLocal,
    "logFormat": obj.logFormat,
    "logLevel": obj.logLevel,
    "minReadySeconds": obj.minReadySeconds,
    "nodeSelector": ((obj.nodeSelector) === undefined)
      ? undefined
      : (Object.entries(obj.nodeSelector).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "paused": obj.paused,
    "podMetadata": toJson_AlertmanagerSpecPodMetadata(obj.podMetadata),
    "portName": obj.portName,
    "priorityClassName": obj.priorityClassName,
    "replicas": obj.replicas,
    "resources": toJson_AlertmanagerSpecResources(obj.resources),
    "retention": obj.retention,
    "routePrefix": obj.routePrefix,
    "secrets": obj.secrets?.map((y) => y),
    "securityContext": toJson_AlertmanagerSpecSecurityContext(
      obj.securityContext,
    ),
    "serviceAccountName": obj.serviceAccountName,
    "sha": obj.sha,
    "storage": toJson_AlertmanagerSpecStorage(obj.storage),
    "tag": obj.tag,
    "tolerations": obj.tolerations?.map((y) =>
      toJson_AlertmanagerSpecTolerations(y)
    ),
    "topologySpreadConstraints": obj.topologySpreadConstraints?.map((y) =>
      toJson_AlertmanagerSpecTopologySpreadConstraints(y)
    ),
    "version": obj.version,
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_AlertmanagerSpecVolumeMounts(y)
    ),
    "volumes": obj.volumes?.map((y) => toJson_AlertmanagerSpecVolumes(y)),
    "web": toJson_AlertmanagerSpecWeb(obj.web),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's scheduling constraints.
 *
 * @schema AlertmanagerSpecAffinity
 */
export interface AlertmanagerSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema AlertmanagerSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: AlertmanagerSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema AlertmanagerSpecAffinity#podAffinity
   */
  readonly podAffinity?: AlertmanagerSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema AlertmanagerSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: AlertmanagerSpecAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinity(
  obj: AlertmanagerSpecAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeAffinity": toJson_AlertmanagerSpecAffinityNodeAffinity(
      obj.nodeAffinity,
    ),
    "podAffinity": toJson_AlertmanagerSpecAffinityPodAffinity(obj.podAffinity),
    "podAntiAffinity": toJson_AlertmanagerSpecAffinityPodAntiAffinity(
      obj.podAntiAffinity,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The AlertmanagerConfigMatcherStrategy defines how AlertmanagerConfig objects match the alerts. In the future more options may be added.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigMatcherStrategy
 */
export interface AlertmanagerSpecAlertmanagerConfigMatcherStrategy {
  /**
   * If set to `OnNamespace`, the operator injects a label matcher matching the namespace of the AlertmanagerConfig object for all its routes and inhibition rules. `None` will not add any additional matchers other than the ones specified in the AlertmanagerConfig. Default is `OnNamespace`.
   *
   * @default OnNamespace`.
   * @schema AlertmanagerSpecAlertmanagerConfigMatcherStrategy#type
   */
  readonly type?: AlertmanagerSpecAlertmanagerConfigMatcherStrategyType;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigMatcherStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigMatcherStrategy(
  obj: AlertmanagerSpecAlertmanagerConfigMatcherStrategy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to be selected for AlertmanagerConfig discovery. If nil, only check own namespace.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigNamespaceSelector
 */
export interface AlertmanagerSpecAlertmanagerConfigNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAlertmanagerConfigNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigNamespaceSelector(
  obj: AlertmanagerSpecAlertmanagerConfigNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAlertmanagerConfigNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlertmanagerConfigs to be selected for to merge and configure Alertmanager with.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigSelector
 */
export interface AlertmanagerSpecAlertmanagerConfigSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAlertmanagerConfigSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigSelector(
  obj: AlertmanagerSpecAlertmanagerConfigSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAlertmanagerConfigSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EXPERIMENTAL: alertmanagerConfiguration specifies the configuration of Alertmanager. If defined, it takes precedence over the `configSecret` field. This field may change in future releases.
 *
 * @schema AlertmanagerSpecAlertmanagerConfiguration
 */
export interface AlertmanagerSpecAlertmanagerConfiguration {
  /**
   * Defines the global parameters of the Alertmanager configuration.
   *
   * @schema AlertmanagerSpecAlertmanagerConfiguration#global
   */
  readonly global?: AlertmanagerSpecAlertmanagerConfigurationGlobal;

  /**
   * The name of the AlertmanagerConfig resource which is used to generate the Alertmanager configuration. It must be defined in the same namespace as the Alertmanager object. The operator will not enforce a `namespace` label for routes and inhibition rules.
   *
   * @schema AlertmanagerSpecAlertmanagerConfiguration#name
   */
  readonly name?: string;

  /**
   * Custom notification templates.
   *
   * @schema AlertmanagerSpecAlertmanagerConfiguration#templates
   */
  readonly templates?: AlertmanagerSpecAlertmanagerConfigurationTemplates[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfiguration(
  obj: AlertmanagerSpecAlertmanagerConfiguration | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "global": toJson_AlertmanagerSpecAlertmanagerConfigurationGlobal(
      obj.global,
    ),
    "name": obj.name,
    "templates": obj.templates?.map((y) =>
      toJson_AlertmanagerSpecAlertmanagerConfigurationTemplates(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema AlertmanagerSpecContainers
 */
export interface AlertmanagerSpecContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AlertmanagerSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AlertmanagerSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema AlertmanagerSpecContainers#env
   */
  readonly env?: AlertmanagerSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema AlertmanagerSpecContainers#envFrom
   */
  readonly envFrom?: AlertmanagerSpecContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema AlertmanagerSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema AlertmanagerSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema AlertmanagerSpecContainers#lifecycle
   */
  readonly lifecycle?: AlertmanagerSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecContainers#livenessProbe
   */
  readonly livenessProbe?: AlertmanagerSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema AlertmanagerSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema AlertmanagerSpecContainers#ports
   */
  readonly ports?: AlertmanagerSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecContainers#readinessProbe
   */
  readonly readinessProbe?: AlertmanagerSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema AlertmanagerSpecContainers#resizePolicy
   */
  readonly resizePolicy?: AlertmanagerSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecContainers#resources
   */
  readonly resources?: AlertmanagerSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is "Always". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as "Always" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy "Always" will be shut down. This lifecycle differs from normal init containers and is often referred to as a "sidecar" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.
   *
   * @schema AlertmanagerSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema AlertmanagerSpecContainers#securityContext
   */
  readonly securityContext?: AlertmanagerSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecContainers#startupProbe
   */
  readonly startupProbe?: AlertmanagerSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema AlertmanagerSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema AlertmanagerSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema AlertmanagerSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema AlertmanagerSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema AlertmanagerSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema AlertmanagerSpecContainers#volumeDevices
   */
  readonly volumeDevices?: AlertmanagerSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema AlertmanagerSpecContainers#volumeMounts
   */
  readonly volumeMounts?: AlertmanagerSpecContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema AlertmanagerSpecContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainers(
  obj: AlertmanagerSpecContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "args": obj.args?.map((y) => y),
    "command": obj.command?.map((y) => y),
    "env": obj.env?.map((y) => toJson_AlertmanagerSpecContainersEnv(y)),
    "envFrom": obj.envFrom?.map((y) =>
      toJson_AlertmanagerSpecContainersEnvFrom(y)
    ),
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "lifecycle": toJson_AlertmanagerSpecContainersLifecycle(obj.lifecycle),
    "livenessProbe": toJson_AlertmanagerSpecContainersLivenessProbe(
      obj.livenessProbe,
    ),
    "name": obj.name,
    "ports": obj.ports?.map((y) => toJson_AlertmanagerSpecContainersPorts(y)),
    "readinessProbe": toJson_AlertmanagerSpecContainersReadinessProbe(
      obj.readinessProbe,
    ),
    "resizePolicy": obj.resizePolicy?.map((y) =>
      toJson_AlertmanagerSpecContainersResizePolicy(y)
    ),
    "resources": toJson_AlertmanagerSpecContainersResources(obj.resources),
    "restartPolicy": obj.restartPolicy,
    "securityContext": toJson_AlertmanagerSpecContainersSecurityContext(
      obj.securityContext,
    ),
    "startupProbe": toJson_AlertmanagerSpecContainersStartupProbe(
      obj.startupProbe,
    ),
    "stdin": obj.stdin,
    "stdinOnce": obj.stdinOnce,
    "terminationMessagePath": obj.terminationMessagePath,
    "terminationMessagePolicy": obj.terminationMessagePolicy,
    "tty": obj.tty,
    "volumeDevices": obj.volumeDevices?.map((y) =>
      toJson_AlertmanagerSpecContainersVolumeDevices(y)
    ),
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_AlertmanagerSpecContainersVolumeMounts(y)
    ),
    "workingDir": obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
 *
 * @schema AlertmanagerSpecHostAliases
 */
export interface AlertmanagerSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema AlertmanagerSpecHostAliases#hostnames
   */
  readonly hostnames: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema AlertmanagerSpecHostAliases#ip
   */
  readonly ip: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecHostAliases(
  obj: AlertmanagerSpecHostAliases | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "hostnames": obj.hostnames?.map((y) => y),
    "ip": obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Image pull policy for the 'alertmanager', 'init-config-reloader' and 'config-reloader' containers. See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
 *
 * @schema AlertmanagerSpecImagePullPolicy
 */
export enum AlertmanagerSpecImagePullPolicy {
  /** Always */
  ALWAYS = "Always",
  /** Never */
  NEVER = "Never",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema AlertmanagerSpecImagePullSecrets
 */
export interface AlertmanagerSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecImagePullSecrets(
  obj: AlertmanagerSpecImagePullSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema AlertmanagerSpecInitContainers
 */
export interface AlertmanagerSpecInitContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AlertmanagerSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema AlertmanagerSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema AlertmanagerSpecInitContainers#env
   */
  readonly env?: AlertmanagerSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema AlertmanagerSpecInitContainers#envFrom
   */
  readonly envFrom?: AlertmanagerSpecInitContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema AlertmanagerSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema AlertmanagerSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema AlertmanagerSpecInitContainers#lifecycle
   */
  readonly lifecycle?: AlertmanagerSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: AlertmanagerSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema AlertmanagerSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema AlertmanagerSpecInitContainers#ports
   */
  readonly ports?: AlertmanagerSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: AlertmanagerSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema AlertmanagerSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: AlertmanagerSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecInitContainers#resources
   */
  readonly resources?: AlertmanagerSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is "Always". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as "Always" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy "Always" will be shut down. This lifecycle differs from normal init containers and is often referred to as a "sidecar" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.
   *
   * @schema AlertmanagerSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema AlertmanagerSpecInitContainers#securityContext
   */
  readonly securityContext?: AlertmanagerSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecInitContainers#startupProbe
   */
  readonly startupProbe?: AlertmanagerSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema AlertmanagerSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema AlertmanagerSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema AlertmanagerSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema AlertmanagerSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema AlertmanagerSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema AlertmanagerSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: AlertmanagerSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema AlertmanagerSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: AlertmanagerSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema AlertmanagerSpecInitContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainers(
  obj: AlertmanagerSpecInitContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "args": obj.args?.map((y) => y),
    "command": obj.command?.map((y) => y),
    "env": obj.env?.map((y) => toJson_AlertmanagerSpecInitContainersEnv(y)),
    "envFrom": obj.envFrom?.map((y) =>
      toJson_AlertmanagerSpecInitContainersEnvFrom(y)
    ),
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "lifecycle": toJson_AlertmanagerSpecInitContainersLifecycle(obj.lifecycle),
    "livenessProbe": toJson_AlertmanagerSpecInitContainersLivenessProbe(
      obj.livenessProbe,
    ),
    "name": obj.name,
    "ports": obj.ports?.map((y) =>
      toJson_AlertmanagerSpecInitContainersPorts(y)
    ),
    "readinessProbe": toJson_AlertmanagerSpecInitContainersReadinessProbe(
      obj.readinessProbe,
    ),
    "resizePolicy": obj.resizePolicy?.map((y) =>
      toJson_AlertmanagerSpecInitContainersResizePolicy(y)
    ),
    "resources": toJson_AlertmanagerSpecInitContainersResources(obj.resources),
    "restartPolicy": obj.restartPolicy,
    "securityContext": toJson_AlertmanagerSpecInitContainersSecurityContext(
      obj.securityContext,
    ),
    "startupProbe": toJson_AlertmanagerSpecInitContainersStartupProbe(
      obj.startupProbe,
    ),
    "stdin": obj.stdin,
    "stdinOnce": obj.stdinOnce,
    "terminationMessagePath": obj.terminationMessagePath,
    "terminationMessagePolicy": obj.terminationMessagePolicy,
    "tty": obj.tty,
    "volumeDevices": obj.volumeDevices?.map((y) =>
      toJson_AlertmanagerSpecInitContainersVolumeDevices(y)
    ),
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_AlertmanagerSpecInitContainersVolumeMounts(y)
    ),
    "workingDir": obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Log format for Alertmanager to be configured with.
 *
 * @schema AlertmanagerSpecLogFormat
 */
export enum AlertmanagerSpecLogFormat {
  /** logfmt */
  LOGFMT = "logfmt",
  /** json */
  JSON = "json",
}

/**
 * Log level for Alertmanager to be configured with.
 *
 * @schema AlertmanagerSpecLogLevel
 */
export enum AlertmanagerSpecLogLevel {
  /** debug */
  DEBUG = "debug",
  /** info */
  INFO = "info",
  /** warn */
  WARN = "warn",
  /** error */
  ERROR = "error",
}

/**
 * PodMetadata configures labels and annotations which are propagated to the Alertmanager pods.
 * The following items are reserved and cannot be overridden: * "alertmanager" label, set to the name of the Alertmanager instance. * "app.kubernetes.io/instance" label, set to the name of the Alertmanager instance. * "app.kubernetes.io/managed-by" label, set to "prometheus-operator". * "app.kubernetes.io/name" label, set to "alertmanager". * "app.kubernetes.io/version" label, set to the Alertmanager version. * "kubectl.kubernetes.io/default-container" annotation, set to "alertmanager".
 *
 * @schema AlertmanagerSpecPodMetadata
 */
export interface AlertmanagerSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema AlertmanagerSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema AlertmanagerSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema AlertmanagerSpecPodMetadata#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecPodMetadata(
  obj: AlertmanagerSpecPodMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "annotations": ((obj.annotations) === undefined)
      ? undefined
      : (Object.entries(obj.annotations).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Define resources requests and limits for single Pods.
 *
 * @schema AlertmanagerSpecResources
 */
export interface AlertmanagerSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema AlertmanagerSpecResources#claims
   */
  readonly claims?: AlertmanagerSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecResources#limits
   */
  readonly limits?: { [key: string]: AlertmanagerSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecResources#requests
   */
  readonly requests?: { [key: string]: AlertmanagerSpecResourcesRequests };
}

/**
 * Converts an object of type 'AlertmanagerSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecResources(
  obj: AlertmanagerSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) => toJson_AlertmanagerSpecResourcesClaims(y)),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.
 *
 * @schema AlertmanagerSpecSecurityContext
 */
export interface AlertmanagerSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AlertmanagerSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema AlertmanagerSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: AlertmanagerSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: AlertmanagerSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process. If unspecified, no additional groups are added to any container. Note that group memberships defined in the container image for the uid of the container process are still effective, even if they are not included in this list. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecSecurityContext#sysctls
   */
  readonly sysctls?: AlertmanagerSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AlertmanagerSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: AlertmanagerSpecSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AlertmanagerSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecSecurityContext(
  obj: AlertmanagerSpecSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsGroup": obj.fsGroup,
    "fsGroupChangePolicy": obj.fsGroupChangePolicy,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions": toJson_AlertmanagerSpecSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    "seccompProfile": toJson_AlertmanagerSpecSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    "supplementalGroups": obj.supplementalGroups?.map((y) => y),
    "sysctls": obj.sysctls?.map((y) =>
      toJson_AlertmanagerSpecSecurityContextSysctls(y)
    ),
    "windowsOptions": toJson_AlertmanagerSpecSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Storage is the definition of how storage will be used by the Alertmanager instances.
 *
 * @schema AlertmanagerSpecStorage
 */
export interface AlertmanagerSpecStorage {
  /**
   * Deprecated: subPath usage will be removed in a future release.
   *
   * @schema AlertmanagerSpecStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the StatefulSet. If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema AlertmanagerSpecStorage#emptyDir
   */
  readonly emptyDir?: AlertmanagerSpecStorageEmptyDir;

  /**
   * EphemeralVolumeSource to be used by the StatefulSet. This is a beta field in k8s 1.21 and GA in 1.15. For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
   *
   * @schema AlertmanagerSpecStorage#ephemeral
   */
  readonly ephemeral?: AlertmanagerSpecStorageEphemeral;

  /**
   * Defines the PVC spec to be used by the Prometheus StatefulSets. The easiest way to use a volume that cannot be automatically provisioned is to use a label selector alongside manually created PersistentVolumes.
   *
   * @schema AlertmanagerSpecStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: AlertmanagerSpecStorageVolumeClaimTemplate;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorage(
  obj: AlertmanagerSpecStorage | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "disableMountSubPath": obj.disableMountSubPath,
    "emptyDir": toJson_AlertmanagerSpecStorageEmptyDir(obj.emptyDir),
    "ephemeral": toJson_AlertmanagerSpecStorageEphemeral(obj.ephemeral),
    "volumeClaimTemplate": toJson_AlertmanagerSpecStorageVolumeClaimTemplate(
      obj.volumeClaimTemplate,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema AlertmanagerSpecTolerations
 */
export interface AlertmanagerSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema AlertmanagerSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema AlertmanagerSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema AlertmanagerSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema AlertmanagerSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema AlertmanagerSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecTolerations(
  obj: AlertmanagerSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "effect": obj.effect,
    "key": obj.key,
    "operator": obj.operator,
    "tolerationSeconds": obj.tolerationSeconds,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema AlertmanagerSpecTopologySpreadConstraints
 */
export interface AlertmanagerSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
   *
   * @schema AlertmanagerSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?:
    AlertmanagerSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels are ANDed with labelSelector to select the group of existing pods over which spreading will be calculated for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector. MatchLabelKeys cannot be set when LabelSelector isn't set. Keys that don't exist in the incoming pod labels will be ignored. A null or empty list means only match against labelSelector.
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema AlertmanagerSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. The global minimum is the minimum number of matching pods in an eligible domain or zero if the number of eligible domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 2/2/1: In this case, the global minimum is 1. | zone1 | zone2 | zone3 | |  P P  |  P P  |   P   | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema AlertmanagerSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.
   * This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema AlertmanagerSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   * If this value is nil, the behavior is equivalent to the Honor policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema AlertmanagerSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.
   * If this value is nil, the behavior is equivalent to the Ignore policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema AlertmanagerSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology. And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology. It's a required field.
   *
   * @schema AlertmanagerSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location, but giving higher precedence to topologies that would help reduce the skew. A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
   *
   * @schema AlertmanagerSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecTopologySpreadConstraints(
  obj: AlertmanagerSpecTopologySpreadConstraints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_AlertmanagerSpecTopologySpreadConstraintsLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "maxSkew": obj.maxSkew,
    "minDomains": obj.minDomains,
    "nodeAffinityPolicy": obj.nodeAffinityPolicy,
    "nodeTaintsPolicy": obj.nodeTaintsPolicy,
    "topologyKey": obj.topologyKey,
    "whenUnsatisfiable": obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AlertmanagerSpecVolumeMounts
 */
export interface AlertmanagerSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema AlertmanagerSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema AlertmanagerSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AlertmanagerSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema AlertmanagerSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AlertmanagerSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema AlertmanagerSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumeMounts(
  obj: AlertmanagerSpecVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema AlertmanagerSpecVolumes
 */
export interface AlertmanagerSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AlertmanagerSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: AlertmanagerSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema AlertmanagerSpecVolumes#azureDisk
   */
  readonly azureDisk?: AlertmanagerSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema AlertmanagerSpecVolumes#azureFile
   */
  readonly azureFile?: AlertmanagerSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema AlertmanagerSpecVolumes#cephfs
   */
  readonly cephfs?: AlertmanagerSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AlertmanagerSpecVolumes#cinder
   */
  readonly cinder?: AlertmanagerSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema AlertmanagerSpecVolumes#configMap
   */
  readonly configMap?: AlertmanagerSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema AlertmanagerSpecVolumes#csi
   */
  readonly csi?: AlertmanagerSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema AlertmanagerSpecVolumes#downwardAPI
   */
  readonly downwardApi?: AlertmanagerSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AlertmanagerSpecVolumes#emptyDir
   */
  readonly emptyDir?: AlertmanagerSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema AlertmanagerSpecVolumes#ephemeral
   */
  readonly ephemeral?: AlertmanagerSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema AlertmanagerSpecVolumes#fc
   */
  readonly fc?: AlertmanagerSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema AlertmanagerSpecVolumes#flexVolume
   */
  readonly flexVolume?: AlertmanagerSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema AlertmanagerSpecVolumes#flocker
   */
  readonly flocker?: AlertmanagerSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AlertmanagerSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: AlertmanagerSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema AlertmanagerSpecVolumes#gitRepo
   */
  readonly gitRepo?: AlertmanagerSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema AlertmanagerSpecVolumes#glusterfs
   */
  readonly glusterfs?: AlertmanagerSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema AlertmanagerSpecVolumes#hostPath
   */
  readonly hostPath?: AlertmanagerSpecVolumesHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema AlertmanagerSpecVolumes#iscsi
   */
  readonly iscsi?: AlertmanagerSpecVolumesIscsi;

  /**
   * name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema AlertmanagerSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AlertmanagerSpecVolumes#nfs
   */
  readonly nfs?: AlertmanagerSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema AlertmanagerSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: AlertmanagerSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema AlertmanagerSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: AlertmanagerSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema AlertmanagerSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: AlertmanagerSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema AlertmanagerSpecVolumes#projected
   */
  readonly projected?: AlertmanagerSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema AlertmanagerSpecVolumes#quobyte
   */
  readonly quobyte?: AlertmanagerSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema AlertmanagerSpecVolumes#rbd
   */
  readonly rbd?: AlertmanagerSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema AlertmanagerSpecVolumes#scaleIO
   */
  readonly scaleIo?: AlertmanagerSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema AlertmanagerSpecVolumes#secret
   */
  readonly secret?: AlertmanagerSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema AlertmanagerSpecVolumes#storageos
   */
  readonly storageos?: AlertmanagerSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema AlertmanagerSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: AlertmanagerSpecVolumesVsphereVolume;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumes(
  obj: AlertmanagerSpecVolumes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "awsElasticBlockStore": toJson_AlertmanagerSpecVolumesAwsElasticBlockStore(
      obj.awsElasticBlockStore,
    ),
    "azureDisk": toJson_AlertmanagerSpecVolumesAzureDisk(obj.azureDisk),
    "azureFile": toJson_AlertmanagerSpecVolumesAzureFile(obj.azureFile),
    "cephfs": toJson_AlertmanagerSpecVolumesCephfs(obj.cephfs),
    "cinder": toJson_AlertmanagerSpecVolumesCinder(obj.cinder),
    "configMap": toJson_AlertmanagerSpecVolumesConfigMap(obj.configMap),
    "csi": toJson_AlertmanagerSpecVolumesCsi(obj.csi),
    "downwardAPI": toJson_AlertmanagerSpecVolumesDownwardApi(obj.downwardApi),
    "emptyDir": toJson_AlertmanagerSpecVolumesEmptyDir(obj.emptyDir),
    "ephemeral": toJson_AlertmanagerSpecVolumesEphemeral(obj.ephemeral),
    "fc": toJson_AlertmanagerSpecVolumesFc(obj.fc),
    "flexVolume": toJson_AlertmanagerSpecVolumesFlexVolume(obj.flexVolume),
    "flocker": toJson_AlertmanagerSpecVolumesFlocker(obj.flocker),
    "gcePersistentDisk": toJson_AlertmanagerSpecVolumesGcePersistentDisk(
      obj.gcePersistentDisk,
    ),
    "gitRepo": toJson_AlertmanagerSpecVolumesGitRepo(obj.gitRepo),
    "glusterfs": toJson_AlertmanagerSpecVolumesGlusterfs(obj.glusterfs),
    "hostPath": toJson_AlertmanagerSpecVolumesHostPath(obj.hostPath),
    "iscsi": toJson_AlertmanagerSpecVolumesIscsi(obj.iscsi),
    "name": obj.name,
    "nfs": toJson_AlertmanagerSpecVolumesNfs(obj.nfs),
    "persistentVolumeClaim":
      toJson_AlertmanagerSpecVolumesPersistentVolumeClaim(
        obj.persistentVolumeClaim,
      ),
    "photonPersistentDisk": toJson_AlertmanagerSpecVolumesPhotonPersistentDisk(
      obj.photonPersistentDisk,
    ),
    "portworxVolume": toJson_AlertmanagerSpecVolumesPortworxVolume(
      obj.portworxVolume,
    ),
    "projected": toJson_AlertmanagerSpecVolumesProjected(obj.projected),
    "quobyte": toJson_AlertmanagerSpecVolumesQuobyte(obj.quobyte),
    "rbd": toJson_AlertmanagerSpecVolumesRbd(obj.rbd),
    "scaleIO": toJson_AlertmanagerSpecVolumesScaleIo(obj.scaleIo),
    "secret": toJson_AlertmanagerSpecVolumesSecret(obj.secret),
    "storageos": toJson_AlertmanagerSpecVolumesStorageos(obj.storageos),
    "vsphereVolume": toJson_AlertmanagerSpecVolumesVsphereVolume(
      obj.vsphereVolume,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the web command line flags when starting Alertmanager.
 *
 * @schema AlertmanagerSpecWeb
 */
export interface AlertmanagerSpecWeb {
  /**
   * Maximum number of GET requests processed concurrently. This corresponds to the Alertmanager's `--web.get-concurrency` flag.
   *
   * @schema AlertmanagerSpecWeb#getConcurrency
   */
  readonly getConcurrency?: number;

  /**
   * Defines HTTP parameters for web server.
   *
   * @schema AlertmanagerSpecWeb#httpConfig
   */
  readonly httpConfig?: AlertmanagerSpecWebHttpConfig;

  /**
   * Timeout for HTTP requests. This corresponds to the Alertmanager's `--web.timeout` flag.
   *
   * @schema AlertmanagerSpecWeb#timeout
   */
  readonly timeout?: number;

  /**
   * Defines the TLS parameters for HTTPS.
   *
   * @schema AlertmanagerSpecWeb#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerSpecWebTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerSpecWeb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecWeb(
  obj: AlertmanagerSpecWeb | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "getConcurrency": obj.getConcurrency,
    "httpConfig": toJson_AlertmanagerSpecWebHttpConfig(obj.httpConfig),
    "timeout": obj.timeout,
    "tlsConfig": toJson_AlertmanagerSpecWebTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema AlertmanagerSpecAffinityNodeAffinity
 */
export interface AlertmanagerSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityNodeAffinity(
  obj: AlertmanagerSpecAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution":
      toJson_AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema AlertmanagerSpecAffinityPodAffinity
 */
export interface AlertmanagerSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema AlertmanagerSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema AlertmanagerSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinity(
  obj: AlertmanagerSpecAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinity
 */
export interface AlertmanagerSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinity(
  obj: AlertmanagerSpecAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If set to `OnNamespace`, the operator injects a label matcher matching the namespace of the AlertmanagerConfig object for all its routes and inhibition rules. `None` will not add any additional matchers other than the ones specified in the AlertmanagerConfig. Default is `OnNamespace`.
 *
 * @default OnNamespace`.
 * @schema AlertmanagerSpecAlertmanagerConfigMatcherStrategyType
 */
export enum AlertmanagerSpecAlertmanagerConfigMatcherStrategyType {
  /** OnNamespace */
  ON_NAMESPACE = "OnNamespace",
  /** None */
  NONE = "None",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigNamespaceSelectorMatchExpressions
 */
export interface AlertmanagerSpecAlertmanagerConfigNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigNamespaceSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecAlertmanagerConfigNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigSelectorMatchExpressions
 */
export interface AlertmanagerSpecAlertmanagerConfigSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigSelectorMatchExpressions(
  obj: AlertmanagerSpecAlertmanagerConfigSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the global parameters of the Alertmanager configuration.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobal
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobal {
  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobal#httpConfig
   */
  readonly httpConfig?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig;

  /**
   * The default OpsGenie API Key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobal#opsGenieApiKey
   */
  readonly opsGenieApiKey?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiKey;

  /**
   * The default OpsGenie API URL.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobal#opsGenieApiUrl
   */
  readonly opsGenieApiUrl?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiUrl;

  /**
   * The default Pagerduty URL.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobal#pagerdutyUrl
   */
  readonly pagerdutyUrl?: string;

  /**
   * ResolveTimeout is the default value used by alertmanager if the alert does not include EndsAt, after this time passes it can declare the alert as resolved if it has not been updated. This has no impact on alerts from Prometheus, as they always include EndsAt.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobal#resolveTimeout
   */
  readonly resolveTimeout?: string;

  /**
   * The default Slack API URL.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobal#slackApiUrl
   */
  readonly slackApiUrl?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalSlackApiUrl;

  /**
   * Configures global SMTP parameters.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobal#smtp
   */
  readonly smtp?: AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobal(
  obj: AlertmanagerSpecAlertmanagerConfigurationGlobal | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "httpConfig":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig(
        obj.httpConfig,
      ),
    "opsGenieApiKey":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiKey(
        obj.opsGenieApiKey,
      ),
    "opsGenieApiUrl":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiUrl(
        obj.opsGenieApiUrl,
      ),
    "pagerdutyUrl": obj.pagerdutyUrl,
    "resolveTimeout": obj.resolveTimeout,
    "slackApiUrl":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalSlackApiUrl(
        obj.slackApiUrl,
      ),
    "smtp": toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp(
      obj.smtp,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretOrConfigMap allows to specify data as a Secret or ConfigMap. Fields are mutually exclusive.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationTemplates
 */
export interface AlertmanagerSpecAlertmanagerConfigurationTemplates {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationTemplates#configMap
   */
  readonly configMap?:
    AlertmanagerSpecAlertmanagerConfigurationTemplatesConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationTemplates#secret
   */
  readonly secret?: AlertmanagerSpecAlertmanagerConfigurationTemplatesSecret;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationTemplates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationTemplates(
  obj: AlertmanagerSpecAlertmanagerConfigurationTemplates | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerSpecAlertmanagerConfigurationTemplatesConfigMap(
        obj.configMap,
      ),
    "secret": toJson_AlertmanagerSpecAlertmanagerConfigurationTemplatesSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema AlertmanagerSpecContainersEnv
 */
export interface AlertmanagerSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema AlertmanagerSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema AlertmanagerSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema AlertmanagerSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: AlertmanagerSpecContainersEnvValueFrom;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersEnv(
  obj: AlertmanagerSpecContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
    "valueFrom": toJson_AlertmanagerSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema AlertmanagerSpecContainersEnvFrom
 */
export interface AlertmanagerSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema AlertmanagerSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: AlertmanagerSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema AlertmanagerSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema AlertmanagerSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: AlertmanagerSpecContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersEnvFrom(
  obj: AlertmanagerSpecContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapRef": toJson_AlertmanagerSpecContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    "prefix": obj.prefix,
    "secretRef": toJson_AlertmanagerSpecContainersEnvFromSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema AlertmanagerSpecContainersLifecycle
 */
export interface AlertmanagerSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AlertmanagerSpecContainersLifecycle#postStart
   */
  readonly postStart?: AlertmanagerSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AlertmanagerSpecContainersLifecycle#preStop
   */
  readonly preStop?: AlertmanagerSpecContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLifecycle(
  obj: AlertmanagerSpecContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "postStart": toJson_AlertmanagerSpecContainersLifecyclePostStart(
      obj.postStart,
    ),
    "preStop": toJson_AlertmanagerSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AlertmanagerSpecContainersLivenessProbe
 */
export interface AlertmanagerSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema AlertmanagerSpecContainersLivenessProbe#exec
   */
  readonly exec?: AlertmanagerSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AlertmanagerSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema AlertmanagerSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: AlertmanagerSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema AlertmanagerSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: AlertmanagerSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AlertmanagerSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AlertmanagerSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema AlertmanagerSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: AlertmanagerSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AlertmanagerSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema AlertmanagerSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLivenessProbe(
  obj: AlertmanagerSpecContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_AlertmanagerSpecContainersLivenessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_AlertmanagerSpecContainersLivenessProbeGrpc(obj.grpc),
    "httpGet": toJson_AlertmanagerSpecContainersLivenessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_AlertmanagerSpecContainersLivenessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema AlertmanagerSpecContainersPorts
 */
export interface AlertmanagerSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema AlertmanagerSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema AlertmanagerSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema AlertmanagerSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema AlertmanagerSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema AlertmanagerSpecContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersPorts(
  obj: AlertmanagerSpecContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerPort": obj.containerPort,
    "hostIP": obj.hostIp,
    "hostPort": obj.hostPort,
    "name": obj.name,
    "protocol": obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AlertmanagerSpecContainersReadinessProbe
 */
export interface AlertmanagerSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema AlertmanagerSpecContainersReadinessProbe#exec
   */
  readonly exec?: AlertmanagerSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AlertmanagerSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema AlertmanagerSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: AlertmanagerSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema AlertmanagerSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: AlertmanagerSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AlertmanagerSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AlertmanagerSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema AlertmanagerSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: AlertmanagerSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AlertmanagerSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema AlertmanagerSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersReadinessProbe(
  obj: AlertmanagerSpecContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_AlertmanagerSpecContainersReadinessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_AlertmanagerSpecContainersReadinessProbeGrpc(obj.grpc),
    "httpGet": toJson_AlertmanagerSpecContainersReadinessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_AlertmanagerSpecContainersReadinessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema AlertmanagerSpecContainersResizePolicy
 */
export interface AlertmanagerSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies. Supported values: cpu, memory.
   *
   * @schema AlertmanagerSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized. If not specified, it defaults to NotRequired.
   *
   * @schema AlertmanagerSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersResizePolicy(
  obj: AlertmanagerSpecContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "resourceName": obj.resourceName,
    "restartPolicy": obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema AlertmanagerSpecContainersResources
 */
export interface AlertmanagerSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema AlertmanagerSpecContainersResources#claims
   */
  readonly claims?: AlertmanagerSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecContainersResources#limits
   */
  readonly limits?: {
    [key: string]: AlertmanagerSpecContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecContainersResources#requests
   */
  readonly requests?: {
    [key: string]: AlertmanagerSpecContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersResources(
  obj: AlertmanagerSpecContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_AlertmanagerSpecContainersResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema AlertmanagerSpecContainersSecurityContext
 */
export interface AlertmanagerSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema AlertmanagerSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: AlertmanagerSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema AlertmanagerSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema AlertmanagerSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AlertmanagerSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema AlertmanagerSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    AlertmanagerSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    AlertmanagerSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AlertmanagerSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    AlertmanagerSpecContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersSecurityContext(
  obj: AlertmanagerSpecContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "allowPrivilegeEscalation": obj.allowPrivilegeEscalation,
    "capabilities":
      toJson_AlertmanagerSpecContainersSecurityContextCapabilities(
        obj.capabilities,
      ),
    "privileged": obj.privileged,
    "procMount": obj.procMount,
    "readOnlyRootFilesystem": obj.readOnlyRootFilesystem,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_AlertmanagerSpecContainersSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_AlertmanagerSpecContainersSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "windowsOptions":
      toJson_AlertmanagerSpecContainersSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AlertmanagerSpecContainersStartupProbe
 */
export interface AlertmanagerSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema AlertmanagerSpecContainersStartupProbe#exec
   */
  readonly exec?: AlertmanagerSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AlertmanagerSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema AlertmanagerSpecContainersStartupProbe#grpc
   */
  readonly grpc?: AlertmanagerSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema AlertmanagerSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: AlertmanagerSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AlertmanagerSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AlertmanagerSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema AlertmanagerSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: AlertmanagerSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AlertmanagerSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema AlertmanagerSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersStartupProbe(
  obj: AlertmanagerSpecContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_AlertmanagerSpecContainersStartupProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_AlertmanagerSpecContainersStartupProbeGrpc(obj.grpc),
    "httpGet": toJson_AlertmanagerSpecContainersStartupProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_AlertmanagerSpecContainersStartupProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema AlertmanagerSpecContainersVolumeDevices
 */
export interface AlertmanagerSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema AlertmanagerSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema AlertmanagerSpecContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersVolumeDevices(
  obj: AlertmanagerSpecContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "devicePath": obj.devicePath,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AlertmanagerSpecContainersVolumeMounts
 */
export interface AlertmanagerSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema AlertmanagerSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema AlertmanagerSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AlertmanagerSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema AlertmanagerSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AlertmanagerSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema AlertmanagerSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersVolumeMounts(
  obj: AlertmanagerSpecContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema AlertmanagerSpecInitContainersEnv
 */
export interface AlertmanagerSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema AlertmanagerSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema AlertmanagerSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema AlertmanagerSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: AlertmanagerSpecInitContainersEnvValueFrom;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersEnv(
  obj: AlertmanagerSpecInitContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
    "valueFrom": toJson_AlertmanagerSpecInitContainersEnvValueFrom(
      obj.valueFrom,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema AlertmanagerSpecInitContainersEnvFrom
 */
export interface AlertmanagerSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema AlertmanagerSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: AlertmanagerSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema AlertmanagerSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema AlertmanagerSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: AlertmanagerSpecInitContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersEnvFrom(
  obj: AlertmanagerSpecInitContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapRef": toJson_AlertmanagerSpecInitContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    "prefix": obj.prefix,
    "secretRef": toJson_AlertmanagerSpecInitContainersEnvFromSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema AlertmanagerSpecInitContainersLifecycle
 */
export interface AlertmanagerSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AlertmanagerSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: AlertmanagerSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema AlertmanagerSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: AlertmanagerSpecInitContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLifecycle(
  obj: AlertmanagerSpecInitContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "postStart": toJson_AlertmanagerSpecInitContainersLifecyclePostStart(
      obj.postStart,
    ),
    "preStop": toJson_AlertmanagerSpecInitContainersLifecyclePreStop(
      obj.preStop,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AlertmanagerSpecInitContainersLivenessProbe
 */
export interface AlertmanagerSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: AlertmanagerSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AlertmanagerSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: AlertmanagerSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: AlertmanagerSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AlertmanagerSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AlertmanagerSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: AlertmanagerSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema AlertmanagerSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLivenessProbe(
  obj: AlertmanagerSpecInitContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_AlertmanagerSpecInitContainersLivenessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_AlertmanagerSpecInitContainersLivenessProbeGrpc(obj.grpc),
    "httpGet": toJson_AlertmanagerSpecInitContainersLivenessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_AlertmanagerSpecInitContainersLivenessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema AlertmanagerSpecInitContainersPorts
 */
export interface AlertmanagerSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema AlertmanagerSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema AlertmanagerSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema AlertmanagerSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema AlertmanagerSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema AlertmanagerSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersPorts(
  obj: AlertmanagerSpecInitContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerPort": obj.containerPort,
    "hostIP": obj.hostIp,
    "hostPort": obj.hostPort,
    "name": obj.name,
    "protocol": obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AlertmanagerSpecInitContainersReadinessProbe
 */
export interface AlertmanagerSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: AlertmanagerSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AlertmanagerSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: AlertmanagerSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: AlertmanagerSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AlertmanagerSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AlertmanagerSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: AlertmanagerSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema AlertmanagerSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersReadinessProbe(
  obj: AlertmanagerSpecInitContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_AlertmanagerSpecInitContainersReadinessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_AlertmanagerSpecInitContainersReadinessProbeGrpc(obj.grpc),
    "httpGet": toJson_AlertmanagerSpecInitContainersReadinessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_AlertmanagerSpecInitContainersReadinessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema AlertmanagerSpecInitContainersResizePolicy
 */
export interface AlertmanagerSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies. Supported values: cpu, memory.
   *
   * @schema AlertmanagerSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized. If not specified, it defaults to NotRequired.
   *
   * @schema AlertmanagerSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersResizePolicy(
  obj: AlertmanagerSpecInitContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "resourceName": obj.resourceName,
    "restartPolicy": obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema AlertmanagerSpecInitContainersResources
 */
export interface AlertmanagerSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema AlertmanagerSpecInitContainersResources#claims
   */
  readonly claims?: AlertmanagerSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecInitContainersResources#limits
   */
  readonly limits?: {
    [key: string]: AlertmanagerSpecInitContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecInitContainersResources#requests
   */
  readonly requests?: {
    [key: string]: AlertmanagerSpecInitContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersResources(
  obj: AlertmanagerSpecInitContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_AlertmanagerSpecInitContainersResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema AlertmanagerSpecInitContainersSecurityContext
 */
export interface AlertmanagerSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema AlertmanagerSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?:
    AlertmanagerSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema AlertmanagerSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema AlertmanagerSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema AlertmanagerSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    AlertmanagerSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    AlertmanagerSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    AlertmanagerSpecInitContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersSecurityContext(
  obj: AlertmanagerSpecInitContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "allowPrivilegeEscalation": obj.allowPrivilegeEscalation,
    "capabilities":
      toJson_AlertmanagerSpecInitContainersSecurityContextCapabilities(
        obj.capabilities,
      ),
    "privileged": obj.privileged,
    "procMount": obj.procMount,
    "readOnlyRootFilesystem": obj.readOnlyRootFilesystem,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_AlertmanagerSpecInitContainersSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_AlertmanagerSpecInitContainersSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "windowsOptions":
      toJson_AlertmanagerSpecInitContainersSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema AlertmanagerSpecInitContainersStartupProbe
 */
export interface AlertmanagerSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbe#exec
   */
  readonly exec?: AlertmanagerSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema AlertmanagerSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: AlertmanagerSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: AlertmanagerSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema AlertmanagerSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema AlertmanagerSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema AlertmanagerSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: AlertmanagerSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema AlertmanagerSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersStartupProbe(
  obj: AlertmanagerSpecInitContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_AlertmanagerSpecInitContainersStartupProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_AlertmanagerSpecInitContainersStartupProbeGrpc(obj.grpc),
    "httpGet": toJson_AlertmanagerSpecInitContainersStartupProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_AlertmanagerSpecInitContainersStartupProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema AlertmanagerSpecInitContainersVolumeDevices
 */
export interface AlertmanagerSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema AlertmanagerSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema AlertmanagerSpecInitContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersVolumeDevices(
  obj: AlertmanagerSpecInitContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "devicePath": obj.devicePath,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema AlertmanagerSpecInitContainersVolumeMounts
 */
export interface AlertmanagerSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema AlertmanagerSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema AlertmanagerSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema AlertmanagerSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema AlertmanagerSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema AlertmanagerSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema AlertmanagerSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersVolumeMounts(
  obj: AlertmanagerSpecInitContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AlertmanagerSpecResourcesClaims
 */
export interface AlertmanagerSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema AlertmanagerSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecResourcesClaims(
  obj: AlertmanagerSpecResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertmanagerSpecResourcesLimits
 */
export class AlertmanagerSpecResourcesLimits {
  public static fromNumber(value: number): AlertmanagerSpecResourcesLimits {
    return new AlertmanagerSpecResourcesLimits(value);
  }
  public static fromString(value: string): AlertmanagerSpecResourcesLimits {
    return new AlertmanagerSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema AlertmanagerSpecResourcesRequests
 */
export class AlertmanagerSpecResourcesRequests {
  public static fromNumber(value: number): AlertmanagerSpecResourcesRequests {
    return new AlertmanagerSpecResourcesRequests(value);
  }
  public static fromString(value: string): AlertmanagerSpecResourcesRequests {
    return new AlertmanagerSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AlertmanagerSpecSecurityContextSeLinuxOptions
 */
export interface AlertmanagerSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AlertmanagerSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AlertmanagerSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AlertmanagerSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AlertmanagerSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecSecurityContextSeLinuxOptions(
  obj: AlertmanagerSpecSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AlertmanagerSpecSecurityContextSeccompProfile
 */
export interface AlertmanagerSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AlertmanagerSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema AlertmanagerSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecSecurityContextSeccompProfile(
  obj: AlertmanagerSpecSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema AlertmanagerSpecSecurityContextSysctls
 */
export interface AlertmanagerSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema AlertmanagerSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema AlertmanagerSpecSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecSecurityContextSysctls(
  obj: AlertmanagerSpecSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AlertmanagerSpecSecurityContextWindowsOptions
 */
export interface AlertmanagerSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AlertmanagerSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AlertmanagerSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AlertmanagerSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema AlertmanagerSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecSecurityContextWindowsOptions(
  obj: AlertmanagerSpecSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDirVolumeSource to be used by the StatefulSet. If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema AlertmanagerSpecStorageEmptyDir
 */
export interface AlertmanagerSpecStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AlertmanagerSpecStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AlertmanagerSpecStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: AlertmanagerSpecStorageEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageEmptyDir(
  obj: AlertmanagerSpecStorageEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "medium": obj.medium,
    "sizeLimit": obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EphemeralVolumeSource to be used by the StatefulSet. This is a beta field in k8s 1.21 and GA in 1.15. For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
 *
 * @schema AlertmanagerSpecStorageEphemeral
 */
export interface AlertmanagerSpecStorageEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema AlertmanagerSpecStorageEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?:
    AlertmanagerSpecStorageEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageEphemeral(
  obj: AlertmanagerSpecStorageEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "volumeClaimTemplate":
      toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplate(
        obj.volumeClaimTemplate,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the PVC spec to be used by the Prometheus StatefulSets. The easiest way to use a volume that cannot be automatically provisioned is to use a label selector alongside manually created PersistentVolumes.
 *
 * @schema AlertmanagerSpecStorageVolumeClaimTemplate
 */
export interface AlertmanagerSpecStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: AlertmanagerSpecStorageVolumeClaimTemplateMetadata;

  /**
   * Defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplate#spec
   */
  readonly spec?: AlertmanagerSpecStorageVolumeClaimTemplateSpec;

  /**
   * Deprecated: this field is never set.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplate#status
   */
  readonly status?: AlertmanagerSpecStorageVolumeClaimTemplateStatus;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageVolumeClaimTemplate(
  obj: AlertmanagerSpecStorageVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "kind": obj.kind,
    "metadata": toJson_AlertmanagerSpecStorageVolumeClaimTemplateMetadata(
      obj.metadata,
    ),
    "spec": toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpec(obj.spec),
    "status": toJson_AlertmanagerSpecStorageVolumeClaimTemplateStatus(
      obj.status,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
 *
 * @schema AlertmanagerSpecTopologySpreadConstraintsLabelSelector
 */
export interface AlertmanagerSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecTopologySpreadConstraintsLabelSelector(
  obj: AlertmanagerSpecTopologySpreadConstraintsLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema AlertmanagerSpecVolumesAwsElasticBlockStore
 */
export interface AlertmanagerSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema AlertmanagerSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema AlertmanagerSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AlertmanagerSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema AlertmanagerSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesAwsElasticBlockStore(
  obj: AlertmanagerSpecVolumesAwsElasticBlockStore | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "partition": obj.partition,
    "readOnly": obj.readOnly,
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema AlertmanagerSpecVolumesAzureDisk
 */
export interface AlertmanagerSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema AlertmanagerSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema AlertmanagerSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema AlertmanagerSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AlertmanagerSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema AlertmanagerSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema AlertmanagerSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesAzureDisk(
  obj: AlertmanagerSpecVolumesAzureDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "cachingMode": obj.cachingMode,
    "diskName": obj.diskName,
    "diskURI": obj.diskUri,
    "fsType": obj.fsType,
    "kind": obj.kind,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema AlertmanagerSpecVolumesAzureFile
 */
export interface AlertmanagerSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema AlertmanagerSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema AlertmanagerSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema AlertmanagerSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesAzureFile(
  obj: AlertmanagerSpecVolumesAzureFile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "readOnly": obj.readOnly,
    "secretName": obj.secretName,
    "shareName": obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema AlertmanagerSpecVolumesCephfs
 */
export interface AlertmanagerSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AlertmanagerSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema AlertmanagerSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema AlertmanagerSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AlertmanagerSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AlertmanagerSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: AlertmanagerSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema AlertmanagerSpecVolumesCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesCephfs(
  obj: AlertmanagerSpecVolumesCephfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "monitors": obj.monitors?.map((y) => y),
    "path": obj.path,
    "readOnly": obj.readOnly,
    "secretFile": obj.secretFile,
    "secretRef": toJson_AlertmanagerSpecVolumesCephfsSecretRef(obj.secretRef),
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema AlertmanagerSpecVolumesCinder
 */
export interface AlertmanagerSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AlertmanagerSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AlertmanagerSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema AlertmanagerSpecVolumesCinder#secretRef
   */
  readonly secretRef?: AlertmanagerSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema AlertmanagerSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesCinder(
  obj: AlertmanagerSpecVolumesCinder | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "secretRef": toJson_AlertmanagerSpecVolumesCinderSecretRef(obj.secretRef),
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema AlertmanagerSpecVolumesConfigMap
 */
export interface AlertmanagerSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema AlertmanagerSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema AlertmanagerSpecVolumesConfigMap#items
   */
  readonly items?: AlertmanagerSpecVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema AlertmanagerSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesConfigMap(
  obj: AlertmanagerSpecVolumesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) =>
      toJson_AlertmanagerSpecVolumesConfigMapItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema AlertmanagerSpecVolumesCsi
 */
export interface AlertmanagerSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema AlertmanagerSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema AlertmanagerSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema AlertmanagerSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?:
    AlertmanagerSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema AlertmanagerSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema AlertmanagerSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesCsi(
  obj: AlertmanagerSpecVolumesCsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "driver": obj.driver,
    "fsType": obj.fsType,
    "nodePublishSecretRef":
      toJson_AlertmanagerSpecVolumesCsiNodePublishSecretRef(
        obj.nodePublishSecretRef,
      ),
    "readOnly": obj.readOnly,
    "volumeAttributes": ((obj.volumeAttributes) === undefined)
      ? undefined
      : (Object.entries(obj.volumeAttributes).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema AlertmanagerSpecVolumesDownwardApi
 */
export interface AlertmanagerSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema AlertmanagerSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema AlertmanagerSpecVolumesDownwardApi#items
   */
  readonly items?: AlertmanagerSpecVolumesDownwardApiItems[];
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesDownwardApi(
  obj: AlertmanagerSpecVolumesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) =>
      toJson_AlertmanagerSpecVolumesDownwardApiItems(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema AlertmanagerSpecVolumesEmptyDir
 */
export interface AlertmanagerSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AlertmanagerSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema AlertmanagerSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: AlertmanagerSpecVolumesEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesEmptyDir(
  obj: AlertmanagerSpecVolumesEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "medium": obj.medium,
    "sizeLimit": obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema AlertmanagerSpecVolumesEphemeral
 */
export interface AlertmanagerSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema AlertmanagerSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?:
    AlertmanagerSpecVolumesEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesEphemeral(
  obj: AlertmanagerSpecVolumesEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "volumeClaimTemplate":
      toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplate(
        obj.volumeClaimTemplate,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema AlertmanagerSpecVolumesFc
 */
export interface AlertmanagerSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema AlertmanagerSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema AlertmanagerSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema AlertmanagerSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema AlertmanagerSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema AlertmanagerSpecVolumesFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesFc(
  obj: AlertmanagerSpecVolumesFc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "lun": obj.lun,
    "readOnly": obj.readOnly,
    "targetWWNs": obj.targetWwNs?.map((y) => y),
    "wwids": obj.wwids?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema AlertmanagerSpecVolumesFlexVolume
 */
export interface AlertmanagerSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema AlertmanagerSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema AlertmanagerSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema AlertmanagerSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema AlertmanagerSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema AlertmanagerSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: AlertmanagerSpecVolumesFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesFlexVolume(
  obj: AlertmanagerSpecVolumesFlexVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "driver": obj.driver,
    "fsType": obj.fsType,
    "options": ((obj.options) === undefined)
      ? undefined
      : (Object.entries(obj.options).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "readOnly": obj.readOnly,
    "secretRef": toJson_AlertmanagerSpecVolumesFlexVolumeSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema AlertmanagerSpecVolumesFlocker
 */
export interface AlertmanagerSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema AlertmanagerSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema AlertmanagerSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesFlocker(
  obj: AlertmanagerSpecVolumesFlocker | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "datasetName": obj.datasetName,
    "datasetUUID": obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema AlertmanagerSpecVolumesGcePersistentDisk
 */
export interface AlertmanagerSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema AlertmanagerSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AlertmanagerSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema AlertmanagerSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema AlertmanagerSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesGcePersistentDisk(
  obj: AlertmanagerSpecVolumesGcePersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "partition": obj.partition,
    "pdName": obj.pdName,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema AlertmanagerSpecVolumesGitRepo
 */
export interface AlertmanagerSpecVolumesGitRepo {
  /**
   * directory is the target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema AlertmanagerSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema AlertmanagerSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema AlertmanagerSpecVolumesGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesGitRepo(
  obj: AlertmanagerSpecVolumesGitRepo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "directory": obj.directory,
    "repository": obj.repository,
    "revision": obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema AlertmanagerSpecVolumesGlusterfs
 */
export interface AlertmanagerSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema AlertmanagerSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema AlertmanagerSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema AlertmanagerSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesGlusterfs(
  obj: AlertmanagerSpecVolumesGlusterfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "endpoints": obj.endpoints,
    "path": obj.path,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema AlertmanagerSpecVolumesHostPath
 */
export interface AlertmanagerSpecVolumesHostPath {
  /**
   * path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema AlertmanagerSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema AlertmanagerSpecVolumesHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesHostPath(
  obj: AlertmanagerSpecVolumesHostPath | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "path": obj.path,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema AlertmanagerSpecVolumesIscsi
 */
export interface AlertmanagerSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema AlertmanagerSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema AlertmanagerSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema AlertmanagerSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema AlertmanagerSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema AlertmanagerSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema AlertmanagerSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema AlertmanagerSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema AlertmanagerSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema AlertmanagerSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema AlertmanagerSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: AlertmanagerSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema AlertmanagerSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesIscsi(
  obj: AlertmanagerSpecVolumesIscsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "chapAuthDiscovery": obj.chapAuthDiscovery,
    "chapAuthSession": obj.chapAuthSession,
    "fsType": obj.fsType,
    "initiatorName": obj.initiatorName,
    "iqn": obj.iqn,
    "iscsiInterface": obj.iscsiInterface,
    "lun": obj.lun,
    "portals": obj.portals?.map((y) => y),
    "readOnly": obj.readOnly,
    "secretRef": toJson_AlertmanagerSpecVolumesIscsiSecretRef(obj.secretRef),
    "targetPortal": obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema AlertmanagerSpecVolumesNfs
 */
export interface AlertmanagerSpecVolumesNfs {
  /**
   * path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AlertmanagerSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema AlertmanagerSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema AlertmanagerSpecVolumesNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesNfs(
  obj: AlertmanagerSpecVolumesNfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "path": obj.path,
    "readOnly": obj.readOnly,
    "server": obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema AlertmanagerSpecVolumesPersistentVolumeClaim
 */
export interface AlertmanagerSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema AlertmanagerSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema AlertmanagerSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesPersistentVolumeClaim(
  obj: AlertmanagerSpecVolumesPersistentVolumeClaim | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claimName": obj.claimName,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema AlertmanagerSpecVolumesPhotonPersistentDisk
 */
export interface AlertmanagerSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AlertmanagerSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema AlertmanagerSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesPhotonPersistentDisk(
  obj: AlertmanagerSpecVolumesPhotonPersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "pdID": obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema AlertmanagerSpecVolumesPortworxVolume
 */
export interface AlertmanagerSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AlertmanagerSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema AlertmanagerSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema AlertmanagerSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesPortworxVolume(
  obj: AlertmanagerSpecVolumesPortworxVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema AlertmanagerSpecVolumesProjected
 */
export interface AlertmanagerSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AlertmanagerSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema AlertmanagerSpecVolumesProjected#sources
   */
  readonly sources?: AlertmanagerSpecVolumesProjectedSources[];
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesProjected(
  obj: AlertmanagerSpecVolumesProjected | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "sources": obj.sources?.map((y) =>
      toJson_AlertmanagerSpecVolumesProjectedSources(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema AlertmanagerSpecVolumesQuobyte
 */
export interface AlertmanagerSpecVolumesQuobyte {
  /**
   * group to map volume access to Default is no group
   *
   * @default no group
   * @schema AlertmanagerSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema AlertmanagerSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema AlertmanagerSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema AlertmanagerSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema AlertmanagerSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema AlertmanagerSpecVolumesQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesQuobyte(
  obj: AlertmanagerSpecVolumesQuobyte | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "group": obj.group,
    "readOnly": obj.readOnly,
    "registry": obj.registry,
    "tenant": obj.tenant,
    "user": obj.user,
    "volume": obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema AlertmanagerSpecVolumesRbd
 */
export interface AlertmanagerSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema AlertmanagerSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema AlertmanagerSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema AlertmanagerSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema AlertmanagerSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema AlertmanagerSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema AlertmanagerSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema AlertmanagerSpecVolumesRbd#secretRef
   */
  readonly secretRef?: AlertmanagerSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema AlertmanagerSpecVolumesRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesRbd(
  obj: AlertmanagerSpecVolumesRbd | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "image": obj.image,
    "keyring": obj.keyring,
    "monitors": obj.monitors?.map((y) => y),
    "pool": obj.pool,
    "readOnly": obj.readOnly,
    "secretRef": toJson_AlertmanagerSpecVolumesRbdSecretRef(obj.secretRef),
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema AlertmanagerSpecVolumesScaleIo
 */
export interface AlertmanagerSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema AlertmanagerSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema AlertmanagerSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema AlertmanagerSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema AlertmanagerSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema AlertmanagerSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: AlertmanagerSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema AlertmanagerSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema AlertmanagerSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema AlertmanagerSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema AlertmanagerSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema AlertmanagerSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesScaleIo(
  obj: AlertmanagerSpecVolumesScaleIo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "gateway": obj.gateway,
    "protectionDomain": obj.protectionDomain,
    "readOnly": obj.readOnly,
    "secretRef": toJson_AlertmanagerSpecVolumesScaleIoSecretRef(obj.secretRef),
    "sslEnabled": obj.sslEnabled,
    "storageMode": obj.storageMode,
    "storagePool": obj.storagePool,
    "system": obj.system,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema AlertmanagerSpecVolumesSecret
 */
export interface AlertmanagerSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema AlertmanagerSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema AlertmanagerSpecVolumesSecret#items
   */
  readonly items?: AlertmanagerSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema AlertmanagerSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema AlertmanagerSpecVolumesSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesSecret(
  obj: AlertmanagerSpecVolumesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) =>
      toJson_AlertmanagerSpecVolumesSecretItems(y)
    ),
    "optional": obj.optional,
    "secretName": obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema AlertmanagerSpecVolumesStorageos
 */
export interface AlertmanagerSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AlertmanagerSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema AlertmanagerSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema AlertmanagerSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: AlertmanagerSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema AlertmanagerSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema AlertmanagerSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesStorageos(
  obj: AlertmanagerSpecVolumesStorageos | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "secretRef": toJson_AlertmanagerSpecVolumesStorageosSecretRef(
      obj.secretRef,
    ),
    "volumeName": obj.volumeName,
    "volumeNamespace": obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema AlertmanagerSpecVolumesVsphereVolume
 */
export interface AlertmanagerSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema AlertmanagerSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema AlertmanagerSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema AlertmanagerSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema AlertmanagerSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesVsphereVolume(
  obj: AlertmanagerSpecVolumesVsphereVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "storagePolicyID": obj.storagePolicyId,
    "storagePolicyName": obj.storagePolicyName,
    "volumePath": obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines HTTP parameters for web server.
 *
 * @schema AlertmanagerSpecWebHttpConfig
 */
export interface AlertmanagerSpecWebHttpConfig {
  /**
   * List of headers that can be added to HTTP responses.
   *
   * @schema AlertmanagerSpecWebHttpConfig#headers
   */
  readonly headers?: AlertmanagerSpecWebHttpConfigHeaders;

  /**
   * Enable HTTP/2 support. Note that HTTP/2 is only supported with TLS. When TLSConfig is not configured, HTTP/2 will be disabled. Whenever the value of the field changes, a rolling update will be triggered.
   *
   * @schema AlertmanagerSpecWebHttpConfig#http2
   */
  readonly http2?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecWebHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecWebHttpConfig(
  obj: AlertmanagerSpecWebHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "headers": toJson_AlertmanagerSpecWebHttpConfigHeaders(obj.headers),
    "http2": obj.http2,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the TLS parameters for HTTPS.
 *
 * @schema AlertmanagerSpecWebTlsConfig
 */
export interface AlertmanagerSpecWebTlsConfig {
  /**
   * Contains the TLS certificate for the server.
   *
   * @schema AlertmanagerSpecWebTlsConfig#cert
   */
  readonly cert: AlertmanagerSpecWebTlsConfigCert;

  /**
   * List of supported cipher suites for TLS versions up to TLS 1.2. If empty, Go default cipher suites are used. Available cipher suites are documented in the go documentation: https://golang.org/pkg/crypto/tls/#pkg-constants
   *
   * @schema AlertmanagerSpecWebTlsConfig#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * Server policy for client authentication. Maps to ClientAuth Policies. For more detail on clientAuth options: https://golang.org/pkg/crypto/tls/#ClientAuthType
   *
   * @schema AlertmanagerSpecWebTlsConfig#clientAuthType
   */
  readonly clientAuthType?: string;

  /**
   * Contains the CA certificate for client certificate authentication to the server.
   *
   * @schema AlertmanagerSpecWebTlsConfig#client_ca
   */
  readonly clientCa?: AlertmanagerSpecWebTlsConfigClientCa;

  /**
   * Elliptic curves that will be used in an ECDHE handshake, in preference order. Available curves are documented in the go documentation: https://golang.org/pkg/crypto/tls/#CurveID
   *
   * @schema AlertmanagerSpecWebTlsConfig#curvePreferences
   */
  readonly curvePreferences?: string[];

  /**
   * Secret containing the TLS key for the server.
   *
   * @schema AlertmanagerSpecWebTlsConfig#keySecret
   */
  readonly keySecret: AlertmanagerSpecWebTlsConfigKeySecret;

  /**
   * Maximum TLS version that is acceptable. Defaults to TLS13.
   *
   * @default TLS13.
   * @schema AlertmanagerSpecWebTlsConfig#maxVersion
   */
  readonly maxVersion?: string;

  /**
   * Minimum TLS version that is acceptable. Defaults to TLS12.
   *
   * @default TLS12.
   * @schema AlertmanagerSpecWebTlsConfig#minVersion
   */
  readonly minVersion?: string;

  /**
   * Controls whether the server selects the client's most preferred cipher suite, or the server's most preferred cipher suite. If true then the server's preference, as expressed in the order of elements in cipherSuites, is used.
   *
   * @schema AlertmanagerSpecWebTlsConfig#preferServerCipherSuites
   */
  readonly preferServerCipherSuites?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecWebTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecWebTlsConfig(
  obj: AlertmanagerSpecWebTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "cert": toJson_AlertmanagerSpecWebTlsConfigCert(obj.cert),
    "cipherSuites": obj.cipherSuites?.map((y) => y),
    "clientAuthType": obj.clientAuthType,
    "client_ca": toJson_AlertmanagerSpecWebTlsConfigClientCa(obj.clientCa),
    "curvePreferences": obj.curvePreferences?.map((y) => y),
    "keySecret": toJson_AlertmanagerSpecWebTlsConfigKeySecret(obj.keySecret),
    "maxVersion": obj.maxVersion,
    "minVersion": obj.minVersion,
    "preferServerCipherSuites": obj.preferServerCipherSuites,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference:
    AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preference":
      toJson_AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms:
    AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeSelectorTerms": obj.nodeSelectorTerms?.map((y) =>
      toJson_AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the Alertmanager object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig#oauth2
   */
  readonly oauth2?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig(
  obj: AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The default OpsGenie API Key.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiKey
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiKey(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiKey
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The default OpsGenie API URL.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiUrl
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiUrl {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiUrl#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiUrl#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiUrl#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiUrl(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalOpsGenieApiUrl
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The default Slack API URL.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSlackApiUrl
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalSlackApiUrl {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSlackApiUrl#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSlackApiUrl#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSlackApiUrl#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalSlackApiUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalSlackApiUrl(
  obj: AlertmanagerSpecAlertmanagerConfigurationGlobalSlackApiUrl | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Configures global SMTP parameters.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp {
  /**
   * SMTP Auth using PLAIN
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp#authIdentity
   */
  readonly authIdentity?: string;

  /**
   * SMTP Auth using LOGIN and PLAIN.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp#authPassword
   */
  readonly authPassword?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthPassword;

  /**
   * SMTP Auth using CRAM-MD5.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp#authSecret
   */
  readonly authSecret?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthSecret;

  /**
   * SMTP Auth using CRAM-MD5, LOGIN and PLAIN. If empty, Alertmanager doesn't authenticate to the SMTP server.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp#authUsername
   */
  readonly authUsername?: string;

  /**
   * The default SMTP From header field.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp#from
   */
  readonly from?: string;

  /**
   * The default hostname to identify to the SMTP server.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp#hello
   */
  readonly hello?: string;

  /**
   * The default SMTP TLS requirement. Note that Go does not support unencrypted connections to remote SMTP endpoints.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp#requireTLS
   */
  readonly requireTls?: boolean;

  /**
   * The default SMTP smarthost used for sending emails.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp#smartHost
   */
  readonly smartHost?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpSmartHost;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp(
  obj: AlertmanagerSpecAlertmanagerConfigurationGlobalSmtp | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authIdentity": obj.authIdentity,
    "authPassword":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthPassword(
        obj.authPassword,
      ),
    "authSecret":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthSecret(
        obj.authSecret,
      ),
    "authUsername": obj.authUsername,
    "from": obj.from,
    "hello": obj.hello,
    "requireTLS": obj.requireTls,
    "smartHost":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpSmartHost(
        obj.smartHost,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationTemplatesConfigMap
 */
export interface AlertmanagerSpecAlertmanagerConfigurationTemplatesConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationTemplatesConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationTemplatesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationTemplatesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationTemplatesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationTemplatesConfigMap(
  obj: AlertmanagerSpecAlertmanagerConfigurationTemplatesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationTemplatesSecret
 */
export interface AlertmanagerSpecAlertmanagerConfigurationTemplatesSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationTemplatesSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationTemplatesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationTemplatesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationTemplatesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationTemplatesSecret(
  obj: AlertmanagerSpecAlertmanagerConfigurationTemplatesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema AlertmanagerSpecContainersEnvValueFrom
 */
export interface AlertmanagerSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema AlertmanagerSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?:
    AlertmanagerSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema AlertmanagerSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: AlertmanagerSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema AlertmanagerSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?:
    AlertmanagerSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema AlertmanagerSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: AlertmanagerSpecContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersEnvValueFrom(
  obj: AlertmanagerSpecContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapKeyRef":
      toJson_AlertmanagerSpecContainersEnvValueFromConfigMapKeyRef(
        obj.configMapKeyRef,
      ),
    "fieldRef": toJson_AlertmanagerSpecContainersEnvValueFromFieldRef(
      obj.fieldRef,
    ),
    "resourceFieldRef":
      toJson_AlertmanagerSpecContainersEnvValueFromResourceFieldRef(
        obj.resourceFieldRef,
      ),
    "secretKeyRef": toJson_AlertmanagerSpecContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema AlertmanagerSpecContainersEnvFromConfigMapRef
 */
export interface AlertmanagerSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema AlertmanagerSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersEnvFromConfigMapRef(
  obj: AlertmanagerSpecContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema AlertmanagerSpecContainersEnvFromSecretRef
 */
export interface AlertmanagerSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema AlertmanagerSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersEnvFromSecretRef(
  obj: AlertmanagerSpecContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AlertmanagerSpecContainersLifecyclePostStart
 */
export interface AlertmanagerSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: AlertmanagerSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: AlertmanagerSpecContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: AlertmanagerSpecContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLifecyclePostStart(
  obj: AlertmanagerSpecContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_AlertmanagerSpecContainersLifecyclePostStartExec(obj.exec),
    "httpGet": toJson_AlertmanagerSpecContainersLifecyclePostStartHttpGet(
      obj.httpGet,
    ),
    "tcpSocket": toJson_AlertmanagerSpecContainersLifecyclePostStartTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AlertmanagerSpecContainersLifecyclePreStop
 */
export interface AlertmanagerSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: AlertmanagerSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: AlertmanagerSpecContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: AlertmanagerSpecContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLifecyclePreStop(
  obj: AlertmanagerSpecContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_AlertmanagerSpecContainersLifecyclePreStopExec(obj.exec),
    "httpGet": toJson_AlertmanagerSpecContainersLifecyclePreStopHttpGet(
      obj.httpGet,
    ),
    "tcpSocket": toJson_AlertmanagerSpecContainersLifecyclePreStopTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema AlertmanagerSpecContainersLivenessProbeExec
 */
export interface AlertmanagerSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AlertmanagerSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLivenessProbeExec(
  obj: AlertmanagerSpecContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema AlertmanagerSpecContainersLivenessProbeGrpc
 */
export interface AlertmanagerSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AlertmanagerSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AlertmanagerSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLivenessProbeGrpc(
  obj: AlertmanagerSpecContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema AlertmanagerSpecContainersLivenessProbeHttpGet
 */
export interface AlertmanagerSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema AlertmanagerSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AlertmanagerSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    AlertmanagerSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AlertmanagerSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: AlertmanagerSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AlertmanagerSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLivenessProbeHttpGet(
  obj: AlertmanagerSpecContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_AlertmanagerSpecContainersLivenessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema AlertmanagerSpecContainersLivenessProbeTcpSocket
 */
export interface AlertmanagerSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AlertmanagerSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: AlertmanagerSpecContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLivenessProbeTcpSocket(
  obj: AlertmanagerSpecContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema AlertmanagerSpecContainersReadinessProbeExec
 */
export interface AlertmanagerSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AlertmanagerSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersReadinessProbeExec(
  obj: AlertmanagerSpecContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema AlertmanagerSpecContainersReadinessProbeGrpc
 */
export interface AlertmanagerSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AlertmanagerSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AlertmanagerSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersReadinessProbeGrpc(
  obj: AlertmanagerSpecContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema AlertmanagerSpecContainersReadinessProbeHttpGet
 */
export interface AlertmanagerSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema AlertmanagerSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AlertmanagerSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    AlertmanagerSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AlertmanagerSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: AlertmanagerSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AlertmanagerSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersReadinessProbeHttpGet(
  obj: AlertmanagerSpecContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_AlertmanagerSpecContainersReadinessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema AlertmanagerSpecContainersReadinessProbeTcpSocket
 */
export interface AlertmanagerSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AlertmanagerSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: AlertmanagerSpecContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersReadinessProbeTcpSocket(
  obj: AlertmanagerSpecContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AlertmanagerSpecContainersResourcesClaims
 */
export interface AlertmanagerSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema AlertmanagerSpecContainersResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersResourcesClaims(
  obj: AlertmanagerSpecContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertmanagerSpecContainersResourcesLimits
 */
export class AlertmanagerSpecContainersResourcesLimits {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersResourcesLimits {
    return new AlertmanagerSpecContainersResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersResourcesLimits {
    return new AlertmanagerSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema AlertmanagerSpecContainersResourcesRequests
 */
export class AlertmanagerSpecContainersResourcesRequests {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersResourcesRequests {
    return new AlertmanagerSpecContainersResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersResourcesRequests {
    return new AlertmanagerSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema AlertmanagerSpecContainersSecurityContextCapabilities
 */
export interface AlertmanagerSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema AlertmanagerSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema AlertmanagerSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersSecurityContextCapabilities(
  obj: AlertmanagerSpecContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "add": obj.add?.map((y) => y),
    "drop": obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AlertmanagerSpecContainersSecurityContextSeLinuxOptions
 */
export interface AlertmanagerSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AlertmanagerSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AlertmanagerSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AlertmanagerSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AlertmanagerSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersSecurityContextSeLinuxOptions(
  obj: AlertmanagerSpecContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AlertmanagerSpecContainersSecurityContextSeccompProfile
 */
export interface AlertmanagerSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AlertmanagerSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema AlertmanagerSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersSecurityContextSeccompProfile(
  obj: AlertmanagerSpecContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AlertmanagerSpecContainersSecurityContextWindowsOptions
 */
export interface AlertmanagerSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AlertmanagerSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AlertmanagerSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AlertmanagerSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema AlertmanagerSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersSecurityContextWindowsOptions(
  obj: AlertmanagerSpecContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema AlertmanagerSpecContainersStartupProbeExec
 */
export interface AlertmanagerSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AlertmanagerSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersStartupProbeExec(
  obj: AlertmanagerSpecContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema AlertmanagerSpecContainersStartupProbeGrpc
 */
export interface AlertmanagerSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AlertmanagerSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AlertmanagerSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersStartupProbeGrpc(
  obj: AlertmanagerSpecContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema AlertmanagerSpecContainersStartupProbeHttpGet
 */
export interface AlertmanagerSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema AlertmanagerSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AlertmanagerSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    AlertmanagerSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AlertmanagerSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecContainersStartupProbeHttpGet#port
   */
  readonly port: AlertmanagerSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AlertmanagerSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersStartupProbeHttpGet(
  obj: AlertmanagerSpecContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_AlertmanagerSpecContainersStartupProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema AlertmanagerSpecContainersStartupProbeTcpSocket
 */
export interface AlertmanagerSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AlertmanagerSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: AlertmanagerSpecContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersStartupProbeTcpSocket(
  obj: AlertmanagerSpecContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema AlertmanagerSpecInitContainersEnvValueFrom
 */
export interface AlertmanagerSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?:
    AlertmanagerSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: AlertmanagerSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?:
    AlertmanagerSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?:
    AlertmanagerSpecInitContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersEnvValueFrom(
  obj: AlertmanagerSpecInitContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapKeyRef":
      toJson_AlertmanagerSpecInitContainersEnvValueFromConfigMapKeyRef(
        obj.configMapKeyRef,
      ),
    "fieldRef": toJson_AlertmanagerSpecInitContainersEnvValueFromFieldRef(
      obj.fieldRef,
    ),
    "resourceFieldRef":
      toJson_AlertmanagerSpecInitContainersEnvValueFromResourceFieldRef(
        obj.resourceFieldRef,
      ),
    "secretKeyRef":
      toJson_AlertmanagerSpecInitContainersEnvValueFromSecretKeyRef(
        obj.secretKeyRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema AlertmanagerSpecInitContainersEnvFromConfigMapRef
 */
export interface AlertmanagerSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema AlertmanagerSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersEnvFromConfigMapRef(
  obj: AlertmanagerSpecInitContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema AlertmanagerSpecInitContainersEnvFromSecretRef
 */
export interface AlertmanagerSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema AlertmanagerSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersEnvFromSecretRef(
  obj: AlertmanagerSpecInitContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePostStart
 */
export interface AlertmanagerSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: AlertmanagerSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: AlertmanagerSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?:
    AlertmanagerSpecInitContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLifecyclePostStart(
  obj: AlertmanagerSpecInitContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_AlertmanagerSpecInitContainersLifecyclePostStartExec(
      obj.exec,
    ),
    "httpGet": toJson_AlertmanagerSpecInitContainersLifecyclePostStartHttpGet(
      obj.httpGet,
    ),
    "tcpSocket":
      toJson_AlertmanagerSpecInitContainersLifecyclePostStartTcpSocket(
        obj.tcpSocket,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePreStop
 */
export interface AlertmanagerSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: AlertmanagerSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: AlertmanagerSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: AlertmanagerSpecInitContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLifecyclePreStop(
  obj: AlertmanagerSpecInitContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_AlertmanagerSpecInitContainersLifecyclePreStopExec(obj.exec),
    "httpGet": toJson_AlertmanagerSpecInitContainersLifecyclePreStopHttpGet(
      obj.httpGet,
    ),
    "tcpSocket": toJson_AlertmanagerSpecInitContainersLifecyclePreStopTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema AlertmanagerSpecInitContainersLivenessProbeExec
 */
export interface AlertmanagerSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLivenessProbeExec(
  obj: AlertmanagerSpecInitContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema AlertmanagerSpecInitContainersLivenessProbeGrpc
 */
export interface AlertmanagerSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLivenessProbeGrpc(
  obj: AlertmanagerSpecInitContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema AlertmanagerSpecInitContainersLivenessProbeHttpGet
 */
export interface AlertmanagerSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    AlertmanagerSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: AlertmanagerSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AlertmanagerSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLivenessProbeHttpGet(
  obj: AlertmanagerSpecInitContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_AlertmanagerSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema AlertmanagerSpecInitContainersLivenessProbeTcpSocket
 */
export interface AlertmanagerSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: AlertmanagerSpecInitContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLivenessProbeTcpSocket(
  obj: AlertmanagerSpecInitContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema AlertmanagerSpecInitContainersReadinessProbeExec
 */
export interface AlertmanagerSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersReadinessProbeExec(
  obj: AlertmanagerSpecInitContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema AlertmanagerSpecInitContainersReadinessProbeGrpc
 */
export interface AlertmanagerSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersReadinessProbeGrpc(
  obj: AlertmanagerSpecInitContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema AlertmanagerSpecInitContainersReadinessProbeHttpGet
 */
export interface AlertmanagerSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    AlertmanagerSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: AlertmanagerSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AlertmanagerSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersReadinessProbeHttpGet(
  obj: AlertmanagerSpecInitContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_AlertmanagerSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema AlertmanagerSpecInitContainersReadinessProbeTcpSocket
 */
export interface AlertmanagerSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: AlertmanagerSpecInitContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersReadinessProbeTcpSocket(
  obj: AlertmanagerSpecInitContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AlertmanagerSpecInitContainersResourcesClaims
 */
export interface AlertmanagerSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema AlertmanagerSpecInitContainersResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersResourcesClaims(
  obj: AlertmanagerSpecInitContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertmanagerSpecInitContainersResourcesLimits
 */
export class AlertmanagerSpecInitContainersResourcesLimits {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersResourcesLimits {
    return new AlertmanagerSpecInitContainersResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersResourcesLimits {
    return new AlertmanagerSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema AlertmanagerSpecInitContainersResourcesRequests
 */
export class AlertmanagerSpecInitContainersResourcesRequests {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersResourcesRequests {
    return new AlertmanagerSpecInitContainersResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersResourcesRequests {
    return new AlertmanagerSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema AlertmanagerSpecInitContainersSecurityContextCapabilities
 */
export interface AlertmanagerSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema AlertmanagerSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema AlertmanagerSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersSecurityContextCapabilities(
  obj: AlertmanagerSpecInitContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "add": obj.add?.map((y) => y),
    "drop": obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AlertmanagerSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface AlertmanagerSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersSecurityContextSeLinuxOptions(
  obj: AlertmanagerSpecInitContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema AlertmanagerSpecInitContainersSecurityContextSeccompProfile
 */
export interface AlertmanagerSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersSecurityContextSeccompProfile(
  obj: AlertmanagerSpecInitContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema AlertmanagerSpecInitContainersSecurityContextWindowsOptions
 */
export interface AlertmanagerSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema AlertmanagerSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema AlertmanagerSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersSecurityContextWindowsOptions(
  obj: AlertmanagerSpecInitContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema AlertmanagerSpecInitContainersStartupProbeExec
 */
export interface AlertmanagerSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersStartupProbeExec(
  obj: AlertmanagerSpecInitContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema AlertmanagerSpecInitContainersStartupProbeGrpc
 */
export interface AlertmanagerSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersStartupProbeGrpc(
  obj: AlertmanagerSpecInitContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema AlertmanagerSpecInitContainersStartupProbeHttpGet
 */
export interface AlertmanagerSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    AlertmanagerSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: AlertmanagerSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AlertmanagerSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersStartupProbeHttpGet(
  obj: AlertmanagerSpecInitContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_AlertmanagerSpecInitContainersStartupProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema AlertmanagerSpecInitContainersStartupProbeTcpSocket
 */
export interface AlertmanagerSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: AlertmanagerSpecInitContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersStartupProbeTcpSocket(
  obj: AlertmanagerSpecInitContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema AlertmanagerSpecStorageEmptyDirSizeLimit
 */
export class AlertmanagerSpecStorageEmptyDirSizeLimit {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecStorageEmptyDirSizeLimit {
    return new AlertmanagerSpecStorageEmptyDirSizeLimit(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecStorageEmptyDirSizeLimit {
    return new AlertmanagerSpecStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplate
 */
export interface AlertmanagerSpecStorageEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplate(
  obj: AlertmanagerSpecStorageEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec(
      obj.spec,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateMetadata
 */
export interface AlertmanagerSpecStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageVolumeClaimTemplateMetadata(
  obj: AlertmanagerSpecStorageVolumeClaimTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "annotations": ((obj.annotations) === undefined)
      ? undefined
      : (Object.entries(obj.annotations).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpec
 */
export interface AlertmanagerSpecStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?:
    AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?: AlertmanagerSpecStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: AlertmanagerSpecStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpec(
  obj: AlertmanagerSpecStorageVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource":
      toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource(
        obj.dataSource,
      ),
    "dataSourceRef":
      toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources": toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecResources(
      obj.resources,
    ),
    "selector": toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecSelector(
      obj.selector,
    ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated: this field is never set.
 *
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatus
 */
export interface AlertmanagerSpecStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC. Key names follow standard Kubernetes label syntax. Valid values are either: * Un-prefixed keys: - storage - the capacity of the volume. * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource" Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used.
   * ClaimResourceStatus can be in any of following states: - ControllerResizeInProgress: State set when resize controller starts resizing the volume in control-plane. - ControllerResizeFailed: State set when resize has failed in resize controller with a terminal error. - NodeResizePending: State set when resize controller has finished resizing the volume but further resizing of volume is needed on the node. - NodeResizeInProgress: State set when kubelet starts resizing the volume. - NodeResizeFailed: State set when resizing has failed in kubelet with a terminal error. Transient errors don't set NodeResizeFailed. For example: if expanding a PVC for more capacity - this field can be one of the following states: - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress" - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed" When this field is not set, it means that no resize operation is in progress for the given PVC.
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity. Key names follow standard Kubernetes label syntax. Valid values are either: * Un-prefixed keys: - storage - the capacity of the volume. * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource" Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used.
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation is requested. For storage quota, the larger value from allocatedResources and PVC.spec.resources is used. If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation. If a volume expansion capacity request is lowered, allocatedResources is only lowered if there are no expansion operations in progress and if the actual volume capacity is equal or lower than the requested capacity.
   * A controller that receives PVC update with previously unknown resourceName should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: {
    [key: string]:
      AlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources;
  };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: {
    [key: string]: AlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity;
  };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?:
    AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions[];

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageVolumeClaimTemplateStatus(
  obj: AlertmanagerSpecStorageVolumeClaimTemplateStatus | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "allocatedResourceStatuses": ((obj.allocatedResourceStatuses) === undefined)
      ? undefined
      : (Object.entries(obj.allocatedResourceStatuses).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "allocatedResources": ((obj.allocatedResources) === undefined)
      ? undefined
      : (Object.entries(obj.allocatedResources).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "capacity": ((obj.capacity) === undefined)
      ? undefined
      : (Object.entries(obj.capacity).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "conditions": obj.conditions?.map((y) =>
      toJson_AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions(y)
    ),
    "phase": obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface AlertmanagerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema AlertmanagerSpecVolumesCephfsSecretRef
 */
export interface AlertmanagerSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesCephfsSecretRef(
  obj: AlertmanagerSpecVolumesCephfsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema AlertmanagerSpecVolumesCinderSecretRef
 */
export interface AlertmanagerSpecVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesCinderSecretRef(
  obj: AlertmanagerSpecVolumesCinderSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AlertmanagerSpecVolumesConfigMapItems
 */
export interface AlertmanagerSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema AlertmanagerSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AlertmanagerSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema AlertmanagerSpecVolumesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesConfigMapItems(
  obj: AlertmanagerSpecVolumesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema AlertmanagerSpecVolumesCsiNodePublishSecretRef
 */
export interface AlertmanagerSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesCsiNodePublishSecretRef(
  obj: AlertmanagerSpecVolumesCsiNodePublishSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema AlertmanagerSpecVolumesDownwardApiItems
 */
export interface AlertmanagerSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema AlertmanagerSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: AlertmanagerSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AlertmanagerSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema AlertmanagerSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema AlertmanagerSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?:
    AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesDownwardApiItems(
  obj: AlertmanagerSpecVolumesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fieldRef": toJson_AlertmanagerSpecVolumesDownwardApiItemsFieldRef(
      obj.fieldRef,
    ),
    "mode": obj.mode,
    "path": obj.path,
    "resourceFieldRef":
      toJson_AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRef(
        obj.resourceFieldRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema AlertmanagerSpecVolumesEmptyDirSizeLimit
 */
export class AlertmanagerSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecVolumesEmptyDirSizeLimit {
    return new AlertmanagerSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecVolumesEmptyDirSizeLimit {
    return new AlertmanagerSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface AlertmanagerSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplate(
  obj: AlertmanagerSpecVolumesEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec(
      obj.spec,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema AlertmanagerSpecVolumesFlexVolumeSecretRef
 */
export interface AlertmanagerSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesFlexVolumeSecretRef(
  obj: AlertmanagerSpecVolumesFlexVolumeSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema AlertmanagerSpecVolumesIscsiSecretRef
 */
export interface AlertmanagerSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesIscsiSecretRef(
  obj: AlertmanagerSpecVolumesIscsiSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema AlertmanagerSpecVolumesProjectedSources
 */
export interface AlertmanagerSpecVolumesProjectedSources {
  /**
   * configMap information about the configMap data to project
   *
   * @schema AlertmanagerSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: AlertmanagerSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema AlertmanagerSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: AlertmanagerSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema AlertmanagerSpecVolumesProjectedSources#secret
   */
  readonly secret?: AlertmanagerSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema AlertmanagerSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?:
    AlertmanagerSpecVolumesProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesProjectedSources(
  obj: AlertmanagerSpecVolumesProjectedSources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_AlertmanagerSpecVolumesProjectedSourcesConfigMap(
      obj.configMap,
    ),
    "downwardAPI": toJson_AlertmanagerSpecVolumesProjectedSourcesDownwardApi(
      obj.downwardApi,
    ),
    "secret": toJson_AlertmanagerSpecVolumesProjectedSourcesSecret(obj.secret),
    "serviceAccountToken":
      toJson_AlertmanagerSpecVolumesProjectedSourcesServiceAccountToken(
        obj.serviceAccountToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema AlertmanagerSpecVolumesRbdSecretRef
 */
export interface AlertmanagerSpecVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesRbdSecretRef(
  obj: AlertmanagerSpecVolumesRbdSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema AlertmanagerSpecVolumesScaleIoSecretRef
 */
export interface AlertmanagerSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesScaleIoSecretRef(
  obj: AlertmanagerSpecVolumesScaleIoSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AlertmanagerSpecVolumesSecretItems
 */
export interface AlertmanagerSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema AlertmanagerSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AlertmanagerSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema AlertmanagerSpecVolumesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesSecretItems(
  obj: AlertmanagerSpecVolumesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema AlertmanagerSpecVolumesStorageosSecretRef
 */
export interface AlertmanagerSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesStorageosSecretRef(
  obj: AlertmanagerSpecVolumesStorageosSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * List of headers that can be added to HTTP responses.
 *
 * @schema AlertmanagerSpecWebHttpConfigHeaders
 */
export interface AlertmanagerSpecWebHttpConfigHeaders {
  /**
   * Set the Content-Security-Policy header to HTTP responses. Unset if blank.
   *
   * @schema AlertmanagerSpecWebHttpConfigHeaders#contentSecurityPolicy
   */
  readonly contentSecurityPolicy?: string;

  /**
   * Set the Strict-Transport-Security header to HTTP responses. Unset if blank. Please make sure that you use this with care as this header might force browsers to load Prometheus and the other applications hosted on the same domain and subdomains over HTTPS. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
   *
   * @schema AlertmanagerSpecWebHttpConfigHeaders#strictTransportSecurity
   */
  readonly strictTransportSecurity?: string;

  /**
   * Set the X-Content-Type-Options header to HTTP responses. Unset if blank. Accepted value is nosniff. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
   *
   * @schema AlertmanagerSpecWebHttpConfigHeaders#xContentTypeOptions
   */
  readonly xContentTypeOptions?:
    AlertmanagerSpecWebHttpConfigHeadersXContentTypeOptions;

  /**
   * Set the X-Frame-Options header to HTTP responses. Unset if blank. Accepted values are deny and sameorigin. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
   *
   * @schema AlertmanagerSpecWebHttpConfigHeaders#xFrameOptions
   */
  readonly xFrameOptions?: AlertmanagerSpecWebHttpConfigHeadersXFrameOptions;

  /**
   * Set the X-XSS-Protection header to all responses. Unset if blank. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
   *
   * @schema AlertmanagerSpecWebHttpConfigHeaders#xXSSProtection
   */
  readonly xXssProtection?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecWebHttpConfigHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecWebHttpConfigHeaders(
  obj: AlertmanagerSpecWebHttpConfigHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "contentSecurityPolicy": obj.contentSecurityPolicy,
    "strictTransportSecurity": obj.strictTransportSecurity,
    "xContentTypeOptions": obj.xContentTypeOptions,
    "xFrameOptions": obj.xFrameOptions,
    "xXSSProtection": obj.xXssProtection,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the TLS certificate for the server.
 *
 * @schema AlertmanagerSpecWebTlsConfigCert
 */
export interface AlertmanagerSpecWebTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerSpecWebTlsConfigCert#configMap
   */
  readonly configMap?: AlertmanagerSpecWebTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerSpecWebTlsConfigCert#secret
   */
  readonly secret?: AlertmanagerSpecWebTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerSpecWebTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecWebTlsConfigCert(
  obj: AlertmanagerSpecWebTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_AlertmanagerSpecWebTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_AlertmanagerSpecWebTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the CA certificate for client certificate authentication to the server.
 *
 * @schema AlertmanagerSpecWebTlsConfigClientCa
 */
export interface AlertmanagerSpecWebTlsConfigClientCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerSpecWebTlsConfigClientCa#configMap
   */
  readonly configMap?: AlertmanagerSpecWebTlsConfigClientCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerSpecWebTlsConfigClientCa#secret
   */
  readonly secret?: AlertmanagerSpecWebTlsConfigClientCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerSpecWebTlsConfigClientCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecWebTlsConfigClientCa(
  obj: AlertmanagerSpecWebTlsConfigClientCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_AlertmanagerSpecWebTlsConfigClientCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_AlertmanagerSpecWebTlsConfigClientCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the TLS key for the server.
 *
 * @schema AlertmanagerSpecWebTlsConfigKeySecret
 */
export interface AlertmanagerSpecWebTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecWebTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecWebTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecWebTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecWebTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecWebTlsConfigKeySecret(
  obj: AlertmanagerSpecWebTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?:
    AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?:
    AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorization
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorization(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuth
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuth(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the Alertmanager object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBearerTokenSecret
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SMTP Auth using LOGIN and PLAIN.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthPassword
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthPassword(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SMTP Auth using CRAM-MD5.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthSecret
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthSecret(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpAuthSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The default SMTP smarthost used for sending emails.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpSmartHost
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpSmartHost {
  /**
   * Defines the host's address, it can be a DNS name or a literal IP address.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpSmartHost#host
   */
  readonly host: string;

  /**
   * Defines the host's port, it can be a literal port number or a port name.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpSmartHost#port
   */
  readonly port: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpSmartHost' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpSmartHost(
  obj: AlertmanagerSpecAlertmanagerConfigurationGlobalSmtpSmartHost | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema AlertmanagerSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface AlertmanagerSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AlertmanagerSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersEnvValueFromConfigMapKeyRef(
  obj: AlertmanagerSpecContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema AlertmanagerSpecContainersEnvValueFromFieldRef
 */
export interface AlertmanagerSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AlertmanagerSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AlertmanagerSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersEnvValueFromFieldRef(
  obj: AlertmanagerSpecContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema AlertmanagerSpecContainersEnvValueFromResourceFieldRef
 */
export interface AlertmanagerSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AlertmanagerSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AlertmanagerSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?:
    AlertmanagerSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AlertmanagerSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersEnvValueFromResourceFieldRef(
  obj: AlertmanagerSpecContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema AlertmanagerSpecContainersEnvValueFromSecretKeyRef
 */
export interface AlertmanagerSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersEnvValueFromSecretKeyRef(
  obj: AlertmanagerSpecContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema AlertmanagerSpecContainersLifecyclePostStartExec
 */
export interface AlertmanagerSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLifecyclePostStartExec(
  obj: AlertmanagerSpecContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema AlertmanagerSpecContainersLifecyclePostStartHttpGet
 */
export interface AlertmanagerSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    AlertmanagerSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: AlertmanagerSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AlertmanagerSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLifecyclePostStartHttpGet(
  obj: AlertmanagerSpecContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_AlertmanagerSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema AlertmanagerSpecContainersLifecyclePostStartTcpSocket
 */
export interface AlertmanagerSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: AlertmanagerSpecContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLifecyclePostStartTcpSocket(
  obj: AlertmanagerSpecContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema AlertmanagerSpecContainersLifecyclePreStopExec
 */
export interface AlertmanagerSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLifecyclePreStopExec(
  obj: AlertmanagerSpecContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema AlertmanagerSpecContainersLifecyclePreStopHttpGet
 */
export interface AlertmanagerSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    AlertmanagerSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: AlertmanagerSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AlertmanagerSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLifecyclePreStopHttpGet(
  obj: AlertmanagerSpecContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_AlertmanagerSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema AlertmanagerSpecContainersLifecyclePreStopTcpSocket
 */
export interface AlertmanagerSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: AlertmanagerSpecContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLifecyclePreStopTcpSocket(
  obj: AlertmanagerSpecContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AlertmanagerSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface AlertmanagerSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AlertmanagerSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AlertmanagerSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLivenessProbeHttpGetHttpHeaders(
  obj: AlertmanagerSpecContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecContainersLivenessProbeHttpGetPort
 */
export class AlertmanagerSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersLivenessProbeHttpGetPort {
    return new AlertmanagerSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersLivenessProbeHttpGetPort {
    return new AlertmanagerSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecContainersLivenessProbeTcpSocketPort
 */
export class AlertmanagerSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersLivenessProbeTcpSocketPort {
    return new AlertmanagerSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersLivenessProbeTcpSocketPort {
    return new AlertmanagerSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AlertmanagerSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface AlertmanagerSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AlertmanagerSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AlertmanagerSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersReadinessProbeHttpGetHttpHeaders(
  obj: AlertmanagerSpecContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecContainersReadinessProbeHttpGetPort
 */
export class AlertmanagerSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersReadinessProbeHttpGetPort {
    return new AlertmanagerSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersReadinessProbeHttpGetPort {
    return new AlertmanagerSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecContainersReadinessProbeTcpSocketPort
 */
export class AlertmanagerSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersReadinessProbeTcpSocketPort {
    return new AlertmanagerSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersReadinessProbeTcpSocketPort {
    return new AlertmanagerSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AlertmanagerSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface AlertmanagerSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AlertmanagerSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AlertmanagerSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersStartupProbeHttpGetHttpHeaders(
  obj: AlertmanagerSpecContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecContainersStartupProbeHttpGetPort
 */
export class AlertmanagerSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersStartupProbeHttpGetPort {
    return new AlertmanagerSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersStartupProbeHttpGetPort {
    return new AlertmanagerSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecContainersStartupProbeTcpSocketPort
 */
export class AlertmanagerSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersStartupProbeTcpSocketPort {
    return new AlertmanagerSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersStartupProbeTcpSocketPort {
    return new AlertmanagerSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema AlertmanagerSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface AlertmanagerSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersEnvValueFromConfigMapKeyRef(
  obj: AlertmanagerSpecInitContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema AlertmanagerSpecInitContainersEnvValueFromFieldRef
 */
export interface AlertmanagerSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersEnvValueFromFieldRef(
  obj: AlertmanagerSpecInitContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema AlertmanagerSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface AlertmanagerSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?:
    AlertmanagerSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersEnvValueFromResourceFieldRef(
  obj: AlertmanagerSpecInitContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema AlertmanagerSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface AlertmanagerSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersEnvValueFromSecretKeyRef(
  obj: AlertmanagerSpecInitContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePostStartExec
 */
export interface AlertmanagerSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLifecyclePostStartExec(
  obj: AlertmanagerSpecInitContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePostStartHttpGet
 */
export interface AlertmanagerSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    AlertmanagerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: AlertmanagerSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AlertmanagerSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLifecyclePostStartHttpGet(
  obj: AlertmanagerSpecInitContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_AlertmanagerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
        y,
      )
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface AlertmanagerSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: AlertmanagerSpecInitContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLifecyclePostStartTcpSocket(
  obj: AlertmanagerSpecInitContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePreStopExec
 */
export interface AlertmanagerSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLifecyclePreStopExec(
  obj: AlertmanagerSpecInitContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePreStopHttpGet
 */
export interface AlertmanagerSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    AlertmanagerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: AlertmanagerSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema AlertmanagerSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLifecyclePreStopHttpGet(
  obj: AlertmanagerSpecInitContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_AlertmanagerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface AlertmanagerSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: AlertmanagerSpecInitContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLifecyclePreStopTcpSocket(
  obj: AlertmanagerSpecInitContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AlertmanagerSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface AlertmanagerSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AlertmanagerSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLivenessProbeHttpGetHttpHeaders(
  obj:
    | AlertmanagerSpecInitContainersLivenessProbeHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecInitContainersLivenessProbeHttpGetPort
 */
export class AlertmanagerSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersLivenessProbeHttpGetPort {
    return new AlertmanagerSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersLivenessProbeHttpGetPort {
    return new AlertmanagerSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecInitContainersLivenessProbeTcpSocketPort
 */
export class AlertmanagerSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersLivenessProbeTcpSocketPort {
    return new AlertmanagerSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersLivenessProbeTcpSocketPort {
    return new AlertmanagerSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AlertmanagerSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface AlertmanagerSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AlertmanagerSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersReadinessProbeHttpGetHttpHeaders(
  obj:
    | AlertmanagerSpecInitContainersReadinessProbeHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecInitContainersReadinessProbeHttpGetPort
 */
export class AlertmanagerSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersReadinessProbeHttpGetPort {
    return new AlertmanagerSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersReadinessProbeHttpGetPort {
    return new AlertmanagerSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecInitContainersReadinessProbeTcpSocketPort
 */
export class AlertmanagerSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersReadinessProbeTcpSocketPort {
    return new AlertmanagerSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersReadinessProbeTcpSocketPort {
    return new AlertmanagerSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AlertmanagerSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface AlertmanagerSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AlertmanagerSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AlertmanagerSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersStartupProbeHttpGetHttpHeaders(
  obj: AlertmanagerSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecInitContainersStartupProbeHttpGetPort
 */
export class AlertmanagerSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersStartupProbeHttpGetPort {
    return new AlertmanagerSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersStartupProbeHttpGetPort {
    return new AlertmanagerSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecInitContainersStartupProbeTcpSocketPort
 */
export class AlertmanagerSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersStartupProbeTcpSocketPort {
    return new AlertmanagerSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersStartupProbeTcpSocketPort {
    return new AlertmanagerSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec
 */
export interface AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?:
    AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?:
    AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?:
    AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec(
  obj: AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource":
      toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(
        obj.dataSource,
      ),
    "dataSourceRef":
      toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources":
      toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResources(
        obj.resources,
      ),
    "selector":
      toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelector(
        obj.selector,
      ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource
 */
export interface AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource(
  obj: AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSource | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef(
  obj: AlertmanagerSpecStorageVolumeClaimTemplateSpecDataSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecResources
 */
export interface AlertmanagerSpecStorageVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]:
      AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecResources(
  obj: AlertmanagerSpecStorageVolumeClaimTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecSelector
 */
export interface AlertmanagerSpecStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecSelector(
  obj: AlertmanagerSpecStorageVolumeClaimTemplateSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class AlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new AlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new AlertmanagerSpecStorageVolumeClaimTemplateStatusAllocatedResources(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity
 */
export class AlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity {
    return new AlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity {
    return new AlertmanagerSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions
 */
export interface AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports "ResizeStarted" that means the underlying persistent volume is being resized.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions(
  obj: AlertmanagerSpecStorageVolumeClaimTemplateStatusConditions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "lastProbeTime": obj.lastProbeTime?.toISOString(),
    "lastTransitionTime": obj.lastTransitionTime?.toISOString(),
    "message": obj.message,
    "reason": obj.reason,
    "status": obj.status,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema AlertmanagerSpecVolumesDownwardApiItemsFieldRef
 */
export interface AlertmanagerSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AlertmanagerSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AlertmanagerSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesDownwardApiItemsFieldRef(
  obj: AlertmanagerSpecVolumesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?:
    AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRef(
  obj: AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?:
    AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?:
    AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?:
    AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec(
  obj: AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource":
      toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
        obj.dataSource,
      ),
    "dataSourceRef":
      toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources":
      toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
        obj.resources,
      ),
    "selector":
      toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
        obj.selector,
      ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema AlertmanagerSpecVolumesProjectedSourcesConfigMap
 */
export interface AlertmanagerSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: AlertmanagerSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesProjectedSourcesConfigMap(
  obj: AlertmanagerSpecVolumesProjectedSourcesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_AlertmanagerSpecVolumesProjectedSourcesConfigMapItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApi
 */
export interface AlertmanagerSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: AlertmanagerSpecVolumesProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesProjectedSourcesDownwardApi(
  obj: AlertmanagerSpecVolumesProjectedSourcesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_AlertmanagerSpecVolumesProjectedSourcesDownwardApiItems(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema AlertmanagerSpecVolumesProjectedSourcesSecret
 */
export interface AlertmanagerSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: AlertmanagerSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesProjectedSourcesSecret(
  obj: AlertmanagerSpecVolumesProjectedSourcesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_AlertmanagerSpecVolumesProjectedSourcesSecretItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema AlertmanagerSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface AlertmanagerSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema AlertmanagerSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the token into.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesProjectedSourcesServiceAccountToken(
  obj: AlertmanagerSpecVolumesProjectedSourcesServiceAccountToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "audience": obj.audience,
    "expirationSeconds": obj.expirationSeconds,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Set the X-Content-Type-Options header to HTTP responses. Unset if blank. Accepted value is nosniff. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
 *
 * @schema AlertmanagerSpecWebHttpConfigHeadersXContentTypeOptions
 */
export enum AlertmanagerSpecWebHttpConfigHeadersXContentTypeOptions {
  /** NoSniff */
  NO_SNIFF = "NoSniff",
}

/**
 * Set the X-Frame-Options header to HTTP responses. Unset if blank. Accepted values are deny and sameorigin. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
 *
 * @schema AlertmanagerSpecWebHttpConfigHeadersXFrameOptions
 */
export enum AlertmanagerSpecWebHttpConfigHeadersXFrameOptions {
  /** Deny */
  DENY = "Deny",
  /** SameOrigin */
  SAME_ORIGIN = "SameOrigin",
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerSpecWebTlsConfigCertConfigMap
 */
export interface AlertmanagerSpecWebTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerSpecWebTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecWebTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerSpecWebTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecWebTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecWebTlsConfigCertConfigMap(
  obj: AlertmanagerSpecWebTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerSpecWebTlsConfigCertSecret
 */
export interface AlertmanagerSpecWebTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecWebTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecWebTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecWebTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecWebTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecWebTlsConfigCertSecret(
  obj: AlertmanagerSpecWebTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerSpecWebTlsConfigClientCaConfigMap
 */
export interface AlertmanagerSpecWebTlsConfigClientCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerSpecWebTlsConfigClientCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecWebTlsConfigClientCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerSpecWebTlsConfigClientCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecWebTlsConfigClientCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecWebTlsConfigClientCaConfigMap(
  obj: AlertmanagerSpecWebTlsConfigClientCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerSpecWebTlsConfigClientCaSecret
 */
export interface AlertmanagerSpecWebTlsConfigClientCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecWebTlsConfigClientCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecWebTlsConfigClientCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecWebTlsConfigClientCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecWebTlsConfigClientCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecWebTlsConfigClientCaSecret(
  obj: AlertmanagerSpecWebTlsConfigClientCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | AlertmanagerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | AlertmanagerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthPassword
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthUsername
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientId
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCa
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCert
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AlertmanagerSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class AlertmanagerSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new AlertmanagerSpecContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new AlertmanagerSpecContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AlertmanagerSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface AlertmanagerSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AlertmanagerSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLifecyclePostStartHttpGetHttpHeaders(
  obj:
    | AlertmanagerSpecContainersLifecyclePostStartHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecContainersLifecyclePostStartHttpGetPort
 */
export class AlertmanagerSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersLifecyclePostStartHttpGetPort {
    return new AlertmanagerSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersLifecyclePostStartHttpGetPort {
    return new AlertmanagerSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecContainersLifecyclePostStartTcpSocketPort
 */
export class AlertmanagerSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersLifecyclePostStartTcpSocketPort {
    return new AlertmanagerSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersLifecyclePostStartTcpSocketPort {
    return new AlertmanagerSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AlertmanagerSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface AlertmanagerSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AlertmanagerSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: AlertmanagerSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecContainersLifecyclePreStopHttpGetPort
 */
export class AlertmanagerSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersLifecyclePreStopHttpGetPort {
    return new AlertmanagerSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersLifecyclePreStopHttpGetPort {
    return new AlertmanagerSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecContainersLifecyclePreStopTcpSocketPort
 */
export class AlertmanagerSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecContainersLifecyclePreStopTcpSocketPort {
    return new AlertmanagerSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecContainersLifecyclePreStopTcpSocketPort {
    return new AlertmanagerSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AlertmanagerSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class AlertmanagerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new AlertmanagerSpecInitContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new AlertmanagerSpecInitContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface AlertmanagerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
  obj:
    | AlertmanagerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class AlertmanagerSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersLifecyclePostStartHttpGetPort {
    return new AlertmanagerSpecInitContainersLifecyclePostStartHttpGetPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersLifecyclePostStartHttpGetPort {
    return new AlertmanagerSpecInitContainersLifecyclePostStartHttpGetPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class AlertmanagerSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new AlertmanagerSpecInitContainersLifecyclePostStartTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new AlertmanagerSpecInitContainersLifecyclePostStartTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface AlertmanagerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema AlertmanagerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(
  obj:
    | AlertmanagerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class AlertmanagerSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersLifecyclePreStopHttpGetPort {
    return new AlertmanagerSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersLifecyclePreStopHttpGetPort {
    return new AlertmanagerSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema AlertmanagerSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class AlertmanagerSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new AlertmanagerSpecInitContainersLifecyclePreStopTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new AlertmanagerSpecInitContainersLifecyclePreStopTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(
  obj:
    | AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj:
    | AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResources
 */
export interface AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]:
      AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResources(
  obj:
    | AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResources
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims(
        y,
      )
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelector
 */
export interface AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelector(
  obj:
    | AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesClaims
 */
export interface AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesClaims(
  obj:
    | AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesClaims
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new AlertmanagerSpecStorageVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface AlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new AlertmanagerSpecVolumesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
  obj:
    | AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj:
    | AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]:
      AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
  obj:
    | AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResources
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims(
        y,
      )
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
  obj:
    | AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AlertmanagerSpecVolumesProjectedSourcesConfigMapItems
 */
export interface AlertmanagerSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesProjectedSourcesConfigMapItems(
  obj: AlertmanagerSpecVolumesProjectedSourcesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface AlertmanagerSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?:
    AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?:
    AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesProjectedSourcesDownwardApiItems(
  obj: AlertmanagerSpecVolumesProjectedSourcesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fieldRef":
      toJson_AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
        obj.fieldRef,
      ),
    "mode": obj.mode,
    "path": obj.path,
    "resourceFieldRef":
      toJson_AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
        obj.resourceFieldRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema AlertmanagerSpecVolumesProjectedSourcesSecretItems
 */
export interface AlertmanagerSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesProjectedSourcesSecretItems(
  obj: AlertmanagerSpecVolumesProjectedSourcesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerSpecAlertmanagerConfigurationGlobalHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims
 */
export interface AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims(
  obj:
    | AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims
 */
export interface AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims(
  obj:
    | AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | AlertmanagerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
  obj:
    | AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?:
    AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
  obj:
    | AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new AlertmanagerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * AlertmanagerConfig configures the Prometheus Alertmanager, specifying how alerts should be grouped, inhibited and notified to external systems.
 *
 * @schema AlertmanagerConfig
 */
export class AlertmanagerConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AlertmanagerConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "monitoring.coreos.com/v1alpha1",
    kind: "AlertmanagerConfig",
  };

  /**
   * Renders a Kubernetes manifest for "AlertmanagerConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AlertmanagerConfigProps): any {
    return {
      ...AlertmanagerConfig.GVK,
      ...toJson_AlertmanagerConfigProps(props),
    };
  }

  /**
   * Defines a "AlertmanagerConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: AlertmanagerConfigProps,
  ) {
    super(scope, id, {
      ...AlertmanagerConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AlertmanagerConfig.GVK,
      ...toJson_AlertmanagerConfigProps(resolved),
    };
  }
}

/**
 * AlertmanagerConfig configures the Prometheus Alertmanager, specifying how alerts should be grouped, inhibited and notified to external systems.
 *
 * @schema AlertmanagerConfig
 */
export interface AlertmanagerConfigProps {
  /**
   * @schema AlertmanagerConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AlertmanagerConfigSpec is a specification of the desired behavior of the Alertmanager configuration. By definition, the Alertmanager configuration only applies to alerts for which the `namespace` label is equal to the namespace of the AlertmanagerConfig resource.
   *
   * @schema AlertmanagerConfig#spec
   */
  readonly spec: AlertmanagerConfigSpec;
}

/**
 * Converts an object of type 'AlertmanagerConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigProps(
  obj: AlertmanagerConfigProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_AlertmanagerConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlertmanagerConfigSpec is a specification of the desired behavior of the Alertmanager configuration. By definition, the Alertmanager configuration only applies to alerts for which the `namespace` label is equal to the namespace of the AlertmanagerConfig resource.
 *
 * @schema AlertmanagerConfigSpec
 */
export interface AlertmanagerConfigSpec {
  /**
   * List of inhibition rules. The rules will only apply to alerts matching the resource's namespace.
   *
   * @schema AlertmanagerConfigSpec#inhibitRules
   */
  readonly inhibitRules?: AlertmanagerConfigSpecInhibitRules[];

  /**
   * List of MuteTimeInterval specifying when the routes should be muted.
   *
   * @schema AlertmanagerConfigSpec#muteTimeIntervals
   */
  readonly muteTimeIntervals?: AlertmanagerConfigSpecMuteTimeIntervals[];

  /**
   * List of receivers.
   *
   * @schema AlertmanagerConfigSpec#receivers
   */
  readonly receivers?: AlertmanagerConfigSpecReceivers[];

  /**
   * The Alertmanager route definition for alerts matching the resource's namespace. If present, it will be added to the generated Alertmanager configuration as a first-level route.
   *
   * @schema AlertmanagerConfigSpec#route
   */
  readonly route?: AlertmanagerConfigSpecRoute;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpec(
  obj: AlertmanagerConfigSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "inhibitRules": obj.inhibitRules?.map((y) =>
      toJson_AlertmanagerConfigSpecInhibitRules(y)
    ),
    "muteTimeIntervals": obj.muteTimeIntervals?.map((y) =>
      toJson_AlertmanagerConfigSpecMuteTimeIntervals(y)
    ),
    "receivers": obj.receivers?.map((y) =>
      toJson_AlertmanagerConfigSpecReceivers(y)
    ),
    "route": toJson_AlertmanagerConfigSpecRoute(obj.route),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * InhibitRule defines an inhibition rule that allows to mute alerts when other alerts are already firing. See https://prometheus.io/docs/alerting/latest/configuration/#inhibit_rule
 *
 * @schema AlertmanagerConfigSpecInhibitRules
 */
export interface AlertmanagerConfigSpecInhibitRules {
  /**
   * Labels that must have an equal value in the source and target alert for the inhibition to take effect.
   *
   * @schema AlertmanagerConfigSpecInhibitRules#equal
   */
  readonly equal?: string[];

  /**
   * Matchers for which one or more alerts have to exist for the inhibition to take effect. The operator enforces that the alert matches the resource's namespace.
   *
   * @schema AlertmanagerConfigSpecInhibitRules#sourceMatch
   */
  readonly sourceMatch?: AlertmanagerConfigSpecInhibitRulesSourceMatch[];

  /**
   * Matchers that have to be fulfilled in the alerts to be muted. The operator enforces that the alert matches the resource's namespace.
   *
   * @schema AlertmanagerConfigSpecInhibitRules#targetMatch
   */
  readonly targetMatch?: AlertmanagerConfigSpecInhibitRulesTargetMatch[];
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecInhibitRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecInhibitRules(
  obj: AlertmanagerConfigSpecInhibitRules | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "equal": obj.equal?.map((y) => y),
    "sourceMatch": obj.sourceMatch?.map((y) =>
      toJson_AlertmanagerConfigSpecInhibitRulesSourceMatch(y)
    ),
    "targetMatch": obj.targetMatch?.map((y) =>
      toJson_AlertmanagerConfigSpecInhibitRulesTargetMatch(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MuteTimeInterval specifies the periods in time when notifications will be muted
 *
 * @schema AlertmanagerConfigSpecMuteTimeIntervals
 */
export interface AlertmanagerConfigSpecMuteTimeIntervals {
  /**
   * Name of the time interval
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervals#name
   */
  readonly name?: string;

  /**
   * TimeIntervals is a list of TimeInterval
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervals#timeIntervals
   */
  readonly timeIntervals?:
    AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals[];
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecMuteTimeIntervals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecMuteTimeIntervals(
  obj: AlertmanagerConfigSpecMuteTimeIntervals | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "timeIntervals": obj.timeIntervals?.map((y) =>
      toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Receiver defines one or more notification integrations.
 *
 * @schema AlertmanagerConfigSpecReceivers
 */
export interface AlertmanagerConfigSpecReceivers {
  /**
   * List of Discord configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#discordConfigs
   */
  readonly discordConfigs?: AlertmanagerConfigSpecReceiversDiscordConfigs[];

  /**
   * List of Email configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#emailConfigs
   */
  readonly emailConfigs?: AlertmanagerConfigSpecReceiversEmailConfigs[];

  /**
   * List of MSTeams configurations. It requires Alertmanager >= 0.26.0.
   *
   * @schema AlertmanagerConfigSpecReceivers#msteamsConfigs
   */
  readonly msteamsConfigs?: AlertmanagerConfigSpecReceiversMsteamsConfigs[];

  /**
   * Name of the receiver. Must be unique across all items from the list.
   *
   * @schema AlertmanagerConfigSpecReceivers#name
   */
  readonly name: string;

  /**
   * List of OpsGenie configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#opsgenieConfigs
   */
  readonly opsgenieConfigs?: AlertmanagerConfigSpecReceiversOpsgenieConfigs[];

  /**
   * List of PagerDuty configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#pagerdutyConfigs
   */
  readonly pagerdutyConfigs?: AlertmanagerConfigSpecReceiversPagerdutyConfigs[];

  /**
   * List of Pushover configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#pushoverConfigs
   */
  readonly pushoverConfigs?: AlertmanagerConfigSpecReceiversPushoverConfigs[];

  /**
   * List of Slack configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#slackConfigs
   */
  readonly slackConfigs?: AlertmanagerConfigSpecReceiversSlackConfigs[];

  /**
   * List of SNS configurations
   *
   * @schema AlertmanagerConfigSpecReceivers#snsConfigs
   */
  readonly snsConfigs?: AlertmanagerConfigSpecReceiversSnsConfigs[];

  /**
   * List of Telegram configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#telegramConfigs
   */
  readonly telegramConfigs?: AlertmanagerConfigSpecReceiversTelegramConfigs[];

  /**
   * List of VictorOps configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#victoropsConfigs
   */
  readonly victoropsConfigs?: AlertmanagerConfigSpecReceiversVictoropsConfigs[];

  /**
   * List of Webex configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#webexConfigs
   */
  readonly webexConfigs?: AlertmanagerConfigSpecReceiversWebexConfigs[];

  /**
   * List of webhook configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#webhookConfigs
   */
  readonly webhookConfigs?: AlertmanagerConfigSpecReceiversWebhookConfigs[];

  /**
   * List of WeChat configurations.
   *
   * @schema AlertmanagerConfigSpecReceivers#wechatConfigs
   */
  readonly wechatConfigs?: AlertmanagerConfigSpecReceiversWechatConfigs[];
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceivers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceivers(
  obj: AlertmanagerConfigSpecReceivers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "discordConfigs": obj.discordConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigs(y)
    ),
    "emailConfigs": obj.emailConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversEmailConfigs(y)
    ),
    "msteamsConfigs": obj.msteamsConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigs(y)
    ),
    "name": obj.name,
    "opsgenieConfigs": obj.opsgenieConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigs(y)
    ),
    "pagerdutyConfigs": obj.pagerdutyConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigs(y)
    ),
    "pushoverConfigs": obj.pushoverConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigs(y)
    ),
    "slackConfigs": obj.slackConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversSlackConfigs(y)
    ),
    "snsConfigs": obj.snsConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversSnsConfigs(y)
    ),
    "telegramConfigs": obj.telegramConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigs(y)
    ),
    "victoropsConfigs": obj.victoropsConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigs(y)
    ),
    "webexConfigs": obj.webexConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversWebexConfigs(y)
    ),
    "webhookConfigs": obj.webhookConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigs(y)
    ),
    "wechatConfigs": obj.wechatConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversWechatConfigs(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Alertmanager route definition for alerts matching the resource's namespace. If present, it will be added to the generated Alertmanager configuration as a first-level route.
 *
 * @schema AlertmanagerConfigSpecRoute
 */
export interface AlertmanagerConfigSpecRoute {
  /**
   * ActiveTimeIntervals is a list of MuteTimeInterval names when this route should be active.
   *
   * @schema AlertmanagerConfigSpecRoute#activeTimeIntervals
   */
  readonly activeTimeIntervals?: string[];

  /**
   * Boolean indicating whether an alert should continue matching subsequent sibling nodes. It will always be overridden to true for the first-level route by the Prometheus operator.
   *
   * @schema AlertmanagerConfigSpecRoute#continue
   */
  readonly continue?: boolean;

  /**
   * List of labels to group by. Labels must not be repeated (unique list). Special label "..." (aggregate by all possible labels), if provided, must be the only element in the list.
   *
   * @schema AlertmanagerConfigSpecRoute#groupBy
   */
  readonly groupBy?: string[];

  /**
   * How long to wait before sending an updated notification. Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$` Example: "5m"
   *
   * @schema AlertmanagerConfigSpecRoute#groupInterval
   */
  readonly groupInterval?: string;

  /**
   * How long to wait before sending the initial notification. Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$` Example: "30s"
   *
   * @schema AlertmanagerConfigSpecRoute#groupWait
   */
  readonly groupWait?: string;

  /**
   * List of matchers that the alert's labels should match. For the first level route, the operator removes any existing equality and regexp matcher on the `namespace` label and adds a `namespace: <object namespace>` matcher.
   *
   * @schema AlertmanagerConfigSpecRoute#matchers
   */
  readonly matchers?: AlertmanagerConfigSpecRouteMatchers[];

  /**
   * Note: this comment applies to the field definition above but appears below otherwise it gets included in the generated manifest. CRD schema doesn't support self-referential types for now (see https://github.com/kubernetes/kubernetes/issues/62872). We have to use an alternative type to circumvent the limitation. The downside is that the Kube API can't validate the data beyond the fact that it is a valid JSON representation. MuteTimeIntervals is a list of MuteTimeInterval names that will mute this route when matched,
   *
   * @schema AlertmanagerConfigSpecRoute#muteTimeIntervals
   */
  readonly muteTimeIntervals?: string[];

  /**
   * Name of the receiver for this route. If not empty, it should be listed in the `receivers` field.
   *
   * @schema AlertmanagerConfigSpecRoute#receiver
   */
  readonly receiver?: string;

  /**
   * How long to wait before repeating the last notification. Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$` Example: "4h"
   *
   * @schema AlertmanagerConfigSpecRoute#repeatInterval
   */
  readonly repeatInterval?: string;

  /**
   * Child routes.
   *
   * @schema AlertmanagerConfigSpecRoute#routes
   */
  readonly routes?: any[];
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecRoute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecRoute(
  obj: AlertmanagerConfigSpecRoute | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "activeTimeIntervals": obj.activeTimeIntervals?.map((y) => y),
    "continue": obj.continue,
    "groupBy": obj.groupBy?.map((y) => y),
    "groupInterval": obj.groupInterval,
    "groupWait": obj.groupWait,
    "matchers": obj.matchers?.map((y) =>
      toJson_AlertmanagerConfigSpecRouteMatchers(y)
    ),
    "muteTimeIntervals": obj.muteTimeIntervals?.map((y) => y),
    "receiver": obj.receiver,
    "repeatInterval": obj.repeatInterval,
    "routes": obj.routes?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Matcher defines how to match on alert's labels.
 *
 * @schema AlertmanagerConfigSpecInhibitRulesSourceMatch
 */
export interface AlertmanagerConfigSpecInhibitRulesSourceMatch {
  /**
   * Match operation available with AlertManager >= v0.22.0 and takes precedence over Regex (deprecated) if non-empty.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesSourceMatch#matchType
   */
  readonly matchType?: AlertmanagerConfigSpecInhibitRulesSourceMatchMatchType;

  /**
   * Label to match.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesSourceMatch#name
   */
  readonly name: string;

  /**
   * Whether to match on equality (false) or regular-expression (true). Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesSourceMatch#regex
   */
  readonly regex?: boolean;

  /**
   * Label value to match.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesSourceMatch#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecInhibitRulesSourceMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecInhibitRulesSourceMatch(
  obj: AlertmanagerConfigSpecInhibitRulesSourceMatch | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchType": obj.matchType,
    "name": obj.name,
    "regex": obj.regex,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Matcher defines how to match on alert's labels.
 *
 * @schema AlertmanagerConfigSpecInhibitRulesTargetMatch
 */
export interface AlertmanagerConfigSpecInhibitRulesTargetMatch {
  /**
   * Match operation available with AlertManager >= v0.22.0 and takes precedence over Regex (deprecated) if non-empty.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesTargetMatch#matchType
   */
  readonly matchType?: AlertmanagerConfigSpecInhibitRulesTargetMatchMatchType;

  /**
   * Label to match.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesTargetMatch#name
   */
  readonly name: string;

  /**
   * Whether to match on equality (false) or regular-expression (true). Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesTargetMatch#regex
   */
  readonly regex?: boolean;

  /**
   * Label value to match.
   *
   * @schema AlertmanagerConfigSpecInhibitRulesTargetMatch#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecInhibitRulesTargetMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecInhibitRulesTargetMatch(
  obj: AlertmanagerConfigSpecInhibitRulesTargetMatch | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchType": obj.matchType,
    "name": obj.name,
    "regex": obj.regex,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TimeInterval describes intervals of time
 *
 * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals
 */
export interface AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals {
  /**
   * DaysOfMonth is a list of DayOfMonthRange
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals#daysOfMonth
   */
  readonly daysOfMonth?:
    AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth[];

  /**
   * Months is a list of MonthRange
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals#months
   */
  readonly months?: string[];

  /**
   * Times is a list of TimeRange
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals#times
   */
  readonly times?: AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes[];

  /**
   * Weekdays is a list of WeekdayRange
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals#weekdays
   */
  readonly weekdays?: string[];

  /**
   * Years is a list of YearRange
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals#years
   */
  readonly years?: string[];
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals(
  obj: AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervals | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "daysOfMonth": obj.daysOfMonth?.map((y) =>
      toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth(y)
    ),
    "months": obj.months?.map((y) => y),
    "times": obj.times?.map((y) =>
      toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes(y)
    ),
    "weekdays": obj.weekdays?.map((y) => y),
    "years": obj.years?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * DiscordConfig configures notifications via Discord. See https://prometheus.io/docs/alerting/latest/configuration/#discord_config
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigs
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigs {
  /**
   * The secret's key that contains the Discord webhook URL. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigs#apiURL
   */
  readonly apiUrl: AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig;

  /**
   * The template of the message's body.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigs#message
   */
  readonly message?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * The template of the message's title.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigs#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigs(
  obj: AlertmanagerConfigSpecReceiversDiscordConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiURL": toJson_AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl(
      obj.apiUrl,
    ),
    "httpConfig":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig(
        obj.httpConfig,
      ),
    "message": obj.message,
    "sendResolved": obj.sendResolved,
    "title": obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EmailConfig configures notifications via Email.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigs
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigs {
  /**
   * The identity to use for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#authIdentity
   */
  readonly authIdentity?: string;

  /**
   * The secret's key that contains the password to use for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#authPassword
   */
  readonly authPassword?:
    AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword;

  /**
   * The secret's key that contains the CRAM-MD5 secret. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#authSecret
   */
  readonly authSecret?: AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret;

  /**
   * The username to use for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#authUsername
   */
  readonly authUsername?: string;

  /**
   * The sender address.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#from
   */
  readonly from?: string;

  /**
   * Further headers email header key/value pairs. Overrides any headers previously set by the notification implementation.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#headers
   */
  readonly headers?: AlertmanagerConfigSpecReceiversEmailConfigsHeaders[];

  /**
   * The hostname to identify to the SMTP server.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#hello
   */
  readonly hello?: string;

  /**
   * The HTML body of the email notification.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#html
   */
  readonly html?: string;

  /**
   * The SMTP TLS requirement. Note that Go does not support unencrypted connections to remote SMTP endpoints.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#requireTLS
   */
  readonly requireTls?: boolean;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * The SMTP host and port through which emails are sent. E.g. example.com:25
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#smarthost
   */
  readonly smarthost?: string;

  /**
   * The text body of the email notification.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#text
   */
  readonly text?: string;

  /**
   * TLS configuration
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#tlsConfig
   */
  readonly tlsConfig?: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig;

  /**
   * The email address to send notifications to.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigs#to
   */
  readonly to?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigs(
  obj: AlertmanagerConfigSpecReceiversEmailConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authIdentity": obj.authIdentity,
    "authPassword":
      toJson_AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword(
        obj.authPassword,
      ),
    "authSecret": toJson_AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret(
      obj.authSecret,
    ),
    "authUsername": obj.authUsername,
    "from": obj.from,
    "headers": obj.headers?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversEmailConfigsHeaders(y)
    ),
    "hello": obj.hello,
    "html": obj.html,
    "requireTLS": obj.requireTls,
    "sendResolved": obj.sendResolved,
    "smarthost": obj.smarthost,
    "text": obj.text,
    "tlsConfig": toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig(
      obj.tlsConfig,
    ),
    "to": obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MSTeamsConfig configures notifications via Microsoft Teams. It requires Alertmanager >= 0.26.0.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigs {
  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig;

  /**
   * Whether to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * Message body template.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs#text
   */
  readonly text?: string;

  /**
   * Message title template.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs#title
   */
  readonly title?: string;

  /**
   * MSTeams webhook URL.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigs#webhookUrl
   */
  readonly webhookUrl: AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigs(
  obj: AlertmanagerConfigSpecReceiversMsteamsConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "httpConfig":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig(
        obj.httpConfig,
      ),
    "sendResolved": obj.sendResolved,
    "text": obj.text,
    "title": obj.title,
    "webhookUrl":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl(
        obj.webhookUrl,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OpsGenieConfig configures notifications via OpsGenie. See https://prometheus.io/docs/alerting/latest/configuration/#opsgenie_config
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigs {
  /**
   * Comma separated list of actions that will be available for the alert.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#actions
   */
  readonly actions?: string;

  /**
   * The secret's key that contains the OpsGenie API key. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#apiKey
   */
  readonly apiKey?: AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey;

  /**
   * The URL to send OpsGenie API requests to.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#apiURL
   */
  readonly apiUrl?: string;

  /**
   * Description of the incident.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#description
   */
  readonly description?: string;

  /**
   * A set of arbitrary key/value pairs that provide further detail about the incident.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#details
   */
  readonly details?: AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails[];

  /**
   * Optional field that can be used to specify which domain alert is related to.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#entity
   */
  readonly entity?: string;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#httpConfig
   */
  readonly httpConfig?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig;

  /**
   * Alert text limited to 130 characters.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#message
   */
  readonly message?: string;

  /**
   * Additional alert note.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#note
   */
  readonly note?: string;

  /**
   * Priority level of alert. Possible values are P1, P2, P3, P4, and P5.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#priority
   */
  readonly priority?: string;

  /**
   * List of responders responsible for notifications.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#responders
   */
  readonly responders?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders[];

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * Backlink to the sender of the notification.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#source
   */
  readonly source?: string;

  /**
   * Comma separated list of tags attached to the notifications.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#tags
   */
  readonly tags?: string;

  /**
   * Whether to update message and description of the alert in OpsGenie if it already exists By default, the alert is never updated in OpsGenie, the new message only appears in activity log.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigs#updateAlerts
   */
  readonly updateAlerts?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigs(
  obj: AlertmanagerConfigSpecReceiversOpsgenieConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "actions": obj.actions,
    "apiKey": toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey(
      obj.apiKey,
    ),
    "apiURL": obj.apiUrl,
    "description": obj.description,
    "details": obj.details?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails(y)
    ),
    "entity": obj.entity,
    "httpConfig":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig(
        obj.httpConfig,
      ),
    "message": obj.message,
    "note": obj.note,
    "priority": obj.priority,
    "responders": obj.responders?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders(y)
    ),
    "sendResolved": obj.sendResolved,
    "source": obj.source,
    "tags": obj.tags,
    "updateAlerts": obj.updateAlerts,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PagerDutyConfig configures notifications via PagerDuty. See https://prometheus.io/docs/alerting/latest/configuration/#pagerduty_config
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigs {
  /**
   * The class/type of the event.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#class
   */
  readonly class?: string;

  /**
   * Client identification.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#client
   */
  readonly client?: string;

  /**
   * Backlink to the sender of notification.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#clientURL
   */
  readonly clientUrl?: string;

  /**
   * The part or component of the affected system that is broken.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#component
   */
  readonly component?: string;

  /**
   * Description of the incident.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#description
   */
  readonly description?: string;

  /**
   * Arbitrary key/value pairs that provide further detail about the incident.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#details
   */
  readonly details?: AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails[];

  /**
   * A cluster or grouping of sources.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#group
   */
  readonly group?: string;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#httpConfig
   */
  readonly httpConfig?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig;

  /**
   * A list of image details to attach that provide further detail about an incident.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#pagerDutyImageConfigs
   */
  readonly pagerDutyImageConfigs?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs[];

  /**
   * A list of link details to attach that provide further detail about an incident.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#pagerDutyLinkConfigs
   */
  readonly pagerDutyLinkConfigs?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs[];

  /**
   * The secret's key that contains the PagerDuty integration key (when using Events API v2). Either this field or `serviceKey` needs to be defined. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#routingKey
   */
  readonly routingKey?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * The secret's key that contains the PagerDuty service key (when using integration type "Prometheus"). Either this field or `routingKey` needs to be defined. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#serviceKey
   */
  readonly serviceKey?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey;

  /**
   * Severity of the incident.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#severity
   */
  readonly severity?: string;

  /**
   * The URL to send requests to.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigs#url
   */
  readonly url?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigs(
  obj: AlertmanagerConfigSpecReceiversPagerdutyConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "class": obj.class,
    "client": obj.client,
    "clientURL": obj.clientUrl,
    "component": obj.component,
    "description": obj.description,
    "details": obj.details?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails(y)
    ),
    "group": obj.group,
    "httpConfig":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig(
        obj.httpConfig,
      ),
    "pagerDutyImageConfigs": obj.pagerDutyImageConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs(
        y,
      )
    ),
    "pagerDutyLinkConfigs": obj.pagerDutyLinkConfigs?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs(
        y,
      )
    ),
    "routingKey":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey(
        obj.routingKey,
      ),
    "sendResolved": obj.sendResolved,
    "serviceKey":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey(
        obj.serviceKey,
      ),
    "severity": obj.severity,
    "url": obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PushoverConfig configures notifications via Pushover. See https://prometheus.io/docs/alerting/latest/configuration/#pushover_config
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigs
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigs {
  /**
   * The name of a device to send the notification to
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#device
   */
  readonly device?: string;

  /**
   * How long your notification will continue to be retried for, unless the user acknowledges the notification.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#expire
   */
  readonly expire?: string;

  /**
   * Whether notification message is HTML or plain text.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#html
   */
  readonly html?: boolean;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#httpConfig
   */
  readonly httpConfig?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig;

  /**
   * Notification message.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#message
   */
  readonly message?: string;

  /**
   * Priority, see https://pushover.net/api#priority
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#priority
   */
  readonly priority?: string;

  /**
   * How often the Pushover servers will send the same notification to the user. Must be at least 30 seconds.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#retry
   */
  readonly retry?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * The name of one of the sounds supported by device clients to override the user's default sound choice
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#sound
   */
  readonly sound?: string;

  /**
   * Notification title.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#title
   */
  readonly title?: string;

  /**
   * The secret's key that contains the registered application's API token, see https://pushover.net/apps. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator. Either `token` or `tokenFile` is required.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#token
   */
  readonly token?: AlertmanagerConfigSpecReceiversPushoverConfigsToken;

  /**
   * The token file that contains the registered application's API token, see https://pushover.net/apps. Either `token` or `tokenFile` is required. It requires Alertmanager >= v0.26.0.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#tokenFile
   */
  readonly tokenFile?: string;

  /**
   * A supplementary URL shown alongside the message.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#url
   */
  readonly url?: string;

  /**
   * A title for supplementary URL, otherwise just the URL is shown
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#urlTitle
   */
  readonly urlTitle?: string;

  /**
   * The secret's key that contains the recipient user's user key. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator. Either `userKey` or `userKeyFile` is required.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#userKey
   */
  readonly userKey?: AlertmanagerConfigSpecReceiversPushoverConfigsUserKey;

  /**
   * The user key file that contains the recipient user's user key. Either `userKey` or `userKeyFile` is required. It requires Alertmanager >= v0.26.0.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigs#userKeyFile
   */
  readonly userKeyFile?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigs(
  obj: AlertmanagerConfigSpecReceiversPushoverConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "device": obj.device,
    "expire": obj.expire,
    "html": obj.html,
    "httpConfig":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig(
        obj.httpConfig,
      ),
    "message": obj.message,
    "priority": obj.priority,
    "retry": obj.retry,
    "sendResolved": obj.sendResolved,
    "sound": obj.sound,
    "title": obj.title,
    "token": toJson_AlertmanagerConfigSpecReceiversPushoverConfigsToken(
      obj.token,
    ),
    "tokenFile": obj.tokenFile,
    "url": obj.url,
    "urlTitle": obj.urlTitle,
    "userKey": toJson_AlertmanagerConfigSpecReceiversPushoverConfigsUserKey(
      obj.userKey,
    ),
    "userKeyFile": obj.userKeyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SlackConfig configures notifications via Slack. See https://prometheus.io/docs/alerting/latest/configuration/#slack_config
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigs
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigs {
  /**
   * A list of Slack actions that are sent with each notification.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#actions
   */
  readonly actions?: AlertmanagerConfigSpecReceiversSlackConfigsActions[];

  /**
   * The secret's key that contains the Slack webhook URL. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#apiURL
   */
  readonly apiUrl?: AlertmanagerConfigSpecReceiversSlackConfigsApiUrl;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#callbackId
   */
  readonly callbackId?: string;

  /**
   * The channel or user to send notifications to.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#channel
   */
  readonly channel?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#color
   */
  readonly color?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#fallback
   */
  readonly fallback?: string;

  /**
   * A list of Slack fields that are sent with each notification.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#fields
   */
  readonly fields?: AlertmanagerConfigSpecReceiversSlackConfigsFields[];

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#footer
   */
  readonly footer?: string;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#iconEmoji
   */
  readonly iconEmoji?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#iconURL
   */
  readonly iconUrl?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#imageURL
   */
  readonly imageUrl?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#linkNames
   */
  readonly linkNames?: boolean;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#mrkdwnIn
   */
  readonly mrkdwnIn?: string[];

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#pretext
   */
  readonly pretext?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#shortFields
   */
  readonly shortFields?: boolean;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#text
   */
  readonly text?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#thumbURL
   */
  readonly thumbUrl?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#title
   */
  readonly title?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#titleLink
   */
  readonly titleLink?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigs#username
   */
  readonly username?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigs(
  obj: AlertmanagerConfigSpecReceiversSlackConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "actions": obj.actions?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsActions(y)
    ),
    "apiURL": toJson_AlertmanagerConfigSpecReceiversSlackConfigsApiUrl(
      obj.apiUrl,
    ),
    "callbackId": obj.callbackId,
    "channel": obj.channel,
    "color": obj.color,
    "fallback": obj.fallback,
    "fields": obj.fields?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsFields(y)
    ),
    "footer": obj.footer,
    "httpConfig": toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig(
      obj.httpConfig,
    ),
    "iconEmoji": obj.iconEmoji,
    "iconURL": obj.iconUrl,
    "imageURL": obj.imageUrl,
    "linkNames": obj.linkNames,
    "mrkdwnIn": obj.mrkdwnIn?.map((y) => y),
    "pretext": obj.pretext,
    "sendResolved": obj.sendResolved,
    "shortFields": obj.shortFields,
    "text": obj.text,
    "thumbURL": obj.thumbUrl,
    "title": obj.title,
    "titleLink": obj.titleLink,
    "username": obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SNSConfig configures notifications via AWS SNS. See https://prometheus.io/docs/alerting/latest/configuration/#sns_configs
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigs
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigs {
  /**
   * The SNS API URL i.e. https://sns.us-east-2.amazonaws.com. If not specified, the SNS API URL from the SNS SDK will be used.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#apiURL
   */
  readonly apiUrl?: string;

  /**
   * SNS message attributes.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig;

  /**
   * The message content of the SNS notification.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#message
   */
  readonly message?: string;

  /**
   * Phone number if message is delivered via SMS in E.164 format. If you don't specify this value, you must specify a value for the TopicARN or TargetARN.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#phoneNumber
   */
  readonly phoneNumber?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * Configures AWS's Signature Verification 4 signing process to sign requests.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#sigv4
   */
  readonly sigv4?: AlertmanagerConfigSpecReceiversSnsConfigsSigv4;

  /**
   * Subject line when the message is delivered to email endpoints.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#subject
   */
  readonly subject?: string;

  /**
   * The  mobile platform endpoint ARN if message is delivered via mobile notifications. If you don't specify this value, you must specify a value for the topic_arn or PhoneNumber.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#targetARN
   */
  readonly targetArn?: string;

  /**
   * SNS topic ARN, i.e. arn:aws:sns:us-east-2:698519295917:My-Topic If you don't specify this value, you must specify a value for the PhoneNumber or TargetARN.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigs#topicARN
   */
  readonly topicArn?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigs(
  obj: AlertmanagerConfigSpecReceiversSnsConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiURL": obj.apiUrl,
    "attributes": ((obj.attributes) === undefined)
      ? undefined
      : (Object.entries(obj.attributes).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "httpConfig": toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig(
      obj.httpConfig,
    ),
    "message": obj.message,
    "phoneNumber": obj.phoneNumber,
    "sendResolved": obj.sendResolved,
    "sigv4": toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4(obj.sigv4),
    "subject": obj.subject,
    "targetARN": obj.targetArn,
    "topicARN": obj.topicArn,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TelegramConfig configures notifications via Telegram. See https://prometheus.io/docs/alerting/latest/configuration/#telegram_config
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigs
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigs {
  /**
   * The Telegram API URL i.e. https://api.telegram.org. If not specified, default API URL will be used.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#apiURL
   */
  readonly apiUrl?: string;

  /**
   * Telegram bot token. It is mutually exclusive with `botTokenFile`. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   * Either `botToken` or `botTokenFile` is required.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#botToken
   */
  readonly botToken?: AlertmanagerConfigSpecReceiversTelegramConfigsBotToken;

  /**
   * File to read the Telegram bot token from. It is mutually exclusive with `botToken`. Either `botToken` or `botTokenFile` is required.
   * It requires Alertmanager >= v0.26.0.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#botTokenFile
   */
  readonly botTokenFile?: string;

  /**
   * The Telegram chat ID.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#chatID
   */
  readonly chatId?: number;

  /**
   * Disable telegram notifications
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#disableNotifications
   */
  readonly disableNotifications?: boolean;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#httpConfig
   */
  readonly httpConfig?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig;

  /**
   * Message template
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#message
   */
  readonly message?: string;

  /**
   * Parse mode for telegram message
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#parseMode
   */
  readonly parseMode?: AlertmanagerConfigSpecReceiversTelegramConfigsParseMode;

  /**
   * Whether to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigs#sendResolved
   */
  readonly sendResolved?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigs(
  obj: AlertmanagerConfigSpecReceiversTelegramConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiURL": obj.apiUrl,
    "botToken": toJson_AlertmanagerConfigSpecReceiversTelegramConfigsBotToken(
      obj.botToken,
    ),
    "botTokenFile": obj.botTokenFile,
    "chatID": obj.chatId,
    "disableNotifications": obj.disableNotifications,
    "httpConfig":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig(
        obj.httpConfig,
      ),
    "message": obj.message,
    "parseMode": obj.parseMode,
    "sendResolved": obj.sendResolved,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VictorOpsConfig configures notifications via VictorOps. See https://prometheus.io/docs/alerting/latest/configuration/#victorops_config
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigs {
  /**
   * The secret's key that contains the API key to use when talking to the VictorOps API. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#apiKey
   */
  readonly apiKey?: AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey;

  /**
   * The VictorOps API URL.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * Additional custom fields for notification.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#customFields
   */
  readonly customFields?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields[];

  /**
   * Contains summary of the alerted problem.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#entityDisplayName
   */
  readonly entityDisplayName?: string;

  /**
   * The HTTP client's configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#httpConfig
   */
  readonly httpConfig?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig;

  /**
   * Describes the behavior of the alert (CRITICAL, WARNING, INFO).
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#messageType
   */
  readonly messageType?: string;

  /**
   * The monitoring tool the state message is from.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#monitoringTool
   */
  readonly monitoringTool?: string;

  /**
   * A key used to map the alert to a team.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#routingKey
   */
  readonly routingKey?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * Contains long explanation of the alerted problem.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigs#stateMessage
   */
  readonly stateMessage?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigs(
  obj: AlertmanagerConfigSpecReceiversVictoropsConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiKey": toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey(
      obj.apiKey,
    ),
    "apiUrl": obj.apiUrl,
    "customFields": obj.customFields?.map((y) =>
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields(y)
    ),
    "entityDisplayName": obj.entityDisplayName,
    "httpConfig":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig(
        obj.httpConfig,
      ),
    "messageType": obj.messageType,
    "monitoringTool": obj.monitoringTool,
    "routingKey": obj.routingKey,
    "sendResolved": obj.sendResolved,
    "stateMessage": obj.stateMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * WebexConfig configures notification via Cisco Webex See https://prometheus.io/docs/alerting/latest/configuration/#webex_config
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigs
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigs {
  /**
   * The Webex Teams API URL i.e. https://webexapis.com/v1/messages Provide if different from the default API URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigs#apiURL
   */
  readonly apiUrl?: string;

  /**
   * The HTTP client's configuration. You must supply the bot token via the `httpConfig.authorization` field.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig;

  /**
   * Message template
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigs#message
   */
  readonly message?: string;

  /**
   * ID of the Webex Teams room where to send the messages.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigs#roomID
   */
  readonly roomId: string;

  /**
   * Whether to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigs#sendResolved
   */
  readonly sendResolved?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigs(
  obj: AlertmanagerConfigSpecReceiversWebexConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiURL": obj.apiUrl,
    "httpConfig": toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig(
      obj.httpConfig,
    ),
    "message": obj.message,
    "roomID": obj.roomId,
    "sendResolved": obj.sendResolved,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * WebhookConfig configures notifications via a generic receiver supporting the webhook payload. See https://prometheus.io/docs/alerting/latest/configuration/#webhook_config
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigs
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigs {
  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig;

  /**
   * Maximum number of alerts to be sent per webhook message. When 0, all alerts are included.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigs#maxAlerts
   */
  readonly maxAlerts?: number;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * The URL to send HTTP POST requests to. `urlSecret` takes precedence over `url`. One of `urlSecret` and `url` should be defined.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigs#url
   */
  readonly url?: string;

  /**
   * The secret's key that contains the webhook URL to send HTTP requests to. `urlSecret` takes precedence over `url`. One of `urlSecret` and `url` should be defined. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigs#urlSecret
   */
  readonly urlSecret?: AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigs(
  obj: AlertmanagerConfigSpecReceiversWebhookConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "httpConfig":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig(
        obj.httpConfig,
      ),
    "maxAlerts": obj.maxAlerts,
    "sendResolved": obj.sendResolved,
    "url": obj.url,
    "urlSecret": toJson_AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret(
      obj.urlSecret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * WeChatConfig configures notifications via WeChat. See https://prometheus.io/docs/alerting/latest/configuration/#wechat_config
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigs
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigs {
  /**
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#agentID
   */
  readonly agentId?: string;

  /**
   * The secret's key that contains the WeChat API key. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#apiSecret
   */
  readonly apiSecret?: AlertmanagerConfigSpecReceiversWechatConfigsApiSecret;

  /**
   * The WeChat API URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#apiURL
   */
  readonly apiUrl?: string;

  /**
   * The corp id for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#corpID
   */
  readonly corpId?: string;

  /**
   * HTTP client configuration.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#httpConfig
   */
  readonly httpConfig?: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig;

  /**
   * API request data as defined by the WeChat API.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#message
   */
  readonly message?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#messageType
   */
  readonly messageType?: string;

  /**
   * Whether or not to notify about resolved alerts.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#sendResolved
   */
  readonly sendResolved?: boolean;

  /**
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#toParty
   */
  readonly toParty?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#toTag
   */
  readonly toTag?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversWechatConfigs#toUser
   */
  readonly toUser?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigs(
  obj: AlertmanagerConfigSpecReceiversWechatConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "agentID": obj.agentId,
    "apiSecret": toJson_AlertmanagerConfigSpecReceiversWechatConfigsApiSecret(
      obj.apiSecret,
    ),
    "apiURL": obj.apiUrl,
    "corpID": obj.corpId,
    "httpConfig": toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig(
      obj.httpConfig,
    ),
    "message": obj.message,
    "messageType": obj.messageType,
    "sendResolved": obj.sendResolved,
    "toParty": obj.toParty,
    "toTag": obj.toTag,
    "toUser": obj.toUser,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Matcher defines how to match on alert's labels.
 *
 * @schema AlertmanagerConfigSpecRouteMatchers
 */
export interface AlertmanagerConfigSpecRouteMatchers {
  /**
   * Match operation available with AlertManager >= v0.22.0 and takes precedence over Regex (deprecated) if non-empty.
   *
   * @schema AlertmanagerConfigSpecRouteMatchers#matchType
   */
  readonly matchType?: AlertmanagerConfigSpecRouteMatchersMatchType;

  /**
   * Label to match.
   *
   * @schema AlertmanagerConfigSpecRouteMatchers#name
   */
  readonly name: string;

  /**
   * Whether to match on equality (false) or regular-expression (true). Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
   *
   * @schema AlertmanagerConfigSpecRouteMatchers#regex
   */
  readonly regex?: boolean;

  /**
   * Label value to match.
   *
   * @schema AlertmanagerConfigSpecRouteMatchers#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecRouteMatchers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecRouteMatchers(
  obj: AlertmanagerConfigSpecRouteMatchers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchType": obj.matchType,
    "name": obj.name,
    "regex": obj.regex,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Match operation available with AlertManager >= v0.22.0 and takes precedence over Regex (deprecated) if non-empty.
 *
 * @schema AlertmanagerConfigSpecInhibitRulesSourceMatchMatchType
 */
export enum AlertmanagerConfigSpecInhibitRulesSourceMatchMatchType {
  /** != */
  VALUE_NOT_EQUALS_TO = "!=",
  /** = */
  VALUE_EQUALS = "=",
  /** =~ */
  VALUE_EQUAL_TILDE = "=~",
  /** !~ */
  VALUE_NEGATION_TILDE = "!~",
}

/**
 * Match operation available with AlertManager >= v0.22.0 and takes precedence over Regex (deprecated) if non-empty.
 *
 * @schema AlertmanagerConfigSpecInhibitRulesTargetMatchMatchType
 */
export enum AlertmanagerConfigSpecInhibitRulesTargetMatchMatchType {
  /** != */
  VALUE_NOT_EQUALS_TO = "!=",
  /** = */
  VALUE_EQUALS = "=",
  /** =~ */
  VALUE_EQUAL_TILDE = "=~",
  /** !~ */
  VALUE_NEGATION_TILDE = "!~",
}

/**
 * DayOfMonthRange is an inclusive range of days of the month beginning at 1
 *
 * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth
 */
export interface AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth {
  /**
   * End of the inclusive range
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth#end
   */
  readonly end?: number;

  /**
   * Start of the inclusive range
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth#start
   */
  readonly start?: number;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth(
  obj:
    | AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsDaysOfMonth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "end": obj.end,
    "start": obj.start,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TimeRange defines a start and end time in 24hr format
 *
 * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes
 */
export interface AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes {
  /**
   * EndTime is the end time in 24hr format.
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes#endTime
   */
  readonly endTime?: string;

  /**
   * StartTime is the start time in 24hr format.
   *
   * @schema AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes#startTime
   */
  readonly startTime?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes(
  obj: AlertmanagerConfigSpecMuteTimeIntervalsTimeIntervalsTimes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "endTime": obj.endTime,
    "startTime": obj.startTime,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the Discord webhook URL. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl(
  obj: AlertmanagerConfigSpecReceiversDiscordConfigsApiUrl | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#oauth2
   */
  readonly oauth2?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the password to use for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword(
  obj: AlertmanagerConfigSpecReceiversEmailConfigsAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the CRAM-MD5 secret. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret(
  obj: AlertmanagerConfigSpecReceiversEmailConfigsAuthSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * KeyValue defines a (key, value) tuple.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsHeaders
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsHeaders {
  /**
   * Key of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsHeaders#key
   */
  readonly key: string;

  /**
   * Value of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsHeaders(
  obj: AlertmanagerConfigSpecReceiversEmailConfigsHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#cert
   */
  readonly cert?: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig(
  obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa(obj.ca),
    "cert": toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert(
      obj.cert,
    ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#oauth2
   */
  readonly oauth2?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MSTeams webhook URL.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl(
  obj: AlertmanagerConfigSpecReceiversMsteamsConfigsWebhookUrl | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the OpsGenie API key. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey(
  obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsApiKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * KeyValue defines a (key, value) tuple.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails {
  /**
   * Key of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails#key
   */
  readonly key: string;

  /**
   * Value of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails(
  obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsDetails | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#oauth2
   */
  readonly oauth2?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OpsGenieConfigResponder defines a responder to an incident. One of `id`, `name` or `username` has to be defined.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders {
  /**
   * ID of the responder.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#id
   */
  readonly id?: string;

  /**
   * Name of the responder.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#name
   */
  readonly name?: string;

  /**
   * Type of responder.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#type
   */
  readonly type: AlertmanagerConfigSpecReceiversOpsgenieConfigsRespondersType;

  /**
   * Username of the responder.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders#username
   */
  readonly username?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders(
  obj: AlertmanagerConfigSpecReceiversOpsgenieConfigsResponders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "id": obj.id,
    "name": obj.name,
    "type": obj.type,
    "username": obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * KeyValue defines a (key, value) tuple.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails {
  /**
   * Key of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails#key
   */
  readonly key: string;

  /**
   * Value of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails(
  obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsDetails | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#oauth2
   */
  readonly oauth2?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PagerDutyImageConfig attaches images to an incident
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs {
  /**
   * Alt is the optional alternative text for the image.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs#alt
   */
  readonly alt?: string;

  /**
   * Optional URL; makes the image a clickable link.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs#href
   */
  readonly href?: string;

  /**
   * Src of the image being attached to the incident
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs#src
   */
  readonly src?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyImageConfigs
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "alt": obj.alt,
    "href": obj.href,
    "src": obj.src,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PagerDutyLinkConfig attaches text links to an incident
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs {
  /**
   * Text that describes the purpose of the link, and can be used as the link's text.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs#alt
   */
  readonly alt?: string;

  /**
   * Href is the URL of the link to be attached
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs#href
   */
  readonly href?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsPagerDutyLinkConfigs
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "alt": obj.alt,
    "href": obj.href,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the PagerDuty integration key (when using Events API v2). Either this field or `serviceKey` needs to be defined. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey(
  obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsRoutingKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the PagerDuty service key (when using integration type "Prometheus"). Either this field or `routingKey` needs to be defined. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey(
  obj: AlertmanagerConfigSpecReceiversPagerdutyConfigsServiceKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#oauth2
   */
  readonly oauth2?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the registered application's API token, see https://pushover.net/apps. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator. Either `token` or `tokenFile` is required.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsToken
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsToken#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsToken#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsToken(
  obj: AlertmanagerConfigSpecReceiversPushoverConfigsToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the recipient user's user key. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator. Either `userKey` or `userKeyFile` is required.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsUserKey
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsUserKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsUserKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsUserKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsUserKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsUserKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsUserKey(
  obj: AlertmanagerConfigSpecReceiversPushoverConfigsUserKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SlackAction configures a single Slack action that is sent with each notification. See https://api.slack.com/docs/message-attachments#action_fields and https://api.slack.com/docs/message-buttons for more information.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsActions {
  /**
   * SlackConfirmationField protect users from destructive actions or particularly distinguished decisions by asking them to confirm their button click one more time. See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields for more information.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#confirm
   */
  readonly confirm?: AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#name
   */
  readonly name?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#style
   */
  readonly style?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#text
   */
  readonly text: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#type
   */
  readonly type: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#url
   */
  readonly url?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActions#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsActions(
  obj: AlertmanagerConfigSpecReceiversSlackConfigsActions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "confirm": toJson_AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm(
      obj.confirm,
    ),
    "name": obj.name,
    "style": obj.style,
    "text": obj.text,
    "type": obj.type,
    "url": obj.url,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the Slack webhook URL. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsApiUrl
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsApiUrl {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsApiUrl#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsApiUrl#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsApiUrl#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsApiUrl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsApiUrl(
  obj: AlertmanagerConfigSpecReceiversSlackConfigsApiUrl | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SlackField configures a single Slack field that is sent with each notification. Each field must contain a title, value, and optionally, a boolean value to indicate if the field is short enough to be displayed next to other fields designated as short. See https://api.slack.com/docs/message-attachments#fields for more information.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsFields
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsFields {
  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsFields#short
   */
  readonly short?: boolean;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsFields#title
   */
  readonly title: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsFields#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsFields(
  obj: AlertmanagerConfigSpecReceiversSlackConfigsFields | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "short": obj.short,
    "title": obj.title,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2": toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2(
      obj.oauth2,
    ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Configures AWS's Signature Verification 4 signing process to sign requests.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsSigv4 {
  /**
   * AccessKey is the AWS API key. If not specified, the environment variable `AWS_ACCESS_KEY_ID` is used.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4#accessKey
   */
  readonly accessKey?: AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey;

  /**
   * Profile is the named AWS profile used to authenticate.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4#profile
   */
  readonly profile?: string;

  /**
   * Region is the AWS region. If blank, the region from the default credentials chain used.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4#region
   */
  readonly region?: string;

  /**
   * RoleArn is the named AWS profile used to authenticate.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4#roleArn
   */
  readonly roleArn?: string;

  /**
   * SecretKey is the AWS API secret. If not specified, the environment variable `AWS_SECRET_ACCESS_KEY` is used.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4#secretKey
   */
  readonly secretKey?: AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsSigv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4(
  obj: AlertmanagerConfigSpecReceiversSnsConfigsSigv4 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessKey": toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey(
      obj.accessKey,
    ),
    "profile": obj.profile,
    "region": obj.region,
    "roleArn": obj.roleArn,
    "secretKey": toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey(
      obj.secretKey,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Telegram bot token. It is mutually exclusive with `botTokenFile`. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 * Either `botToken` or `botTokenFile` is required.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsBotToken
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsBotToken {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsBotToken#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsBotToken#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsBotToken#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsBotToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsBotToken(
  obj: AlertmanagerConfigSpecReceiversTelegramConfigsBotToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#oauth2
   */
  readonly oauth2?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Parse mode for telegram message
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsParseMode
 */
export enum AlertmanagerConfigSpecReceiversTelegramConfigsParseMode {
  /** MarkdownV2 */
  MARKDOWN_V2 = "MarkdownV2",
  /** Markdown */
  MARKDOWN = "Markdown",
  /** HTML */
  HTML = "HTML",
}

/**
 * The secret's key that contains the API key to use when talking to the VictorOps API. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey(
  obj: AlertmanagerConfigSpecReceiversVictoropsConfigsApiKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * KeyValue defines a (key, value) tuple.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields {
  /**
   * Key of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields#key
   */
  readonly key: string;

  /**
   * Value of the tuple.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields(
  obj: AlertmanagerConfigSpecReceiversVictoropsConfigsCustomFields | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The HTTP client's configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#oauth2
   */
  readonly oauth2?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The HTTP client's configuration. You must supply the bot token via the `httpConfig.authorization` field.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#oauth2
   */
  readonly oauth2?: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#oauth2
   */
  readonly oauth2?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the webhook URL to send HTTP requests to. `urlSecret` takes precedence over `url`. One of `urlSecret` and `url` should be defined. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret(
  obj: AlertmanagerConfigSpecReceiversWebhookConfigsUrlSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the WeChat API key. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsApiSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsApiSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsApiSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsApiSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsApiSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsApiSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsApiSecret(
  obj: AlertmanagerConfigSpecReceiversWechatConfigsApiSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP client configuration.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig {
  /**
   * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#authorization
   */
  readonly authorization?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization;

  /**
   * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#basicAuth
   */
  readonly basicAuth?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth;

  /**
   * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret;

  /**
   * FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * OAuth2 client credentials used to fetch a token for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#oauth2
   */
  readonly oauth2?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2;

  /**
   * Optional proxy URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#proxyURL
   */
  readonly proxyUrl?: string;

  /**
   * TLS configuration for the client.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig#tlsConfig
   */
  readonly tlsConfig?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig(
  obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization(
        obj.authorization,
      ),
    "basicAuth":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth(
        obj.basicAuth,
      ),
    "bearerTokenSecret":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "followRedirects": obj.followRedirects,
    "oauth2":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2(
        obj.oauth2,
      ),
    "proxyURL": obj.proxyUrl,
    "tlsConfig":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig(
        obj.tlsConfig,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Match operation available with AlertManager >= v0.22.0 and takes precedence over Regex (deprecated) if non-empty.
 *
 * @schema AlertmanagerConfigSpecRouteMatchersMatchType
 */
export enum AlertmanagerConfigSpecRouteMatchersMatchType {
  /** != */
  VALUE_NOT_EQUALS_TO = "!=",
  /** = */
  VALUE_EQUALS = "=",
  /** =~ */
  VALUE_EQUAL_TILDE = "=~",
  /** !~ */
  VALUE_NEGATION_TILDE = "!~",
}

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa(
  obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert(
  obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Type of responder.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsRespondersType
 */
export enum AlertmanagerConfigSpecReceiversOpsgenieConfigsRespondersType {
  /** team */
  TEAM = "team",
  /** teams */
  TEAMS = "teams",
  /** user */
  USER = "user",
  /** escalation */
  ESCALATION = "escalation",
  /** schedule */
  SCHEDULE = "schedule",
}

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SlackConfirmationField protect users from destructive actions or particularly distinguished decisions by asking them to confirm their button click one more time. See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields for more information.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm {
  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#dismissText
   */
  readonly dismissText?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#okText
   */
  readonly okText?: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#text
   */
  readonly text: string;

  /**
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm#title
   */
  readonly title?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm(
  obj: AlertmanagerConfigSpecReceiversSlackConfigsActionsConfirm | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "dismissText": obj.dismissText,
    "okText": obj.okText,
    "text": obj.text,
    "title": obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2(
  obj: AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth(
  obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2(
  obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig(
  obj: AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa(
      obj.ca,
    ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AccessKey is the AWS API key. If not specified, the environment variable `AWS_ACCESS_KEY_ID` is used.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey(
  obj: AlertmanagerConfigSpecReceiversSnsConfigsSigv4AccessKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey is the AWS API secret. If not specified, the environment variable `AWS_SECRET_ACCESS_KEY` is used.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey(
  obj: AlertmanagerConfigSpecReceiversSnsConfigsSigv4SecretKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2(
  obj: AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration for the client. This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization#credentials
   */
  readonly credentials?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorization
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth for the client. This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth#password
   */
  readonly password?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth#username
   */
  readonly username?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuth
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword(
        obj.password,
      ),
    "username":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername(
        obj.username,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The secret's key that contains the bearer token to be used by the client for authentication. The secret needs to be in the same namespace as the AlertmanagerConfig object and accessible by the Prometheus Operator.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBearerTokenSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 client credentials used to fetch a token for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#clientId
   */
  readonly clientId:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#clientSecret
   */
  readonly clientSecret:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2(
  obj: AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId(
        obj.clientId,
      ),
    "clientSecret":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration for the client.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#ca
   */
  readonly ca?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#cert
   */
  readonly cert?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#keySecret
   */
  readonly keySecret?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfig
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa(
        obj.ca,
      ),
    "cert":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert(
        obj.cert,
      ),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret(
        obj.keySecret,
      ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret(
  obj: AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversEmailConfigsTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigAuthorizationCredentials
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthPassword
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigBasicAuthUsername
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientId
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCa
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert#configMap
   */
  readonly configMap?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert#secret
   */
  readonly secret?:
    AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCert
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret":
      toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret(
        obj.secret,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigKeySecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversDiscordConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversMsteamsConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversOpsgenieConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversPagerdutyConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversPushoverConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversSlackConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversSnsConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversTelegramConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversVictoropsConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebexConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWebhookConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigOauth2ClientIdSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCaSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertConfigMap
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret
 */
export interface AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret(
  obj:
    | AlertmanagerConfigSpecReceiversWechatConfigsHttpConfigTlsConfigCertSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PodMonitor defines monitoring for a set of pods.
 *
 * @schema PodMonitor
 */
export class PodMonitor extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PodMonitor"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "monitoring.coreos.com/v1",
    kind: "PodMonitor",
  };

  /**
   * Renders a Kubernetes manifest for "PodMonitor".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PodMonitorProps): any {
    return {
      ...PodMonitor.GVK,
      ...toJson_PodMonitorProps(props),
    };
  }

  /**
   * Defines a "PodMonitor" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PodMonitorProps) {
    super(scope, id, {
      ...PodMonitor.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PodMonitor.GVK,
      ...toJson_PodMonitorProps(resolved),
    };
  }
}

/**
 * PodMonitor defines monitoring for a set of pods.
 *
 * @schema PodMonitor
 */
export interface PodMonitorProps {
  /**
   * @schema PodMonitor#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of desired Pod selection for target discovery by Prometheus.
   *
   * @schema PodMonitor#spec
   */
  readonly spec: PodMonitorSpec;
}

/**
 * Converts an object of type 'PodMonitorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorProps(
  obj: PodMonitorProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_PodMonitorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of desired Pod selection for target discovery by Prometheus.
 *
 * @schema PodMonitorSpec
 */
export interface PodMonitorSpec {
  /**
   * `attachMetadata` defines additional metadata which is added to the discovered targets.
   * It requires Prometheus >= v2.37.0.
   *
   * @schema PodMonitorSpec#attachMetadata
   */
  readonly attachMetadata?: PodMonitorSpecAttachMetadata;

  /**
   * The label to use to retrieve the job name from. `jobLabel` selects the label from the associated Kubernetes `Pod` object which will be used as the `job` label for all metrics.
   * For example if `jobLabel` is set to `foo` and the Kubernetes `Pod` object is labeled with `foo: bar`, then Prometheus adds the `job="bar"` label to all ingested metrics.
   * If the value of this field is empty, the `job` label of the metrics defaults to the namespace and name of the PodMonitor object (e.g. `<namespace>/<name>`).
   *
   * @schema PodMonitorSpec#jobLabel
   */
  readonly jobLabel?: string;

  /**
   * Per-scrape limit on the number of targets dropped by relabeling that will be kept in memory. 0 means no limit.
   * It requires Prometheus >= v2.47.0.
   *
   * @schema PodMonitorSpec#keepDroppedTargets
   */
  readonly keepDroppedTargets?: number;

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PodMonitorSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PodMonitorSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PodMonitorSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * Selector to select which namespaces the Kubernetes `Pods` objects are discovered from.
   *
   * @schema PodMonitorSpec#namespaceSelector
   */
  readonly namespaceSelector?: PodMonitorSpecNamespaceSelector;

  /**
   * List of endpoints part of this PodMonitor.
   *
   * @schema PodMonitorSpec#podMetricsEndpoints
   */
  readonly podMetricsEndpoints?: PodMonitorSpecPodMetricsEndpoints[];

  /**
   * `podTargetLabels` defines the labels which are transferred from the associated Kubernetes `Pod` object onto the ingested metrics.
   *
   * @schema PodMonitorSpec#podTargetLabels
   */
  readonly podTargetLabels?: string[];

  /**
   * `sampleLimit` defines a per-scrape limit on the number of scraped samples that will be accepted.
   *
   * @schema PodMonitorSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * Label selector to select the Kubernetes `Pod` objects.
   *
   * @schema PodMonitorSpec#selector
   */
  readonly selector: PodMonitorSpecSelector;

  /**
   * `targetLimit` defines a limit on the number of scraped targets that will be accepted.
   *
   * @schema PodMonitorSpec#targetLimit
   */
  readonly targetLimit?: number;
}

/**
 * Converts an object of type 'PodMonitorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpec(
  obj: PodMonitorSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "attachMetadata": toJson_PodMonitorSpecAttachMetadata(obj.attachMetadata),
    "jobLabel": obj.jobLabel,
    "keepDroppedTargets": obj.keepDroppedTargets,
    "labelLimit": obj.labelLimit,
    "labelNameLengthLimit": obj.labelNameLengthLimit,
    "labelValueLengthLimit": obj.labelValueLengthLimit,
    "namespaceSelector": toJson_PodMonitorSpecNamespaceSelector(
      obj.namespaceSelector,
    ),
    "podMetricsEndpoints": obj.podMetricsEndpoints?.map((y) =>
      toJson_PodMonitorSpecPodMetricsEndpoints(y)
    ),
    "podTargetLabels": obj.podTargetLabels?.map((y) => y),
    "sampleLimit": obj.sampleLimit,
    "selector": toJson_PodMonitorSpecSelector(obj.selector),
    "targetLimit": obj.targetLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `attachMetadata` defines additional metadata which is added to the discovered targets.
 * It requires Prometheus >= v2.37.0.
 *
 * @schema PodMonitorSpecAttachMetadata
 */
export interface PodMonitorSpecAttachMetadata {
  /**
   * When set to true, Prometheus must have the `get` permission on the `Nodes` objects.
   *
   * @schema PodMonitorSpecAttachMetadata#node
   */
  readonly node?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecAttachMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecAttachMetadata(
  obj: PodMonitorSpecAttachMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "node": obj.node,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selector to select which namespaces the Kubernetes `Pods` objects are discovered from.
 *
 * @schema PodMonitorSpecNamespaceSelector
 */
export interface PodMonitorSpecNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a list restricting them.
   *
   * @schema PodMonitorSpecNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names to select from.
   *
   * @schema PodMonitorSpecNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];
}

/**
 * Converts an object of type 'PodMonitorSpecNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecNamespaceSelector(
  obj: PodMonitorSpecNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "any": obj.any,
    "matchNames": obj.matchNames?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PodMetricsEndpoint defines an endpoint serving Prometheus metrics to be scraped by Prometheus.
 *
 * @schema PodMonitorSpecPodMetricsEndpoints
 */
export interface PodMonitorSpecPodMetricsEndpoints {
  /**
   * `authorization` configures the Authorization header credentials to use when scraping the target.
   * Cannot be set at the same time as `basicAuth`, or `oauth2`.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#authorization
   */
  readonly authorization?: PodMonitorSpecPodMetricsEndpointsAuthorization;

  /**
   * `basicAuth` configures the Basic Authentication credentials to use when scraping the target.
   * Cannot be set at the same time as `authorization`, or `oauth2`.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#basicAuth
   */
  readonly basicAuth?: PodMonitorSpecPodMetricsEndpointsBasicAuth;

  /**
   * `bearerTokenSecret` specifies a key of a Secret containing the bearer token for scraping targets. The secret needs to be in the same namespace as the PodMonitor object and readable by the Prometheus Operator.
   * Deprecated: use `authorization` instead.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#bearerTokenSecret
   */
  readonly bearerTokenSecret?:
    PodMonitorSpecPodMetricsEndpointsBearerTokenSecret;

  /**
   * `enableHttp2` can be used to disable HTTP2 when scraping the target.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#enableHttp2
   */
  readonly enableHttp2?: boolean;

  /**
   * When true, the pods which are not running (e.g. either in Failed or Succeeded state) are dropped during the target discovery.
   * If unset, the filtering is enabled.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#filterRunning
   */
  readonly filterRunning?: boolean;

  /**
   * `followRedirects` defines whether the scrape requests should follow HTTP 3xx redirects.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * When true, `honorLabels` preserves the metric's labels when they collide with the target's labels.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * `honorTimestamps` controls whether Prometheus preserves the timestamps when exposed by the target.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * Interval at which Prometheus scrapes the metrics from the target.
   * If empty, Prometheus uses the global scrape interval.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#interval
   */
  readonly interval?: string;

  /**
   * `metricRelabelings` configures the relabeling rules to apply to the samples before ingestion.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#metricRelabelings
   */
  readonly metricRelabelings?:
    PodMonitorSpecPodMetricsEndpointsMetricRelabelings[];

  /**
   * `oauth2` configures the OAuth2 settings to use when scraping the target.
   * It requires Prometheus >= 2.27.0.
   * Cannot be set at the same time as `authorization`, or `basicAuth`.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#oauth2
   */
  readonly oauth2?: PodMonitorSpecPodMetricsEndpointsOauth2;

  /**
   * `params` define optional HTTP URL parameters.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * HTTP path from which to scrape for metrics.
   * If empty, Prometheus uses the default value (e.g. `/metrics`).
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#path
   */
  readonly path?: string;

  /**
   * Name of the Pod port which this endpoint refers to.
   * It takes precedence over `targetPort`.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#port
   */
  readonly port?: string;

  /**
   * `proxyURL` configures the HTTP Proxy URL (e.g. "http://proxyserver:2195") to go through when scraping the target.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * `relabelings` configures the relabeling rules to apply the target's metadata labels.
   * The Operator automatically adds relabelings for a few standard Kubernetes fields.
   * The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
   * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#relabelings
   */
  readonly relabelings?: PodMonitorSpecPodMetricsEndpointsRelabelings[];

  /**
   * HTTP scheme to use for scraping.
   * `http` and `https` are the expected values unless you rewrite the `__scheme__` label via relabeling.
   * If empty, Prometheus uses the default value `http`.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#scheme
   */
  readonly scheme?: PodMonitorSpecPodMetricsEndpointsScheme;

  /**
   * Timeout after which Prometheus considers the scrape to be failed.
   * If empty, Prometheus uses the global scrape timeout unless it is less than the target's scrape interval value in which the latter is used.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * Name or number of the target port of the `Pod` object behind the Service, the port must be specified with container port property.
   * Deprecated: use 'port' instead.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#targetPort
   */
  readonly targetPort?: PodMonitorSpecPodMetricsEndpointsTargetPort;

  /**
   * TLS configuration to use when scraping the target.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#tlsConfig
   */
  readonly tlsConfig?: PodMonitorSpecPodMetricsEndpointsTlsConfig;

  /**
   * `trackTimestampsStaleness` defines whether Prometheus tracks staleness of the metrics that have an explicit timestamp present in scraped data. Has no effect if `honorTimestamps` is false.
   * It requires Prometheus >= v2.48.0.
   *
   * @schema PodMonitorSpecPodMetricsEndpoints#trackTimestampsStaleness
   */
  readonly trackTimestampsStaleness?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpoints(
  obj: PodMonitorSpecPodMetricsEndpoints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization": toJson_PodMonitorSpecPodMetricsEndpointsAuthorization(
      obj.authorization,
    ),
    "basicAuth": toJson_PodMonitorSpecPodMetricsEndpointsBasicAuth(
      obj.basicAuth,
    ),
    "bearerTokenSecret":
      toJson_PodMonitorSpecPodMetricsEndpointsBearerTokenSecret(
        obj.bearerTokenSecret,
      ),
    "enableHttp2": obj.enableHttp2,
    "filterRunning": obj.filterRunning,
    "followRedirects": obj.followRedirects,
    "honorLabels": obj.honorLabels,
    "honorTimestamps": obj.honorTimestamps,
    "interval": obj.interval,
    "metricRelabelings": obj.metricRelabelings?.map((y) =>
      toJson_PodMonitorSpecPodMetricsEndpointsMetricRelabelings(y)
    ),
    "oauth2": toJson_PodMonitorSpecPodMetricsEndpointsOauth2(obj.oauth2),
    "params": ((obj.params) === undefined)
      ? undefined
      : (Object.entries(obj.params).reduce(
        (r, i) =>
          (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map((y) => y) }),
        {},
      )),
    "path": obj.path,
    "port": obj.port,
    "proxyUrl": obj.proxyUrl,
    "relabelings": obj.relabelings?.map((y) =>
      toJson_PodMonitorSpecPodMetricsEndpointsRelabelings(y)
    ),
    "scheme": obj.scheme,
    "scrapeTimeout": obj.scrapeTimeout,
    "targetPort": obj.targetPort?.value,
    "tlsConfig": toJson_PodMonitorSpecPodMetricsEndpointsTlsConfig(
      obj.tlsConfig,
    ),
    "trackTimestampsStaleness": obj.trackTimestampsStaleness,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Label selector to select the Kubernetes `Pod` objects.
 *
 * @schema PodMonitorSpecSelector
 */
export interface PodMonitorSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PodMonitorSpecSelector#matchExpressions
   */
  readonly matchExpressions?: PodMonitorSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PodMonitorSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PodMonitorSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecSelector(
  obj: PodMonitorSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PodMonitorSpecSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `authorization` configures the Authorization header credentials to use when scraping the target.
 * Cannot be set at the same time as `basicAuth`, or `oauth2`.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsAuthorization
 */
export interface PodMonitorSpecPodMetricsEndpointsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsAuthorization#credentials
   */
  readonly credentials?:
    PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema PodMonitorSpecPodMetricsEndpointsAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsAuthorization(
  obj: PodMonitorSpecPodMetricsEndpointsAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `basicAuth` configures the Basic Authentication credentials to use when scraping the target.
 * Cannot be set at the same time as `authorization`, or `oauth2`.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsBasicAuth
 */
export interface PodMonitorSpecPodMetricsEndpointsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuth#password
   */
  readonly password?: PodMonitorSpecPodMetricsEndpointsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuth#username
   */
  readonly username?: PodMonitorSpecPodMetricsEndpointsBasicAuthUsername;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsBasicAuth(
  obj: PodMonitorSpecPodMetricsEndpointsBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_PodMonitorSpecPodMetricsEndpointsBasicAuthPassword(
      obj.password,
    ),
    "username": toJson_PodMonitorSpecPodMetricsEndpointsBasicAuthUsername(
      obj.username,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `bearerTokenSecret` specifies a key of a Secret containing the bearer token for scraping targets. The secret needs to be in the same namespace as the PodMonitor object and readable by the Prometheus Operator.
 * Deprecated: use `authorization` instead.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsBearerTokenSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsBearerTokenSecret(
  obj: PodMonitorSpecPodMetricsEndpointsBearerTokenSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings
 */
export interface PodMonitorSpecPodMetricsEndpointsMetricRelabelings {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#action
   */
  readonly action?: PodMonitorSpecPodMetricsEndpointsMetricRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the regular expression matches.
   * Regex capture groups are available.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions.
   * Regex capture groups are available.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelings#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsMetricRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsMetricRelabelings(
  obj: PodMonitorSpecPodMetricsEndpointsMetricRelabelings | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "action": obj.action,
    "modulus": obj.modulus,
    "regex": obj.regex,
    "replacement": obj.replacement,
    "separator": obj.separator,
    "sourceLabels": obj.sourceLabels?.map((y) => y),
    "targetLabel": obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `oauth2` configures the OAuth2 settings to use when scraping the target.
 * It requires Prometheus >= 2.27.0.
 * Cannot be set at the same time as `authorization`, or `basicAuth`.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#clientId
   */
  readonly clientId: PodMonitorSpecPodMetricsEndpointsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#clientSecret
   */
  readonly clientSecret: PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2(
  obj: PodMonitorSpecPodMetricsEndpointsOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientId(
      obj.clientId,
    ),
    "clientSecret": toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret(
      obj.clientSecret,
    ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema PodMonitorSpecPodMetricsEndpointsRelabelings
 */
export interface PodMonitorSpecPodMetricsEndpointsRelabelings {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#action
   */
  readonly action?: PodMonitorSpecPodMetricsEndpointsRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the regular expression matches.
   * Regex capture groups are available.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions.
   * Regex capture groups are available.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsRelabelings#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsRelabelings(
  obj: PodMonitorSpecPodMetricsEndpointsRelabelings | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "action": obj.action,
    "modulus": obj.modulus,
    "regex": obj.regex,
    "replacement": obj.replacement,
    "separator": obj.separator,
    "sourceLabels": obj.sourceLabels?.map((y) => y),
    "targetLabel": obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP scheme to use for scraping.
 * `http` and `https` are the expected values unless you rewrite the `__scheme__` label via relabeling.
 * If empty, Prometheus uses the default value `http`.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsScheme
 */
export enum PodMonitorSpecPodMetricsEndpointsScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * Name or number of the target port of the `Pod` object behind the Service, the port must be specified with container port property.
 * Deprecated: use 'port' instead.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTargetPort
 */
export class PodMonitorSpecPodMetricsEndpointsTargetPort {
  public static fromNumber(
    value: number,
  ): PodMonitorSpecPodMetricsEndpointsTargetPort {
    return new PodMonitorSpecPodMetricsEndpointsTargetPort(value);
  }
  public static fromString(
    value: string,
  ): PodMonitorSpecPodMetricsEndpointsTargetPort {
    return new PodMonitorSpecPodMetricsEndpointsTargetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TLS configuration to use when scraping the target.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#ca
   */
  readonly ca?: PodMonitorSpecPodMetricsEndpointsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#cert
   */
  readonly cert?: PodMonitorSpecPodMetricsEndpointsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#keySecret
   */
  readonly keySecret?: PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfig(
  obj: PodMonitorSpecPodMetricsEndpointsTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCa(obj.ca),
    "cert": toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCert(obj.cert),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret": toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PodMonitorSpecSelectorMatchExpressions
 */
export interface PodMonitorSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PodMonitorSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PodMonitorSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PodMonitorSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PodMonitorSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecSelectorMatchExpressions(
  obj: PodMonitorSpecSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials
 */
export interface PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials(
  obj: PodMonitorSpecPodMetricsEndpointsAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthPassword
 */
export interface PodMonitorSpecPodMetricsEndpointsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsBasicAuthPassword(
  obj: PodMonitorSpecPodMetricsEndpointsBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthUsername
 */
export interface PodMonitorSpecPodMetricsEndpointsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsBasicAuthUsername(
  obj: PodMonitorSpecPodMetricsEndpointsBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 *
 * @schema PodMonitorSpecPodMetricsEndpointsMetricRelabelingsAction
 */
export enum PodMonitorSpecPodMetricsEndpointsMetricRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientId
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientId#configMap
   */
  readonly configMap?: PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientId#secret
   */
  readonly secret?: PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientId(
  obj: PodMonitorSpecPodMetricsEndpointsOauth2ClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret": toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret(
  obj: PodMonitorSpecPodMetricsEndpointsOauth2ClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 *
 * @schema PodMonitorSpecPodMetricsEndpointsRelabelingsAction
 */
export enum PodMonitorSpecPodMetricsEndpointsRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCa
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCa#configMap
   */
  readonly configMap?: PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCa#secret
   */
  readonly secret?: PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCa(
  obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCert
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCert#configMap
   */
  readonly configMap?: PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCert#secret
   */
  readonly secret?: PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCert(
  obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret(
  obj: PodMonitorSpecPodMetricsEndpointsTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap(
  obj: PodMonitorSpecPodMetricsEndpointsOauth2ClientIdConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret(
  obj: PodMonitorSpecPodMetricsEndpointsOauth2ClientIdSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap(
  obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret(
  obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap(
  obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret
 */
export interface PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret(
  obj: PodMonitorSpecPodMetricsEndpointsTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Probe defines monitoring for a set of static targets or ingresses.
 *
 * @schema Probe
 */
export class Probe extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Probe"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "monitoring.coreos.com/v1",
    kind: "Probe",
  };

  /**
   * Renders a Kubernetes manifest for "Probe".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProbeProps): any {
    return {
      ...Probe.GVK,
      ...toJson_ProbeProps(props),
    };
  }

  /**
   * Defines a "Probe" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProbeProps) {
    super(scope, id, {
      ...Probe.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Probe.GVK,
      ...toJson_ProbeProps(resolved),
    };
  }
}

/**
 * Probe defines monitoring for a set of static targets or ingresses.
 *
 * @schema Probe
 */
export interface ProbeProps {
  /**
   * @schema Probe#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of desired Ingress selection for target discovery by Prometheus.
   *
   * @schema Probe#spec
   */
  readonly spec: ProbeSpec;
}

/**
 * Converts an object of type 'ProbeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeProps(
  obj: ProbeProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ProbeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of desired Ingress selection for target discovery by Prometheus.
 *
 * @schema ProbeSpec
 */
export interface ProbeSpec {
  /**
   * Authorization section for this endpoint
   *
   * @schema ProbeSpec#authorization
   */
  readonly authorization?: ProbeSpecAuthorization;

  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication. More info: https://prometheus.io/docs/operating/configuration/#endpoint
   *
   * @schema ProbeSpec#basicAuth
   */
  readonly basicAuth?: ProbeSpecBasicAuth;

  /**
   * Secret to mount to read bearer token for scraping targets. The secret needs to be in the same namespace as the probe and accessible by the Prometheus Operator.
   *
   * @schema ProbeSpec#bearerTokenSecret
   */
  readonly bearerTokenSecret?: ProbeSpecBearerTokenSecret;

  /**
   * Interval at which targets are probed using the configured prober. If not specified Prometheus' global scrape interval is used.
   *
   * @schema ProbeSpec#interval
   */
  readonly interval?: string;

  /**
   * The job name assigned to scraped metrics by default.
   *
   * @schema ProbeSpec#jobName
   */
  readonly jobName?: string;

  /**
   * Per-scrape limit on the number of targets dropped by relabeling that will be kept in memory. 0 means no limit.
   * It requires Prometheus >= v2.47.0.
   *
   * @schema ProbeSpec#keepDroppedTargets
   */
  readonly keepDroppedTargets?: number;

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ProbeSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ProbeSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ProbeSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * MetricRelabelConfigs to apply to samples before ingestion.
   *
   * @schema ProbeSpec#metricRelabelings
   */
  readonly metricRelabelings?: ProbeSpecMetricRelabelings[];

  /**
   * The module to use for probing specifying how to probe the target. Example module configuring in the blackbox exporter: https://github.com/prometheus/blackbox_exporter/blob/master/example.yml
   *
   * @schema ProbeSpec#module
   */
  readonly module?: string;

  /**
   * OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ProbeSpec#oauth2
   */
  readonly oauth2?: ProbeSpecOauth2;

  /**
   * Specification for the prober to use for probing targets. The prober.URL parameter is required. Targets cannot be probed if left empty.
   *
   * @schema ProbeSpec#prober
   */
  readonly prober?: ProbeSpecProber;

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema ProbeSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * Timeout for scraping metrics from the Prometheus exporter. If not specified, the Prometheus global scrape timeout is used.
   *
   * @schema ProbeSpec#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * TargetLimit defines a limit on the number of scraped targets that will be accepted.
   *
   * @schema ProbeSpec#targetLimit
   */
  readonly targetLimit?: number;

  /**
   * Targets defines a set of static or dynamically discovered targets to probe.
   *
   * @schema ProbeSpec#targets
   */
  readonly targets?: ProbeSpecTargets;

  /**
   * TLS configuration to use when scraping the endpoint.
   *
   * @schema ProbeSpec#tlsConfig
   */
  readonly tlsConfig?: ProbeSpecTlsConfig;
}

/**
 * Converts an object of type 'ProbeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpec(
  obj: ProbeSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization": toJson_ProbeSpecAuthorization(obj.authorization),
    "basicAuth": toJson_ProbeSpecBasicAuth(obj.basicAuth),
    "bearerTokenSecret": toJson_ProbeSpecBearerTokenSecret(
      obj.bearerTokenSecret,
    ),
    "interval": obj.interval,
    "jobName": obj.jobName,
    "keepDroppedTargets": obj.keepDroppedTargets,
    "labelLimit": obj.labelLimit,
    "labelNameLengthLimit": obj.labelNameLengthLimit,
    "labelValueLengthLimit": obj.labelValueLengthLimit,
    "metricRelabelings": obj.metricRelabelings?.map((y) =>
      toJson_ProbeSpecMetricRelabelings(y)
    ),
    "module": obj.module,
    "oauth2": toJson_ProbeSpecOauth2(obj.oauth2),
    "prober": toJson_ProbeSpecProber(obj.prober),
    "sampleLimit": obj.sampleLimit,
    "scrapeTimeout": obj.scrapeTimeout,
    "targetLimit": obj.targetLimit,
    "targets": toJson_ProbeSpecTargets(obj.targets),
    "tlsConfig": toJson_ProbeSpecTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for this endpoint
 *
 * @schema ProbeSpecAuthorization
 */
export interface ProbeSpecAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ProbeSpecAuthorization#credentials
   */
  readonly credentials?: ProbeSpecAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema ProbeSpecAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ProbeSpecAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecAuthorization(
  obj: ProbeSpecAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials": toJson_ProbeSpecAuthorizationCredentials(obj.credentials),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication. More info: https://prometheus.io/docs/operating/configuration/#endpoint
 *
 * @schema ProbeSpecBasicAuth
 */
export interface ProbeSpecBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema ProbeSpecBasicAuth#password
   */
  readonly password?: ProbeSpecBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema ProbeSpecBasicAuth#username
   */
  readonly username?: ProbeSpecBasicAuthUsername;
}

/**
 * Converts an object of type 'ProbeSpecBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecBasicAuth(
  obj: ProbeSpecBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_ProbeSpecBasicAuthPassword(obj.password),
    "username": toJson_ProbeSpecBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret to mount to read bearer token for scraping targets. The secret needs to be in the same namespace as the probe and accessible by the Prometheus Operator.
 *
 * @schema ProbeSpecBearerTokenSecret
 */
export interface ProbeSpecBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecBearerTokenSecret(
  obj: ProbeSpecBearerTokenSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ProbeSpecMetricRelabelings
 */
export interface ProbeSpecMetricRelabelings {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   *
   * @schema ProbeSpecMetricRelabelings#action
   */
  readonly action?: ProbeSpecMetricRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   *
   * @schema ProbeSpecMetricRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ProbeSpecMetricRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the regular expression matches.
   * Regex capture groups are available.
   *
   * @schema ProbeSpecMetricRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ProbeSpecMetricRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
   *
   * @schema ProbeSpecMetricRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions.
   * Regex capture groups are available.
   *
   * @schema ProbeSpecMetricRelabelings#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'ProbeSpecMetricRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecMetricRelabelings(
  obj: ProbeSpecMetricRelabelings | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "action": obj.action,
    "modulus": obj.modulus,
    "regex": obj.regex,
    "replacement": obj.replacement,
    "separator": obj.separator,
    "sourceLabels": obj.sourceLabels?.map((y) => y),
    "targetLabel": obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
 *
 * @schema ProbeSpecOauth2
 */
export interface ProbeSpecOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema ProbeSpecOauth2#clientId
   */
  readonly clientId: ProbeSpecOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema ProbeSpecOauth2#clientSecret
   */
  readonly clientSecret: ProbeSpecOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema ProbeSpecOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ProbeSpecOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ProbeSpecOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'ProbeSpecOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecOauth2(
  obj: ProbeSpecOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": toJson_ProbeSpecOauth2ClientId(obj.clientId),
    "clientSecret": toJson_ProbeSpecOauth2ClientSecret(obj.clientSecret),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specification for the prober to use for probing targets. The prober.URL parameter is required. Targets cannot be probed if left empty.
 *
 * @schema ProbeSpecProber
 */
export interface ProbeSpecProber {
  /**
   * Path to collect metrics from. Defaults to `/probe`.
   *
   * @default probe`.
   * @schema ProbeSpecProber#path
   */
  readonly path?: string;

  /**
   * Optional ProxyURL.
   *
   * @schema ProbeSpecProber#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * HTTP scheme to use for scraping. `http` and `https` are the expected values unless you rewrite the `__scheme__` label via relabeling. If empty, Prometheus uses the default value `http`.
   *
   * @schema ProbeSpecProber#scheme
   */
  readonly scheme?: ProbeSpecProberScheme;

  /**
   * Mandatory URL of the prober.
   *
   * @schema ProbeSpecProber#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'ProbeSpecProber' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecProber(
  obj: ProbeSpecProber | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "path": obj.path,
    "proxyUrl": obj.proxyUrl,
    "scheme": obj.scheme,
    "url": obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Targets defines a set of static or dynamically discovered targets to probe.
 *
 * @schema ProbeSpecTargets
 */
export interface ProbeSpecTargets {
  /**
   * ingress defines the Ingress objects to probe and the relabeling configuration. If `staticConfig` is also defined, `staticConfig` takes precedence.
   *
   * @schema ProbeSpecTargets#ingress
   */
  readonly ingress?: ProbeSpecTargetsIngress;

  /**
   * staticConfig defines the static list of targets to probe and the relabeling configuration. If `ingress` is also defined, `staticConfig` takes precedence. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
   *
   * @schema ProbeSpecTargets#staticConfig
   */
  readonly staticConfig?: ProbeSpecTargetsStaticConfig;
}

/**
 * Converts an object of type 'ProbeSpecTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargets(
  obj: ProbeSpecTargets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ingress": toJson_ProbeSpecTargetsIngress(obj.ingress),
    "staticConfig": toJson_ProbeSpecTargetsStaticConfig(obj.staticConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration to use when scraping the endpoint.
 *
 * @schema ProbeSpecTlsConfig
 */
export interface ProbeSpecTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ProbeSpecTlsConfig#ca
   */
  readonly ca?: ProbeSpecTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ProbeSpecTlsConfig#cert
   */
  readonly cert?: ProbeSpecTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ProbeSpecTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ProbeSpecTlsConfig#keySecret
   */
  readonly keySecret?: ProbeSpecTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ProbeSpecTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'ProbeSpecTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfig(
  obj: ProbeSpecTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_ProbeSpecTlsConfigCa(obj.ca),
    "cert": toJson_ProbeSpecTlsConfigCert(obj.cert),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret": toJson_ProbeSpecTlsConfigKeySecret(obj.keySecret),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ProbeSpecAuthorizationCredentials
 */
export interface ProbeSpecAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecAuthorizationCredentials(
  obj: ProbeSpecAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema ProbeSpecBasicAuthPassword
 */
export interface ProbeSpecBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecBasicAuthPassword(
  obj: ProbeSpecBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema ProbeSpecBasicAuthUsername
 */
export interface ProbeSpecBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecBasicAuthUsername(
  obj: ProbeSpecBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 *
 * @schema ProbeSpecMetricRelabelingsAction
 */
export enum ProbeSpecMetricRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema ProbeSpecOauth2ClientId
 */
export interface ProbeSpecOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ProbeSpecOauth2ClientId#configMap
   */
  readonly configMap?: ProbeSpecOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ProbeSpecOauth2ClientId#secret
   */
  readonly secret?: ProbeSpecOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'ProbeSpecOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecOauth2ClientId(
  obj: ProbeSpecOauth2ClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ProbeSpecOauth2ClientIdConfigMap(obj.configMap),
    "secret": toJson_ProbeSpecOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema ProbeSpecOauth2ClientSecret
 */
export interface ProbeSpecOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecOauth2ClientSecret(
  obj: ProbeSpecOauth2ClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP scheme to use for scraping. `http` and `https` are the expected values unless you rewrite the `__scheme__` label via relabeling. If empty, Prometheus uses the default value `http`.
 *
 * @schema ProbeSpecProberScheme
 */
export enum ProbeSpecProberScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * ingress defines the Ingress objects to probe and the relabeling configuration. If `staticConfig` is also defined, `staticConfig` takes precedence.
 *
 * @schema ProbeSpecTargetsIngress
 */
export interface ProbeSpecTargetsIngress {
  /**
   * From which namespaces to select Ingress objects.
   *
   * @schema ProbeSpecTargetsIngress#namespaceSelector
   */
  readonly namespaceSelector?: ProbeSpecTargetsIngressNamespaceSelector;

  /**
   * RelabelConfigs to apply to the label set of the target before it gets scraped. The original ingress address is available via the `__tmp_prometheus_ingress_address` label. It can be used to customize the probed URL. The original scrape job's name is available via the `__tmp_prometheus_job_name` label. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema ProbeSpecTargetsIngress#relabelingConfigs
   */
  readonly relabelingConfigs?: ProbeSpecTargetsIngressRelabelingConfigs[];

  /**
   * Selector to select the Ingress objects.
   *
   * @schema ProbeSpecTargetsIngress#selector
   */
  readonly selector?: ProbeSpecTargetsIngressSelector;
}

/**
 * Converts an object of type 'ProbeSpecTargetsIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsIngress(
  obj: ProbeSpecTargetsIngress | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "namespaceSelector": toJson_ProbeSpecTargetsIngressNamespaceSelector(
      obj.namespaceSelector,
    ),
    "relabelingConfigs": obj.relabelingConfigs?.map((y) =>
      toJson_ProbeSpecTargetsIngressRelabelingConfigs(y)
    ),
    "selector": toJson_ProbeSpecTargetsIngressSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * staticConfig defines the static list of targets to probe and the relabeling configuration. If `ingress` is also defined, `staticConfig` takes precedence. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
 *
 * @schema ProbeSpecTargetsStaticConfig
 */
export interface ProbeSpecTargetsStaticConfig {
  /**
   * Labels assigned to all metrics scraped from the targets.
   *
   * @schema ProbeSpecTargetsStaticConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * RelabelConfigs to apply to the label set of the targets before it gets scraped. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema ProbeSpecTargetsStaticConfig#relabelingConfigs
   */
  readonly relabelingConfigs?: ProbeSpecTargetsStaticConfigRelabelingConfigs[];

  /**
   * The list of hosts to probe.
   *
   * @schema ProbeSpecTargetsStaticConfig#static
   */
  readonly static?: string[];
}

/**
 * Converts an object of type 'ProbeSpecTargetsStaticConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsStaticConfig(
  obj: ProbeSpecTargetsStaticConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "relabelingConfigs": obj.relabelingConfigs?.map((y) =>
      toJson_ProbeSpecTargetsStaticConfigRelabelingConfigs(y)
    ),
    "static": obj.static?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ProbeSpecTlsConfigCa
 */
export interface ProbeSpecTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ProbeSpecTlsConfigCa#configMap
   */
  readonly configMap?: ProbeSpecTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ProbeSpecTlsConfigCa#secret
   */
  readonly secret?: ProbeSpecTlsConfigCaSecret;
}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCa(
  obj: ProbeSpecTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ProbeSpecTlsConfigCaConfigMap(obj.configMap),
    "secret": toJson_ProbeSpecTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ProbeSpecTlsConfigCert
 */
export interface ProbeSpecTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ProbeSpecTlsConfigCert#configMap
   */
  readonly configMap?: ProbeSpecTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ProbeSpecTlsConfigCert#secret
   */
  readonly secret?: ProbeSpecTlsConfigCertSecret;
}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCert(
  obj: ProbeSpecTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ProbeSpecTlsConfigCertConfigMap(obj.configMap),
    "secret": toJson_ProbeSpecTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ProbeSpecTlsConfigKeySecret
 */
export interface ProbeSpecTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigKeySecret(
  obj: ProbeSpecTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ProbeSpecOauth2ClientIdConfigMap
 */
export interface ProbeSpecOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ProbeSpecOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ProbeSpecOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecOauth2ClientIdConfigMap(
  obj: ProbeSpecOauth2ClientIdConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ProbeSpecOauth2ClientIdSecret
 */
export interface ProbeSpecOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecOauth2ClientIdSecret(
  obj: ProbeSpecOauth2ClientIdSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * From which namespaces to select Ingress objects.
 *
 * @schema ProbeSpecTargetsIngressNamespaceSelector
 */
export interface ProbeSpecTargetsIngressNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a list restricting them.
   *
   * @schema ProbeSpecTargetsIngressNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names to select from.
   *
   * @schema ProbeSpecTargetsIngressNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];
}

/**
 * Converts an object of type 'ProbeSpecTargetsIngressNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsIngressNamespaceSelector(
  obj: ProbeSpecTargetsIngressNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "any": obj.any,
    "matchNames": obj.matchNames?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ProbeSpecTargetsIngressRelabelingConfigs
 */
export interface ProbeSpecTargetsIngressRelabelingConfigs {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#action
   */
  readonly action?: ProbeSpecTargetsIngressRelabelingConfigsAction;

  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the regular expression matches.
   * Regex capture groups are available.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions.
   * Regex capture groups are available.
   *
   * @schema ProbeSpecTargetsIngressRelabelingConfigs#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'ProbeSpecTargetsIngressRelabelingConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsIngressRelabelingConfigs(
  obj: ProbeSpecTargetsIngressRelabelingConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "action": obj.action,
    "modulus": obj.modulus,
    "regex": obj.regex,
    "replacement": obj.replacement,
    "separator": obj.separator,
    "sourceLabels": obj.sourceLabels?.map((y) => y),
    "targetLabel": obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selector to select the Ingress objects.
 *
 * @schema ProbeSpecTargetsIngressSelector
 */
export interface ProbeSpecTargetsIngressSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ProbeSpecTargetsIngressSelector#matchExpressions
   */
  readonly matchExpressions?: ProbeSpecTargetsIngressSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ProbeSpecTargetsIngressSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ProbeSpecTargetsIngressSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsIngressSelector(
  obj: ProbeSpecTargetsIngressSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ProbeSpecTargetsIngressSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs
 */
export interface ProbeSpecTargetsStaticConfigRelabelingConfigs {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#action
   */
  readonly action?: ProbeSpecTargetsStaticConfigRelabelingConfigsAction;

  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the regular expression matches.
   * Regex capture groups are available.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions.
   * Regex capture groups are available.
   *
   * @schema ProbeSpecTargetsStaticConfigRelabelingConfigs#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'ProbeSpecTargetsStaticConfigRelabelingConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsStaticConfigRelabelingConfigs(
  obj: ProbeSpecTargetsStaticConfigRelabelingConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "action": obj.action,
    "modulus": obj.modulus,
    "regex": obj.regex,
    "replacement": obj.replacement,
    "separator": obj.separator,
    "sourceLabels": obj.sourceLabels?.map((y) => y),
    "targetLabel": obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ProbeSpecTlsConfigCaConfigMap
 */
export interface ProbeSpecTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ProbeSpecTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ProbeSpecTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCaConfigMap(
  obj: ProbeSpecTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ProbeSpecTlsConfigCaSecret
 */
export interface ProbeSpecTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCaSecret(
  obj: ProbeSpecTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ProbeSpecTlsConfigCertConfigMap
 */
export interface ProbeSpecTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ProbeSpecTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ProbeSpecTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCertConfigMap(
  obj: ProbeSpecTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ProbeSpecTlsConfigCertSecret
 */
export interface ProbeSpecTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ProbeSpecTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ProbeSpecTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ProbeSpecTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ProbeSpecTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTlsConfigCertSecret(
  obj: ProbeSpecTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 *
 * @schema ProbeSpecTargetsIngressRelabelingConfigsAction
 */
export enum ProbeSpecTargetsIngressRelabelingConfigsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ProbeSpecTargetsIngressSelectorMatchExpressions
 */
export interface ProbeSpecTargetsIngressSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ProbeSpecTargetsIngressSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ProbeSpecTargetsIngressSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ProbeSpecTargetsIngressSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ProbeSpecTargetsIngressSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProbeSpecTargetsIngressSelectorMatchExpressions(
  obj: ProbeSpecTargetsIngressSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 *
 * @schema ProbeSpecTargetsStaticConfigRelabelingConfigsAction
 */
export enum ProbeSpecTargetsStaticConfigRelabelingConfigsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Prometheus defines a Prometheus deployment.
 *
 * @schema Prometheus
 */
export class Prometheus extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Prometheus"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "monitoring.coreos.com/v1",
    kind: "Prometheus",
  };

  /**
   * Renders a Kubernetes manifest for "Prometheus".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PrometheusProps): any {
    return {
      ...Prometheus.GVK,
      ...toJson_PrometheusProps(props),
    };
  }

  /**
   * Defines a "Prometheus" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PrometheusProps) {
    super(scope, id, {
      ...Prometheus.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Prometheus.GVK,
      ...toJson_PrometheusProps(resolved),
    };
  }
}

/**
 * Prometheus defines a Prometheus deployment.
 *
 * @schema Prometheus
 */
export interface PrometheusProps {
  /**
   * @schema Prometheus#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the Prometheus cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema Prometheus#spec
   */
  readonly spec: PrometheusSpec;
}

/**
 * Converts an object of type 'PrometheusProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusProps(
  obj: PrometheusProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_PrometheusSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired behavior of the Prometheus cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema PrometheusSpec
 */
export interface PrometheusSpec {
  /**
   * AdditionalAlertManagerConfigs specifies a key of a Secret containing additional Prometheus Alertmanager configurations. The Alertmanager configurations are appended to the configuration generated by the Prometheus Operator. They must be formatted according to the official Prometheus documentation:
   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config
   * The user is responsible for making sure that the configurations are valid
   * Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible AlertManager configs are going to break Prometheus after the upgrade.
   *
   * @schema PrometheusSpec#additionalAlertManagerConfigs
   */
  readonly additionalAlertManagerConfigs?:
    PrometheusSpecAdditionalAlertManagerConfigs;

  /**
   * AdditionalAlertRelabelConfigs specifies a key of a Secret containing additional Prometheus alert relabel configurations. The alert relabel configurations are appended to the configuration generated by the Prometheus Operator. They must be formatted according to the official Prometheus documentation:
   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs
   * The user is responsible for making sure that the configurations are valid
   * Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible alert relabel configs are going to break Prometheus after the upgrade.
   *
   * @schema PrometheusSpec#additionalAlertRelabelConfigs
   */
  readonly additionalAlertRelabelConfigs?:
    PrometheusSpecAdditionalAlertRelabelConfigs;

  /**
   * AdditionalArgs allows setting additional arguments for the 'prometheus' container.
   * It is intended for e.g. activating hidden flags which are not supported by the dedicated configuration options yet. The arguments are passed as-is to the Prometheus container which may cause issues if they are invalid or not supported by the given Prometheus version.
   * In case of an argument conflict (e.g. an argument which is already set by the operator itself) or when providing an invalid argument, the reconciliation will fail and an error will be logged.
   *
   * @schema PrometheusSpec#additionalArgs
   */
  readonly additionalArgs?: PrometheusSpecAdditionalArgs[];

  /**
   * AdditionalScrapeConfigs allows specifying a key of a Secret containing additional Prometheus scrape configurations. Scrape configurations specified are appended to the configurations generated by the Prometheus Operator. Job configurations specified must have the form as specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config. As scrape configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible scrape configs are going to break Prometheus after the upgrade.
   *
   * @schema PrometheusSpec#additionalScrapeConfigs
   */
  readonly additionalScrapeConfigs?: PrometheusSpecAdditionalScrapeConfigs;

  /**
   * Defines the Pods' affinity scheduling rules if specified.
   *
   * @schema PrometheusSpec#affinity
   */
  readonly affinity?: PrometheusSpecAffinity;

  /**
   * Defines the settings related to Alertmanager.
   *
   * @schema PrometheusSpec#alerting
   */
  readonly alerting?: PrometheusSpecAlerting;

  /**
   * AllowOverlappingBlocks enables vertical compaction and vertical query merge in Prometheus.
   * Deprecated: this flag has no effect for Prometheus >= 2.39.0 where overlapping blocks are enabled by default.
   *
   * @schema PrometheusSpec#allowOverlappingBlocks
   */
  readonly allowOverlappingBlocks?: boolean;

  /**
   * APIServerConfig allows specifying a host and auth methods to access the Kuberntees API server. If null, Prometheus is assumed to run inside of the cluster: it will discover the API servers automatically and use the Pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
   *
   * @schema PrometheusSpec#apiserverConfig
   */
  readonly apiserverConfig?: PrometheusSpecApiserverConfig;

  /**
   * When true, ServiceMonitor, PodMonitor and Probe object are forbidden to reference arbitrary files on the file system of the 'prometheus' container. When a ServiceMonitor's endpoint specifies a `bearerTokenFile` value (e.g.  '/var/run/secrets/kubernetes.io/serviceaccount/token'), a malicious target can get access to the Prometheus service account's token in the Prometheus' scrape request. Setting `spec.arbitraryFSAccessThroughSM` to 'true' would prevent the attack. Users should instead provide the credentials using the `spec.bearerTokenSecret` field.
   *
   * @schema PrometheusSpec#arbitraryFSAccessThroughSMs
   */
  readonly arbitraryFsAccessThroughSMs?:
    PrometheusSpecArbitraryFsAccessThroughSMs;

  /**
   * Deprecated: use 'spec.image' instead.
   *
   * @schema PrometheusSpec#baseImage
   */
  readonly baseImage?: string;

  /**
   * BodySizeLimit defines per-scrape on response body size. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#bodySizeLimit
   */
  readonly bodySizeLimit?: string;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus object, which shall be mounted into the Prometheus Pods. Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`. The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name> in the 'prometheus' container.
   *
   * @schema PrometheusSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers allows injecting additional containers or modifying operator generated containers. This can be used to allow adding an authentication proxy to the Pods or to change the behavior of an operator generated container. Containers described here modify an operator generated container if they share the same name and modifications are done via a strategic merge patch.
   * The names of containers managed by the operator are: * `prometheus` * `config-reloader` * `thanos-sidecar`
   * Overriding containers is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   *
   * @schema PrometheusSpec#containers
   */
  readonly containers?: PrometheusSpecContainers[];

  /**
   * When true, the Prometheus compaction is disabled.
   *
   * @schema PrometheusSpec#disableCompaction
   */
  readonly disableCompaction?: boolean;

  /**
   * Enables access to the Prometheus web admin API.
   * WARNING: Enabling the admin APIs enables mutating endpoints, to delete data, shutdown Prometheus, and more. Enabling this should be done with care and the user is advised to add additional authentication authorization via a proxy to ensure only clients authorized to perform these actions can do so.
   * For more information: https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis
   *
   * @schema PrometheusSpec#enableAdminAPI
   */
  readonly enableAdminApi?: boolean;

  /**
   * Enable access to Prometheus feature flags. By default, no features are enabled.
   * Enabling features which are disabled by default is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   * For more information see https://prometheus.io/docs/prometheus/latest/feature_flags/
   *
   * @schema PrometheusSpec#enableFeatures
   */
  readonly enableFeatures?: string[];

  /**
   * Enable Prometheus to be used as a receiver for the Prometheus remote write protocol.
   * WARNING: This is not considered an efficient way of ingesting samples. Use it with caution for specific low-volume use cases. It is not suitable for replacing the ingestion via scraping and turning Prometheus into a push-based metrics collection system. For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#remote-write-receiver
   * It requires Prometheus >= v2.33.0.
   *
   * @schema PrometheusSpec#enableRemoteWriteReceiver
   */
  readonly enableRemoteWriteReceiver?: boolean;

  /**
   * When defined, enforcedBodySizeLimit specifies a global limit on the size of uncompressed response body that will be accepted by Prometheus. Targets responding with a body larger than this many bytes will cause the scrape to fail.
   * It requires Prometheus >= v2.28.0.
   *
   * @schema PrometheusSpec#enforcedBodySizeLimit
   */
  readonly enforcedBodySizeLimit?: string;

  /**
   * When defined, enforcedKeepDroppedTargets specifies a global limit on the number of targets dropped by relabeling that will be kept in memory. The value overrides any `spec.keepDroppedTargets` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.keepDroppedTargets` is greater than zero and less than `spec.enforcedKeepDroppedTargets`.
   * It requires Prometheus >= v2.47.0.
   *
   * @schema PrometheusSpec#enforcedKeepDroppedTargets
   */
  readonly enforcedKeepDroppedTargets?: number;

  /**
   * When defined, enforcedLabelLimit specifies a global limit on the number of labels per sample. The value overrides any `spec.labelLimit` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.labelLimit` is greater than zero and less than `spec.enforcedLabelLimit`.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusSpec#enforcedLabelLimit
   */
  readonly enforcedLabelLimit?: number;

  /**
   * When defined, enforcedLabelNameLengthLimit specifies a global limit on the length of labels name per sample. The value overrides any `spec.labelNameLengthLimit` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.labelNameLengthLimit` is greater than zero and less than `spec.enforcedLabelNameLengthLimit`.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusSpec#enforcedLabelNameLengthLimit
   */
  readonly enforcedLabelNameLengthLimit?: number;

  /**
   * When not null, enforcedLabelValueLengthLimit defines a global limit on the length of labels value per sample. The value overrides any `spec.labelValueLengthLimit` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.labelValueLengthLimit` is greater than zero and less than `spec.enforcedLabelValueLengthLimit`.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusSpec#enforcedLabelValueLengthLimit
   */
  readonly enforcedLabelValueLengthLimit?: number;

  /**
   * When not empty, a label will be added to
   * 1. All metrics scraped from `ServiceMonitor`, `PodMonitor`, `Probe` and `ScrapeConfig` objects. 2. All metrics generated from recording rules defined in `PrometheusRule` objects. 3. All alerts generated from alerting rules defined in `PrometheusRule` objects. 4. All vector selectors of PromQL expressions defined in `PrometheusRule` objects.
   * The label will not added for objects referenced in `spec.excludedFromEnforcement`.
   * The label's name is this field's value. The label's value is the namespace of the `ServiceMonitor`, `PodMonitor`, `Probe` or `PrometheusRule` object.
   *
   * @schema PrometheusSpec#enforcedNamespaceLabel
   */
  readonly enforcedNamespaceLabel?: string;

  /**
   * When defined, enforcedSampleLimit specifies a global limit on the number of scraped samples that will be accepted. This overrides any `spec.sampleLimit` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.sampleLimit` is greater than zero and less than than `spec.enforcedSampleLimit`.
   * It is meant to be used by admins to keep the overall number of samples/series under a desired limit.
   *
   * @schema PrometheusSpec#enforcedSampleLimit
   */
  readonly enforcedSampleLimit?: number;

  /**
   * When defined, enforcedTargetLimit specifies a global limit on the number of scraped targets. The value overrides any `spec.targetLimit` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.targetLimit` is greater than zero and less than `spec.enforcedTargetLimit`.
   * It is meant to be used by admins to to keep the overall number of targets under a desired limit.
   *
   * @schema PrometheusSpec#enforcedTargetLimit
   */
  readonly enforcedTargetLimit?: number;

  /**
   * Interval between rule evaluations. Default: "30s"
   *
   * @schema PrometheusSpec#evaluationInterval
   */
  readonly evaluationInterval?: string;

  /**
   * List of references to PodMonitor, ServiceMonitor, Probe and PrometheusRule objects to be excluded from enforcing a namespace label of origin.
   * It is only applicable if `spec.enforcedNamespaceLabel` set to true.
   *
   * @schema PrometheusSpec#excludedFromEnforcement
   */
  readonly excludedFromEnforcement?: PrometheusSpecExcludedFromEnforcement[];

  /**
   * Exemplars related settings that are runtime reloadable. It requires to enable the `exemplar-storage` feature flag to be effective.
   *
   * @schema PrometheusSpec#exemplars
   */
  readonly exemplars?: PrometheusSpecExemplars;

  /**
   * The labels to add to any time series or alerts when communicating with external systems (federation, remote storage, Alertmanager). Labels defined by `spec.replicaExternalLabelName` and `spec.prometheusExternalLabelName` take precedence over this list.
   *
   * @schema PrometheusSpec#externalLabels
   */
  readonly externalLabels?: { [key: string]: string };

  /**
   * The external URL under which the Prometheus service is externally available. This is necessary to generate correct URLs (for instance if Prometheus is accessible behind an Ingress resource).
   *
   * @schema PrometheusSpec#externalUrl
   */
  readonly externalUrl?: string;

  /**
   * Optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema PrometheusSpec#hostAliases
   */
  readonly hostAliases?: PrometheusSpecHostAliases[];

  /**
   * Use the host's network namespace if true.
   * Make sure to understand the security implications if you want to enable it (https://kubernetes.io/docs/concepts/configuration/overview/).
   * When hostNetwork is enabled, this will set the DNS policy to `ClusterFirstWithHostNet` automatically.
   *
   * @schema PrometheusSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * When true, `spec.namespaceSelector` from all PodMonitor, ServiceMonitor and Probe objects will be ignored. They will only discover targets within the namespace of the PodMonitor, ServiceMonitor and Probe object.
   *
   * @schema PrometheusSpec#ignoreNamespaceSelectors
   */
  readonly ignoreNamespaceSelectors?: boolean;

  /**
   * Container image name for Prometheus. If specified, it takes precedence over the `spec.baseImage`, `spec.tag` and `spec.sha` fields.
   * Specifying `spec.version` is still necessary to ensure the Prometheus Operator knows which version of Prometheus is being configured.
   * If neither `spec.image` nor `spec.baseImage` are defined, the operator will use the latest upstream version of Prometheus available at the time when the operator was released.
   *
   * @schema PrometheusSpec#image
   */
  readonly image?: string;

  /**
   * Image pull policy for the 'prometheus', 'init-config-reloader' and 'config-reloader' containers. See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
   *
   * @schema PrometheusSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: PrometheusSpecImagePullPolicy;

  /**
   * An optional list of references to Secrets in the same namespace to use for pulling images from registries. See http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema PrometheusSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: PrometheusSpecImagePullSecrets[];

  /**
   * InitContainers allows injecting initContainers to the Pod definition. Those can be used to e.g.  fetch secrets for injection into the Prometheus configuration from external sources. Any errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ InitContainers described here modify an operator generated init containers if they share the same name and modifications are done via a strategic merge patch.
   * The names of init container name managed by the operator are: * `init-config-reloader`.
   * Overriding init containers is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   *
   * @schema PrometheusSpec#initContainers
   */
  readonly initContainers?: PrometheusSpecInitContainers[];

  /**
   * Per-scrape limit on the number of targets dropped by relabeling that will be kept in memory. 0 means no limit.
   * It requires Prometheus >= v2.47.0.
   *
   * @schema PrometheusSpec#keepDroppedTargets
   */
  readonly keepDroppedTargets?: number;

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * When true, the Prometheus server listens on the loopback address instead of the Pod IP's address.
   *
   * @schema PrometheusSpec#listenLocal
   */
  readonly listenLocal?: boolean;

  /**
   * Log format for Log level for Prometheus and the config-reloader sidecar.
   *
   * @schema PrometheusSpec#logFormat
   */
  readonly logFormat?: PrometheusSpecLogFormat;

  /**
   * Log level for Prometheus and the config-reloader sidecar.
   *
   * @schema PrometheusSpec#logLevel
   */
  readonly logLevel?: PrometheusSpecLogLevel;

  /**
   * Defines the maximum time that the `prometheus` container's startup probe will wait before being considered failed. The startup probe will return success after the WAL replay is complete. If set, the value should be greater than 60 (seconds). Otherwise it will be equal to 600 seconds (15 minutes).
   *
   * @schema PrometheusSpec#maximumStartupDurationSeconds
   */
  readonly maximumStartupDurationSeconds?: number;

  /**
   * Minimum number of seconds for which a newly created Pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
   * This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
   *
   * @default 0 (pod will be considered available as soon as it is ready)
   * @schema PrometheusSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * Defines on which Nodes the Pods are scheduled.
   *
   * @schema PrometheusSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * When true, Prometheus resolves label conflicts by renaming the labels in the scraped data to "exported_<label value>" for all targets created from service and pod monitors. Otherwise the HonorLabels field of the service or pod monitor applies.
   *
   * @schema PrometheusSpec#overrideHonorLabels
   */
  readonly overrideHonorLabels?: boolean;

  /**
   * When true, Prometheus ignores the timestamps for all the targets created from service and pod monitors. Otherwise the HonorTimestamps field of the service or pod monitor applies.
   *
   * @schema PrometheusSpec#overrideHonorTimestamps
   */
  readonly overrideHonorTimestamps?: boolean;

  /**
   * When a Prometheus deployment is paused, no actions except for deletion will be performed on the underlying objects.
   *
   * @schema PrometheusSpec#paused
   */
  readonly paused?: boolean;

  /**
   * The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet. The default behavior is all PVCs are retained. This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26. It requires enabling the StatefulSetAutoDeletePVC feature gate.
   *
   * @schema PrometheusSpec#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?:
    PrometheusSpecPersistentVolumeClaimRetentionPolicy;

  /**
   * PodMetadata configures labels and annotations which are propagated to the Prometheus pods.
   * The following items are reserved and cannot be overridden: * "prometheus" label, set to the name of the Prometheus object. * "app.kubernetes.io/instance" label, set to the name of the Prometheus object. * "app.kubernetes.io/managed-by" label, set to "prometheus-operator". * "app.kubernetes.io/name" label, set to "prometheus". * "app.kubernetes.io/version" label, set to the Prometheus version. * "operator.prometheus.io/name" label, set to the name of the Prometheus object. * "operator.prometheus.io/shard" label, set to the shard number of the Prometheus object. * "kubectl.kubernetes.io/default-container" annotation, set to "prometheus".
   *
   * @schema PrometheusSpec#podMetadata
   */
  readonly podMetadata?: PrometheusSpecPodMetadata;

  /**
   * Namespaces to match for PodMonitors discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
   *
   * @schema PrometheusSpec#podMonitorNamespaceSelector
   */
  readonly podMonitorNamespaceSelector?:
    PrometheusSpecPodMonitorNamespaceSelector;

  /**
   * *Experimental* PodMonitors to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
   *
   * @schema PrometheusSpec#podMonitorSelector
   */
  readonly podMonitorSelector?: PrometheusSpecPodMonitorSelector;

  /**
   * PodTargetLabels are appended to the `spec.podTargetLabels` field of all PodMonitor and ServiceMonitor objects.
   *
   * @schema PrometheusSpec#podTargetLabels
   */
  readonly podTargetLabels?: string[];

  /**
   * Port name used for the pods and governing service. Default: "web"
   *
   * @schema PrometheusSpec#portName
   */
  readonly portName?: string;

  /**
   * Priority class assigned to the Pods.
   *
   * @schema PrometheusSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * *Experimental* Namespaces to match for Probe discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
   *
   * @schema PrometheusSpec#probeNamespaceSelector
   */
  readonly probeNamespaceSelector?: PrometheusSpecProbeNamespaceSelector;

  /**
   * *Experimental* Probes to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
   *
   * @schema PrometheusSpec#probeSelector
   */
  readonly probeSelector?: PrometheusSpecProbeSelector;

  /**
   * Name of Prometheus external label used to denote the Prometheus instance name. The external label will _not_ be added when the field is set to the empty string (`""`).
   * Default: "prometheus"
   *
   * @schema PrometheusSpec#prometheusExternalLabelName
   */
  readonly prometheusExternalLabelName?: string;

  /**
   * Defines the list of PrometheusRule objects to which the namespace label enforcement doesn't apply. This is only relevant when `spec.enforcedNamespaceLabel` is set to true. Deprecated: use `spec.excludedFromEnforcement` instead.
   *
   * @schema PrometheusSpec#prometheusRulesExcludedFromEnforce
   */
  readonly prometheusRulesExcludedFromEnforce?:
    PrometheusSpecPrometheusRulesExcludedFromEnforce[];

  /**
   * QuerySpec defines the configuration of the Promethus query service.
   *
   * @schema PrometheusSpec#query
   */
  readonly query?: PrometheusSpecQuery;

  /**
   * queryLogFile specifies where the file to which PromQL queries are logged.
   * If the filename has an empty path, e.g. 'query.log', The Prometheus Pods will mount the file into an emptyDir volume at `/var/log/prometheus`. If a full path is provided, e.g. '/var/log/prometheus/query.log', you must mount a volume in the specified directory and it must be writable. This is because the prometheus container runs with a read-only root filesystem for security reasons. Alternatively, the location can be set to a standard I/O stream, e.g. `/dev/stdout`, to log query information to the default Prometheus log stream.
   *
   * @schema PrometheusSpec#queryLogFile
   */
  readonly queryLogFile?: string;

  /**
   * Defines the strategy used to reload the Prometheus configuration. If not specified, the configuration is reloaded using the /-/reload HTTP endpoint.
   *
   * @schema PrometheusSpec#reloadStrategy
   */
  readonly reloadStrategy?: PrometheusSpecReloadStrategy;

  /**
   * Defines the list of remote read configurations.
   *
   * @schema PrometheusSpec#remoteRead
   */
  readonly remoteRead?: PrometheusSpecRemoteRead[];

  /**
   * Defines the list of remote write configurations.
   *
   * @schema PrometheusSpec#remoteWrite
   */
  readonly remoteWrite?: PrometheusSpecRemoteWrite[];

  /**
   * Name of Prometheus external label used to denote the replica name. The external label will _not_ be added when the field is set to the empty string (`""`).
   * Default: "prometheus_replica"
   *
   * @schema PrometheusSpec#replicaExternalLabelName
   */
  readonly replicaExternalLabelName?: string;

  /**
   * Number of replicas of each shard to deploy for a Prometheus deployment. `spec.replicas` multiplied by `spec.shards` is the total number of Pods created.
   * Default: 1
   *
   * @schema PrometheusSpec#replicas
   */
  readonly replicas?: number;

  /**
   * Defines the resources requests and limits of the 'prometheus' container.
   *
   * @schema PrometheusSpec#resources
   */
  readonly resources?: PrometheusSpecResources;

  /**
   * How long to retain the Prometheus data.
   * Default: "24h" if `spec.retention` and `spec.retentionSize` are empty.
   *
   * @schema PrometheusSpec#retention
   */
  readonly retention?: string;

  /**
   * Maximum number of bytes used by the Prometheus data.
   *
   * @schema PrometheusSpec#retentionSize
   */
  readonly retentionSize?: string;

  /**
   * The route prefix Prometheus registers HTTP handlers for.
   * This is useful when using `spec.externalURL`, and a proxy is rewriting HTTP routes of a request, and the actual ExternalURL is still true, but the server serves requests under a different route prefix. For example for use with `kubectl proxy`.
   *
   * @schema PrometheusSpec#routePrefix
   */
  readonly routePrefix?: string;

  /**
   * Namespaces to match for PrometheusRule discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
   *
   * @schema PrometheusSpec#ruleNamespaceSelector
   */
  readonly ruleNamespaceSelector?: PrometheusSpecRuleNamespaceSelector;

  /**
   * PrometheusRule objects to be selected for rule evaluation. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema PrometheusSpec#ruleSelector
   */
  readonly ruleSelector?: PrometheusSpecRuleSelector;

  /**
   * Defines the configuration of the Prometheus rules' engine.
   *
   * @schema PrometheusSpec#rules
   */
  readonly rules?: PrometheusSpecRules;

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * Namespaces to match for ScrapeConfig discovery. An empty label selector matches all namespaces. A null label selector matches the current current namespace only.
   *
   * @schema PrometheusSpec#scrapeConfigNamespaceSelector
   */
  readonly scrapeConfigNamespaceSelector?:
    PrometheusSpecScrapeConfigNamespaceSelector;

  /**
   * *Experimental* ScrapeConfigs to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
   *
   * @schema PrometheusSpec#scrapeConfigSelector
   */
  readonly scrapeConfigSelector?: PrometheusSpecScrapeConfigSelector;

  /**
   * Interval between consecutive scrapes.
   * Default: "30s"
   *
   * @schema PrometheusSpec#scrapeInterval
   */
  readonly scrapeInterval?: string;

  /**
   * Number of seconds to wait until a scrape request times out.
   *
   * @schema PrometheusSpec#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Prometheus object, which shall be mounted into the Prometheus Pods. Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`. The Secrets are mounted into /etc/prometheus/secrets/<secret-name> in the 'prometheus' container.
   *
   * @schema PrometheusSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.
   *
   * @schema PrometheusSpec#securityContext
   */
  readonly securityContext?: PrometheusSpecSecurityContext;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the Prometheus Pods.
   *
   * @schema PrometheusSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Namespaces to match for ServicedMonitors discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
   *
   * @schema PrometheusSpec#serviceMonitorNamespaceSelector
   */
  readonly serviceMonitorNamespaceSelector?:
    PrometheusSpecServiceMonitorNamespaceSelector;

  /**
   * ServiceMonitors to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
   *
   * @schema PrometheusSpec#serviceMonitorSelector
   */
  readonly serviceMonitorSelector?: PrometheusSpecServiceMonitorSelector;

  /**
   * Deprecated: use 'spec.image' instead. The image's digest can be specified as part of the image name.
   *
   * @schema PrometheusSpec#sha
   */
  readonly sha?: string;

  /**
   * EXPERIMENTAL: Number of shards to distribute targets onto. `spec.replicas` multiplied by `spec.shards` is the total number of Pods created.
   * Note that scaling down shards will not reshard data onto remaining instances, it must be manually moved. Increasing shards will not reshard data either but it will continue to be available from the same instances. To query globally, use Thanos sidecar and Thanos querier or remote write data to a central location.
   * Sharding is performed on the content of the `__address__` target meta-label for PodMonitors and ServiceMonitors and `__param_target__` for Probes.
   * Default: 1
   *
   * @schema PrometheusSpec#shards
   */
  readonly shards?: number;

  /**
   * Storage defines the storage used by Prometheus.
   *
   * @schema PrometheusSpec#storage
   */
  readonly storage?: PrometheusSpecStorage;

  /**
   * Deprecated: use 'spec.image' instead. The image's tag can be specified as part of the image name.
   *
   * @schema PrometheusSpec#tag
   */
  readonly tag?: string;

  /**
   * TargetLimit defines a limit on the number of scraped targets that will be accepted. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusSpec#targetLimit
   */
  readonly targetLimit?: number;

  /**
   * Defines the configuration of the optional Thanos sidecar.
   * This section is experimental, it may change significantly without deprecation notice in any release.
   *
   * @schema PrometheusSpec#thanos
   */
  readonly thanos?: PrometheusSpecThanos;

  /**
   * Defines the Pods' tolerations if specified.
   *
   * @schema PrometheusSpec#tolerations
   */
  readonly tolerations?: PrometheusSpecTolerations[];

  /**
   * Defines the pod's topology spread constraints if specified.
   *
   * @schema PrometheusSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?:
    PrometheusSpecTopologySpreadConstraints[];

  /**
   * EXPERIMENTAL: TracingConfig configures tracing in Prometheus. This is an experimental feature, it may change in any upcoming release in a breaking way.
   *
   * @schema PrometheusSpec#tracingConfig
   */
  readonly tracingConfig?: PrometheusSpecTracingConfig;

  /**
   * Defines the runtime reloadable configuration of the timeseries database (TSDB).
   *
   * @schema PrometheusSpec#tsdb
   */
  readonly tsdb?: PrometheusSpecTsdb;

  /**
   * Version of Prometheus being deployed. The operator uses this information to generate the Prometheus StatefulSet + configuration files.
   * If not specified, the operator assumes the latest upstream version of Prometheus available at the time when the version of the operator was released.
   *
   * @schema PrometheusSpec#version
   */
  readonly version?: string;

  /**
   * VolumeMounts allows the configuration of additional VolumeMounts.
   * VolumeMounts will be appended to other VolumeMounts in the 'prometheus' container, that are generated as a result of StorageSpec objects.
   *
   * @schema PrometheusSpec#volumeMounts
   */
  readonly volumeMounts?: PrometheusSpecVolumeMounts[];

  /**
   * Volumes allows the configuration of additional volumes on the output StatefulSet definition. Volumes specified will be appended to other volumes that are generated as a result of StorageSpec objects.
   *
   * @schema PrometheusSpec#volumes
   */
  readonly volumes?: PrometheusSpecVolumes[];

  /**
   * Configures compression of the write-ahead log (WAL) using Snappy.
   * WAL compression is enabled by default for Prometheus >= 2.20.0
   * Requires Prometheus v2.11.0 and above.
   *
   * @schema PrometheusSpec#walCompression
   */
  readonly walCompression?: boolean;

  /**
   * Defines the configuration of the Prometheus web server.
   *
   * @schema PrometheusSpec#web
   */
  readonly web?: PrometheusSpecWeb;
}

/**
 * Converts an object of type 'PrometheusSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpec(
  obj: PrometheusSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "additionalAlertManagerConfigs":
      toJson_PrometheusSpecAdditionalAlertManagerConfigs(
        obj.additionalAlertManagerConfigs,
      ),
    "additionalAlertRelabelConfigs":
      toJson_PrometheusSpecAdditionalAlertRelabelConfigs(
        obj.additionalAlertRelabelConfigs,
      ),
    "additionalArgs": obj.additionalArgs?.map((y) =>
      toJson_PrometheusSpecAdditionalArgs(y)
    ),
    "additionalScrapeConfigs": toJson_PrometheusSpecAdditionalScrapeConfigs(
      obj.additionalScrapeConfigs,
    ),
    "affinity": toJson_PrometheusSpecAffinity(obj.affinity),
    "alerting": toJson_PrometheusSpecAlerting(obj.alerting),
    "allowOverlappingBlocks": obj.allowOverlappingBlocks,
    "apiserverConfig": toJson_PrometheusSpecApiserverConfig(
      obj.apiserverConfig,
    ),
    "arbitraryFSAccessThroughSMs":
      toJson_PrometheusSpecArbitraryFsAccessThroughSMs(
        obj.arbitraryFsAccessThroughSMs,
      ),
    "baseImage": obj.baseImage,
    "bodySizeLimit": obj.bodySizeLimit,
    "configMaps": obj.configMaps?.map((y) => y),
    "containers": obj.containers?.map((y) =>
      toJson_PrometheusSpecContainers(y)
    ),
    "disableCompaction": obj.disableCompaction,
    "enableAdminAPI": obj.enableAdminApi,
    "enableFeatures": obj.enableFeatures?.map((y) => y),
    "enableRemoteWriteReceiver": obj.enableRemoteWriteReceiver,
    "enforcedBodySizeLimit": obj.enforcedBodySizeLimit,
    "enforcedKeepDroppedTargets": obj.enforcedKeepDroppedTargets,
    "enforcedLabelLimit": obj.enforcedLabelLimit,
    "enforcedLabelNameLengthLimit": obj.enforcedLabelNameLengthLimit,
    "enforcedLabelValueLengthLimit": obj.enforcedLabelValueLengthLimit,
    "enforcedNamespaceLabel": obj.enforcedNamespaceLabel,
    "enforcedSampleLimit": obj.enforcedSampleLimit,
    "enforcedTargetLimit": obj.enforcedTargetLimit,
    "evaluationInterval": obj.evaluationInterval,
    "excludedFromEnforcement": obj.excludedFromEnforcement?.map((y) =>
      toJson_PrometheusSpecExcludedFromEnforcement(y)
    ),
    "exemplars": toJson_PrometheusSpecExemplars(obj.exemplars),
    "externalLabels": ((obj.externalLabels) === undefined)
      ? undefined
      : (Object.entries(obj.externalLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "externalUrl": obj.externalUrl,
    "hostAliases": obj.hostAliases?.map((y) =>
      toJson_PrometheusSpecHostAliases(y)
    ),
    "hostNetwork": obj.hostNetwork,
    "ignoreNamespaceSelectors": obj.ignoreNamespaceSelectors,
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "imagePullSecrets": obj.imagePullSecrets?.map((y) =>
      toJson_PrometheusSpecImagePullSecrets(y)
    ),
    "initContainers": obj.initContainers?.map((y) =>
      toJson_PrometheusSpecInitContainers(y)
    ),
    "keepDroppedTargets": obj.keepDroppedTargets,
    "labelLimit": obj.labelLimit,
    "labelNameLengthLimit": obj.labelNameLengthLimit,
    "labelValueLengthLimit": obj.labelValueLengthLimit,
    "listenLocal": obj.listenLocal,
    "logFormat": obj.logFormat,
    "logLevel": obj.logLevel,
    "maximumStartupDurationSeconds": obj.maximumStartupDurationSeconds,
    "minReadySeconds": obj.minReadySeconds,
    "nodeSelector": ((obj.nodeSelector) === undefined)
      ? undefined
      : (Object.entries(obj.nodeSelector).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "overrideHonorLabels": obj.overrideHonorLabels,
    "overrideHonorTimestamps": obj.overrideHonorTimestamps,
    "paused": obj.paused,
    "persistentVolumeClaimRetentionPolicy":
      toJson_PrometheusSpecPersistentVolumeClaimRetentionPolicy(
        obj.persistentVolumeClaimRetentionPolicy,
      ),
    "podMetadata": toJson_PrometheusSpecPodMetadata(obj.podMetadata),
    "podMonitorNamespaceSelector":
      toJson_PrometheusSpecPodMonitorNamespaceSelector(
        obj.podMonitorNamespaceSelector,
      ),
    "podMonitorSelector": toJson_PrometheusSpecPodMonitorSelector(
      obj.podMonitorSelector,
    ),
    "podTargetLabels": obj.podTargetLabels?.map((y) => y),
    "portName": obj.portName,
    "priorityClassName": obj.priorityClassName,
    "probeNamespaceSelector": toJson_PrometheusSpecProbeNamespaceSelector(
      obj.probeNamespaceSelector,
    ),
    "probeSelector": toJson_PrometheusSpecProbeSelector(obj.probeSelector),
    "prometheusExternalLabelName": obj.prometheusExternalLabelName,
    "prometheusRulesExcludedFromEnforce": obj.prometheusRulesExcludedFromEnforce
      ?.map((y) => toJson_PrometheusSpecPrometheusRulesExcludedFromEnforce(y)),
    "query": toJson_PrometheusSpecQuery(obj.query),
    "queryLogFile": obj.queryLogFile,
    "reloadStrategy": obj.reloadStrategy,
    "remoteRead": obj.remoteRead?.map((y) =>
      toJson_PrometheusSpecRemoteRead(y)
    ),
    "remoteWrite": obj.remoteWrite?.map((y) =>
      toJson_PrometheusSpecRemoteWrite(y)
    ),
    "replicaExternalLabelName": obj.replicaExternalLabelName,
    "replicas": obj.replicas,
    "resources": toJson_PrometheusSpecResources(obj.resources),
    "retention": obj.retention,
    "retentionSize": obj.retentionSize,
    "routePrefix": obj.routePrefix,
    "ruleNamespaceSelector": toJson_PrometheusSpecRuleNamespaceSelector(
      obj.ruleNamespaceSelector,
    ),
    "ruleSelector": toJson_PrometheusSpecRuleSelector(obj.ruleSelector),
    "rules": toJson_PrometheusSpecRules(obj.rules),
    "sampleLimit": obj.sampleLimit,
    "scrapeConfigNamespaceSelector":
      toJson_PrometheusSpecScrapeConfigNamespaceSelector(
        obj.scrapeConfigNamespaceSelector,
      ),
    "scrapeConfigSelector": toJson_PrometheusSpecScrapeConfigSelector(
      obj.scrapeConfigSelector,
    ),
    "scrapeInterval": obj.scrapeInterval,
    "scrapeTimeout": obj.scrapeTimeout,
    "secrets": obj.secrets?.map((y) => y),
    "securityContext": toJson_PrometheusSpecSecurityContext(
      obj.securityContext,
    ),
    "serviceAccountName": obj.serviceAccountName,
    "serviceMonitorNamespaceSelector":
      toJson_PrometheusSpecServiceMonitorNamespaceSelector(
        obj.serviceMonitorNamespaceSelector,
      ),
    "serviceMonitorSelector": toJson_PrometheusSpecServiceMonitorSelector(
      obj.serviceMonitorSelector,
    ),
    "sha": obj.sha,
    "shards": obj.shards,
    "storage": toJson_PrometheusSpecStorage(obj.storage),
    "tag": obj.tag,
    "targetLimit": obj.targetLimit,
    "thanos": toJson_PrometheusSpecThanos(obj.thanos),
    "tolerations": obj.tolerations?.map((y) =>
      toJson_PrometheusSpecTolerations(y)
    ),
    "topologySpreadConstraints": obj.topologySpreadConstraints?.map((y) =>
      toJson_PrometheusSpecTopologySpreadConstraints(y)
    ),
    "tracingConfig": toJson_PrometheusSpecTracingConfig(obj.tracingConfig),
    "tsdb": toJson_PrometheusSpecTsdb(obj.tsdb),
    "version": obj.version,
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_PrometheusSpecVolumeMounts(y)
    ),
    "volumes": obj.volumes?.map((y) => toJson_PrometheusSpecVolumes(y)),
    "walCompression": obj.walCompression,
    "web": toJson_PrometheusSpecWeb(obj.web),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalAlertManagerConfigs specifies a key of a Secret containing additional Prometheus Alertmanager configurations. The Alertmanager configurations are appended to the configuration generated by the Prometheus Operator. They must be formatted according to the official Prometheus documentation:
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config
 * The user is responsible for making sure that the configurations are valid
 * Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible AlertManager configs are going to break Prometheus after the upgrade.
 *
 * @schema PrometheusSpecAdditionalAlertManagerConfigs
 */
export interface PrometheusSpecAdditionalAlertManagerConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAdditionalAlertManagerConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAdditionalAlertManagerConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAdditionalAlertManagerConfigs#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAdditionalAlertManagerConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAdditionalAlertManagerConfigs(
  obj: PrometheusSpecAdditionalAlertManagerConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalAlertRelabelConfigs specifies a key of a Secret containing additional Prometheus alert relabel configurations. The alert relabel configurations are appended to the configuration generated by the Prometheus Operator. They must be formatted according to the official Prometheus documentation:
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs
 * The user is responsible for making sure that the configurations are valid
 * Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible alert relabel configs are going to break Prometheus after the upgrade.
 *
 * @schema PrometheusSpecAdditionalAlertRelabelConfigs
 */
export interface PrometheusSpecAdditionalAlertRelabelConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAdditionalAlertRelabelConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAdditionalAlertRelabelConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAdditionalAlertRelabelConfigs#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAdditionalAlertRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAdditionalAlertRelabelConfigs(
  obj: PrometheusSpecAdditionalAlertRelabelConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Argument as part of the AdditionalArgs list.
 *
 * @schema PrometheusSpecAdditionalArgs
 */
export interface PrometheusSpecAdditionalArgs {
  /**
   * Name of the argument, e.g. "scrape.discovery-reload-interval".
   *
   * @schema PrometheusSpecAdditionalArgs#name
   */
  readonly name: string;

  /**
   * Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
   *
   * @schema PrometheusSpecAdditionalArgs#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'PrometheusSpecAdditionalArgs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAdditionalArgs(
  obj: PrometheusSpecAdditionalArgs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalScrapeConfigs allows specifying a key of a Secret containing additional Prometheus scrape configurations. Scrape configurations specified are appended to the configurations generated by the Prometheus Operator. Job configurations specified must have the form as specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config. As scrape configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible scrape configs are going to break Prometheus after the upgrade.
 *
 * @schema PrometheusSpecAdditionalScrapeConfigs
 */
export interface PrometheusSpecAdditionalScrapeConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAdditionalScrapeConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAdditionalScrapeConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAdditionalScrapeConfigs#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAdditionalScrapeConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAdditionalScrapeConfigs(
  obj: PrometheusSpecAdditionalScrapeConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the Pods' affinity scheduling rules if specified.
 *
 * @schema PrometheusSpecAffinity
 */
export interface PrometheusSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema PrometheusSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: PrometheusSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema PrometheusSpecAffinity#podAffinity
   */
  readonly podAffinity?: PrometheusSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema PrometheusSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: PrometheusSpecAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'PrometheusSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinity(
  obj: PrometheusSpecAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeAffinity": toJson_PrometheusSpecAffinityNodeAffinity(obj.nodeAffinity),
    "podAffinity": toJson_PrometheusSpecAffinityPodAffinity(obj.podAffinity),
    "podAntiAffinity": toJson_PrometheusSpecAffinityPodAntiAffinity(
      obj.podAntiAffinity,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the settings related to Alertmanager.
 *
 * @schema PrometheusSpecAlerting
 */
export interface PrometheusSpecAlerting {
  /**
   * AlertmanagerEndpoints Prometheus should fire alerts against.
   *
   * @schema PrometheusSpecAlerting#alertmanagers
   */
  readonly alertmanagers: PrometheusSpecAlertingAlertmanagers[];
}

/**
 * Converts an object of type 'PrometheusSpecAlerting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlerting(
  obj: PrometheusSpecAlerting | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "alertmanagers": obj.alertmanagers?.map((y) =>
      toJson_PrometheusSpecAlertingAlertmanagers(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * APIServerConfig allows specifying a host and auth methods to access the Kuberntees API server. If null, Prometheus is assumed to run inside of the cluster: it will discover the API servers automatically and use the Pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
 *
 * @schema PrometheusSpecApiserverConfig
 */
export interface PrometheusSpecApiserverConfig {
  /**
   * Authorization section for the API server.
   * Cannot be set at the same time as `basicAuth`, `bearerToken`, or `bearerTokenFile`.
   *
   * @schema PrometheusSpecApiserverConfig#authorization
   */
  readonly authorization?: PrometheusSpecApiserverConfigAuthorization;

  /**
   * BasicAuth configuration for the API server.
   * Cannot be set at the same time as `authorization`, `bearerToken`, or `bearerTokenFile`.
   *
   * @schema PrometheusSpecApiserverConfig#basicAuth
   */
  readonly basicAuth?: PrometheusSpecApiserverConfigBasicAuth;

  /**
   * *Warning: this field shouldn't be used because the token value appears in clear-text. Prefer using `authorization`.*
   * Deprecated: this will be removed in a future release.
   *
   * @schema PrometheusSpecApiserverConfig#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * File to read bearer token for accessing apiserver.
   * Cannot be set at the same time as `basicAuth`, `authorization`, or `bearerToken`.
   * Deprecated: this will be removed in a future release. Prefer using `authorization`.
   *
   * @schema PrometheusSpecApiserverConfig#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Kubernetes API address consisting of a hostname or IP address followed by an optional port number.
   *
   * @schema PrometheusSpecApiserverConfig#host
   */
  readonly host: string;

  /**
   * TLS Config to use for the API server.
   *
   * @schema PrometheusSpecApiserverConfig#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecApiserverConfigTlsConfig;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfig(
  obj: PrometheusSpecApiserverConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization": toJson_PrometheusSpecApiserverConfigAuthorization(
      obj.authorization,
    ),
    "basicAuth": toJson_PrometheusSpecApiserverConfigBasicAuth(obj.basicAuth),
    "bearerToken": obj.bearerToken,
    "bearerTokenFile": obj.bearerTokenFile,
    "host": obj.host,
    "tlsConfig": toJson_PrometheusSpecApiserverConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * When true, ServiceMonitor, PodMonitor and Probe object are forbidden to reference arbitrary files on the file system of the 'prometheus' container. When a ServiceMonitor's endpoint specifies a `bearerTokenFile` value (e.g.  '/var/run/secrets/kubernetes.io/serviceaccount/token'), a malicious target can get access to the Prometheus service account's token in the Prometheus' scrape request. Setting `spec.arbitraryFSAccessThroughSM` to 'true' would prevent the attack. Users should instead provide the credentials using the `spec.bearerTokenSecret` field.
 *
 * @schema PrometheusSpecArbitraryFsAccessThroughSMs
 */
export interface PrometheusSpecArbitraryFsAccessThroughSMs {
  /**
   * @schema PrometheusSpecArbitraryFsAccessThroughSMs#deny
   */
  readonly deny?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecArbitraryFsAccessThroughSMs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecArbitraryFsAccessThroughSMs(
  obj: PrometheusSpecArbitraryFsAccessThroughSMs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "deny": obj.deny,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema PrometheusSpecContainers
 */
export interface PrometheusSpecContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PrometheusSpecContainers#env
   */
  readonly env?: PrometheusSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema PrometheusSpecContainers#envFrom
   */
  readonly envFrom?: PrometheusSpecContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema PrometheusSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema PrometheusSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema PrometheusSpecContainers#lifecycle
   */
  readonly lifecycle?: PrometheusSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainers#livenessProbe
   */
  readonly livenessProbe?: PrometheusSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema PrometheusSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema PrometheusSpecContainers#ports
   */
  readonly ports?: PrometheusSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainers#readinessProbe
   */
  readonly readinessProbe?: PrometheusSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema PrometheusSpecContainers#resizePolicy
   */
  readonly resizePolicy?: PrometheusSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecContainers#resources
   */
  readonly resources?: PrometheusSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is "Always". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as "Always" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy "Always" will be shut down. This lifecycle differs from normal init containers and is often referred to as a "sidecar" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.
   *
   * @schema PrometheusSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema PrometheusSpecContainers#securityContext
   */
  readonly securityContext?: PrometheusSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainers#startupProbe
   */
  readonly startupProbe?: PrometheusSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema PrometheusSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema PrometheusSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema PrometheusSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema PrometheusSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema PrometheusSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema PrometheusSpecContainers#volumeDevices
   */
  readonly volumeDevices?: PrometheusSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema PrometheusSpecContainers#volumeMounts
   */
  readonly volumeMounts?: PrometheusSpecContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema PrometheusSpecContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainers(
  obj: PrometheusSpecContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "args": obj.args?.map((y) => y),
    "command": obj.command?.map((y) => y),
    "env": obj.env?.map((y) => toJson_PrometheusSpecContainersEnv(y)),
    "envFrom": obj.envFrom?.map((y) =>
      toJson_PrometheusSpecContainersEnvFrom(y)
    ),
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "lifecycle": toJson_PrometheusSpecContainersLifecycle(obj.lifecycle),
    "livenessProbe": toJson_PrometheusSpecContainersLivenessProbe(
      obj.livenessProbe,
    ),
    "name": obj.name,
    "ports": obj.ports?.map((y) => toJson_PrometheusSpecContainersPorts(y)),
    "readinessProbe": toJson_PrometheusSpecContainersReadinessProbe(
      obj.readinessProbe,
    ),
    "resizePolicy": obj.resizePolicy?.map((y) =>
      toJson_PrometheusSpecContainersResizePolicy(y)
    ),
    "resources": toJson_PrometheusSpecContainersResources(obj.resources),
    "restartPolicy": obj.restartPolicy,
    "securityContext": toJson_PrometheusSpecContainersSecurityContext(
      obj.securityContext,
    ),
    "startupProbe": toJson_PrometheusSpecContainersStartupProbe(
      obj.startupProbe,
    ),
    "stdin": obj.stdin,
    "stdinOnce": obj.stdinOnce,
    "terminationMessagePath": obj.terminationMessagePath,
    "terminationMessagePolicy": obj.terminationMessagePolicy,
    "tty": obj.tty,
    "volumeDevices": obj.volumeDevices?.map((y) =>
      toJson_PrometheusSpecContainersVolumeDevices(y)
    ),
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_PrometheusSpecContainersVolumeMounts(y)
    ),
    "workingDir": obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectReference references a PodMonitor, ServiceMonitor, Probe or PrometheusRule object.
 *
 * @schema PrometheusSpecExcludedFromEnforcement
 */
export interface PrometheusSpecExcludedFromEnforcement {
  /**
   * Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
   *
   * @schema PrometheusSpecExcludedFromEnforcement#group
   */
  readonly group?: PrometheusSpecExcludedFromEnforcementGroup;

  /**
   * Name of the referent. When not set, all resources in the namespace are matched.
   *
   * @schema PrometheusSpecExcludedFromEnforcement#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema PrometheusSpecExcludedFromEnforcement#namespace
   */
  readonly namespace: string;

  /**
   * Resource of the referent.
   *
   * @schema PrometheusSpecExcludedFromEnforcement#resource
   */
  readonly resource: PrometheusSpecExcludedFromEnforcementResource;
}

/**
 * Converts an object of type 'PrometheusSpecExcludedFromEnforcement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecExcludedFromEnforcement(
  obj: PrometheusSpecExcludedFromEnforcement | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "group": obj.group,
    "name": obj.name,
    "namespace": obj.namespace,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exemplars related settings that are runtime reloadable. It requires to enable the `exemplar-storage` feature flag to be effective.
 *
 * @schema PrometheusSpecExemplars
 */
export interface PrometheusSpecExemplars {
  /**
   * Maximum number of exemplars stored in memory for all series.
   * exemplar-storage itself must be enabled using the `spec.enableFeature` option for exemplars to be scraped in the first place.
   * If not set, Prometheus uses its default value. A value of zero or less than zero disables the storage.
   *
   * @schema PrometheusSpecExemplars#maxSize
   */
  readonly maxSize?: number;
}

/**
 * Converts an object of type 'PrometheusSpecExemplars' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecExemplars(
  obj: PrometheusSpecExemplars | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "maxSize": obj.maxSize,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
 *
 * @schema PrometheusSpecHostAliases
 */
export interface PrometheusSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema PrometheusSpecHostAliases#hostnames
   */
  readonly hostnames: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema PrometheusSpecHostAliases#ip
   */
  readonly ip: string;
}

/**
 * Converts an object of type 'PrometheusSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecHostAliases(
  obj: PrometheusSpecHostAliases | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "hostnames": obj.hostnames?.map((y) => y),
    "ip": obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Image pull policy for the 'prometheus', 'init-config-reloader' and 'config-reloader' containers. See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
 *
 * @schema PrometheusSpecImagePullPolicy
 */
export enum PrometheusSpecImagePullPolicy {
  /** Always */
  ALWAYS = "Always",
  /** Never */
  NEVER = "Never",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PrometheusSpecImagePullSecrets
 */
export interface PrometheusSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecImagePullSecrets(
  obj: PrometheusSpecImagePullSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema PrometheusSpecInitContainers
 */
export interface PrometheusSpecInitContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#env
   */
  readonly env?: PrometheusSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#envFrom
   */
  readonly envFrom?: PrometheusSpecInitContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema PrometheusSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema PrometheusSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#lifecycle
   */
  readonly lifecycle?: PrometheusSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: PrometheusSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#ports
   */
  readonly ports?: PrometheusSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: PrometheusSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema PrometheusSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: PrometheusSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecInitContainers#resources
   */
  readonly resources?: PrometheusSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is "Always". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as "Always" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy "Always" will be shut down. This lifecycle differs from normal init containers and is often referred to as a "sidecar" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.
   *
   * @schema PrometheusSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema PrometheusSpecInitContainers#securityContext
   */
  readonly securityContext?: PrometheusSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainers#startupProbe
   */
  readonly startupProbe?: PrometheusSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema PrometheusSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema PrometheusSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema PrometheusSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema PrometheusSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema PrometheusSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema PrometheusSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: PrometheusSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: PrometheusSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema PrometheusSpecInitContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainers(
  obj: PrometheusSpecInitContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "args": obj.args?.map((y) => y),
    "command": obj.command?.map((y) => y),
    "env": obj.env?.map((y) => toJson_PrometheusSpecInitContainersEnv(y)),
    "envFrom": obj.envFrom?.map((y) =>
      toJson_PrometheusSpecInitContainersEnvFrom(y)
    ),
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "lifecycle": toJson_PrometheusSpecInitContainersLifecycle(obj.lifecycle),
    "livenessProbe": toJson_PrometheusSpecInitContainersLivenessProbe(
      obj.livenessProbe,
    ),
    "name": obj.name,
    "ports": obj.ports?.map((y) => toJson_PrometheusSpecInitContainersPorts(y)),
    "readinessProbe": toJson_PrometheusSpecInitContainersReadinessProbe(
      obj.readinessProbe,
    ),
    "resizePolicy": obj.resizePolicy?.map((y) =>
      toJson_PrometheusSpecInitContainersResizePolicy(y)
    ),
    "resources": toJson_PrometheusSpecInitContainersResources(obj.resources),
    "restartPolicy": obj.restartPolicy,
    "securityContext": toJson_PrometheusSpecInitContainersSecurityContext(
      obj.securityContext,
    ),
    "startupProbe": toJson_PrometheusSpecInitContainersStartupProbe(
      obj.startupProbe,
    ),
    "stdin": obj.stdin,
    "stdinOnce": obj.stdinOnce,
    "terminationMessagePath": obj.terminationMessagePath,
    "terminationMessagePolicy": obj.terminationMessagePolicy,
    "tty": obj.tty,
    "volumeDevices": obj.volumeDevices?.map((y) =>
      toJson_PrometheusSpecInitContainersVolumeDevices(y)
    ),
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_PrometheusSpecInitContainersVolumeMounts(y)
    ),
    "workingDir": obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Log format for Log level for Prometheus and the config-reloader sidecar.
 *
 * @schema PrometheusSpecLogFormat
 */
export enum PrometheusSpecLogFormat {
  /** logfmt */
  LOGFMT = "logfmt",
  /** json */
  JSON = "json",
}

/**
 * Log level for Prometheus and the config-reloader sidecar.
 *
 * @schema PrometheusSpecLogLevel
 */
export enum PrometheusSpecLogLevel {
  /** debug */
  DEBUG = "debug",
  /** info */
  INFO = "info",
  /** warn */
  WARN = "warn",
  /** error */
  ERROR = "error",
}

/**
 * The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet. The default behavior is all PVCs are retained. This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26. It requires enabling the StatefulSetAutoDeletePVC feature gate.
 *
 * @schema PrometheusSpecPersistentVolumeClaimRetentionPolicy
 */
export interface PrometheusSpecPersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.
   *
   * @schema PrometheusSpecPersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.
   *
   * @schema PrometheusSpecPersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;
}

/**
 * Converts an object of type 'PrometheusSpecPersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPersistentVolumeClaimRetentionPolicy(
  obj: PrometheusSpecPersistentVolumeClaimRetentionPolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "whenDeleted": obj.whenDeleted,
    "whenScaled": obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PodMetadata configures labels and annotations which are propagated to the Prometheus pods.
 * The following items are reserved and cannot be overridden: * "prometheus" label, set to the name of the Prometheus object. * "app.kubernetes.io/instance" label, set to the name of the Prometheus object. * "app.kubernetes.io/managed-by" label, set to "prometheus-operator". * "app.kubernetes.io/name" label, set to "prometheus". * "app.kubernetes.io/version" label, set to the Prometheus version. * "operator.prometheus.io/name" label, set to the name of the Prometheus object. * "operator.prometheus.io/shard" label, set to the shard number of the Prometheus object. * "kubectl.kubernetes.io/default-container" annotation, set to "prometheus".
 *
 * @schema PrometheusSpecPodMetadata
 */
export interface PrometheusSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PrometheusSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema PrometheusSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema PrometheusSpecPodMetadata#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPodMetadata(
  obj: PrometheusSpecPodMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "annotations": ((obj.annotations) === undefined)
      ? undefined
      : (Object.entries(obj.annotations).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for PodMonitors discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
 *
 * @schema PrometheusSpecPodMonitorNamespaceSelector
 */
export interface PrometheusSpecPodMonitorNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecPodMonitorNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecPodMonitorNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecPodMonitorNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPodMonitorNamespaceSelector(
  obj: PrometheusSpecPodMonitorNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * *Experimental* PodMonitors to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
 *
 * @schema PrometheusSpecPodMonitorSelector
 */
export interface PrometheusSpecPodMonitorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecPodMonitorSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecPodMonitorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecPodMonitorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecPodMonitorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPodMonitorSelector(
  obj: PrometheusSpecPodMonitorSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecPodMonitorSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * *Experimental* Namespaces to match for Probe discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
 *
 * @schema PrometheusSpecProbeNamespaceSelector
 */
export interface PrometheusSpecProbeNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecProbeNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecProbeNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecProbeNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecProbeNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecProbeNamespaceSelector(
  obj: PrometheusSpecProbeNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecProbeNamespaceSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * *Experimental* Probes to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
 *
 * @schema PrometheusSpecProbeSelector
 */
export interface PrometheusSpecProbeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecProbeSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecProbeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecProbeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecProbeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecProbeSelector(
  obj: PrometheusSpecProbeSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecProbeSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PrometheusRuleExcludeConfig enables users to configure excluded PrometheusRule names and their namespaces to be ignored while enforcing namespace label for alerts and metrics.
 *
 * @schema PrometheusSpecPrometheusRulesExcludedFromEnforce
 */
export interface PrometheusSpecPrometheusRulesExcludedFromEnforce {
  /**
   * Name of the excluded PrometheusRule object.
   *
   * @schema PrometheusSpecPrometheusRulesExcludedFromEnforce#ruleName
   */
  readonly ruleName: string;

  /**
   * Namespace of the excluded PrometheusRule object.
   *
   * @schema PrometheusSpecPrometheusRulesExcludedFromEnforce#ruleNamespace
   */
  readonly ruleNamespace: string;
}

/**
 * Converts an object of type 'PrometheusSpecPrometheusRulesExcludedFromEnforce' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPrometheusRulesExcludedFromEnforce(
  obj: PrometheusSpecPrometheusRulesExcludedFromEnforce | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ruleName": obj.ruleName,
    "ruleNamespace": obj.ruleNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * QuerySpec defines the configuration of the Promethus query service.
 *
 * @schema PrometheusSpecQuery
 */
export interface PrometheusSpecQuery {
  /**
   * The delta difference allowed for retrieving metrics during expression evaluations.
   *
   * @schema PrometheusSpecQuery#lookbackDelta
   */
  readonly lookbackDelta?: string;

  /**
   * Number of concurrent queries that can be run at once.
   *
   * @schema PrometheusSpecQuery#maxConcurrency
   */
  readonly maxConcurrency?: number;

  /**
   * Maximum number of samples a single query can load into memory. Note that queries will fail if they would load more samples than this into memory, so this also limits the number of samples a query can return.
   *
   * @schema PrometheusSpecQuery#maxSamples
   */
  readonly maxSamples?: number;

  /**
   * Maximum time a query may take before being aborted.
   *
   * @schema PrometheusSpecQuery#timeout
   */
  readonly timeout?: string;
}

/**
 * Converts an object of type 'PrometheusSpecQuery' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecQuery(
  obj: PrometheusSpecQuery | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "lookbackDelta": obj.lookbackDelta,
    "maxConcurrency": obj.maxConcurrency,
    "maxSamples": obj.maxSamples,
    "timeout": obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the strategy used to reload the Prometheus configuration. If not specified, the configuration is reloaded using the /-/reload HTTP endpoint.
 *
 * @schema PrometheusSpecReloadStrategy
 */
export enum PrometheusSpecReloadStrategy {
  /** HTTP */
  HTTP = "HTTP",
  /** ProcessSignal */
  PROCESS_SIGNAL = "ProcessSignal",
}

/**
 * RemoteReadSpec defines the configuration for Prometheus to read back samples from a remote endpoint.
 *
 * @schema PrometheusSpecRemoteRead
 */
export interface PrometheusSpecRemoteRead {
  /**
   * Authorization section for the URL.
   * It requires Prometheus >= v2.26.0.
   * Cannot be set at the same time as `basicAuth`, or `oauth2`.
   *
   * @schema PrometheusSpecRemoteRead#authorization
   */
  readonly authorization?: PrometheusSpecRemoteReadAuthorization;

  /**
   * BasicAuth configuration for the URL.
   * Cannot be set at the same time as `authorization`, or `oauth2`.
   *
   * @schema PrometheusSpecRemoteRead#basicAuth
   */
  readonly basicAuth?: PrometheusSpecRemoteReadBasicAuth;

  /**
   * *Warning: this field shouldn't be used because the token value appears in clear-text. Prefer using `authorization`.*
   * Deprecated: this will be removed in a future release.
   *
   * @schema PrometheusSpecRemoteRead#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * File from which to read the bearer token for the URL.
   * Deprecated: this will be removed in a future release. Prefer using `authorization`.
   *
   * @schema PrometheusSpecRemoteRead#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Whether to use the external labels as selectors for the remote read endpoint.
   * It requires Prometheus >= v2.34.0.
   *
   * @schema PrometheusSpecRemoteRead#filterExternalLabels
   */
  readonly filterExternalLabels?: boolean;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   * It requires Prometheus >= v2.26.0.
   *
   * @schema PrometheusSpecRemoteRead#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * Custom HTTP headers to be sent along with each remote read request. Be aware that headers that are set by Prometheus itself can't be overwritten. Only valid in Prometheus versions 2.26.0 and newer.
   *
   * @schema PrometheusSpecRemoteRead#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * The name of the remote read queue, it must be unique if specified. The name is used in metrics and logging in order to differentiate read configurations.
   * It requires Prometheus >= v2.15.0.
   *
   * @schema PrometheusSpecRemoteRead#name
   */
  readonly name?: string;

  /**
   * OAuth2 configuration for the URL.
   * It requires Prometheus >= v2.27.0.
   * Cannot be set at the same time as `authorization`, or `basicAuth`.
   *
   * @schema PrometheusSpecRemoteRead#oauth2
   */
  readonly oauth2?: PrometheusSpecRemoteReadOauth2;

  /**
   * Optional ProxyURL.
   *
   * @schema PrometheusSpecRemoteRead#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * Whether reads should be made for queries for time ranges that the local storage should have complete data for.
   *
   * @schema PrometheusSpecRemoteRead#readRecent
   */
  readonly readRecent?: boolean;

  /**
   * Timeout for requests to the remote read endpoint.
   *
   * @schema PrometheusSpecRemoteRead#remoteTimeout
   */
  readonly remoteTimeout?: string;

  /**
   * An optional list of equality matchers which have to be present in a selector to query the remote read endpoint.
   *
   * @schema PrometheusSpecRemoteRead#requiredMatchers
   */
  readonly requiredMatchers?: { [key: string]: string };

  /**
   * TLS Config to use for the URL.
   *
   * @schema PrometheusSpecRemoteRead#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecRemoteReadTlsConfig;

  /**
   * The URL of the endpoint to query from.
   *
   * @schema PrometheusSpecRemoteRead#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteRead' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteRead(
  obj: PrometheusSpecRemoteRead | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization": toJson_PrometheusSpecRemoteReadAuthorization(
      obj.authorization,
    ),
    "basicAuth": toJson_PrometheusSpecRemoteReadBasicAuth(obj.basicAuth),
    "bearerToken": obj.bearerToken,
    "bearerTokenFile": obj.bearerTokenFile,
    "filterExternalLabels": obj.filterExternalLabels,
    "followRedirects": obj.followRedirects,
    "headers": ((obj.headers) === undefined)
      ? undefined
      : (Object.entries(obj.headers).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "name": obj.name,
    "oauth2": toJson_PrometheusSpecRemoteReadOauth2(obj.oauth2),
    "proxyUrl": obj.proxyUrl,
    "readRecent": obj.readRecent,
    "remoteTimeout": obj.remoteTimeout,
    "requiredMatchers": ((obj.requiredMatchers) === undefined)
      ? undefined
      : (Object.entries(obj.requiredMatchers).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "tlsConfig": toJson_PrometheusSpecRemoteReadTlsConfig(obj.tlsConfig),
    "url": obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RemoteWriteSpec defines the configuration to write samples from Prometheus to a remote endpoint.
 *
 * @schema PrometheusSpecRemoteWrite
 */
export interface PrometheusSpecRemoteWrite {
  /**
   * Authorization section for the URL.
   * It requires Prometheus >= v2.26.0.
   * Cannot be set at the same time as `sigv4`, `basicAuth`, `oauth2`, or `azureAd`.
   *
   * @schema PrometheusSpecRemoteWrite#authorization
   */
  readonly authorization?: PrometheusSpecRemoteWriteAuthorization;

  /**
   * AzureAD for the URL.
   * It requires Prometheus >= v2.45.0.
   * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `sigv4`.
   *
   * @schema PrometheusSpecRemoteWrite#azureAd
   */
  readonly azureAd?: PrometheusSpecRemoteWriteAzureAd;

  /**
   * BasicAuth configuration for the URL.
   * Cannot be set at the same time as `sigv4`, `authorization`, `oauth2`, or `azureAd`.
   *
   * @schema PrometheusSpecRemoteWrite#basicAuth
   */
  readonly basicAuth?: PrometheusSpecRemoteWriteBasicAuth;

  /**
   * *Warning: this field shouldn't be used because the token value appears in clear-text. Prefer using `authorization`.*
   * Deprecated: this will be removed in a future release.
   *
   * @schema PrometheusSpecRemoteWrite#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * File from which to read bearer token for the URL.
   * Deprecated: this will be removed in a future release. Prefer using `authorization`.
   *
   * @schema PrometheusSpecRemoteWrite#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Whether to enable HTTP2.
   *
   * @schema PrometheusSpecRemoteWrite#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Custom HTTP headers to be sent along with each remote write request. Be aware that headers that are set by Prometheus itself can't be overwritten.
   * It requires Prometheus >= v2.25.0.
   *
   * @schema PrometheusSpecRemoteWrite#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * MetadataConfig configures the sending of series metadata to the remote storage.
   *
   * @schema PrometheusSpecRemoteWrite#metadataConfig
   */
  readonly metadataConfig?: PrometheusSpecRemoteWriteMetadataConfig;

  /**
   * The name of the remote write queue, it must be unique if specified. The name is used in metrics and logging in order to differentiate queues.
   * It requires Prometheus >= v2.15.0.
   *
   * @schema PrometheusSpecRemoteWrite#name
   */
  readonly name?: string;

  /**
   * OAuth2 configuration for the URL.
   * It requires Prometheus >= v2.27.0.
   * Cannot be set at the same time as `sigv4`, `authorization`, `basicAuth`, or `azureAd`.
   *
   * @schema PrometheusSpecRemoteWrite#oauth2
   */
  readonly oauth2?: PrometheusSpecRemoteWriteOauth2;

  /**
   * Optional ProxyURL.
   *
   * @schema PrometheusSpecRemoteWrite#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * QueueConfig allows tuning of the remote write queue parameters.
   *
   * @schema PrometheusSpecRemoteWrite#queueConfig
   */
  readonly queueConfig?: PrometheusSpecRemoteWriteQueueConfig;

  /**
   * Timeout for requests to the remote write endpoint.
   *
   * @schema PrometheusSpecRemoteWrite#remoteTimeout
   */
  readonly remoteTimeout?: string;

  /**
   * Enables sending of exemplars over remote write. Note that exemplar-storage itself must be enabled using the `spec.enableFeature` option for exemplars to be scraped in the first place.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusSpecRemoteWrite#sendExemplars
   */
  readonly sendExemplars?: boolean;

  /**
   * Enables sending of native histograms, also known as sparse histograms over remote write.
   * It requires Prometheus >= v2.40.0.
   *
   * @schema PrometheusSpecRemoteWrite#sendNativeHistograms
   */
  readonly sendNativeHistograms?: boolean;

  /**
   * Sigv4 allows to configures AWS's Signature Verification 4 for the URL.
   * It requires Prometheus >= v2.26.0.
   * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `azureAd`.
   *
   * @schema PrometheusSpecRemoteWrite#sigv4
   */
  readonly sigv4?: PrometheusSpecRemoteWriteSigv4;

  /**
   * TLS Config to use for the URL.
   *
   * @schema PrometheusSpecRemoteWrite#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecRemoteWriteTlsConfig;

  /**
   * The URL of the endpoint to send samples to.
   *
   * @schema PrometheusSpecRemoteWrite#url
   */
  readonly url: string;

  /**
   * The list of remote write relabel configurations.
   *
   * @schema PrometheusSpecRemoteWrite#writeRelabelConfigs
   */
  readonly writeRelabelConfigs?: PrometheusSpecRemoteWriteWriteRelabelConfigs[];
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWrite(
  obj: PrometheusSpecRemoteWrite | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization": toJson_PrometheusSpecRemoteWriteAuthorization(
      obj.authorization,
    ),
    "azureAd": toJson_PrometheusSpecRemoteWriteAzureAd(obj.azureAd),
    "basicAuth": toJson_PrometheusSpecRemoteWriteBasicAuth(obj.basicAuth),
    "bearerToken": obj.bearerToken,
    "bearerTokenFile": obj.bearerTokenFile,
    "enableHTTP2": obj.enableHttp2,
    "headers": ((obj.headers) === undefined)
      ? undefined
      : (Object.entries(obj.headers).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "metadataConfig": toJson_PrometheusSpecRemoteWriteMetadataConfig(
      obj.metadataConfig,
    ),
    "name": obj.name,
    "oauth2": toJson_PrometheusSpecRemoteWriteOauth2(obj.oauth2),
    "proxyUrl": obj.proxyUrl,
    "queueConfig": toJson_PrometheusSpecRemoteWriteQueueConfig(obj.queueConfig),
    "remoteTimeout": obj.remoteTimeout,
    "sendExemplars": obj.sendExemplars,
    "sendNativeHistograms": obj.sendNativeHistograms,
    "sigv4": toJson_PrometheusSpecRemoteWriteSigv4(obj.sigv4),
    "tlsConfig": toJson_PrometheusSpecRemoteWriteTlsConfig(obj.tlsConfig),
    "url": obj.url,
    "writeRelabelConfigs": obj.writeRelabelConfigs?.map((y) =>
      toJson_PrometheusSpecRemoteWriteWriteRelabelConfigs(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the resources requests and limits of the 'prometheus' container.
 *
 * @schema PrometheusSpecResources
 */
export interface PrometheusSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusSpecResources#claims
   */
  readonly claims?: PrometheusSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecResources#limits
   */
  readonly limits?: { [key: string]: PrometheusSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecResources#requests
   */
  readonly requests?: { [key: string]: PrometheusSpecResourcesRequests };
}

/**
 * Converts an object of type 'PrometheusSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecResources(
  obj: PrometheusSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) => toJson_PrometheusSpecResourcesClaims(y)),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for PrometheusRule discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
 *
 * @schema PrometheusSpecRuleNamespaceSelector
 */
export interface PrometheusSpecRuleNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecRuleNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecRuleNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecRuleNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecRuleNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRuleNamespaceSelector(
  obj: PrometheusSpecRuleNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecRuleNamespaceSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PrometheusRule objects to be selected for rule evaluation. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema PrometheusSpecRuleSelector
 */
export interface PrometheusSpecRuleSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecRuleSelector#matchExpressions
   */
  readonly matchExpressions?: PrometheusSpecRuleSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecRuleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecRuleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRuleSelector(
  obj: PrometheusSpecRuleSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecRuleSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the configuration of the Prometheus rules' engine.
 *
 * @schema PrometheusSpecRules
 */
export interface PrometheusSpecRules {
  /**
   * Defines the parameters of the Prometheus rules' engine.
   * Any update to these parameters trigger a restart of the pods.
   *
   * @schema PrometheusSpecRules#alert
   */
  readonly alert?: PrometheusSpecRulesAlert;
}

/**
 * Converts an object of type 'PrometheusSpecRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRules(
  obj: PrometheusSpecRules | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "alert": toJson_PrometheusSpecRulesAlert(obj.alert),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for ScrapeConfig discovery. An empty label selector matches all namespaces. A null label selector matches the current current namespace only.
 *
 * @schema PrometheusSpecScrapeConfigNamespaceSelector
 */
export interface PrometheusSpecScrapeConfigNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecScrapeConfigNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecScrapeConfigNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecScrapeConfigNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeConfigNamespaceSelector(
  obj: PrometheusSpecScrapeConfigNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * *Experimental* ScrapeConfigs to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
 *
 * @schema PrometheusSpecScrapeConfigSelector
 */
export interface PrometheusSpecScrapeConfigSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecScrapeConfigSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecScrapeConfigSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecScrapeConfigSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecScrapeConfigSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeConfigSelector(
  obj: PrometheusSpecScrapeConfigSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecScrapeConfigSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.
 *
 * @schema PrometheusSpecSecurityContext
 */
export interface PrometheusSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PrometheusSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PrometheusSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: PrometheusSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process. If unspecified, no additional groups are added to any container. Note that group memberships defined in the container image for the uid of the container process are still effective, even if they are not included in this list. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecSecurityContext#sysctls
   */
  readonly sysctls?: PrometheusSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PrometheusSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: PrometheusSpecSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'PrometheusSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecSecurityContext(
  obj: PrometheusSpecSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsGroup": obj.fsGroup,
    "fsGroupChangePolicy": obj.fsGroupChangePolicy,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions": toJson_PrometheusSpecSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    "seccompProfile": toJson_PrometheusSpecSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    "supplementalGroups": obj.supplementalGroups?.map((y) => y),
    "sysctls": obj.sysctls?.map((y) =>
      toJson_PrometheusSpecSecurityContextSysctls(y)
    ),
    "windowsOptions": toJson_PrometheusSpecSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for ServicedMonitors discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
 *
 * @schema PrometheusSpecServiceMonitorNamespaceSelector
 */
export interface PrometheusSpecServiceMonitorNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecServiceMonitorNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecServiceMonitorNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecServiceMonitorNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecServiceMonitorNamespaceSelector(
  obj: PrometheusSpecServiceMonitorNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceMonitors to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
 *
 * @schema PrometheusSpecServiceMonitorSelector
 */
export interface PrometheusSpecServiceMonitorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecServiceMonitorSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecServiceMonitorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecServiceMonitorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecServiceMonitorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecServiceMonitorSelector(
  obj: PrometheusSpecServiceMonitorSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecServiceMonitorSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Storage defines the storage used by Prometheus.
 *
 * @schema PrometheusSpecStorage
 */
export interface PrometheusSpecStorage {
  /**
   * Deprecated: subPath usage will be removed in a future release.
   *
   * @schema PrometheusSpecStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the StatefulSet. If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema PrometheusSpecStorage#emptyDir
   */
  readonly emptyDir?: PrometheusSpecStorageEmptyDir;

  /**
   * EphemeralVolumeSource to be used by the StatefulSet. This is a beta field in k8s 1.21 and GA in 1.15. For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
   *
   * @schema PrometheusSpecStorage#ephemeral
   */
  readonly ephemeral?: PrometheusSpecStorageEphemeral;

  /**
   * Defines the PVC spec to be used by the Prometheus StatefulSets. The easiest way to use a volume that cannot be automatically provisioned is to use a label selector alongside manually created PersistentVolumes.
   *
   * @schema PrometheusSpecStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: PrometheusSpecStorageVolumeClaimTemplate;
}

/**
 * Converts an object of type 'PrometheusSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorage(
  obj: PrometheusSpecStorage | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "disableMountSubPath": obj.disableMountSubPath,
    "emptyDir": toJson_PrometheusSpecStorageEmptyDir(obj.emptyDir),
    "ephemeral": toJson_PrometheusSpecStorageEphemeral(obj.ephemeral),
    "volumeClaimTemplate": toJson_PrometheusSpecStorageVolumeClaimTemplate(
      obj.volumeClaimTemplate,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the configuration of the optional Thanos sidecar.
 * This section is experimental, it may change significantly without deprecation notice in any release.
 *
 * @schema PrometheusSpecThanos
 */
export interface PrometheusSpecThanos {
  /**
   * AdditionalArgs allows setting additional arguments for the Thanos container. The arguments are passed as-is to the Thanos container which may cause issues if they are invalid or not supported the given Thanos version. In case of an argument conflict (e.g. an argument which is already set by the operator itself) or when providing an invalid argument, the reconciliation will fail and an error will be logged.
   *
   * @schema PrometheusSpecThanos#additionalArgs
   */
  readonly additionalArgs?: PrometheusSpecThanosAdditionalArgs[];

  /**
   * Deprecated: use 'image' instead.
   *
   * @schema PrometheusSpecThanos#baseImage
   */
  readonly baseImage?: string;

  /**
   * BlockDuration controls the size of TSDB blocks produced by Prometheus. The default value is 2h to match the upstream Prometheus defaults.
   * WARNING: Changing the block duration can impact the performance and efficiency of the entire Prometheus/Thanos stack due to how it interacts with memory and Thanos compactors. It is recommended to keep this value set to a multiple of 120 times your longest scrape or rule interval. For example, 30s * 120 = 1h.
   *
   * @schema PrometheusSpecThanos#blockSize
   */
  readonly blockSize?: string;

  /**
   * How often to retrieve the Prometheus configuration.
   *
   * @schema PrometheusSpecThanos#getConfigInterval
   */
  readonly getConfigInterval?: string;

  /**
   * Maximum time to wait when retrieving the Prometheus configuration.
   *
   * @schema PrometheusSpecThanos#getConfigTimeout
   */
  readonly getConfigTimeout?: string;

  /**
   * When true, the Thanos sidecar listens on the loopback interface instead of the Pod IP's address for the gRPC endpoints.
   * It has no effect if `listenLocal` is true.
   *
   * @schema PrometheusSpecThanos#grpcListenLocal
   */
  readonly grpcListenLocal?: boolean;

  /**
   * Configures the TLS parameters for the gRPC server providing the StoreAPI.
   * Note: Currently only the `caFile`, `certFile`, and `keyFile` fields are supported.
   *
   * @schema PrometheusSpecThanos#grpcServerTlsConfig
   */
  readonly grpcServerTlsConfig?: PrometheusSpecThanosGrpcServerTlsConfig;

  /**
   * When true, the Thanos sidecar listens on the loopback interface instead of the Pod IP's address for the HTTP endpoints.
   * It has no effect if `listenLocal` is true.
   *
   * @schema PrometheusSpecThanos#httpListenLocal
   */
  readonly httpListenLocal?: boolean;

  /**
   * Container image name for Thanos. If specified, it takes precedence over the `spec.thanos.baseImage`, `spec.thanos.tag` and `spec.thanos.sha` fields.
   * Specifying `spec.thanos.version` is still necessary to ensure the Prometheus Operator knows which version of Thanos is being configured.
   * If neither `spec.thanos.image` nor `spec.thanos.baseImage` are defined, the operator will use the latest upstream version of Thanos available at the time when the operator was released.
   *
   * @schema PrometheusSpecThanos#image
   */
  readonly image?: string;

  /**
   * Deprecated: use `grpcListenLocal` and `httpListenLocal` instead.
   *
   * @schema PrometheusSpecThanos#listenLocal
   */
  readonly listenLocal?: boolean;

  /**
   * Log format for the Thanos sidecar.
   *
   * @schema PrometheusSpecThanos#logFormat
   */
  readonly logFormat?: PrometheusSpecThanosLogFormat;

  /**
   * Log level for the Thanos sidecar.
   *
   * @schema PrometheusSpecThanos#logLevel
   */
  readonly logLevel?: PrometheusSpecThanosLogLevel;

  /**
   * Defines the start of time range limit served by the Thanos sidecar's StoreAPI. The field's value should be a constant time in RFC3339 format or a time duration relative to current time, such as -1d or 2h45m. Valid duration units are ms, s, m, h, d, w, y.
   *
   * @schema PrometheusSpecThanos#minTime
   */
  readonly minTime?: string;

  /**
   * Defines the Thanos sidecar's configuration to upload TSDB blocks to object storage.
   * More info: https://thanos.io/tip/thanos/storage.md/
   * objectStorageConfigFile takes precedence over this field.
   *
   * @schema PrometheusSpecThanos#objectStorageConfig
   */
  readonly objectStorageConfig?: PrometheusSpecThanosObjectStorageConfig;

  /**
   * Defines the Thanos sidecar's configuration file to upload TSDB blocks to object storage.
   * More info: https://thanos.io/tip/thanos/storage.md/
   * This field takes precedence over objectStorageConfig.
   *
   * @schema PrometheusSpecThanos#objectStorageConfigFile
   */
  readonly objectStorageConfigFile?: string;

  /**
   * ReadyTimeout is the maximum time that the Thanos sidecar will wait for Prometheus to start.
   *
   * @schema PrometheusSpecThanos#readyTimeout
   */
  readonly readyTimeout?: string;

  /**
   * Defines the resources requests and limits of the Thanos sidecar.
   *
   * @schema PrometheusSpecThanos#resources
   */
  readonly resources?: PrometheusSpecThanosResources;

  /**
   * Deprecated: use 'image' instead.  The image digest can be specified as part of the image name.
   *
   * @schema PrometheusSpecThanos#sha
   */
  readonly sha?: string;

  /**
   * Deprecated: use 'image' instead. The image's tag can be specified as as part of the image name.
   *
   * @schema PrometheusSpecThanos#tag
   */
  readonly tag?: string;

  /**
   * Defines the tracing configuration for the Thanos sidecar.
   * More info: https://thanos.io/tip/thanos/tracing.md/
   * This is an experimental feature, it may change in any upcoming release in a breaking way.
   * tracingConfigFile takes precedence over this field.
   *
   * @schema PrometheusSpecThanos#tracingConfig
   */
  readonly tracingConfig?: PrometheusSpecThanosTracingConfig;

  /**
   * Defines the tracing configuration file for the Thanos sidecar.
   * More info: https://thanos.io/tip/thanos/tracing.md/
   * This is an experimental feature, it may change in any upcoming release in a breaking way.
   * This field takes precedence over tracingConfig.
   *
   * @schema PrometheusSpecThanos#tracingConfigFile
   */
  readonly tracingConfigFile?: string;

  /**
   * Version of Thanos being deployed. The operator uses this information to generate the Prometheus StatefulSet + configuration files.
   * If not specified, the operator assumes the latest upstream release of Thanos available at the time when the version of the operator was released.
   *
   * @schema PrometheusSpecThanos#version
   */
  readonly version?: string;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts for Thanos. VolumeMounts specified will be appended to other VolumeMounts in the 'thanos-sidecar' container.
   *
   * @schema PrometheusSpecThanos#volumeMounts
   */
  readonly volumeMounts?: PrometheusSpecThanosVolumeMounts[];
}

/**
 * Converts an object of type 'PrometheusSpecThanos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanos(
  obj: PrometheusSpecThanos | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "additionalArgs": obj.additionalArgs?.map((y) =>
      toJson_PrometheusSpecThanosAdditionalArgs(y)
    ),
    "baseImage": obj.baseImage,
    "blockSize": obj.blockSize,
    "getConfigInterval": obj.getConfigInterval,
    "getConfigTimeout": obj.getConfigTimeout,
    "grpcListenLocal": obj.grpcListenLocal,
    "grpcServerTlsConfig": toJson_PrometheusSpecThanosGrpcServerTlsConfig(
      obj.grpcServerTlsConfig,
    ),
    "httpListenLocal": obj.httpListenLocal,
    "image": obj.image,
    "listenLocal": obj.listenLocal,
    "logFormat": obj.logFormat,
    "logLevel": obj.logLevel,
    "minTime": obj.minTime,
    "objectStorageConfig": toJson_PrometheusSpecThanosObjectStorageConfig(
      obj.objectStorageConfig,
    ),
    "objectStorageConfigFile": obj.objectStorageConfigFile,
    "readyTimeout": obj.readyTimeout,
    "resources": toJson_PrometheusSpecThanosResources(obj.resources),
    "sha": obj.sha,
    "tag": obj.tag,
    "tracingConfig": toJson_PrometheusSpecThanosTracingConfig(
      obj.tracingConfig,
    ),
    "tracingConfigFile": obj.tracingConfigFile,
    "version": obj.version,
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_PrometheusSpecThanosVolumeMounts(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema PrometheusSpecTolerations
 */
export interface PrometheusSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema PrometheusSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema PrometheusSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema PrometheusSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema PrometheusSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema PrometheusSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'PrometheusSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTolerations(
  obj: PrometheusSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "effect": obj.effect,
    "key": obj.key,
    "operator": obj.operator,
    "tolerationSeconds": obj.tolerationSeconds,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecTopologySpreadConstraints
 */
export interface PrometheusSpecTopologySpreadConstraints {
  /**
   * Defines what Prometheus Operator managed labels should be added to labelSelector on the topologySpreadConstraint.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#additionalLabelSelectors
   */
  readonly additionalLabelSelectors?:
    PrometheusSpecTopologySpreadConstraintsAdditionalLabelSelectors;

  /**
   * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: PrometheusSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels are ANDed with labelSelector to select the group of existing pods over which spreading will be calculated for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector. MatchLabelKeys cannot be set when LabelSelector isn't set. Keys that don't exist in the incoming pod labels will be ignored. A null or empty list means only match against labelSelector.
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema PrometheusSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. The global minimum is the minimum number of matching pods in an eligible domain or zero if the number of eligible domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 2/2/1: In this case, the global minimum is 1. | zone1 | zone2 | zone3 | |  P P  |  P P  |   P   | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.
   * This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema PrometheusSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   * If this value is nil, the behavior is equivalent to the Honor policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.
   * If this value is nil, the behavior is equivalent to the Ignore policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology. And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology. It's a required field.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location, but giving higher precedence to topologies that would help reduce the skew. A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
   *
   * @schema PrometheusSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'PrometheusSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTopologySpreadConstraints(
  obj: PrometheusSpecTopologySpreadConstraints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "additionalLabelSelectors": obj.additionalLabelSelectors,
    "labelSelector":
      toJson_PrometheusSpecTopologySpreadConstraintsLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "maxSkew": obj.maxSkew,
    "minDomains": obj.minDomains,
    "nodeAffinityPolicy": obj.nodeAffinityPolicy,
    "nodeTaintsPolicy": obj.nodeTaintsPolicy,
    "topologyKey": obj.topologyKey,
    "whenUnsatisfiable": obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EXPERIMENTAL: TracingConfig configures tracing in Prometheus. This is an experimental feature, it may change in any upcoming release in a breaking way.
 *
 * @schema PrometheusSpecTracingConfig
 */
export interface PrometheusSpecTracingConfig {
  /**
   * Client used to export the traces. Supported values are `http` or `grpc`.
   *
   * @schema PrometheusSpecTracingConfig#clientType
   */
  readonly clientType?: PrometheusSpecTracingConfigClientType;

  /**
   * Compression key for supported compression types. The only supported value is `gzip`.
   *
   * @schema PrometheusSpecTracingConfig#compression
   */
  readonly compression?: PrometheusSpecTracingConfigCompression;

  /**
   * Endpoint to send the traces to. Should be provided in format <host>:<port>.
   *
   * @schema PrometheusSpecTracingConfig#endpoint
   */
  readonly endpoint: string;

  /**
   * Key-value pairs to be used as headers associated with gRPC or HTTP requests.
   *
   * @schema PrometheusSpecTracingConfig#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * If disabled, the client will use a secure connection.
   *
   * @schema PrometheusSpecTracingConfig#insecure
   */
  readonly insecure?: boolean;

  /**
   * Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
   *
   * @schema PrometheusSpecTracingConfig#samplingFraction
   */
  readonly samplingFraction?: PrometheusSpecTracingConfigSamplingFraction;

  /**
   * Maximum time the exporter will wait for each batch export.
   *
   * @schema PrometheusSpecTracingConfig#timeout
   */
  readonly timeout?: string;

  /**
   * TLS Config to use when sending traces.
   *
   * @schema PrometheusSpecTracingConfig#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecTracingConfigTlsConfig;
}

/**
 * Converts an object of type 'PrometheusSpecTracingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfig(
  obj: PrometheusSpecTracingConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientType": obj.clientType,
    "compression": obj.compression,
    "endpoint": obj.endpoint,
    "headers": ((obj.headers) === undefined)
      ? undefined
      : (Object.entries(obj.headers).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "insecure": obj.insecure,
    "samplingFraction": obj.samplingFraction?.value,
    "timeout": obj.timeout,
    "tlsConfig": toJson_PrometheusSpecTracingConfigTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the runtime reloadable configuration of the timeseries database (TSDB).
 *
 * @schema PrometheusSpecTsdb
 */
export interface PrometheusSpecTsdb {
  /**
   * Configures how old an out-of-order/out-of-bounds sample can be with respect to the TSDB max time.
   * An out-of-order/out-of-bounds sample is ingested into the TSDB as long as the timestamp of the sample is >= (TSDB.MaxTime - outOfOrderTimeWindow).
   * Out of order ingestion is an experimental feature.
   * It requires Prometheus >= v2.39.0.
   *
   * @schema PrometheusSpecTsdb#outOfOrderTimeWindow
   */
  readonly outOfOrderTimeWindow?: string;
}

/**
 * Converts an object of type 'PrometheusSpecTsdb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTsdb(
  obj: PrometheusSpecTsdb | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "outOfOrderTimeWindow": obj.outOfOrderTimeWindow,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PrometheusSpecVolumeMounts
 */
export interface PrometheusSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PrometheusSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PrometheusSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PrometheusSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PrometheusSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema PrometheusSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumeMounts(
  obj: PrometheusSpecVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema PrometheusSpecVolumes
 */
export interface PrometheusSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PrometheusSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: PrometheusSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema PrometheusSpecVolumes#azureDisk
   */
  readonly azureDisk?: PrometheusSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema PrometheusSpecVolumes#azureFile
   */
  readonly azureFile?: PrometheusSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema PrometheusSpecVolumes#cephfs
   */
  readonly cephfs?: PrometheusSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusSpecVolumes#cinder
   */
  readonly cinder?: PrometheusSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema PrometheusSpecVolumes#configMap
   */
  readonly configMap?: PrometheusSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema PrometheusSpecVolumes#csi
   */
  readonly csi?: PrometheusSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema PrometheusSpecVolumes#downwardAPI
   */
  readonly downwardApi?: PrometheusSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusSpecVolumes#emptyDir
   */
  readonly emptyDir?: PrometheusSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema PrometheusSpecVolumes#ephemeral
   */
  readonly ephemeral?: PrometheusSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema PrometheusSpecVolumes#fc
   */
  readonly fc?: PrometheusSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema PrometheusSpecVolumes#flexVolume
   */
  readonly flexVolume?: PrometheusSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema PrometheusSpecVolumes#flocker
   */
  readonly flocker?: PrometheusSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PrometheusSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: PrometheusSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema PrometheusSpecVolumes#gitRepo
   */
  readonly gitRepo?: PrometheusSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema PrometheusSpecVolumes#glusterfs
   */
  readonly glusterfs?: PrometheusSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema PrometheusSpecVolumes#hostPath
   */
  readonly hostPath?: PrometheusSpecVolumesHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema PrometheusSpecVolumes#iscsi
   */
  readonly iscsi?: PrometheusSpecVolumesIscsi;

  /**
   * name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PrometheusSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PrometheusSpecVolumes#nfs
   */
  readonly nfs?: PrometheusSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PrometheusSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: PrometheusSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema PrometheusSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: PrometheusSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema PrometheusSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: PrometheusSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema PrometheusSpecVolumes#projected
   */
  readonly projected?: PrometheusSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema PrometheusSpecVolumes#quobyte
   */
  readonly quobyte?: PrometheusSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema PrometheusSpecVolumes#rbd
   */
  readonly rbd?: PrometheusSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema PrometheusSpecVolumes#scaleIO
   */
  readonly scaleIo?: PrometheusSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema PrometheusSpecVolumes#secret
   */
  readonly secret?: PrometheusSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema PrometheusSpecVolumes#storageos
   */
  readonly storageos?: PrometheusSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema PrometheusSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: PrometheusSpecVolumesVsphereVolume;
}

/**
 * Converts an object of type 'PrometheusSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumes(
  obj: PrometheusSpecVolumes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "awsElasticBlockStore": toJson_PrometheusSpecVolumesAwsElasticBlockStore(
      obj.awsElasticBlockStore,
    ),
    "azureDisk": toJson_PrometheusSpecVolumesAzureDisk(obj.azureDisk),
    "azureFile": toJson_PrometheusSpecVolumesAzureFile(obj.azureFile),
    "cephfs": toJson_PrometheusSpecVolumesCephfs(obj.cephfs),
    "cinder": toJson_PrometheusSpecVolumesCinder(obj.cinder),
    "configMap": toJson_PrometheusSpecVolumesConfigMap(obj.configMap),
    "csi": toJson_PrometheusSpecVolumesCsi(obj.csi),
    "downwardAPI": toJson_PrometheusSpecVolumesDownwardApi(obj.downwardApi),
    "emptyDir": toJson_PrometheusSpecVolumesEmptyDir(obj.emptyDir),
    "ephemeral": toJson_PrometheusSpecVolumesEphemeral(obj.ephemeral),
    "fc": toJson_PrometheusSpecVolumesFc(obj.fc),
    "flexVolume": toJson_PrometheusSpecVolumesFlexVolume(obj.flexVolume),
    "flocker": toJson_PrometheusSpecVolumesFlocker(obj.flocker),
    "gcePersistentDisk": toJson_PrometheusSpecVolumesGcePersistentDisk(
      obj.gcePersistentDisk,
    ),
    "gitRepo": toJson_PrometheusSpecVolumesGitRepo(obj.gitRepo),
    "glusterfs": toJson_PrometheusSpecVolumesGlusterfs(obj.glusterfs),
    "hostPath": toJson_PrometheusSpecVolumesHostPath(obj.hostPath),
    "iscsi": toJson_PrometheusSpecVolumesIscsi(obj.iscsi),
    "name": obj.name,
    "nfs": toJson_PrometheusSpecVolumesNfs(obj.nfs),
    "persistentVolumeClaim": toJson_PrometheusSpecVolumesPersistentVolumeClaim(
      obj.persistentVolumeClaim,
    ),
    "photonPersistentDisk": toJson_PrometheusSpecVolumesPhotonPersistentDisk(
      obj.photonPersistentDisk,
    ),
    "portworxVolume": toJson_PrometheusSpecVolumesPortworxVolume(
      obj.portworxVolume,
    ),
    "projected": toJson_PrometheusSpecVolumesProjected(obj.projected),
    "quobyte": toJson_PrometheusSpecVolumesQuobyte(obj.quobyte),
    "rbd": toJson_PrometheusSpecVolumesRbd(obj.rbd),
    "scaleIO": toJson_PrometheusSpecVolumesScaleIo(obj.scaleIo),
    "secret": toJson_PrometheusSpecVolumesSecret(obj.secret),
    "storageos": toJson_PrometheusSpecVolumesStorageos(obj.storageos),
    "vsphereVolume": toJson_PrometheusSpecVolumesVsphereVolume(
      obj.vsphereVolume,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the configuration of the Prometheus web server.
 *
 * @schema PrometheusSpecWeb
 */
export interface PrometheusSpecWeb {
  /**
   * Defines HTTP parameters for web server.
   *
   * @schema PrometheusSpecWeb#httpConfig
   */
  readonly httpConfig?: PrometheusSpecWebHttpConfig;

  /**
   * Defines the maximum number of simultaneous connections A zero value means that Prometheus doesn't accept any incoming connection.
   *
   * @schema PrometheusSpecWeb#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The prometheus web page title.
   *
   * @schema PrometheusSpecWeb#pageTitle
   */
  readonly pageTitle?: string;

  /**
   * Defines the TLS parameters for HTTPS.
   *
   * @schema PrometheusSpecWeb#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecWebTlsConfig;
}

/**
 * Converts an object of type 'PrometheusSpecWeb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWeb(
  obj: PrometheusSpecWeb | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "httpConfig": toJson_PrometheusSpecWebHttpConfig(obj.httpConfig),
    "maxConnections": obj.maxConnections,
    "pageTitle": obj.pageTitle,
    "tlsConfig": toJson_PrometheusSpecWebTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema PrometheusSpecAffinityNodeAffinity
 */
export interface PrometheusSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema PrometheusSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema PrometheusSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinity(
  obj: PrometheusSpecAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution":
      toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema PrometheusSpecAffinityPodAffinity
 */
export interface PrometheusSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema PrometheusSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PrometheusSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinity(
  obj: PrometheusSpecAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema PrometheusSpecAffinityPodAntiAffinity
 */
export interface PrometheusSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinity(
  obj: PrometheusSpecAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlertmanagerEndpoints defines a selection of a single Endpoints object containing Alertmanager IPs to fire alerts against.
 *
 * @schema PrometheusSpecAlertingAlertmanagers
 */
export interface PrometheusSpecAlertingAlertmanagers {
  /**
   * Version of the Alertmanager API that Prometheus uses to send alerts. It can be "v1" or "v2".
   *
   * @schema PrometheusSpecAlertingAlertmanagers#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Authorization section for Alertmanager.
   * Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `sigv4`.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#authorization
   */
  readonly authorization?: PrometheusSpecAlertingAlertmanagersAuthorization;

  /**
   * BasicAuth configuration for Alertmanager.
   * Cannot be set at the same time as `bearerTokenFile`, `authorization` or `sigv4`.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#basicAuth
   */
  readonly basicAuth?: PrometheusSpecAlertingAlertmanagersBasicAuth;

  /**
   * File to read bearer token for Alertmanager.
   * Cannot be set at the same time as `basicAuth`, `authorization`, or `sigv4`.
   * Deprecated: this will be removed in a future release. Prefer using `authorization`.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Whether to enable HTTP2.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#enableHttp2
   */
  readonly enableHttp2?: boolean;

  /**
   * Name of the Endpoints object in the namespace.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#name
   */
  readonly name: string;

  /**
   * Namespace of the Endpoints object.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#namespace
   */
  readonly namespace: string;

  /**
   * Prefix for the HTTP path alerts are pushed to.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#pathPrefix
   */
  readonly pathPrefix?: string;

  /**
   * Port on which the Alertmanager API is exposed.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#port
   */
  readonly port: PrometheusSpecAlertingAlertmanagersPort;

  /**
   * Scheme to use when firing alerts.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#scheme
   */
  readonly scheme?: string;

  /**
   * Sigv4 allows to configures AWS's Signature Verification 4 for the URL.
   * It requires Prometheus >= v2.48.0.
   * Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `authorization`.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#sigv4
   */
  readonly sigv4?: PrometheusSpecAlertingAlertmanagersSigv4;

  /**
   * Timeout is a per-target Alertmanager timeout when pushing alerts.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#timeout
   */
  readonly timeout?: string;

  /**
   * TLS Config to use for Alertmanager.
   *
   * @schema PrometheusSpecAlertingAlertmanagers#tlsConfig
   */
  readonly tlsConfig?: PrometheusSpecAlertingAlertmanagersTlsConfig;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagers(
  obj: PrometheusSpecAlertingAlertmanagers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "authorization": toJson_PrometheusSpecAlertingAlertmanagersAuthorization(
      obj.authorization,
    ),
    "basicAuth": toJson_PrometheusSpecAlertingAlertmanagersBasicAuth(
      obj.basicAuth,
    ),
    "bearerTokenFile": obj.bearerTokenFile,
    "enableHttp2": obj.enableHttp2,
    "name": obj.name,
    "namespace": obj.namespace,
    "pathPrefix": obj.pathPrefix,
    "port": obj.port?.value,
    "scheme": obj.scheme,
    "sigv4": toJson_PrometheusSpecAlertingAlertmanagersSigv4(obj.sigv4),
    "timeout": obj.timeout,
    "tlsConfig": toJson_PrometheusSpecAlertingAlertmanagersTlsConfig(
      obj.tlsConfig,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for the API server.
 * Cannot be set at the same time as `basicAuth`, `bearerToken`, or `bearerTokenFile`.
 *
 * @schema PrometheusSpecApiserverConfigAuthorization
 */
export interface PrometheusSpecApiserverConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PrometheusSpecApiserverConfigAuthorization#credentials
   */
  readonly credentials?: PrometheusSpecApiserverConfigAuthorizationCredentials;

  /**
   * File to read a secret from, mutually exclusive with `credentials`.
   *
   * @schema PrometheusSpecApiserverConfigAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema PrometheusSpecApiserverConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigAuthorization(
  obj: PrometheusSpecApiserverConfigAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials": toJson_PrometheusSpecApiserverConfigAuthorizationCredentials(
      obj.credentials,
    ),
    "credentialsFile": obj.credentialsFile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth configuration for the API server.
 * Cannot be set at the same time as `authorization`, `bearerToken`, or `bearerTokenFile`.
 *
 * @schema PrometheusSpecApiserverConfigBasicAuth
 */
export interface PrometheusSpecApiserverConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema PrometheusSpecApiserverConfigBasicAuth#password
   */
  readonly password?: PrometheusSpecApiserverConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema PrometheusSpecApiserverConfigBasicAuth#username
   */
  readonly username?: PrometheusSpecApiserverConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigBasicAuth(
  obj: PrometheusSpecApiserverConfigBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_PrometheusSpecApiserverConfigBasicAuthPassword(
      obj.password,
    ),
    "username": toJson_PrometheusSpecApiserverConfigBasicAuthUsername(
      obj.username,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS Config to use for the API server.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfig
 */
export interface PrometheusSpecApiserverConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#ca
   */
  readonly ca?: PrometheusSpecApiserverConfigTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#cert
   */
  readonly cert?: PrometheusSpecApiserverConfigTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecApiserverConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfig(
  obj: PrometheusSpecApiserverConfigTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_PrometheusSpecApiserverConfigTlsConfigCa(obj.ca),
    "caFile": obj.caFile,
    "cert": toJson_PrometheusSpecApiserverConfigTlsConfigCert(obj.cert),
    "certFile": obj.certFile,
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keyFile": obj.keyFile,
    "keySecret": toJson_PrometheusSpecApiserverConfigTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PrometheusSpecContainersEnv
 */
export interface PrometheusSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PrometheusSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema PrometheusSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: PrometheusSpecContainersEnvValueFrom;
}

/**
 * Converts an object of type 'PrometheusSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnv(
  obj: PrometheusSpecContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
    "valueFrom": toJson_PrometheusSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PrometheusSpecContainersEnvFrom
 */
export interface PrometheusSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema PrometheusSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: PrometheusSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema PrometheusSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: PrometheusSpecContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvFrom(
  obj: PrometheusSpecContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapRef": toJson_PrometheusSpecContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    "prefix": obj.prefix,
    "secretRef": toJson_PrometheusSpecContainersEnvFromSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema PrometheusSpecContainersLifecycle
 */
export interface PrometheusSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusSpecContainersLifecycle#postStart
   */
  readonly postStart?: PrometheusSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusSpecContainersLifecycle#preStop
   */
  readonly preStop?: PrometheusSpecContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecycle(
  obj: PrometheusSpecContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "postStart": toJson_PrometheusSpecContainersLifecyclePostStart(
      obj.postStart,
    ),
    "preStop": toJson_PrometheusSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecContainersLivenessProbe
 */
export interface PrometheusSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecContainersLivenessProbe#exec
   */
  readonly exec?: PrometheusSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: PrometheusSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbe(
  obj: PrometheusSpecContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusSpecContainersLivenessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusSpecContainersLivenessProbeGrpc(obj.grpc),
    "httpGet": toJson_PrometheusSpecContainersLivenessProbeHttpGet(obj.httpGet),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_PrometheusSpecContainersLivenessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema PrometheusSpecContainersPorts
 */
export interface PrometheusSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema PrometheusSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema PrometheusSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema PrometheusSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema PrometheusSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema PrometheusSpecContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersPorts(
  obj: PrometheusSpecContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerPort": obj.containerPort,
    "hostIP": obj.hostIp,
    "hostPort": obj.hostPort,
    "name": obj.name,
    "protocol": obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecContainersReadinessProbe
 */
export interface PrometheusSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecContainersReadinessProbe#exec
   */
  readonly exec?: PrometheusSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: PrometheusSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbe(
  obj: PrometheusSpecContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusSpecContainersReadinessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusSpecContainersReadinessProbeGrpc(obj.grpc),
    "httpGet": toJson_PrometheusSpecContainersReadinessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_PrometheusSpecContainersReadinessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema PrometheusSpecContainersResizePolicy
 */
export interface PrometheusSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies. Supported values: cpu, memory.
   *
   * @schema PrometheusSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized. If not specified, it defaults to NotRequired.
   *
   * @schema PrometheusSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersResizePolicy(
  obj: PrometheusSpecContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "resourceName": obj.resourceName,
    "restartPolicy": obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema PrometheusSpecContainersResources
 */
export interface PrometheusSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusSpecContainersResources#claims
   */
  readonly claims?: PrometheusSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: PrometheusSpecContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecContainersResources#requests
   */
  readonly requests?: {
    [key: string]: PrometheusSpecContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'PrometheusSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersResources(
  obj: PrometheusSpecContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusSpecContainersResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema PrometheusSpecContainersSecurityContext
 */
export interface PrometheusSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: PrometheusSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PrometheusSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    PrometheusSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    PrometheusSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PrometheusSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    PrometheusSpecContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'PrometheusSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersSecurityContext(
  obj: PrometheusSpecContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "allowPrivilegeEscalation": obj.allowPrivilegeEscalation,
    "capabilities": toJson_PrometheusSpecContainersSecurityContextCapabilities(
      obj.capabilities,
    ),
    "privileged": obj.privileged,
    "procMount": obj.procMount,
    "readOnlyRootFilesystem": obj.readOnlyRootFilesystem,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_PrometheusSpecContainersSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_PrometheusSpecContainersSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "windowsOptions":
      toJson_PrometheusSpecContainersSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecContainersStartupProbe
 */
export interface PrometheusSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecContainersStartupProbe#exec
   */
  readonly exec?: PrometheusSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecContainersStartupProbe#grpc
   */
  readonly grpc?: PrometheusSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbe(
  obj: PrometheusSpecContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusSpecContainersStartupProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusSpecContainersStartupProbeGrpc(obj.grpc),
    "httpGet": toJson_PrometheusSpecContainersStartupProbeHttpGet(obj.httpGet),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_PrometheusSpecContainersStartupProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema PrometheusSpecContainersVolumeDevices
 */
export interface PrometheusSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema PrometheusSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema PrometheusSpecContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersVolumeDevices(
  obj: PrometheusSpecContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "devicePath": obj.devicePath,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PrometheusSpecContainersVolumeMounts
 */
export interface PrometheusSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PrometheusSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PrometheusSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PrometheusSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PrometheusSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema PrometheusSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersVolumeMounts(
  obj: PrometheusSpecContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
 *
 * @schema PrometheusSpecExcludedFromEnforcementGroup
 */
export enum PrometheusSpecExcludedFromEnforcementGroup {
  /** monitoring.coreos.com */
  MONITORING_PERIOD_COREOS_PERIOD_COM = "monitoring.coreos.com",
}

/**
 * Resource of the referent.
 *
 * @schema PrometheusSpecExcludedFromEnforcementResource
 */
export enum PrometheusSpecExcludedFromEnforcementResource {
  /** prometheusrules */
  PROMETHEUSRULES = "prometheusrules",
  /** servicemonitors */
  SERVICEMONITORS = "servicemonitors",
  /** podmonitors */
  PODMONITORS = "podmonitors",
  /** probes */
  PROBES = "probes",
  /** scrapeconfigs */
  SCRAPECONFIGS = "scrapeconfigs",
}

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PrometheusSpecInitContainersEnv
 */
export interface PrometheusSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PrometheusSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema PrometheusSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: PrometheusSpecInitContainersEnvValueFrom;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnv(
  obj: PrometheusSpecInitContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
    "valueFrom": toJson_PrometheusSpecInitContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PrometheusSpecInitContainersEnvFrom
 */
export interface PrometheusSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema PrometheusSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: PrometheusSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema PrometheusSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: PrometheusSpecInitContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvFrom(
  obj: PrometheusSpecInitContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapRef": toJson_PrometheusSpecInitContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    "prefix": obj.prefix,
    "secretRef": toJson_PrometheusSpecInitContainersEnvFromSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema PrometheusSpecInitContainersLifecycle
 */
export interface PrometheusSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: PrometheusSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: PrometheusSpecInitContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecycle(
  obj: PrometheusSpecInitContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "postStart": toJson_PrometheusSpecInitContainersLifecyclePostStart(
      obj.postStart,
    ),
    "preStop": toJson_PrometheusSpecInitContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecInitContainersLivenessProbe
 */
export interface PrometheusSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: PrometheusSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: PrometheusSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbe(
  obj: PrometheusSpecInitContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusSpecInitContainersLivenessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusSpecInitContainersLivenessProbeGrpc(obj.grpc),
    "httpGet": toJson_PrometheusSpecInitContainersLivenessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_PrometheusSpecInitContainersLivenessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema PrometheusSpecInitContainersPorts
 */
export interface PrometheusSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema PrometheusSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema PrometheusSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema PrometheusSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema PrometheusSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema PrometheusSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersPorts(
  obj: PrometheusSpecInitContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerPort": obj.containerPort,
    "hostIP": obj.hostIp,
    "hostPort": obj.hostPort,
    "name": obj.name,
    "protocol": obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecInitContainersReadinessProbe
 */
export interface PrometheusSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: PrometheusSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: PrometheusSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbe(
  obj: PrometheusSpecInitContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusSpecInitContainersReadinessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusSpecInitContainersReadinessProbeGrpc(obj.grpc),
    "httpGet": toJson_PrometheusSpecInitContainersReadinessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_PrometheusSpecInitContainersReadinessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema PrometheusSpecInitContainersResizePolicy
 */
export interface PrometheusSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies. Supported values: cpu, memory.
   *
   * @schema PrometheusSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized. If not specified, it defaults to NotRequired.
   *
   * @schema PrometheusSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersResizePolicy(
  obj: PrometheusSpecInitContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "resourceName": obj.resourceName,
    "restartPolicy": obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema PrometheusSpecInitContainersResources
 */
export interface PrometheusSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusSpecInitContainersResources#claims
   */
  readonly claims?: PrometheusSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecInitContainersResources#limits
   */
  readonly limits?: {
    [key: string]: PrometheusSpecInitContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecInitContainersResources#requests
   */
  readonly requests?: {
    [key: string]: PrometheusSpecInitContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersResources(
  obj: PrometheusSpecInitContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusSpecInitContainersResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema PrometheusSpecInitContainersSecurityContext
 */
export interface PrometheusSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?:
    PrometheusSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    PrometheusSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    PrometheusSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PrometheusSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    PrometheusSpecInitContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersSecurityContext(
  obj: PrometheusSpecInitContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "allowPrivilegeEscalation": obj.allowPrivilegeEscalation,
    "capabilities":
      toJson_PrometheusSpecInitContainersSecurityContextCapabilities(
        obj.capabilities,
      ),
    "privileged": obj.privileged,
    "procMount": obj.procMount,
    "readOnlyRootFilesystem": obj.readOnlyRootFilesystem,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_PrometheusSpecInitContainersSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_PrometheusSpecInitContainersSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "windowsOptions":
      toJson_PrometheusSpecInitContainersSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusSpecInitContainersStartupProbe
 */
export interface PrometheusSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecInitContainersStartupProbe#exec
   */
  readonly exec?: PrometheusSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: PrometheusSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: PrometheusSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbe(
  obj: PrometheusSpecInitContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusSpecInitContainersStartupProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusSpecInitContainersStartupProbeGrpc(obj.grpc),
    "httpGet": toJson_PrometheusSpecInitContainersStartupProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_PrometheusSpecInitContainersStartupProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema PrometheusSpecInitContainersVolumeDevices
 */
export interface PrometheusSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema PrometheusSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema PrometheusSpecInitContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersVolumeDevices(
  obj: PrometheusSpecInitContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "devicePath": obj.devicePath,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PrometheusSpecInitContainersVolumeMounts
 */
export interface PrometheusSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PrometheusSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PrometheusSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PrometheusSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PrometheusSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema PrometheusSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersVolumeMounts(
  obj: PrometheusSpecInitContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions(
  obj: PrometheusSpecPodMonitorNamespaceSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecPodMonitorSelectorMatchExpressions
 */
export interface PrometheusSpecPodMonitorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecPodMonitorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecPodMonitorSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecPodMonitorSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecPodMonitorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecPodMonitorSelectorMatchExpressions(
  obj: PrometheusSpecPodMonitorSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecProbeNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecProbeNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecProbeNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecProbeNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecProbeNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecProbeNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecProbeNamespaceSelectorMatchExpressions(
  obj: PrometheusSpecProbeNamespaceSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecProbeSelectorMatchExpressions
 */
export interface PrometheusSpecProbeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecProbeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecProbeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecProbeSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecProbeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecProbeSelectorMatchExpressions(
  obj: PrometheusSpecProbeSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for the URL.
 * It requires Prometheus >= v2.26.0.
 * Cannot be set at the same time as `basicAuth`, or `oauth2`.
 *
 * @schema PrometheusSpecRemoteReadAuthorization
 */
export interface PrometheusSpecRemoteReadAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PrometheusSpecRemoteReadAuthorization#credentials
   */
  readonly credentials?: PrometheusSpecRemoteReadAuthorizationCredentials;

  /**
   * File to read a secret from, mutually exclusive with `credentials`.
   *
   * @schema PrometheusSpecRemoteReadAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema PrometheusSpecRemoteReadAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadAuthorization(
  obj: PrometheusSpecRemoteReadAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials": toJson_PrometheusSpecRemoteReadAuthorizationCredentials(
      obj.credentials,
    ),
    "credentialsFile": obj.credentialsFile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth configuration for the URL.
 * Cannot be set at the same time as `authorization`, or `oauth2`.
 *
 * @schema PrometheusSpecRemoteReadBasicAuth
 */
export interface PrometheusSpecRemoteReadBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema PrometheusSpecRemoteReadBasicAuth#password
   */
  readonly password?: PrometheusSpecRemoteReadBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema PrometheusSpecRemoteReadBasicAuth#username
   */
  readonly username?: PrometheusSpecRemoteReadBasicAuthUsername;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadBasicAuth(
  obj: PrometheusSpecRemoteReadBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_PrometheusSpecRemoteReadBasicAuthPassword(obj.password),
    "username": toJson_PrometheusSpecRemoteReadBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 configuration for the URL.
 * It requires Prometheus >= v2.27.0.
 * Cannot be set at the same time as `authorization`, or `basicAuth`.
 *
 * @schema PrometheusSpecRemoteReadOauth2
 */
export interface PrometheusSpecRemoteReadOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema PrometheusSpecRemoteReadOauth2#clientId
   */
  readonly clientId: PrometheusSpecRemoteReadOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema PrometheusSpecRemoteReadOauth2#clientSecret
   */
  readonly clientSecret: PrometheusSpecRemoteReadOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema PrometheusSpecRemoteReadOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema PrometheusSpecRemoteReadOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema PrometheusSpecRemoteReadOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadOauth2(
  obj: PrometheusSpecRemoteReadOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": toJson_PrometheusSpecRemoteReadOauth2ClientId(obj.clientId),
    "clientSecret": toJson_PrometheusSpecRemoteReadOauth2ClientSecret(
      obj.clientSecret,
    ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS Config to use for the URL.
 *
 * @schema PrometheusSpecRemoteReadTlsConfig
 */
export interface PrometheusSpecRemoteReadTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#ca
   */
  readonly ca?: PrometheusSpecRemoteReadTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#cert
   */
  readonly cert?: PrometheusSpecRemoteReadTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecRemoteReadTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfig(
  obj: PrometheusSpecRemoteReadTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_PrometheusSpecRemoteReadTlsConfigCa(obj.ca),
    "caFile": obj.caFile,
    "cert": toJson_PrometheusSpecRemoteReadTlsConfigCert(obj.cert),
    "certFile": obj.certFile,
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keyFile": obj.keyFile,
    "keySecret": toJson_PrometheusSpecRemoteReadTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for the URL.
 * It requires Prometheus >= v2.26.0.
 * Cannot be set at the same time as `sigv4`, `basicAuth`, `oauth2`, or `azureAd`.
 *
 * @schema PrometheusSpecRemoteWriteAuthorization
 */
export interface PrometheusSpecRemoteWriteAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PrometheusSpecRemoteWriteAuthorization#credentials
   */
  readonly credentials?: PrometheusSpecRemoteWriteAuthorizationCredentials;

  /**
   * File to read a secret from, mutually exclusive with `credentials`.
   *
   * @schema PrometheusSpecRemoteWriteAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema PrometheusSpecRemoteWriteAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAuthorization(
  obj: PrometheusSpecRemoteWriteAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials": toJson_PrometheusSpecRemoteWriteAuthorizationCredentials(
      obj.credentials,
    ),
    "credentialsFile": obj.credentialsFile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AzureAD for the URL.
 * It requires Prometheus >= v2.45.0.
 * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `sigv4`.
 *
 * @schema PrometheusSpecRemoteWriteAzureAd
 */
export interface PrometheusSpecRemoteWriteAzureAd {
  /**
   * The Azure Cloud. Options are 'AzurePublic', 'AzureChina', or 'AzureGovernment'.
   *
   * @schema PrometheusSpecRemoteWriteAzureAd#cloud
   */
  readonly cloud?: PrometheusSpecRemoteWriteAzureAdCloud;

  /**
   * ManagedIdentity defines the Azure User-assigned Managed identity. Cannot be set at the same time as `oauth`.
   *
   * @schema PrometheusSpecRemoteWriteAzureAd#managedIdentity
   */
  readonly managedIdentity?: PrometheusSpecRemoteWriteAzureAdManagedIdentity;

  /**
   * OAuth defines the oauth config that is being used to authenticate. Cannot be set at the same time as `managedIdentity`.
   * It requires Prometheus >= v2.48.0.
   *
   * @schema PrometheusSpecRemoteWriteAzureAd#oauth
   */
  readonly oauth?: PrometheusSpecRemoteWriteAzureAdOauth;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAzureAd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAzureAd(
  obj: PrometheusSpecRemoteWriteAzureAd | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "cloud": obj.cloud,
    "managedIdentity": toJson_PrometheusSpecRemoteWriteAzureAdManagedIdentity(
      obj.managedIdentity,
    ),
    "oauth": toJson_PrometheusSpecRemoteWriteAzureAdOauth(obj.oauth),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth configuration for the URL.
 * Cannot be set at the same time as `sigv4`, `authorization`, `oauth2`, or `azureAd`.
 *
 * @schema PrometheusSpecRemoteWriteBasicAuth
 */
export interface PrometheusSpecRemoteWriteBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema PrometheusSpecRemoteWriteBasicAuth#password
   */
  readonly password?: PrometheusSpecRemoteWriteBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema PrometheusSpecRemoteWriteBasicAuth#username
   */
  readonly username?: PrometheusSpecRemoteWriteBasicAuthUsername;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteBasicAuth(
  obj: PrometheusSpecRemoteWriteBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_PrometheusSpecRemoteWriteBasicAuthPassword(obj.password),
    "username": toJson_PrometheusSpecRemoteWriteBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MetadataConfig configures the sending of series metadata to the remote storage.
 *
 * @schema PrometheusSpecRemoteWriteMetadataConfig
 */
export interface PrometheusSpecRemoteWriteMetadataConfig {
  /**
   * Defines whether metric metadata is sent to the remote storage or not.
   *
   * @schema PrometheusSpecRemoteWriteMetadataConfig#send
   */
  readonly send?: boolean;

  /**
   * Defines how frequently metric metadata is sent to the remote storage.
   *
   * @schema PrometheusSpecRemoteWriteMetadataConfig#sendInterval
   */
  readonly sendInterval?: string;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteMetadataConfig(
  obj: PrometheusSpecRemoteWriteMetadataConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "send": obj.send,
    "sendInterval": obj.sendInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 configuration for the URL.
 * It requires Prometheus >= v2.27.0.
 * Cannot be set at the same time as `sigv4`, `authorization`, `basicAuth`, or `azureAd`.
 *
 * @schema PrometheusSpecRemoteWriteOauth2
 */
export interface PrometheusSpecRemoteWriteOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema PrometheusSpecRemoteWriteOauth2#clientId
   */
  readonly clientId: PrometheusSpecRemoteWriteOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema PrometheusSpecRemoteWriteOauth2#clientSecret
   */
  readonly clientSecret: PrometheusSpecRemoteWriteOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema PrometheusSpecRemoteWriteOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema PrometheusSpecRemoteWriteOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema PrometheusSpecRemoteWriteOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteOauth2(
  obj: PrometheusSpecRemoteWriteOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": toJson_PrometheusSpecRemoteWriteOauth2ClientId(obj.clientId),
    "clientSecret": toJson_PrometheusSpecRemoteWriteOauth2ClientSecret(
      obj.clientSecret,
    ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * QueueConfig allows tuning of the remote write queue parameters.
 *
 * @schema PrometheusSpecRemoteWriteQueueConfig
 */
export interface PrometheusSpecRemoteWriteQueueConfig {
  /**
   * BatchSendDeadline is the maximum time a sample will wait in buffer.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#batchSendDeadline
   */
  readonly batchSendDeadline?: string;

  /**
   * Capacity is the number of samples to buffer per shard before we start dropping them.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#capacity
   */
  readonly capacity?: number;

  /**
   * MaxBackoff is the maximum retry delay.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#maxBackoff
   */
  readonly maxBackoff?: string;

  /**
   * MaxRetries is the maximum number of times to retry a batch on recoverable errors.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * MaxSamplesPerSend is the maximum number of samples per send.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#maxSamplesPerSend
   */
  readonly maxSamplesPerSend?: number;

  /**
   * MaxShards is the maximum number of shards, i.e. amount of concurrency.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#maxShards
   */
  readonly maxShards?: number;

  /**
   * MinBackoff is the initial retry delay. Gets doubled for every retry.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#minBackoff
   */
  readonly minBackoff?: string;

  /**
   * MinShards is the minimum number of shards, i.e. amount of concurrency.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#minShards
   */
  readonly minShards?: number;

  /**
   * Retry upon receiving a 429 status code from the remote-write storage. This is experimental feature and might change in the future.
   *
   * @schema PrometheusSpecRemoteWriteQueueConfig#retryOnRateLimit
   */
  readonly retryOnRateLimit?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteQueueConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteQueueConfig(
  obj: PrometheusSpecRemoteWriteQueueConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "batchSendDeadline": obj.batchSendDeadline,
    "capacity": obj.capacity,
    "maxBackoff": obj.maxBackoff,
    "maxRetries": obj.maxRetries,
    "maxSamplesPerSend": obj.maxSamplesPerSend,
    "maxShards": obj.maxShards,
    "minBackoff": obj.minBackoff,
    "minShards": obj.minShards,
    "retryOnRateLimit": obj.retryOnRateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sigv4 allows to configures AWS's Signature Verification 4 for the URL.
 * It requires Prometheus >= v2.26.0.
 * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `azureAd`.
 *
 * @schema PrometheusSpecRemoteWriteSigv4
 */
export interface PrometheusSpecRemoteWriteSigv4 {
  /**
   * AccessKey is the AWS API key. If not specified, the environment variable `AWS_ACCESS_KEY_ID` is used.
   *
   * @schema PrometheusSpecRemoteWriteSigv4#accessKey
   */
  readonly accessKey?: PrometheusSpecRemoteWriteSigv4AccessKey;

  /**
   * Profile is the named AWS profile used to authenticate.
   *
   * @schema PrometheusSpecRemoteWriteSigv4#profile
   */
  readonly profile?: string;

  /**
   * Region is the AWS region. If blank, the region from the default credentials chain used.
   *
   * @schema PrometheusSpecRemoteWriteSigv4#region
   */
  readonly region?: string;

  /**
   * RoleArn is the named AWS profile used to authenticate.
   *
   * @schema PrometheusSpecRemoteWriteSigv4#roleArn
   */
  readonly roleArn?: string;

  /**
   * SecretKey is the AWS API secret. If not specified, the environment variable `AWS_SECRET_ACCESS_KEY` is used.
   *
   * @schema PrometheusSpecRemoteWriteSigv4#secretKey
   */
  readonly secretKey?: PrometheusSpecRemoteWriteSigv4SecretKey;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteSigv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteSigv4(
  obj: PrometheusSpecRemoteWriteSigv4 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessKey": toJson_PrometheusSpecRemoteWriteSigv4AccessKey(obj.accessKey),
    "profile": obj.profile,
    "region": obj.region,
    "roleArn": obj.roleArn,
    "secretKey": toJson_PrometheusSpecRemoteWriteSigv4SecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS Config to use for the URL.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfig
 */
export interface PrometheusSpecRemoteWriteTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#ca
   */
  readonly ca?: PrometheusSpecRemoteWriteTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#cert
   */
  readonly cert?: PrometheusSpecRemoteWriteTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecRemoteWriteTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfig(
  obj: PrometheusSpecRemoteWriteTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_PrometheusSpecRemoteWriteTlsConfigCa(obj.ca),
    "caFile": obj.caFile,
    "cert": toJson_PrometheusSpecRemoteWriteTlsConfigCert(obj.cert),
    "certFile": obj.certFile,
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keyFile": obj.keyFile,
    "keySecret": toJson_PrometheusSpecRemoteWriteTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs
 */
export interface PrometheusSpecRemoteWriteWriteRelabelConfigs {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#action
   */
  readonly action?: PrometheusSpecRemoteWriteWriteRelabelConfigsAction;

  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the regular expression matches.
   * Regex capture groups are available.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions.
   * Regex capture groups are available.
   *
   * @schema PrometheusSpecRemoteWriteWriteRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteWriteRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteWriteRelabelConfigs(
  obj: PrometheusSpecRemoteWriteWriteRelabelConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "action": obj.action,
    "modulus": obj.modulus,
    "regex": obj.regex,
    "replacement": obj.replacement,
    "separator": obj.separator,
    "sourceLabels": obj.sourceLabels?.map((y) => y),
    "targetLabel": obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusSpecResourcesClaims
 */
export interface PrometheusSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecResourcesClaims(
  obj: PrometheusSpecResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecResourcesLimits
 */
export class PrometheusSpecResourcesLimits {
  public static fromNumber(value: number): PrometheusSpecResourcesLimits {
    return new PrometheusSpecResourcesLimits(value);
  }
  public static fromString(value: string): PrometheusSpecResourcesLimits {
    return new PrometheusSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecResourcesRequests
 */
export class PrometheusSpecResourcesRequests {
  public static fromNumber(value: number): PrometheusSpecResourcesRequests {
    return new PrometheusSpecResourcesRequests(value);
  }
  public static fromString(value: string): PrometheusSpecResourcesRequests {
    return new PrometheusSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecRuleNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecRuleNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecRuleNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecRuleNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecRuleNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecRuleNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRuleNamespaceSelectorMatchExpressions(
  obj: PrometheusSpecRuleNamespaceSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecRuleSelectorMatchExpressions
 */
export interface PrometheusSpecRuleSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecRuleSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecRuleSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecRuleSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecRuleSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRuleSelectorMatchExpressions(
  obj: PrometheusSpecRuleSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the parameters of the Prometheus rules' engine.
 * Any update to these parameters trigger a restart of the pods.
 *
 * @schema PrometheusSpecRulesAlert
 */
export interface PrometheusSpecRulesAlert {
  /**
   * Minimum duration between alert and restored 'for' state.
   * This is maintained only for alerts with a configured 'for' time greater than the grace period.
   *
   * @schema PrometheusSpecRulesAlert#forGracePeriod
   */
  readonly forGracePeriod?: string;

  /**
   * Max time to tolerate prometheus outage for restoring 'for' state of alert.
   *
   * @schema PrometheusSpecRulesAlert#forOutageTolerance
   */
  readonly forOutageTolerance?: string;

  /**
   * Minimum amount of time to wait before resending an alert to Alertmanager.
   *
   * @schema PrometheusSpecRulesAlert#resendDelay
   */
  readonly resendDelay?: string;
}

/**
 * Converts an object of type 'PrometheusSpecRulesAlert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRulesAlert(
  obj: PrometheusSpecRulesAlert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "forGracePeriod": obj.forGracePeriod,
    "forOutageTolerance": obj.forOutageTolerance,
    "resendDelay": obj.resendDelay,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions(
  obj: PrometheusSpecScrapeConfigNamespaceSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecScrapeConfigSelectorMatchExpressions
 */
export interface PrometheusSpecScrapeConfigSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecScrapeConfigSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecScrapeConfigSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecScrapeConfigSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecScrapeConfigSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecScrapeConfigSelectorMatchExpressions(
  obj: PrometheusSpecScrapeConfigSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecSecurityContextSeLinuxOptions
 */
export interface PrometheusSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PrometheusSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PrometheusSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PrometheusSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PrometheusSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'PrometheusSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecSecurityContextSeLinuxOptions(
  obj: PrometheusSpecSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecSecurityContextSeccompProfile
 */
export interface PrometheusSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema PrometheusSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema PrometheusSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'PrometheusSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecSecurityContextSeccompProfile(
  obj: PrometheusSpecSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema PrometheusSpecSecurityContextSysctls
 */
export interface PrometheusSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema PrometheusSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema PrometheusSpecSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecSecurityContextSysctls(
  obj: PrometheusSpecSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PrometheusSpecSecurityContextWindowsOptions
 */
export interface PrometheusSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PrometheusSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PrometheusSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PrometheusSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PrometheusSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecSecurityContextWindowsOptions(
  obj: PrometheusSpecSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusSpecServiceMonitorNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecServiceMonitorSelectorMatchExpressions
 */
export interface PrometheusSpecServiceMonitorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecServiceMonitorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecServiceMonitorSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecServiceMonitorSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecServiceMonitorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecServiceMonitorSelectorMatchExpressions(
  obj: PrometheusSpecServiceMonitorSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDirVolumeSource to be used by the StatefulSet. If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema PrometheusSpecStorageEmptyDir
 */
export interface PrometheusSpecStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusSpecStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusSpecStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: PrometheusSpecStorageEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'PrometheusSpecStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEmptyDir(
  obj: PrometheusSpecStorageEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "medium": obj.medium,
    "sizeLimit": obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EphemeralVolumeSource to be used by the StatefulSet. This is a beta field in k8s 1.21 and GA in 1.15. For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
 *
 * @schema PrometheusSpecStorageEphemeral
 */
export interface PrometheusSpecStorageEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema PrometheusSpecStorageEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?:
    PrometheusSpecStorageEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeral(
  obj: PrometheusSpecStorageEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "volumeClaimTemplate":
      toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplate(
        obj.volumeClaimTemplate,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the PVC spec to be used by the Prometheus StatefulSets. The easiest way to use a volume that cannot be automatically provisioned is to use a label selector alongside manually created PersistentVolumes.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplate
 */
export interface PrometheusSpecStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: PrometheusSpecStorageVolumeClaimTemplateMetadata;

  /**
   * Defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplate#spec
   */
  readonly spec?: PrometheusSpecStorageVolumeClaimTemplateSpec;

  /**
   * Deprecated: this field is never set.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplate#status
   */
  readonly status?: PrometheusSpecStorageVolumeClaimTemplateStatus;
}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplate(
  obj: PrometheusSpecStorageVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "kind": obj.kind,
    "metadata": toJson_PrometheusSpecStorageVolumeClaimTemplateMetadata(
      obj.metadata,
    ),
    "spec": toJson_PrometheusSpecStorageVolumeClaimTemplateSpec(obj.spec),
    "status": toJson_PrometheusSpecStorageVolumeClaimTemplateStatus(obj.status),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Argument as part of the AdditionalArgs list.
 *
 * @schema PrometheusSpecThanosAdditionalArgs
 */
export interface PrometheusSpecThanosAdditionalArgs {
  /**
   * Name of the argument, e.g. "scrape.discovery-reload-interval".
   *
   * @schema PrometheusSpecThanosAdditionalArgs#name
   */
  readonly name: string;

  /**
   * Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
   *
   * @schema PrometheusSpecThanosAdditionalArgs#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'PrometheusSpecThanosAdditionalArgs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosAdditionalArgs(
  obj: PrometheusSpecThanosAdditionalArgs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Configures the TLS parameters for the gRPC server providing the StoreAPI.
 * Note: Currently only the `caFile`, `certFile`, and `keyFile` fields are supported.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfig
 */
export interface PrometheusSpecThanosGrpcServerTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#ca
   */
  readonly ca?: PrometheusSpecThanosGrpcServerTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#cert
   */
  readonly cert?: PrometheusSpecThanosGrpcServerTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecThanosGrpcServerTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfig(
  obj: PrometheusSpecThanosGrpcServerTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_PrometheusSpecThanosGrpcServerTlsConfigCa(obj.ca),
    "caFile": obj.caFile,
    "cert": toJson_PrometheusSpecThanosGrpcServerTlsConfigCert(obj.cert),
    "certFile": obj.certFile,
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keyFile": obj.keyFile,
    "keySecret": toJson_PrometheusSpecThanosGrpcServerTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Log format for the Thanos sidecar.
 *
 * @schema PrometheusSpecThanosLogFormat
 */
export enum PrometheusSpecThanosLogFormat {
  /** logfmt */
  LOGFMT = "logfmt",
  /** json */
  JSON = "json",
}

/**
 * Log level for the Thanos sidecar.
 *
 * @schema PrometheusSpecThanosLogLevel
 */
export enum PrometheusSpecThanosLogLevel {
  /** debug */
  DEBUG = "debug",
  /** info */
  INFO = "info",
  /** warn */
  WARN = "warn",
  /** error */
  ERROR = "error",
}

/**
 * Defines the Thanos sidecar's configuration to upload TSDB blocks to object storage.
 * More info: https://thanos.io/tip/thanos/storage.md/
 * objectStorageConfigFile takes precedence over this field.
 *
 * @schema PrometheusSpecThanosObjectStorageConfig
 */
export interface PrometheusSpecThanosObjectStorageConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecThanosObjectStorageConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosObjectStorageConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecThanosObjectStorageConfig#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecThanosObjectStorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosObjectStorageConfig(
  obj: PrometheusSpecThanosObjectStorageConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the resources requests and limits of the Thanos sidecar.
 *
 * @schema PrometheusSpecThanosResources
 */
export interface PrometheusSpecThanosResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusSpecThanosResources#claims
   */
  readonly claims?: PrometheusSpecThanosResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecThanosResources#limits
   */
  readonly limits?: { [key: string]: PrometheusSpecThanosResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecThanosResources#requests
   */
  readonly requests?: { [key: string]: PrometheusSpecThanosResourcesRequests };
}

/**
 * Converts an object of type 'PrometheusSpecThanosResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosResources(
  obj: PrometheusSpecThanosResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusSpecThanosResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the tracing configuration for the Thanos sidecar.
 * More info: https://thanos.io/tip/thanos/tracing.md/
 * This is an experimental feature, it may change in any upcoming release in a breaking way.
 * tracingConfigFile takes precedence over this field.
 *
 * @schema PrometheusSpecThanosTracingConfig
 */
export interface PrometheusSpecThanosTracingConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecThanosTracingConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosTracingConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecThanosTracingConfig#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecThanosTracingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosTracingConfig(
  obj: PrometheusSpecThanosTracingConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PrometheusSpecThanosVolumeMounts
 */
export interface PrometheusSpecThanosVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PrometheusSpecThanosVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PrometheusSpecThanosVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PrometheusSpecThanosVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecThanosVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PrometheusSpecThanosVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema PrometheusSpecThanosVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'PrometheusSpecThanosVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosVolumeMounts(
  obj: PrometheusSpecThanosVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines what Prometheus Operator managed labels should be added to labelSelector on the topologySpreadConstraint.
 *
 * @schema PrometheusSpecTopologySpreadConstraintsAdditionalLabelSelectors
 */
export enum PrometheusSpecTopologySpreadConstraintsAdditionalLabelSelectors {
  /** OnResource */
  ON_RESOURCE = "OnResource",
  /** OnShard */
  ON_SHARD = "OnShard",
}

/**
 * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
 *
 * @schema PrometheusSpecTopologySpreadConstraintsLabelSelector
 */
export interface PrometheusSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTopologySpreadConstraintsLabelSelector(
  obj: PrometheusSpecTopologySpreadConstraintsLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client used to export the traces. Supported values are `http` or `grpc`.
 *
 * @schema PrometheusSpecTracingConfigClientType
 */
export enum PrometheusSpecTracingConfigClientType {
  /** http */
  HTTP = "http",
  /** grpc */
  GRPC = "grpc",
}

/**
 * Compression key for supported compression types. The only supported value is `gzip`.
 *
 * @schema PrometheusSpecTracingConfigCompression
 */
export enum PrometheusSpecTracingConfigCompression {
  /** gzip */
  GZIP = "gzip",
}

/**
 * Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
 *
 * @schema PrometheusSpecTracingConfigSamplingFraction
 */
export class PrometheusSpecTracingConfigSamplingFraction {
  public static fromNumber(
    value: number,
  ): PrometheusSpecTracingConfigSamplingFraction {
    return new PrometheusSpecTracingConfigSamplingFraction(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecTracingConfigSamplingFraction {
    return new PrometheusSpecTracingConfigSamplingFraction(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TLS Config to use when sending traces.
 *
 * @schema PrometheusSpecTracingConfigTlsConfig
 */
export interface PrometheusSpecTracingConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#ca
   */
  readonly ca?: PrometheusSpecTracingConfigTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#cert
   */
  readonly cert?: PrometheusSpecTracingConfigTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecTracingConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfig(
  obj: PrometheusSpecTracingConfigTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_PrometheusSpecTracingConfigTlsConfigCa(obj.ca),
    "caFile": obj.caFile,
    "cert": toJson_PrometheusSpecTracingConfigTlsConfigCert(obj.cert),
    "certFile": obj.certFile,
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keyFile": obj.keyFile,
    "keySecret": toJson_PrometheusSpecTracingConfigTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema PrometheusSpecVolumesAwsElasticBlockStore
 */
export interface PrometheusSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema PrometheusSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PrometheusSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PrometheusSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesAwsElasticBlockStore(
  obj: PrometheusSpecVolumesAwsElasticBlockStore | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "partition": obj.partition,
    "readOnly": obj.readOnly,
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema PrometheusSpecVolumesAzureDisk
 */
export interface PrometheusSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema PrometheusSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema PrometheusSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema PrometheusSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema PrometheusSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PrometheusSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesAzureDisk(
  obj: PrometheusSpecVolumesAzureDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "cachingMode": obj.cachingMode,
    "diskName": obj.diskName,
    "diskURI": obj.diskUri,
    "fsType": obj.fsType,
    "kind": obj.kind,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema PrometheusSpecVolumesAzureFile
 */
export interface PrometheusSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema PrometheusSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema PrometheusSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesAzureFile(
  obj: PrometheusSpecVolumesAzureFile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "readOnly": obj.readOnly,
    "secretName": obj.secretName,
    "shareName": obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema PrometheusSpecVolumesCephfs
 */
export interface PrometheusSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema PrometheusSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema PrometheusSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCephfs(
  obj: PrometheusSpecVolumesCephfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "monitors": obj.monitors?.map((y) => y),
    "path": obj.path,
    "readOnly": obj.readOnly,
    "secretFile": obj.secretFile,
    "secretRef": toJson_PrometheusSpecVolumesCephfsSecretRef(obj.secretRef),
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema PrometheusSpecVolumesCinder
 */
export interface PrometheusSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema PrometheusSpecVolumesCinder#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCinder(
  obj: PrometheusSpecVolumesCinder | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusSpecVolumesCinderSecretRef(obj.secretRef),
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema PrometheusSpecVolumesConfigMap
 */
export interface PrometheusSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PrometheusSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusSpecVolumesConfigMap#items
   */
  readonly items?: PrometheusSpecVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema PrometheusSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesConfigMap(
  obj: PrometheusSpecVolumesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) =>
      toJson_PrometheusSpecVolumesConfigMapItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema PrometheusSpecVolumesCsi
 */
export interface PrometheusSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema PrometheusSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema PrometheusSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema PrometheusSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: PrometheusSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema PrometheusSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema PrometheusSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCsi(
  obj: PrometheusSpecVolumesCsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "driver": obj.driver,
    "fsType": obj.fsType,
    "nodePublishSecretRef": toJson_PrometheusSpecVolumesCsiNodePublishSecretRef(
      obj.nodePublishSecretRef,
    ),
    "readOnly": obj.readOnly,
    "volumeAttributes": ((obj.volumeAttributes) === undefined)
      ? undefined
      : (Object.entries(obj.volumeAttributes).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema PrometheusSpecVolumesDownwardApi
 */
export interface PrometheusSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PrometheusSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema PrometheusSpecVolumesDownwardApi#items
   */
  readonly items?: PrometheusSpecVolumesDownwardApiItems[];
}

/**
 * Converts an object of type 'PrometheusSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesDownwardApi(
  obj: PrometheusSpecVolumesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) =>
      toJson_PrometheusSpecVolumesDownwardApiItems(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema PrometheusSpecVolumesEmptyDir
 */
export interface PrometheusSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: PrometheusSpecVolumesEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEmptyDir(
  obj: PrometheusSpecVolumesEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "medium": obj.medium,
    "sizeLimit": obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema PrometheusSpecVolumesEphemeral
 */
export interface PrometheusSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema PrometheusSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?:
    PrometheusSpecVolumesEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeral(
  obj: PrometheusSpecVolumesEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "volumeClaimTemplate":
      toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplate(
        obj.volumeClaimTemplate,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema PrometheusSpecVolumesFc
 */
export interface PrometheusSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema PrometheusSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PrometheusSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema PrometheusSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema PrometheusSpecVolumesFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesFc(
  obj: PrometheusSpecVolumesFc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "lun": obj.lun,
    "readOnly": obj.readOnly,
    "targetWWNs": obj.targetWwNs?.map((y) => y),
    "wwids": obj.wwids?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema PrometheusSpecVolumesFlexVolume
 */
export interface PrometheusSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema PrometheusSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema PrometheusSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema PrometheusSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema PrometheusSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesFlexVolume(
  obj: PrometheusSpecVolumesFlexVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "driver": obj.driver,
    "fsType": obj.fsType,
    "options": ((obj.options) === undefined)
      ? undefined
      : (Object.entries(obj.options).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusSpecVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema PrometheusSpecVolumesFlocker
 */
export interface PrometheusSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema PrometheusSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema PrometheusSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesFlocker(
  obj: PrometheusSpecVolumesFlocker | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "datasetName": obj.datasetName,
    "datasetUUID": obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema PrometheusSpecVolumesGcePersistentDisk
 */
export interface PrometheusSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PrometheusSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PrometheusSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema PrometheusSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesGcePersistentDisk(
  obj: PrometheusSpecVolumesGcePersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "partition": obj.partition,
    "pdName": obj.pdName,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema PrometheusSpecVolumesGitRepo
 */
export interface PrometheusSpecVolumesGitRepo {
  /**
   * directory is the target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema PrometheusSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema PrometheusSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema PrometheusSpecVolumesGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesGitRepo(
  obj: PrometheusSpecVolumesGitRepo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "directory": obj.directory,
    "repository": obj.repository,
    "revision": obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema PrometheusSpecVolumesGlusterfs
 */
export interface PrometheusSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PrometheusSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PrometheusSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema PrometheusSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesGlusterfs(
  obj: PrometheusSpecVolumesGlusterfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "endpoints": obj.endpoints,
    "path": obj.path,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema PrometheusSpecVolumesHostPath
 */
export interface PrometheusSpecVolumesHostPath {
  /**
   * path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema PrometheusSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema PrometheusSpecVolumesHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesHostPath(
  obj: PrometheusSpecVolumesHostPath | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "path": obj.path,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema PrometheusSpecVolumesIscsi
 */
export interface PrometheusSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema PrometheusSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema PrometheusSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema PrometheusSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema PrometheusSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema PrometheusSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema PrometheusSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PrometheusSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema PrometheusSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PrometheusSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesIscsi(
  obj: PrometheusSpecVolumesIscsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "chapAuthDiscovery": obj.chapAuthDiscovery,
    "chapAuthSession": obj.chapAuthSession,
    "fsType": obj.fsType,
    "initiatorName": obj.initiatorName,
    "iqn": obj.iqn,
    "iscsiInterface": obj.iscsiInterface,
    "lun": obj.lun,
    "portals": obj.portals?.map((y) => y),
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusSpecVolumesIscsiSecretRef(obj.secretRef),
    "targetPortal": obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema PrometheusSpecVolumesNfs
 */
export interface PrometheusSpecVolumesNfs {
  /**
   * path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PrometheusSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema PrometheusSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PrometheusSpecVolumesNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesNfs(
  obj: PrometheusSpecVolumesNfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "path": obj.path,
    "readOnly": obj.readOnly,
    "server": obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema PrometheusSpecVolumesPersistentVolumeClaim
 */
export interface PrometheusSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PrometheusSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema PrometheusSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesPersistentVolumeClaim(
  obj: PrometheusSpecVolumesPersistentVolumeClaim | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claimName": obj.claimName,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema PrometheusSpecVolumesPhotonPersistentDisk
 */
export interface PrometheusSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema PrometheusSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesPhotonPersistentDisk(
  obj: PrometheusSpecVolumesPhotonPersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "pdID": obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema PrometheusSpecVolumesPortworxVolume
 */
export interface PrometheusSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema PrometheusSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesPortworxVolume(
  obj: PrometheusSpecVolumesPortworxVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema PrometheusSpecVolumesProjected
 */
export interface PrometheusSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema PrometheusSpecVolumesProjected#sources
   */
  readonly sources?: PrometheusSpecVolumesProjectedSources[];
}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjected(
  obj: PrometheusSpecVolumesProjected | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "sources": obj.sources?.map((y) =>
      toJson_PrometheusSpecVolumesProjectedSources(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema PrometheusSpecVolumesQuobyte
 */
export interface PrometheusSpecVolumesQuobyte {
  /**
   * group to map volume access to Default is no group
   *
   * @default no group
   * @schema PrometheusSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema PrometheusSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema PrometheusSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema PrometheusSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema PrometheusSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema PrometheusSpecVolumesQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesQuobyte(
  obj: PrometheusSpecVolumesQuobyte | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "group": obj.group,
    "readOnly": obj.readOnly,
    "registry": obj.registry,
    "tenant": obj.tenant,
    "user": obj.user,
    "volume": obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema PrometheusSpecVolumesRbd
 */
export interface PrometheusSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PrometheusSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PrometheusSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PrometheusSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PrometheusSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PrometheusSpecVolumesRbd#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PrometheusSpecVolumesRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesRbd(
  obj: PrometheusSpecVolumesRbd | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "image": obj.image,
    "keyring": obj.keyring,
    "monitors": obj.monitors?.map((y) => y),
    "pool": obj.pool,
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusSpecVolumesRbdSecretRef(obj.secretRef),
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema PrometheusSpecVolumesScaleIo
 */
export interface PrometheusSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema PrometheusSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema PrometheusSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema PrometheusSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PrometheusSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema PrometheusSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: PrometheusSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema PrometheusSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema PrometheusSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema PrometheusSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema PrometheusSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema PrometheusSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesScaleIo(
  obj: PrometheusSpecVolumesScaleIo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "gateway": obj.gateway,
    "protectionDomain": obj.protectionDomain,
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusSpecVolumesScaleIoSecretRef(obj.secretRef),
    "sslEnabled": obj.sslEnabled,
    "storageMode": obj.storageMode,
    "storagePool": obj.storagePool,
    "system": obj.system,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema PrometheusSpecVolumesSecret
 */
export interface PrometheusSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PrometheusSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusSpecVolumesSecret#items
   */
  readonly items?: PrometheusSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema PrometheusSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema PrometheusSpecVolumesSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesSecret(
  obj: PrometheusSpecVolumesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) => toJson_PrometheusSpecVolumesSecretItems(y)),
    "optional": obj.optional,
    "secretName": obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema PrometheusSpecVolumesStorageos
 */
export interface PrometheusSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema PrometheusSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: PrometheusSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema PrometheusSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema PrometheusSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesStorageos(
  obj: PrometheusSpecVolumesStorageos | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusSpecVolumesStorageosSecretRef(obj.secretRef),
    "volumeName": obj.volumeName,
    "volumeNamespace": obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema PrometheusSpecVolumesVsphereVolume
 */
export interface PrometheusSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema PrometheusSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema PrometheusSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema PrometheusSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesVsphereVolume(
  obj: PrometheusSpecVolumesVsphereVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "storagePolicyID": obj.storagePolicyId,
    "storagePolicyName": obj.storagePolicyName,
    "volumePath": obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines HTTP parameters for web server.
 *
 * @schema PrometheusSpecWebHttpConfig
 */
export interface PrometheusSpecWebHttpConfig {
  /**
   * List of headers that can be added to HTTP responses.
   *
   * @schema PrometheusSpecWebHttpConfig#headers
   */
  readonly headers?: PrometheusSpecWebHttpConfigHeaders;

  /**
   * Enable HTTP/2 support. Note that HTTP/2 is only supported with TLS. When TLSConfig is not configured, HTTP/2 will be disabled. Whenever the value of the field changes, a rolling update will be triggered.
   *
   * @schema PrometheusSpecWebHttpConfig#http2
   */
  readonly http2?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecWebHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebHttpConfig(
  obj: PrometheusSpecWebHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "headers": toJson_PrometheusSpecWebHttpConfigHeaders(obj.headers),
    "http2": obj.http2,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the TLS parameters for HTTPS.
 *
 * @schema PrometheusSpecWebTlsConfig
 */
export interface PrometheusSpecWebTlsConfig {
  /**
   * Contains the TLS certificate for the server.
   *
   * @schema PrometheusSpecWebTlsConfig#cert
   */
  readonly cert: PrometheusSpecWebTlsConfigCert;

  /**
   * List of supported cipher suites for TLS versions up to TLS 1.2. If empty, Go default cipher suites are used. Available cipher suites are documented in the go documentation: https://golang.org/pkg/crypto/tls/#pkg-constants
   *
   * @schema PrometheusSpecWebTlsConfig#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * Server policy for client authentication. Maps to ClientAuth Policies. For more detail on clientAuth options: https://golang.org/pkg/crypto/tls/#ClientAuthType
   *
   * @schema PrometheusSpecWebTlsConfig#clientAuthType
   */
  readonly clientAuthType?: string;

  /**
   * Contains the CA certificate for client certificate authentication to the server.
   *
   * @schema PrometheusSpecWebTlsConfig#client_ca
   */
  readonly clientCa?: PrometheusSpecWebTlsConfigClientCa;

  /**
   * Elliptic curves that will be used in an ECDHE handshake, in preference order. Available curves are documented in the go documentation: https://golang.org/pkg/crypto/tls/#CurveID
   *
   * @schema PrometheusSpecWebTlsConfig#curvePreferences
   */
  readonly curvePreferences?: string[];

  /**
   * Secret containing the TLS key for the server.
   *
   * @schema PrometheusSpecWebTlsConfig#keySecret
   */
  readonly keySecret: PrometheusSpecWebTlsConfigKeySecret;

  /**
   * Maximum TLS version that is acceptable. Defaults to TLS13.
   *
   * @default TLS13.
   * @schema PrometheusSpecWebTlsConfig#maxVersion
   */
  readonly maxVersion?: string;

  /**
   * Minimum TLS version that is acceptable. Defaults to TLS12.
   *
   * @default TLS12.
   * @schema PrometheusSpecWebTlsConfig#minVersion
   */
  readonly minVersion?: string;

  /**
   * Controls whether the server selects the client's most preferred cipher suite, or the server's most preferred cipher suite. If true then the server's preference, as expressed in the order of elements in cipherSuites, is used.
   *
   * @schema PrometheusSpecWebTlsConfig#preferServerCipherSuites
   */
  readonly preferServerCipherSuites?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfig(
  obj: PrometheusSpecWebTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "cert": toJson_PrometheusSpecWebTlsConfigCert(obj.cert),
    "cipherSuites": obj.cipherSuites?.map((y) => y),
    "clientAuthType": obj.clientAuthType,
    "client_ca": toJson_PrometheusSpecWebTlsConfigClientCa(obj.clientCa),
    "curvePreferences": obj.curvePreferences?.map((y) => y),
    "keySecret": toJson_PrometheusSpecWebTlsConfigKeySecret(obj.keySecret),
    "maxVersion": obj.maxVersion,
    "minVersion": obj.minVersion,
    "preferServerCipherSuites": obj.preferServerCipherSuites,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference:
    PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preference":
      toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms:
    PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeSelectorTerms": obj.nodeSelectorTerms?.map((y) =>
      toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for Alertmanager.
 * Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `sigv4`.
 *
 * @schema PrometheusSpecAlertingAlertmanagersAuthorization
 */
export interface PrometheusSpecAlertingAlertmanagersAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PrometheusSpecAlertingAlertmanagersAuthorization#credentials
   */
  readonly credentials?:
    PrometheusSpecAlertingAlertmanagersAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema PrometheusSpecAlertingAlertmanagersAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersAuthorization(
  obj: PrometheusSpecAlertingAlertmanagersAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_PrometheusSpecAlertingAlertmanagersAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth configuration for Alertmanager.
 * Cannot be set at the same time as `bearerTokenFile`, `authorization` or `sigv4`.
 *
 * @schema PrometheusSpecAlertingAlertmanagersBasicAuth
 */
export interface PrometheusSpecAlertingAlertmanagersBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuth#password
   */
  readonly password?: PrometheusSpecAlertingAlertmanagersBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuth#username
   */
  readonly username?: PrometheusSpecAlertingAlertmanagersBasicAuthUsername;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersBasicAuth(
  obj: PrometheusSpecAlertingAlertmanagersBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_PrometheusSpecAlertingAlertmanagersBasicAuthPassword(
      obj.password,
    ),
    "username": toJson_PrometheusSpecAlertingAlertmanagersBasicAuthUsername(
      obj.username,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Port on which the Alertmanager API is exposed.
 *
 * @schema PrometheusSpecAlertingAlertmanagersPort
 */
export class PrometheusSpecAlertingAlertmanagersPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecAlertingAlertmanagersPort {
    return new PrometheusSpecAlertingAlertmanagersPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecAlertingAlertmanagersPort {
    return new PrometheusSpecAlertingAlertmanagersPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Sigv4 allows to configures AWS's Signature Verification 4 for the URL.
 * It requires Prometheus >= v2.48.0.
 * Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `authorization`.
 *
 * @schema PrometheusSpecAlertingAlertmanagersSigv4
 */
export interface PrometheusSpecAlertingAlertmanagersSigv4 {
  /**
   * AccessKey is the AWS API key. If not specified, the environment variable `AWS_ACCESS_KEY_ID` is used.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4#accessKey
   */
  readonly accessKey?: PrometheusSpecAlertingAlertmanagersSigv4AccessKey;

  /**
   * Profile is the named AWS profile used to authenticate.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4#profile
   */
  readonly profile?: string;

  /**
   * Region is the AWS region. If blank, the region from the default credentials chain used.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4#region
   */
  readonly region?: string;

  /**
   * RoleArn is the named AWS profile used to authenticate.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4#roleArn
   */
  readonly roleArn?: string;

  /**
   * SecretKey is the AWS API secret. If not specified, the environment variable `AWS_SECRET_ACCESS_KEY` is used.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4#secretKey
   */
  readonly secretKey?: PrometheusSpecAlertingAlertmanagersSigv4SecretKey;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersSigv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersSigv4(
  obj: PrometheusSpecAlertingAlertmanagersSigv4 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessKey": toJson_PrometheusSpecAlertingAlertmanagersSigv4AccessKey(
      obj.accessKey,
    ),
    "profile": obj.profile,
    "region": obj.region,
    "roleArn": obj.roleArn,
    "secretKey": toJson_PrometheusSpecAlertingAlertmanagersSigv4SecretKey(
      obj.secretKey,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS Config to use for Alertmanager.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfig
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#ca
   */
  readonly ca?: PrometheusSpecAlertingAlertmanagersTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#cert
   */
  readonly cert?: PrometheusSpecAlertingAlertmanagersTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfig(
  obj: PrometheusSpecAlertingAlertmanagersTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCa(obj.ca),
    "caFile": obj.caFile,
    "cert": toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCert(obj.cert),
    "certFile": obj.certFile,
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keyFile": obj.keyFile,
    "keySecret": toJson_PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PrometheusSpecApiserverConfigAuthorizationCredentials
 */
export interface PrometheusSpecApiserverConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigAuthorizationCredentials(
  obj: PrometheusSpecApiserverConfigAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema PrometheusSpecApiserverConfigBasicAuthPassword
 */
export interface PrometheusSpecApiserverConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigBasicAuthPassword(
  obj: PrometheusSpecApiserverConfigBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema PrometheusSpecApiserverConfigBasicAuthUsername
 */
export interface PrometheusSpecApiserverConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigBasicAuthUsername(
  obj: PrometheusSpecApiserverConfigBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCa
 */
export interface PrometheusSpecApiserverConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecApiserverConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecApiserverConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCa(
  obj: PrometheusSpecApiserverConfigTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecApiserverConfigTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecApiserverConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCert
 */
export interface PrometheusSpecApiserverConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecApiserverConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecApiserverConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCert(
  obj: PrometheusSpecApiserverConfigTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecApiserverConfigTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecApiserverConfigTlsConfigCertSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigKeySecret
 */
export interface PrometheusSpecApiserverConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigKeySecret(
  obj: PrometheusSpecApiserverConfigTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema PrometheusSpecContainersEnvValueFrom
 */
export interface PrometheusSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema PrometheusSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?:
    PrometheusSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema PrometheusSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PrometheusSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema PrometheusSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?:
    PrometheusSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema PrometheusSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PrometheusSpecContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvValueFrom(
  obj: PrometheusSpecContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapKeyRef":
      toJson_PrometheusSpecContainersEnvValueFromConfigMapKeyRef(
        obj.configMapKeyRef,
      ),
    "fieldRef": toJson_PrometheusSpecContainersEnvValueFromFieldRef(
      obj.fieldRef,
    ),
    "resourceFieldRef":
      toJson_PrometheusSpecContainersEnvValueFromResourceFieldRef(
        obj.resourceFieldRef,
      ),
    "secretKeyRef": toJson_PrometheusSpecContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema PrometheusSpecContainersEnvFromConfigMapRef
 */
export interface PrometheusSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PrometheusSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvFromConfigMapRef(
  obj: PrometheusSpecContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema PrometheusSpecContainersEnvFromSecretRef
 */
export interface PrometheusSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PrometheusSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvFromSecretRef(
  obj: PrometheusSpecContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusSpecContainersLifecyclePostStart
 */
export interface PrometheusSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: PrometheusSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: PrometheusSpecContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePostStart(
  obj: PrometheusSpecContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusSpecContainersLifecyclePostStartExec(obj.exec),
    "httpGet": toJson_PrometheusSpecContainersLifecyclePostStartHttpGet(
      obj.httpGet,
    ),
    "tcpSocket": toJson_PrometheusSpecContainersLifecyclePostStartTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusSpecContainersLifecyclePreStop
 */
export interface PrometheusSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: PrometheusSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: PrometheusSpecContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePreStop(
  obj: PrometheusSpecContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusSpecContainersLifecyclePreStopExec(obj.exec),
    "httpGet": toJson_PrometheusSpecContainersLifecyclePreStopHttpGet(
      obj.httpGet,
    ),
    "tcpSocket": toJson_PrometheusSpecContainersLifecyclePreStopTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecContainersLivenessProbeExec
 */
export interface PrometheusSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbeExec(
  obj: PrometheusSpecContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecContainersLivenessProbeGrpc
 */
export interface PrometheusSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbeGrpc(
  obj: PrometheusSpecContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecContainersLivenessProbeHttpGet
 */
export interface PrometheusSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: PrometheusSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbeHttpGet(
  obj: PrometheusSpecContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecContainersLivenessProbeTcpSocket
 */
export interface PrometheusSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: PrometheusSpecContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbeTcpSocket(
  obj: PrometheusSpecContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecContainersReadinessProbeExec
 */
export interface PrometheusSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbeExec(
  obj: PrometheusSpecContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecContainersReadinessProbeGrpc
 */
export interface PrometheusSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbeGrpc(
  obj: PrometheusSpecContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecContainersReadinessProbeHttpGet
 */
export interface PrometheusSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: PrometheusSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbeHttpGet(
  obj: PrometheusSpecContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecContainersReadinessProbeTcpSocket
 */
export interface PrometheusSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: PrometheusSpecContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbeTcpSocket(
  obj: PrometheusSpecContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusSpecContainersResourcesClaims
 */
export interface PrometheusSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusSpecContainersResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersResourcesClaims(
  obj: PrometheusSpecContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecContainersResourcesLimits
 */
export class PrometheusSpecContainersResourcesLimits {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersResourcesLimits {
    return new PrometheusSpecContainersResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersResourcesLimits {
    return new PrometheusSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecContainersResourcesRequests
 */
export class PrometheusSpecContainersResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersResourcesRequests {
    return new PrometheusSpecContainersResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersResourcesRequests {
    return new PrometheusSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema PrometheusSpecContainersSecurityContextCapabilities
 */
export interface PrometheusSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PrometheusSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PrometheusSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersSecurityContextCapabilities(
  obj: PrometheusSpecContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "add": obj.add?.map((y) => y),
    "drop": obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecContainersSecurityContextSeLinuxOptions
 */
export interface PrometheusSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PrometheusSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PrometheusSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PrometheusSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PrometheusSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersSecurityContextSeLinuxOptions(
  obj: PrometheusSpecContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecContainersSecurityContextSeccompProfile
 */
export interface PrometheusSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema PrometheusSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema PrometheusSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersSecurityContextSeccompProfile(
  obj: PrometheusSpecContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PrometheusSpecContainersSecurityContextWindowsOptions
 */
export interface PrometheusSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PrometheusSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PrometheusSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PrometheusSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PrometheusSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersSecurityContextWindowsOptions(
  obj: PrometheusSpecContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecContainersStartupProbeExec
 */
export interface PrometheusSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbeExec(
  obj: PrometheusSpecContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecContainersStartupProbeGrpc
 */
export interface PrometheusSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbeGrpc(
  obj: PrometheusSpecContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecContainersStartupProbeHttpGet
 */
export interface PrometheusSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGet#port
   */
  readonly port: PrometheusSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbeHttpGet(
  obj: PrometheusSpecContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusSpecContainersStartupProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecContainersStartupProbeTcpSocket
 */
export interface PrometheusSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: PrometheusSpecContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbeTcpSocket(
  obj: PrometheusSpecContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema PrometheusSpecInitContainersEnvValueFrom
 */
export interface PrometheusSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema PrometheusSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?:
    PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema PrometheusSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PrometheusSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema PrometheusSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?:
    PrometheusSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema PrometheusSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PrometheusSpecInitContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvValueFrom(
  obj: PrometheusSpecInitContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapKeyRef":
      toJson_PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef(
        obj.configMapKeyRef,
      ),
    "fieldRef": toJson_PrometheusSpecInitContainersEnvValueFromFieldRef(
      obj.fieldRef,
    ),
    "resourceFieldRef":
      toJson_PrometheusSpecInitContainersEnvValueFromResourceFieldRef(
        obj.resourceFieldRef,
      ),
    "secretKeyRef": toJson_PrometheusSpecInitContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema PrometheusSpecInitContainersEnvFromConfigMapRef
 */
export interface PrometheusSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PrometheusSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvFromConfigMapRef(
  obj: PrometheusSpecInitContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema PrometheusSpecInitContainersEnvFromSecretRef
 */
export interface PrometheusSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PrometheusSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvFromSecretRef(
  obj: PrometheusSpecInitContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStart
 */
export interface PrometheusSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: PrometheusSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: PrometheusSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecInitContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePostStart(
  obj: PrometheusSpecInitContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusSpecInitContainersLifecyclePostStartExec(obj.exec),
    "httpGet": toJson_PrometheusSpecInitContainersLifecyclePostStartHttpGet(
      obj.httpGet,
    ),
    "tcpSocket": toJson_PrometheusSpecInitContainersLifecyclePostStartTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStop
 */
export interface PrometheusSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: PrometheusSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: PrometheusSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PrometheusSpecInitContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePreStop(
  obj: PrometheusSpecInitContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusSpecInitContainersLifecyclePreStopExec(obj.exec),
    "httpGet": toJson_PrometheusSpecInitContainersLifecyclePreStopHttpGet(
      obj.httpGet,
    ),
    "tcpSocket": toJson_PrometheusSpecInitContainersLifecyclePreStopTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeExec
 */
export interface PrometheusSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbeExec(
  obj: PrometheusSpecInitContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeGrpc
 */
export interface PrometheusSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbeGrpc(
  obj: PrometheusSpecInitContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeHttpGet
 */
export interface PrometheusSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: PrometheusSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbeHttpGet(
  obj: PrometheusSpecInitContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeTcpSocket
 */
export interface PrometheusSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: PrometheusSpecInitContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbeTcpSocket(
  obj: PrometheusSpecInitContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeExec
 */
export interface PrometheusSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbeExec(
  obj: PrometheusSpecInitContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeGrpc
 */
export interface PrometheusSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbeGrpc(
  obj: PrometheusSpecInitContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeHttpGet
 */
export interface PrometheusSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: PrometheusSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbeHttpGet(
  obj: PrometheusSpecInitContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeTcpSocket
 */
export interface PrometheusSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: PrometheusSpecInitContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbeTcpSocket(
  obj: PrometheusSpecInitContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusSpecInitContainersResourcesClaims
 */
export interface PrometheusSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusSpecInitContainersResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersResourcesClaims(
  obj: PrometheusSpecInitContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecInitContainersResourcesLimits
 */
export class PrometheusSpecInitContainersResourcesLimits {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersResourcesLimits {
    return new PrometheusSpecInitContainersResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersResourcesLimits {
    return new PrometheusSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecInitContainersResourcesRequests
 */
export class PrometheusSpecInitContainersResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersResourcesRequests {
    return new PrometheusSpecInitContainersResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersResourcesRequests {
    return new PrometheusSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema PrometheusSpecInitContainersSecurityContextCapabilities
 */
export interface PrometheusSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PrometheusSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PrometheusSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersSecurityContextCapabilities(
  obj: PrometheusSpecInitContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "add": obj.add?.map((y) => y),
    "drop": obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface PrometheusSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersSecurityContextSeLinuxOptions(
  obj: PrometheusSpecInitContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusSpecInitContainersSecurityContextSeccompProfile
 */
export interface PrometheusSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema PrometheusSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersSecurityContextSeccompProfile(
  obj: PrometheusSpecInitContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PrometheusSpecInitContainersSecurityContextWindowsOptions
 */
export interface PrometheusSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PrometheusSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PrometheusSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PrometheusSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PrometheusSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersSecurityContextWindowsOptions(
  obj: PrometheusSpecInitContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecInitContainersStartupProbeExec
 */
export interface PrometheusSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbeExec(
  obj: PrometheusSpecInitContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusSpecInitContainersStartupProbeGrpc
 */
export interface PrometheusSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbeGrpc(
  obj: PrometheusSpecInitContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecInitContainersStartupProbeHttpGet
 */
export interface PrometheusSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: PrometheusSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbeHttpGet(
  obj: PrometheusSpecInitContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusSpecInitContainersStartupProbeTcpSocket
 */
export interface PrometheusSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: PrometheusSpecInitContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbeTcpSocket(
  obj: PrometheusSpecInitContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PrometheusSpecRemoteReadAuthorizationCredentials
 */
export interface PrometheusSpecRemoteReadAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadAuthorizationCredentials(
  obj: PrometheusSpecRemoteReadAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema PrometheusSpecRemoteReadBasicAuthPassword
 */
export interface PrometheusSpecRemoteReadBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadBasicAuthPassword(
  obj: PrometheusSpecRemoteReadBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema PrometheusSpecRemoteReadBasicAuthUsername
 */
export interface PrometheusSpecRemoteReadBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadBasicAuthUsername(
  obj: PrometheusSpecRemoteReadBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema PrometheusSpecRemoteReadOauth2ClientId
 */
export interface PrometheusSpecRemoteReadOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientId#configMap
   */
  readonly configMap?: PrometheusSpecRemoteReadOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientId#secret
   */
  readonly secret?: PrometheusSpecRemoteReadOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadOauth2ClientId(
  obj: PrometheusSpecRemoteReadOauth2ClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecRemoteReadOauth2ClientIdConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecRemoteReadOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema PrometheusSpecRemoteReadOauth2ClientSecret
 */
export interface PrometheusSpecRemoteReadOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadOauth2ClientSecret(
  obj: PrometheusSpecRemoteReadOauth2ClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCa
 */
export interface PrometheusSpecRemoteReadTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecRemoteReadTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecRemoteReadTlsConfigCaSecret;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCa(
  obj: PrometheusSpecRemoteReadTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecRemoteReadTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecRemoteReadTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCert
 */
export interface PrometheusSpecRemoteReadTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecRemoteReadTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecRemoteReadTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCert(
  obj: PrometheusSpecRemoteReadTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecRemoteReadTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecRemoteReadTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigKeySecret
 */
export interface PrometheusSpecRemoteReadTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigKeySecret(
  obj: PrometheusSpecRemoteReadTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PrometheusSpecRemoteWriteAuthorizationCredentials
 */
export interface PrometheusSpecRemoteWriteAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAuthorizationCredentials(
  obj: PrometheusSpecRemoteWriteAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure Cloud. Options are 'AzurePublic', 'AzureChina', or 'AzureGovernment'.
 *
 * @schema PrometheusSpecRemoteWriteAzureAdCloud
 */
export enum PrometheusSpecRemoteWriteAzureAdCloud {
  /** AzureChina */
  AZURE_CHINA = "AzureChina",
  /** AzureGovernment */
  AZURE_GOVERNMENT = "AzureGovernment",
  /** AzurePublic */
  AZURE_PUBLIC = "AzurePublic",
}

/**
 * ManagedIdentity defines the Azure User-assigned Managed identity. Cannot be set at the same time as `oauth`.
 *
 * @schema PrometheusSpecRemoteWriteAzureAdManagedIdentity
 */
export interface PrometheusSpecRemoteWriteAzureAdManagedIdentity {
  /**
   * The client id
   *
   * @schema PrometheusSpecRemoteWriteAzureAdManagedIdentity#clientId
   */
  readonly clientId: string;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAzureAdManagedIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAzureAdManagedIdentity(
  obj: PrometheusSpecRemoteWriteAzureAdManagedIdentity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": obj.clientId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth defines the oauth config that is being used to authenticate. Cannot be set at the same time as `managedIdentity`.
 * It requires Prometheus >= v2.48.0.
 *
 * @schema PrometheusSpecRemoteWriteAzureAdOauth
 */
export interface PrometheusSpecRemoteWriteAzureAdOauth {
  /**
   * `clientID` is the clientId of the Azure Active Directory application that is being used to authenticate.
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauth#clientId
   */
  readonly clientId: string;

  /**
   * `clientSecret` specifies a key of a Secret containing the client secret of the Azure Active Directory application that is being used to authenticate.
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauth#clientSecret
   */
  readonly clientSecret: PrometheusSpecRemoteWriteAzureAdOauthClientSecret;

  /**
   * `tenantID` is the tenant ID of the Azure Active Directory application that is being used to authenticate.
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauth#tenantId
   */
  readonly tenantId: string;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAzureAdOauth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAzureAdOauth(
  obj: PrometheusSpecRemoteWriteAzureAdOauth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": obj.clientId,
    "clientSecret": toJson_PrometheusSpecRemoteWriteAzureAdOauthClientSecret(
      obj.clientSecret,
    ),
    "tenantId": obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema PrometheusSpecRemoteWriteBasicAuthPassword
 */
export interface PrometheusSpecRemoteWriteBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteBasicAuthPassword(
  obj: PrometheusSpecRemoteWriteBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema PrometheusSpecRemoteWriteBasicAuthUsername
 */
export interface PrometheusSpecRemoteWriteBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteBasicAuthUsername(
  obj: PrometheusSpecRemoteWriteBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema PrometheusSpecRemoteWriteOauth2ClientId
 */
export interface PrometheusSpecRemoteWriteOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientId#configMap
   */
  readonly configMap?: PrometheusSpecRemoteWriteOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientId#secret
   */
  readonly secret?: PrometheusSpecRemoteWriteOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteOauth2ClientId(
  obj: PrometheusSpecRemoteWriteOauth2ClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecRemoteWriteOauth2ClientIdConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecRemoteWriteOauth2ClientIdSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema PrometheusSpecRemoteWriteOauth2ClientSecret
 */
export interface PrometheusSpecRemoteWriteOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteOauth2ClientSecret(
  obj: PrometheusSpecRemoteWriteOauth2ClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AccessKey is the AWS API key. If not specified, the environment variable `AWS_ACCESS_KEY_ID` is used.
 *
 * @schema PrometheusSpecRemoteWriteSigv4AccessKey
 */
export interface PrometheusSpecRemoteWriteSigv4AccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteSigv4AccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteSigv4AccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteSigv4AccessKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteSigv4AccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteSigv4AccessKey(
  obj: PrometheusSpecRemoteWriteSigv4AccessKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey is the AWS API secret. If not specified, the environment variable `AWS_SECRET_ACCESS_KEY` is used.
 *
 * @schema PrometheusSpecRemoteWriteSigv4SecretKey
 */
export interface PrometheusSpecRemoteWriteSigv4SecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteSigv4SecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteSigv4SecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteSigv4SecretKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteSigv4SecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteSigv4SecretKey(
  obj: PrometheusSpecRemoteWriteSigv4SecretKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCa
 */
export interface PrometheusSpecRemoteWriteTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecRemoteWriteTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecRemoteWriteTlsConfigCaSecret;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCa(
  obj: PrometheusSpecRemoteWriteTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecRemoteWriteTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecRemoteWriteTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCert
 */
export interface PrometheusSpecRemoteWriteTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecRemoteWriteTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecRemoteWriteTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCert(
  obj: PrometheusSpecRemoteWriteTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecRemoteWriteTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecRemoteWriteTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigKeySecret
 */
export interface PrometheusSpecRemoteWriteTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigKeySecret(
  obj: PrometheusSpecRemoteWriteTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 *
 * @schema PrometheusSpecRemoteWriteWriteRelabelConfigsAction
 */
export enum PrometheusSpecRemoteWriteWriteRelabelConfigsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema PrometheusSpecStorageEmptyDirSizeLimit
 */
export class PrometheusSpecStorageEmptyDirSizeLimit {
  public static fromNumber(
    value: number,
  ): PrometheusSpecStorageEmptyDirSizeLimit {
    return new PrometheusSpecStorageEmptyDirSizeLimit(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecStorageEmptyDirSizeLimit {
    return new PrometheusSpecStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplate
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplate(
  obj: PrometheusSpecStorageEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec(
      obj.spec,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateMetadata
 */
export interface PrometheusSpecStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateMetadata(
  obj: PrometheusSpecStorageVolumeClaimTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "annotations": ((obj.annotations) === undefined)
      ? undefined
      : (Object.entries(obj.annotations).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpec
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: PrometheusSpecStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?: PrometheusSpecStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: PrometheusSpecStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpec(
  obj: PrometheusSpecStorageVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource": toJson_PrometheusSpecStorageVolumeClaimTemplateSpecDataSource(
      obj.dataSource,
    ),
    "dataSourceRef":
      toJson_PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources": toJson_PrometheusSpecStorageVolumeClaimTemplateSpecResources(
      obj.resources,
    ),
    "selector": toJson_PrometheusSpecStorageVolumeClaimTemplateSpecSelector(
      obj.selector,
    ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated: this field is never set.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateStatus
 */
export interface PrometheusSpecStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC. Key names follow standard Kubernetes label syntax. Valid values are either: * Un-prefixed keys: - storage - the capacity of the volume. * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource" Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used.
   * ClaimResourceStatus can be in any of following states: - ControllerResizeInProgress: State set when resize controller starts resizing the volume in control-plane. - ControllerResizeFailed: State set when resize has failed in resize controller with a terminal error. - NodeResizePending: State set when resize controller has finished resizing the volume but further resizing of volume is needed on the node. - NodeResizeInProgress: State set when kubelet starts resizing the volume. - NodeResizeFailed: State set when resizing has failed in kubelet with a terminal error. Transient errors don't set NodeResizeFailed. For example: if expanding a PVC for more capacity - this field can be one of the following states: - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress" - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed" When this field is not set, it means that no resize operation is in progress for the given PVC.
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity. Key names follow standard Kubernetes label syntax. Valid values are either: * Un-prefixed keys: - storage - the capacity of the volume. * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource" Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used.
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation is requested. For storage quota, the larger value from allocatedResources and PVC.spec.resources is used. If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation. If a volume expansion capacity request is lowered, allocatedResources is only lowered if there are no expansion operations in progress and if the actual volume capacity is equal or lower than the requested capacity.
   * A controller that receives PVC update with previously unknown resourceName should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: {
    [key: string]:
      PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources;
  };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: {
    [key: string]: PrometheusSpecStorageVolumeClaimTemplateStatusCapacity;
  };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?:
    PrometheusSpecStorageVolumeClaimTemplateStatusConditions[];

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;
}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateStatus(
  obj: PrometheusSpecStorageVolumeClaimTemplateStatus | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "allocatedResourceStatuses": ((obj.allocatedResourceStatuses) === undefined)
      ? undefined
      : (Object.entries(obj.allocatedResourceStatuses).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "allocatedResources": ((obj.allocatedResources) === undefined)
      ? undefined
      : (Object.entries(obj.allocatedResources).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "capacity": ((obj.capacity) === undefined)
      ? undefined
      : (Object.entries(obj.capacity).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "conditions": obj.conditions?.map((y) =>
      toJson_PrometheusSpecStorageVolumeClaimTemplateStatusConditions(y)
    ),
    "phase": obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCa
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecThanosGrpcServerTlsConfigCaSecret;
}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCa(
  obj: PrometheusSpecThanosGrpcServerTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecThanosGrpcServerTlsConfigCaSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCert
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecThanosGrpcServerTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCert(
  obj: PrometheusSpecThanosGrpcServerTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecThanosGrpcServerTlsConfigCertSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigKeySecret
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigKeySecret(
  obj: PrometheusSpecThanosGrpcServerTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusSpecThanosResourcesClaims
 */
export interface PrometheusSpecThanosResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusSpecThanosResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecThanosResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosResourcesClaims(
  obj: PrometheusSpecThanosResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecThanosResourcesLimits
 */
export class PrometheusSpecThanosResourcesLimits {
  public static fromNumber(value: number): PrometheusSpecThanosResourcesLimits {
    return new PrometheusSpecThanosResourcesLimits(value);
  }
  public static fromString(value: string): PrometheusSpecThanosResourcesLimits {
    return new PrometheusSpecThanosResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecThanosResourcesRequests
 */
export class PrometheusSpecThanosResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusSpecThanosResourcesRequests {
    return new PrometheusSpecThanosResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecThanosResourcesRequests {
    return new PrometheusSpecThanosResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
  obj:
    | PrometheusSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCa
 */
export interface PrometheusSpecTracingConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecTracingConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecTracingConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCa(
  obj: PrometheusSpecTracingConfigTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecTracingConfigTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecTracingConfigTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCert
 */
export interface PrometheusSpecTracingConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecTracingConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecTracingConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCert(
  obj: PrometheusSpecTracingConfigTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecTracingConfigTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecTracingConfigTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigKeySecret
 */
export interface PrometheusSpecTracingConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecTracingConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecTracingConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigKeySecret(
  obj: PrometheusSpecTracingConfigTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema PrometheusSpecVolumesCephfsSecretRef
 */
export interface PrometheusSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCephfsSecretRef(
  obj: PrometheusSpecVolumesCephfsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema PrometheusSpecVolumesCinderSecretRef
 */
export interface PrometheusSpecVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCinderSecretRef(
  obj: PrometheusSpecVolumesCinderSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusSpecVolumesConfigMapItems
 */
export interface PrometheusSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PrometheusSpecVolumesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesConfigMapItems(
  obj: PrometheusSpecVolumesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema PrometheusSpecVolumesCsiNodePublishSecretRef
 */
export interface PrometheusSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesCsiNodePublishSecretRef(
  obj: PrometheusSpecVolumesCsiNodePublishSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PrometheusSpecVolumesDownwardApiItems
 */
export interface PrometheusSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema PrometheusSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: PrometheusSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PrometheusSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema PrometheusSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?:
    PrometheusSpecVolumesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesDownwardApiItems(
  obj: PrometheusSpecVolumesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fieldRef": toJson_PrometheusSpecVolumesDownwardApiItemsFieldRef(
      obj.fieldRef,
    ),
    "mode": obj.mode,
    "path": obj.path,
    "resourceFieldRef":
      toJson_PrometheusSpecVolumesDownwardApiItemsResourceFieldRef(
        obj.resourceFieldRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema PrometheusSpecVolumesEmptyDirSizeLimit
 */
export class PrometheusSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(
    value: number,
  ): PrometheusSpecVolumesEmptyDirSizeLimit {
    return new PrometheusSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecVolumesEmptyDirSizeLimit {
    return new PrometheusSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplate(
  obj: PrometheusSpecVolumesEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec(
      obj.spec,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema PrometheusSpecVolumesFlexVolumeSecretRef
 */
export interface PrometheusSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesFlexVolumeSecretRef(
  obj: PrometheusSpecVolumesFlexVolumeSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema PrometheusSpecVolumesIscsiSecretRef
 */
export interface PrometheusSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesIscsiSecretRef(
  obj: PrometheusSpecVolumesIscsiSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema PrometheusSpecVolumesProjectedSources
 */
export interface PrometheusSpecVolumesProjectedSources {
  /**
   * configMap information about the configMap data to project
   *
   * @schema PrometheusSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: PrometheusSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema PrometheusSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: PrometheusSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema PrometheusSpecVolumesProjectedSources#secret
   */
  readonly secret?: PrometheusSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema PrometheusSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?:
    PrometheusSpecVolumesProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSources(
  obj: PrometheusSpecVolumesProjectedSources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecVolumesProjectedSourcesConfigMap(
      obj.configMap,
    ),
    "downwardAPI": toJson_PrometheusSpecVolumesProjectedSourcesDownwardApi(
      obj.downwardApi,
    ),
    "secret": toJson_PrometheusSpecVolumesProjectedSourcesSecret(obj.secret),
    "serviceAccountToken":
      toJson_PrometheusSpecVolumesProjectedSourcesServiceAccountToken(
        obj.serviceAccountToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema PrometheusSpecVolumesRbdSecretRef
 */
export interface PrometheusSpecVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesRbdSecretRef(
  obj: PrometheusSpecVolumesRbdSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema PrometheusSpecVolumesScaleIoSecretRef
 */
export interface PrometheusSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesScaleIoSecretRef(
  obj: PrometheusSpecVolumesScaleIoSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusSpecVolumesSecretItems
 */
export interface PrometheusSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PrometheusSpecVolumesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesSecretItems(
  obj: PrometheusSpecVolumesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema PrometheusSpecVolumesStorageosSecretRef
 */
export interface PrometheusSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesStorageosSecretRef(
  obj: PrometheusSpecVolumesStorageosSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * List of headers that can be added to HTTP responses.
 *
 * @schema PrometheusSpecWebHttpConfigHeaders
 */
export interface PrometheusSpecWebHttpConfigHeaders {
  /**
   * Set the Content-Security-Policy header to HTTP responses. Unset if blank.
   *
   * @schema PrometheusSpecWebHttpConfigHeaders#contentSecurityPolicy
   */
  readonly contentSecurityPolicy?: string;

  /**
   * Set the Strict-Transport-Security header to HTTP responses. Unset if blank. Please make sure that you use this with care as this header might force browsers to load Prometheus and the other applications hosted on the same domain and subdomains over HTTPS. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
   *
   * @schema PrometheusSpecWebHttpConfigHeaders#strictTransportSecurity
   */
  readonly strictTransportSecurity?: string;

  /**
   * Set the X-Content-Type-Options header to HTTP responses. Unset if blank. Accepted value is nosniff. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
   *
   * @schema PrometheusSpecWebHttpConfigHeaders#xContentTypeOptions
   */
  readonly xContentTypeOptions?:
    PrometheusSpecWebHttpConfigHeadersXContentTypeOptions;

  /**
   * Set the X-Frame-Options header to HTTP responses. Unset if blank. Accepted values are deny and sameorigin. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
   *
   * @schema PrometheusSpecWebHttpConfigHeaders#xFrameOptions
   */
  readonly xFrameOptions?: PrometheusSpecWebHttpConfigHeadersXFrameOptions;

  /**
   * Set the X-XSS-Protection header to all responses. Unset if blank. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
   *
   * @schema PrometheusSpecWebHttpConfigHeaders#xXSSProtection
   */
  readonly xXssProtection?: string;
}

/**
 * Converts an object of type 'PrometheusSpecWebHttpConfigHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebHttpConfigHeaders(
  obj: PrometheusSpecWebHttpConfigHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "contentSecurityPolicy": obj.contentSecurityPolicy,
    "strictTransportSecurity": obj.strictTransportSecurity,
    "xContentTypeOptions": obj.xContentTypeOptions,
    "xFrameOptions": obj.xFrameOptions,
    "xXSSProtection": obj.xXssProtection,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the TLS certificate for the server.
 *
 * @schema PrometheusSpecWebTlsConfigCert
 */
export interface PrometheusSpecWebTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecWebTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusSpecWebTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecWebTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecWebTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigCert(
  obj: PrometheusSpecWebTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecWebTlsConfigCertConfigMap(obj.configMap),
    "secret": toJson_PrometheusSpecWebTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the CA certificate for client certificate authentication to the server.
 *
 * @schema PrometheusSpecWebTlsConfigClientCa
 */
export interface PrometheusSpecWebTlsConfigClientCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecWebTlsConfigClientCa#configMap
   */
  readonly configMap?: PrometheusSpecWebTlsConfigClientCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecWebTlsConfigClientCa#secret
   */
  readonly secret?: PrometheusSpecWebTlsConfigClientCaSecret;
}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigClientCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigClientCa(
  obj: PrometheusSpecWebTlsConfigClientCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecWebTlsConfigClientCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecWebTlsConfigClientCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the TLS key for the server.
 *
 * @schema PrometheusSpecWebTlsConfigKeySecret
 */
export interface PrometheusSpecWebTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecWebTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecWebTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecWebTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigKeySecret(
  obj: PrometheusSpecWebTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?:
    PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?:
    PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PrometheusSpecAlertingAlertmanagersAuthorizationCredentials
 */
export interface PrometheusSpecAlertingAlertmanagersAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersAuthorizationCredentials(
  obj: PrometheusSpecAlertingAlertmanagersAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema PrometheusSpecAlertingAlertmanagersBasicAuthPassword
 */
export interface PrometheusSpecAlertingAlertmanagersBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersBasicAuthPassword(
  obj: PrometheusSpecAlertingAlertmanagersBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema PrometheusSpecAlertingAlertmanagersBasicAuthUsername
 */
export interface PrometheusSpecAlertingAlertmanagersBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersBasicAuthUsername(
  obj: PrometheusSpecAlertingAlertmanagersBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AccessKey is the AWS API key. If not specified, the environment variable `AWS_ACCESS_KEY_ID` is used.
 *
 * @schema PrometheusSpecAlertingAlertmanagersSigv4AccessKey
 */
export interface PrometheusSpecAlertingAlertmanagersSigv4AccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4AccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4AccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4AccessKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersSigv4AccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersSigv4AccessKey(
  obj: PrometheusSpecAlertingAlertmanagersSigv4AccessKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey is the AWS API secret. If not specified, the environment variable `AWS_SECRET_ACCESS_KEY` is used.
 *
 * @schema PrometheusSpecAlertingAlertmanagersSigv4SecretKey
 */
export interface PrometheusSpecAlertingAlertmanagersSigv4SecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4SecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4SecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersSigv4SecretKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersSigv4SecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersSigv4SecretKey(
  obj: PrometheusSpecAlertingAlertmanagersSigv4SecretKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCa
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCa#secret
   */
  readonly secret?: PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCa(
  obj: PrometheusSpecAlertingAlertmanagersTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCert
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCert#configMap
   */
  readonly configMap?:
    PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCert#secret
   */
  readonly secret?: PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCert(
  obj: PrometheusSpecAlertingAlertmanagersTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret": toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret(
  obj: PrometheusSpecAlertingAlertmanagersTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCaConfigMap
 */
export interface PrometheusSpecApiserverConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCaConfigMap(
  obj: PrometheusSpecApiserverConfigTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCaSecret
 */
export interface PrometheusSpecApiserverConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCaSecret(
  obj: PrometheusSpecApiserverConfigTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCertConfigMap
 */
export interface PrometheusSpecApiserverConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCertConfigMap(
  obj: PrometheusSpecApiserverConfigTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecApiserverConfigTlsConfigCertSecret
 */
export interface PrometheusSpecApiserverConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecApiserverConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecApiserverConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecApiserverConfigTlsConfigCertSecret(
  obj: PrometheusSpecApiserverConfigTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema PrometheusSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface PrometheusSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvValueFromConfigMapKeyRef(
  obj: PrometheusSpecContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema PrometheusSpecContainersEnvValueFromFieldRef
 */
export interface PrometheusSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvValueFromFieldRef(
  obj: PrometheusSpecContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema PrometheusSpecContainersEnvValueFromResourceFieldRef
 */
export interface PrometheusSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?:
    PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvValueFromResourceFieldRef(
  obj: PrometheusSpecContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema PrometheusSpecContainersEnvValueFromSecretKeyRef
 */
export interface PrometheusSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersEnvValueFromSecretKeyRef(
  obj: PrometheusSpecContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecContainersLifecyclePostStartExec
 */
export interface PrometheusSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePostStartExec(
  obj: PrometheusSpecContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecContainersLifecyclePostStartHttpGet
 */
export interface PrometheusSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: PrometheusSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePostStartHttpGet(
  obj: PrometheusSpecContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusSpecContainersLifecyclePostStartTcpSocket
 */
export interface PrometheusSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: PrometheusSpecContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePostStartTcpSocket(
  obj: PrometheusSpecContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecContainersLifecyclePreStopExec
 */
export interface PrometheusSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePreStopExec(
  obj: PrometheusSpecContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecContainersLifecyclePreStopHttpGet
 */
export interface PrometheusSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: PrometheusSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePreStopHttpGet(
  obj: PrometheusSpecContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusSpecContainersLifecyclePreStopTcpSocket
 */
export interface PrometheusSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: PrometheusSpecContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePreStopTcpSocket(
  obj: PrometheusSpecContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders(
  obj: PrometheusSpecContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLivenessProbeHttpGetPort
 */
export class PrometheusSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersLivenessProbeHttpGetPort {
    return new PrometheusSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersLivenessProbeHttpGetPort {
    return new PrometheusSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLivenessProbeTcpSocketPort
 */
export class PrometheusSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersLivenessProbeTcpSocketPort {
    return new PrometheusSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersLivenessProbeTcpSocketPort {
    return new PrometheusSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders(
  obj: PrometheusSpecContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersReadinessProbeHttpGetPort
 */
export class PrometheusSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersReadinessProbeHttpGetPort {
    return new PrometheusSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersReadinessProbeHttpGetPort {
    return new PrometheusSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersReadinessProbeTcpSocketPort
 */
export class PrometheusSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersReadinessProbeTcpSocketPort {
    return new PrometheusSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersReadinessProbeTcpSocketPort {
    return new PrometheusSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersStartupProbeHttpGetHttpHeaders(
  obj: PrometheusSpecContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersStartupProbeHttpGetPort
 */
export class PrometheusSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersStartupProbeHttpGetPort {
    return new PrometheusSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersStartupProbeHttpGetPort {
    return new PrometheusSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersStartupProbeTcpSocketPort
 */
export class PrometheusSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersStartupProbeTcpSocketPort {
    return new PrometheusSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersStartupProbeTcpSocketPort {
    return new PrometheusSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef(
  obj: PrometheusSpecInitContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema PrometheusSpecInitContainersEnvValueFromFieldRef
 */
export interface PrometheusSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvValueFromFieldRef(
  obj: PrometheusSpecInitContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema PrometheusSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface PrometheusSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?:
    PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvValueFromResourceFieldRef(
  obj: PrometheusSpecInitContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema PrometheusSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface PrometheusSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersEnvValueFromSecretKeyRef(
  obj: PrometheusSpecInitContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartExec
 */
export interface PrometheusSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePostStartExec(
  obj: PrometheusSpecInitContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet
 */
export interface PrometheusSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: PrometheusSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePostStartHttpGet(
  obj: PrometheusSpecInitContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface PrometheusSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePostStartTcpSocket(
  obj: PrometheusSpecInitContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopExec
 */
export interface PrometheusSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePreStopExec(
  obj: PrometheusSpecInitContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet
 */
export interface PrometheusSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: PrometheusSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePreStopHttpGet(
  obj: PrometheusSpecInitContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface PrometheusSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePreStopTcpSocket(
  obj: PrometheusSpecInitContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders(
  obj: PrometheusSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeHttpGetPort
 */
export class PrometheusSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersLivenessProbeHttpGetPort {
    return new PrometheusSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersLivenessProbeHttpGetPort {
    return new PrometheusSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLivenessProbeTcpSocketPort
 */
export class PrometheusSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersLivenessProbeTcpSocketPort {
    return new PrometheusSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersLivenessProbeTcpSocketPort {
    return new PrometheusSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders(
  obj: PrometheusSpecInitContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeHttpGetPort
 */
export class PrometheusSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersReadinessProbeHttpGetPort {
    return new PrometheusSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersReadinessProbeHttpGetPort {
    return new PrometheusSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersReadinessProbeTcpSocketPort
 */
export class PrometheusSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersReadinessProbeTcpSocketPort {
    return new PrometheusSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersReadinessProbeTcpSocketPort {
    return new PrometheusSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders(
  obj: PrometheusSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersStartupProbeHttpGetPort
 */
export class PrometheusSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersStartupProbeHttpGetPort {
    return new PrometheusSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersStartupProbeHttpGetPort {
    return new PrometheusSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersStartupProbeTcpSocketPort
 */
export class PrometheusSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersStartupProbeTcpSocketPort {
    return new PrometheusSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersStartupProbeTcpSocketPort {
    return new PrometheusSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadOauth2ClientIdConfigMap
 */
export interface PrometheusSpecRemoteReadOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadOauth2ClientIdConfigMap(
  obj: PrometheusSpecRemoteReadOauth2ClientIdConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadOauth2ClientIdSecret
 */
export interface PrometheusSpecRemoteReadOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadOauth2ClientIdSecret(
  obj: PrometheusSpecRemoteReadOauth2ClientIdSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCaConfigMap
 */
export interface PrometheusSpecRemoteReadTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCaConfigMap(
  obj: PrometheusSpecRemoteReadTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCaSecret
 */
export interface PrometheusSpecRemoteReadTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCaSecret(
  obj: PrometheusSpecRemoteReadTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCertConfigMap
 */
export interface PrometheusSpecRemoteReadTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCertConfigMap(
  obj: PrometheusSpecRemoteReadTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteReadTlsConfigCertSecret
 */
export interface PrometheusSpecRemoteReadTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteReadTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteReadTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteReadTlsConfigCertSecret(
  obj: PrometheusSpecRemoteReadTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the client secret of the Azure Active Directory application that is being used to authenticate.
 *
 * @schema PrometheusSpecRemoteWriteAzureAdOauthClientSecret
 */
export interface PrometheusSpecRemoteWriteAzureAdOauthClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauthClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauthClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteAzureAdOauthClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteAzureAdOauthClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteAzureAdOauthClientSecret(
  obj: PrometheusSpecRemoteWriteAzureAdOauthClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteOauth2ClientIdConfigMap
 */
export interface PrometheusSpecRemoteWriteOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteOauth2ClientIdConfigMap(
  obj: PrometheusSpecRemoteWriteOauth2ClientIdConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteOauth2ClientIdSecret
 */
export interface PrometheusSpecRemoteWriteOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteOauth2ClientIdSecret(
  obj: PrometheusSpecRemoteWriteOauth2ClientIdSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCaConfigMap
 */
export interface PrometheusSpecRemoteWriteTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCaConfigMap(
  obj: PrometheusSpecRemoteWriteTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCaSecret
 */
export interface PrometheusSpecRemoteWriteTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCaSecret(
  obj: PrometheusSpecRemoteWriteTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCertConfigMap
 */
export interface PrometheusSpecRemoteWriteTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCertConfigMap(
  obj: PrometheusSpecRemoteWriteTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecRemoteWriteTlsConfigCertSecret
 */
export interface PrometheusSpecRemoteWriteTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecRemoteWriteTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecRemoteWriteTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecRemoteWriteTlsConfigCertSecret(
  obj: PrometheusSpecRemoteWriteTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?:
    PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?:
    PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?:
    PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec(
  obj: PrometheusSpecStorageEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource":
      toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(
        obj.dataSource,
      ),
    "dataSourceRef":
      toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources":
      toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources(
        obj.resources,
      ),
    "selector":
      toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector(
        obj.selector,
      ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSource
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpecDataSource(
  obj: PrometheusSpecStorageVolumeClaimTemplateSpecDataSource | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef(
  obj: PrometheusSpecStorageVolumeClaimTemplateSpecDataSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResources
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    PrometheusSpecStorageVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]: PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpecResources(
  obj: PrometheusSpecStorageVolumeClaimTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusSpecStorageVolumeClaimTemplateSpecResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelector
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpecSelector(
  obj: PrometheusSpecStorageVolumeClaimTemplateSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(
    value: number,
  ): PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new PrometheusSpecStorageVolumeClaimTemplateStatusAllocatedResources(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecStorageVolumeClaimTemplateStatusCapacity
 */
export class PrometheusSpecStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(
    value: number,
  ): PrometheusSpecStorageVolumeClaimTemplateStatusCapacity {
    return new PrometheusSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecStorageVolumeClaimTemplateStatusCapacity {
    return new PrometheusSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions
 */
export interface PrometheusSpecStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports "ResizeStarted" that means the underlying persistent volume is being resized.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateStatusConditions(
  obj: PrometheusSpecStorageVolumeClaimTemplateStatusConditions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "lastProbeTime": obj.lastProbeTime?.toISOString(),
    "lastTransitionTime": obj.lastTransitionTime?.toISOString(),
    "message": obj.message,
    "reason": obj.reason,
    "status": obj.status,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap(
  obj: PrometheusSpecThanosGrpcServerTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCaSecret
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCaSecret(
  obj: PrometheusSpecThanosGrpcServerTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap(
  obj: PrometheusSpecThanosGrpcServerTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecThanosGrpcServerTlsConfigCertSecret
 */
export interface PrometheusSpecThanosGrpcServerTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecThanosGrpcServerTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecThanosGrpcServerTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecThanosGrpcServerTlsConfigCertSecret(
  obj: PrometheusSpecThanosGrpcServerTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCaConfigMap
 */
export interface PrometheusSpecTracingConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCaConfigMap(
  obj: PrometheusSpecTracingConfigTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCaSecret
 */
export interface PrometheusSpecTracingConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCaSecret(
  obj: PrometheusSpecTracingConfigTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCertConfigMap
 */
export interface PrometheusSpecTracingConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCertConfigMap(
  obj: PrometheusSpecTracingConfigTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecTracingConfigTlsConfigCertSecret
 */
export interface PrometheusSpecTracingConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecTracingConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecTracingConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecTracingConfigTlsConfigCertSecret(
  obj: PrometheusSpecTracingConfigTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema PrometheusSpecVolumesDownwardApiItemsFieldRef
 */
export interface PrometheusSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesDownwardApiItemsFieldRef(
  obj: PrometheusSpecVolumesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema PrometheusSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface PrometheusSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?:
    PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesDownwardApiItemsResourceFieldRef(
  obj: PrometheusSpecVolumesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?:
    PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?:
    PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?:
    PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec(
  obj: PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource":
      toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
        obj.dataSource,
      ),
    "dataSourceRef":
      toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources":
      toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
        obj.resources,
      ),
    "selector":
      toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
        obj.selector,
      ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema PrometheusSpecVolumesProjectedSourcesConfigMap
 */
export interface PrometheusSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: PrometheusSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesConfigMap(
  obj: PrometheusSpecVolumesProjectedSourcesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_PrometheusSpecVolumesProjectedSourcesConfigMapItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema PrometheusSpecVolumesProjectedSourcesDownwardApi
 */
export interface PrometheusSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: PrometheusSpecVolumesProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesDownwardApi(
  obj: PrometheusSpecVolumesProjectedSourcesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItems(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema PrometheusSpecVolumesProjectedSourcesSecret
 */
export interface PrometheusSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: PrometheusSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesSecret(
  obj: PrometheusSpecVolumesProjectedSourcesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_PrometheusSpecVolumesProjectedSourcesSecretItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema PrometheusSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface PrometheusSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema PrometheusSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the token into.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesServiceAccountToken(
  obj: PrometheusSpecVolumesProjectedSourcesServiceAccountToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "audience": obj.audience,
    "expirationSeconds": obj.expirationSeconds,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Set the X-Content-Type-Options header to HTTP responses. Unset if blank. Accepted value is nosniff. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
 *
 * @schema PrometheusSpecWebHttpConfigHeadersXContentTypeOptions
 */
export enum PrometheusSpecWebHttpConfigHeadersXContentTypeOptions {
  /** NoSniff */
  NO_SNIFF = "NoSniff",
}

/**
 * Set the X-Frame-Options header to HTTP responses. Unset if blank. Accepted values are deny and sameorigin. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
 *
 * @schema PrometheusSpecWebHttpConfigHeadersXFrameOptions
 */
export enum PrometheusSpecWebHttpConfigHeadersXFrameOptions {
  /** Deny */
  DENY = "Deny",
  /** SameOrigin */
  SAME_ORIGIN = "SameOrigin",
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecWebTlsConfigCertConfigMap
 */
export interface PrometheusSpecWebTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecWebTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecWebTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecWebTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigCertConfigMap(
  obj: PrometheusSpecWebTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecWebTlsConfigCertSecret
 */
export interface PrometheusSpecWebTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecWebTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecWebTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecWebTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigCertSecret(
  obj: PrometheusSpecWebTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecWebTlsConfigClientCaConfigMap
 */
export interface PrometheusSpecWebTlsConfigClientCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecWebTlsConfigClientCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecWebTlsConfigClientCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecWebTlsConfigClientCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigClientCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigClientCaConfigMap(
  obj: PrometheusSpecWebTlsConfigClientCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecWebTlsConfigClientCaSecret
 */
export interface PrometheusSpecWebTlsConfigClientCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecWebTlsConfigClientCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecWebTlsConfigClientCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecWebTlsConfigClientCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecWebTlsConfigClientCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecWebTlsConfigClientCaSecret(
  obj: PrometheusSpecWebTlsConfigClientCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | PrometheusSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | PrometheusSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap(
  obj: PrometheusSpecAlertingAlertmanagersTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret(
  obj: PrometheusSpecAlertingAlertmanagersTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap(
  obj: PrometheusSpecAlertingAlertmanagersTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret
 */
export interface PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret(
  obj: PrometheusSpecAlertingAlertmanagersTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusSpecContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders(
  obj: PrometheusSpecContainersLifecyclePostStartHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLifecyclePostStartHttpGetPort
 */
export class PrometheusSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersLifecyclePostStartHttpGetPort {
    return new PrometheusSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersLifecyclePostStartHttpGetPort {
    return new PrometheusSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLifecyclePostStartTcpSocketPort
 */
export class PrometheusSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: PrometheusSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLifecyclePreStopHttpGetPort
 */
export class PrometheusSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersLifecyclePreStopHttpGetPort {
    return new PrometheusSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersLifecyclePreStopHttpGetPort {
    return new PrometheusSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecContainersLifecyclePreStopTcpSocketPort
 */
export class PrometheusSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusSpecInitContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
  obj:
    | PrometheusSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class PrometheusSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PrometheusSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PrometheusSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusSpecInitContainersLifecyclePostStartTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(
  obj:
    | PrometheusSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class PrometheusSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PrometheusSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PrometheusSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(
  obj:
    | PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSource
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj:
    | PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]:
      PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources(
  obj:
    | PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResources
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims(
        y,
      )
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector(
  obj:
    | PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResourcesClaims
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpecResourcesClaims(
  obj: PrometheusSpecStorageVolumeClaimTemplateSpecResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecStorageVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecStorageVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | PrometheusSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusSpecVolumesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
  obj:
    | PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj:
    | PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]:
      PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
  obj:
    | PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResources
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims(
        y,
      )
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
  obj:
    | PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusSpecVolumesProjectedSourcesConfigMapItems
 */
export interface PrometheusSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesConfigMapItems(
  obj: PrometheusSpecVolumesProjectedSourcesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface PrometheusSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?:
    PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?:
    PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItems(
  obj: PrometheusSpecVolumesProjectedSourcesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fieldRef":
      toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
        obj.fieldRef,
      ),
    "mode": obj.mode,
    "path": obj.path,
    "resourceFieldRef":
      toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
        obj.resourceFieldRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusSpecVolumesProjectedSourcesSecretItems
 */
export interface PrometheusSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesSecretItems(
  obj: PrometheusSpecVolumesProjectedSourcesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims(
  obj:
    | PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | PrometheusSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims(
  obj:
    | PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | PrometheusSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
  obj:
    | PrometheusSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?:
    PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
  obj:
    | PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PrometheusAgent defines a Prometheus agent deployment.
 *
 * @schema PrometheusAgent
 */
export class PrometheusAgent extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PrometheusAgent"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "monitoring.coreos.com/v1alpha1",
    kind: "PrometheusAgent",
  };

  /**
   * Renders a Kubernetes manifest for "PrometheusAgent".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PrometheusAgentProps): any {
    return {
      ...PrometheusAgent.GVK,
      ...toJson_PrometheusAgentProps(props),
    };
  }

  /**
   * Defines a "PrometheusAgent" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: PrometheusAgentProps,
  ) {
    super(scope, id, {
      ...PrometheusAgent.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PrometheusAgent.GVK,
      ...toJson_PrometheusAgentProps(resolved),
    };
  }
}

/**
 * PrometheusAgent defines a Prometheus agent deployment.
 *
 * @schema PrometheusAgent
 */
export interface PrometheusAgentProps {
  /**
   * @schema PrometheusAgent#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the Prometheus agent. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema PrometheusAgent#spec
   */
  readonly spec: PrometheusAgentSpec;
}

/**
 * Converts an object of type 'PrometheusAgentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentProps(
  obj: PrometheusAgentProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_PrometheusAgentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired behavior of the Prometheus agent. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema PrometheusAgentSpec
 */
export interface PrometheusAgentSpec {
  /**
   * AdditionalArgs allows setting additional arguments for the 'prometheus' container.
   * It is intended for e.g. activating hidden flags which are not supported by the dedicated configuration options yet. The arguments are passed as-is to the Prometheus container which may cause issues if they are invalid or not supported by the given Prometheus version.
   * In case of an argument conflict (e.g. an argument which is already set by the operator itself) or when providing an invalid argument, the reconciliation will fail and an error will be logged.
   *
   * @schema PrometheusAgentSpec#additionalArgs
   */
  readonly additionalArgs?: PrometheusAgentSpecAdditionalArgs[];

  /**
   * AdditionalScrapeConfigs allows specifying a key of a Secret containing additional Prometheus scrape configurations. Scrape configurations specified are appended to the configurations generated by the Prometheus Operator. Job configurations specified must have the form as specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config. As scrape configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible scrape configs are going to break Prometheus after the upgrade.
   *
   * @schema PrometheusAgentSpec#additionalScrapeConfigs
   */
  readonly additionalScrapeConfigs?: PrometheusAgentSpecAdditionalScrapeConfigs;

  /**
   * Defines the Pods' affinity scheduling rules if specified.
   *
   * @schema PrometheusAgentSpec#affinity
   */
  readonly affinity?: PrometheusAgentSpecAffinity;

  /**
   * APIServerConfig allows specifying a host and auth methods to access the Kuberntees API server. If null, Prometheus is assumed to run inside of the cluster: it will discover the API servers automatically and use the Pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
   *
   * @schema PrometheusAgentSpec#apiserverConfig
   */
  readonly apiserverConfig?: PrometheusAgentSpecApiserverConfig;

  /**
   * When true, ServiceMonitor, PodMonitor and Probe object are forbidden to reference arbitrary files on the file system of the 'prometheus' container. When a ServiceMonitor's endpoint specifies a `bearerTokenFile` value (e.g.  '/var/run/secrets/kubernetes.io/serviceaccount/token'), a malicious target can get access to the Prometheus service account's token in the Prometheus' scrape request. Setting `spec.arbitraryFSAccessThroughSM` to 'true' would prevent the attack. Users should instead provide the credentials using the `spec.bearerTokenSecret` field.
   *
   * @schema PrometheusAgentSpec#arbitraryFSAccessThroughSMs
   */
  readonly arbitraryFsAccessThroughSMs?:
    PrometheusAgentSpecArbitraryFsAccessThroughSMs;

  /**
   * BodySizeLimit defines per-scrape on response body size. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusAgentSpec#bodySizeLimit
   */
  readonly bodySizeLimit?: string;

  /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus object, which shall be mounted into the Prometheus Pods. Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`. The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name> in the 'prometheus' container.
   *
   * @schema PrometheusAgentSpec#configMaps
   */
  readonly configMaps?: string[];

  /**
   * Containers allows injecting additional containers or modifying operator generated containers. This can be used to allow adding an authentication proxy to the Pods or to change the behavior of an operator generated container. Containers described here modify an operator generated container if they share the same name and modifications are done via a strategic merge patch.
   * The names of containers managed by the operator are: * `prometheus` * `config-reloader` * `thanos-sidecar`
   * Overriding containers is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   *
   * @schema PrometheusAgentSpec#containers
   */
  readonly containers?: PrometheusAgentSpecContainers[];

  /**
   * Enable access to Prometheus feature flags. By default, no features are enabled.
   * Enabling features which are disabled by default is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   * For more information see https://prometheus.io/docs/prometheus/latest/feature_flags/
   *
   * @schema PrometheusAgentSpec#enableFeatures
   */
  readonly enableFeatures?: string[];

  /**
   * Enable Prometheus to be used as a receiver for the Prometheus remote write protocol.
   * WARNING: This is not considered an efficient way of ingesting samples. Use it with caution for specific low-volume use cases. It is not suitable for replacing the ingestion via scraping and turning Prometheus into a push-based metrics collection system. For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#remote-write-receiver
   * It requires Prometheus >= v2.33.0.
   *
   * @schema PrometheusAgentSpec#enableRemoteWriteReceiver
   */
  readonly enableRemoteWriteReceiver?: boolean;

  /**
   * When defined, enforcedBodySizeLimit specifies a global limit on the size of uncompressed response body that will be accepted by Prometheus. Targets responding with a body larger than this many bytes will cause the scrape to fail.
   * It requires Prometheus >= v2.28.0.
   *
   * @schema PrometheusAgentSpec#enforcedBodySizeLimit
   */
  readonly enforcedBodySizeLimit?: string;

  /**
   * When defined, enforcedKeepDroppedTargets specifies a global limit on the number of targets dropped by relabeling that will be kept in memory. The value overrides any `spec.keepDroppedTargets` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.keepDroppedTargets` is greater than zero and less than `spec.enforcedKeepDroppedTargets`.
   * It requires Prometheus >= v2.47.0.
   *
   * @schema PrometheusAgentSpec#enforcedKeepDroppedTargets
   */
  readonly enforcedKeepDroppedTargets?: number;

  /**
   * When defined, enforcedLabelLimit specifies a global limit on the number of labels per sample. The value overrides any `spec.labelLimit` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.labelLimit` is greater than zero and less than `spec.enforcedLabelLimit`.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusAgentSpec#enforcedLabelLimit
   */
  readonly enforcedLabelLimit?: number;

  /**
   * When defined, enforcedLabelNameLengthLimit specifies a global limit on the length of labels name per sample. The value overrides any `spec.labelNameLengthLimit` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.labelNameLengthLimit` is greater than zero and less than `spec.enforcedLabelNameLengthLimit`.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusAgentSpec#enforcedLabelNameLengthLimit
   */
  readonly enforcedLabelNameLengthLimit?: number;

  /**
   * When not null, enforcedLabelValueLengthLimit defines a global limit on the length of labels value per sample. The value overrides any `spec.labelValueLengthLimit` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.labelValueLengthLimit` is greater than zero and less than `spec.enforcedLabelValueLengthLimit`.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusAgentSpec#enforcedLabelValueLengthLimit
   */
  readonly enforcedLabelValueLengthLimit?: number;

  /**
   * When not empty, a label will be added to
   * 1. All metrics scraped from `ServiceMonitor`, `PodMonitor`, `Probe` and `ScrapeConfig` objects. 2. All metrics generated from recording rules defined in `PrometheusRule` objects. 3. All alerts generated from alerting rules defined in `PrometheusRule` objects. 4. All vector selectors of PromQL expressions defined in `PrometheusRule` objects.
   * The label will not added for objects referenced in `spec.excludedFromEnforcement`.
   * The label's name is this field's value. The label's value is the namespace of the `ServiceMonitor`, `PodMonitor`, `Probe` or `PrometheusRule` object.
   *
   * @schema PrometheusAgentSpec#enforcedNamespaceLabel
   */
  readonly enforcedNamespaceLabel?: string;

  /**
   * When defined, enforcedSampleLimit specifies a global limit on the number of scraped samples that will be accepted. This overrides any `spec.sampleLimit` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.sampleLimit` is greater than zero and less than than `spec.enforcedSampleLimit`.
   * It is meant to be used by admins to keep the overall number of samples/series under a desired limit.
   *
   * @schema PrometheusAgentSpec#enforcedSampleLimit
   */
  readonly enforcedSampleLimit?: number;

  /**
   * When defined, enforcedTargetLimit specifies a global limit on the number of scraped targets. The value overrides any `spec.targetLimit` set by ServiceMonitor, PodMonitor, Probe objects unless `spec.targetLimit` is greater than zero and less than `spec.enforcedTargetLimit`.
   * It is meant to be used by admins to to keep the overall number of targets under a desired limit.
   *
   * @schema PrometheusAgentSpec#enforcedTargetLimit
   */
  readonly enforcedTargetLimit?: number;

  /**
   * List of references to PodMonitor, ServiceMonitor, Probe and PrometheusRule objects to be excluded from enforcing a namespace label of origin.
   * It is only applicable if `spec.enforcedNamespaceLabel` set to true.
   *
   * @schema PrometheusAgentSpec#excludedFromEnforcement
   */
  readonly excludedFromEnforcement?:
    PrometheusAgentSpecExcludedFromEnforcement[];

  /**
   * The labels to add to any time series or alerts when communicating with external systems (federation, remote storage, Alertmanager). Labels defined by `spec.replicaExternalLabelName` and `spec.prometheusExternalLabelName` take precedence over this list.
   *
   * @schema PrometheusAgentSpec#externalLabels
   */
  readonly externalLabels?: { [key: string]: string };

  /**
   * The external URL under which the Prometheus service is externally available. This is necessary to generate correct URLs (for instance if Prometheus is accessible behind an Ingress resource).
   *
   * @schema PrometheusAgentSpec#externalUrl
   */
  readonly externalUrl?: string;

  /**
   * Optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema PrometheusAgentSpec#hostAliases
   */
  readonly hostAliases?: PrometheusAgentSpecHostAliases[];

  /**
   * Use the host's network namespace if true.
   * Make sure to understand the security implications if you want to enable it (https://kubernetes.io/docs/concepts/configuration/overview/).
   * When hostNetwork is enabled, this will set the DNS policy to `ClusterFirstWithHostNet` automatically.
   *
   * @schema PrometheusAgentSpec#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * When true, `spec.namespaceSelector` from all PodMonitor, ServiceMonitor and Probe objects will be ignored. They will only discover targets within the namespace of the PodMonitor, ServiceMonitor and Probe object.
   *
   * @schema PrometheusAgentSpec#ignoreNamespaceSelectors
   */
  readonly ignoreNamespaceSelectors?: boolean;

  /**
   * Container image name for Prometheus. If specified, it takes precedence over the `spec.baseImage`, `spec.tag` and `spec.sha` fields.
   * Specifying `spec.version` is still necessary to ensure the Prometheus Operator knows which version of Prometheus is being configured.
   * If neither `spec.image` nor `spec.baseImage` are defined, the operator will use the latest upstream version of Prometheus available at the time when the operator was released.
   *
   * @schema PrometheusAgentSpec#image
   */
  readonly image?: string;

  /**
   * Image pull policy for the 'prometheus', 'init-config-reloader' and 'config-reloader' containers. See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
   *
   * @schema PrometheusAgentSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: PrometheusAgentSpecImagePullPolicy;

  /**
   * An optional list of references to Secrets in the same namespace to use for pulling images from registries. See http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema PrometheusAgentSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: PrometheusAgentSpecImagePullSecrets[];

  /**
   * InitContainers allows injecting initContainers to the Pod definition. Those can be used to e.g.  fetch secrets for injection into the Prometheus configuration from external sources. Any errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ InitContainers described here modify an operator generated init containers if they share the same name and modifications are done via a strategic merge patch.
   * The names of init container name managed by the operator are: * `init-config-reloader`.
   * Overriding init containers is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   *
   * @schema PrometheusAgentSpec#initContainers
   */
  readonly initContainers?: PrometheusAgentSpecInitContainers[];

  /**
   * Per-scrape limit on the number of targets dropped by relabeling that will be kept in memory. 0 means no limit.
   * It requires Prometheus >= v2.47.0.
   *
   * @schema PrometheusAgentSpec#keepDroppedTargets
   */
  readonly keepDroppedTargets?: number;

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusAgentSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusAgentSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusAgentSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * When true, the Prometheus server listens on the loopback address instead of the Pod IP's address.
   *
   * @schema PrometheusAgentSpec#listenLocal
   */
  readonly listenLocal?: boolean;

  /**
   * Log format for Log level for Prometheus and the config-reloader sidecar.
   *
   * @schema PrometheusAgentSpec#logFormat
   */
  readonly logFormat?: PrometheusAgentSpecLogFormat;

  /**
   * Log level for Prometheus and the config-reloader sidecar.
   *
   * @schema PrometheusAgentSpec#logLevel
   */
  readonly logLevel?: PrometheusAgentSpecLogLevel;

  /**
   * Defines the maximum time that the `prometheus` container's startup probe will wait before being considered failed. The startup probe will return success after the WAL replay is complete. If set, the value should be greater than 60 (seconds). Otherwise it will be equal to 600 seconds (15 minutes).
   *
   * @schema PrometheusAgentSpec#maximumStartupDurationSeconds
   */
  readonly maximumStartupDurationSeconds?: number;

  /**
   * Minimum number of seconds for which a newly created Pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
   * This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
   *
   * @default 0 (pod will be considered available as soon as it is ready)
   * @schema PrometheusAgentSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * Defines on which Nodes the Pods are scheduled.
   *
   * @schema PrometheusAgentSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * When true, Prometheus resolves label conflicts by renaming the labels in the scraped data to "exported_<label value>" for all targets created from service and pod monitors. Otherwise the HonorLabels field of the service or pod monitor applies.
   *
   * @schema PrometheusAgentSpec#overrideHonorLabels
   */
  readonly overrideHonorLabels?: boolean;

  /**
   * When true, Prometheus ignores the timestamps for all the targets created from service and pod monitors. Otherwise the HonorTimestamps field of the service or pod monitor applies.
   *
   * @schema PrometheusAgentSpec#overrideHonorTimestamps
   */
  readonly overrideHonorTimestamps?: boolean;

  /**
   * When a Prometheus deployment is paused, no actions except for deletion will be performed on the underlying objects.
   *
   * @schema PrometheusAgentSpec#paused
   */
  readonly paused?: boolean;

  /**
   * The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet. The default behavior is all PVCs are retained. This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26. It requires enabling the StatefulSetAutoDeletePVC feature gate.
   *
   * @schema PrometheusAgentSpec#persistentVolumeClaimRetentionPolicy
   */
  readonly persistentVolumeClaimRetentionPolicy?:
    PrometheusAgentSpecPersistentVolumeClaimRetentionPolicy;

  /**
   * PodMetadata configures labels and annotations which are propagated to the Prometheus pods.
   * The following items are reserved and cannot be overridden: * "prometheus" label, set to the name of the Prometheus object. * "app.kubernetes.io/instance" label, set to the name of the Prometheus object. * "app.kubernetes.io/managed-by" label, set to "prometheus-operator". * "app.kubernetes.io/name" label, set to "prometheus". * "app.kubernetes.io/version" label, set to the Prometheus version. * "operator.prometheus.io/name" label, set to the name of the Prometheus object. * "operator.prometheus.io/shard" label, set to the shard number of the Prometheus object. * "kubectl.kubernetes.io/default-container" annotation, set to "prometheus".
   *
   * @schema PrometheusAgentSpec#podMetadata
   */
  readonly podMetadata?: PrometheusAgentSpecPodMetadata;

  /**
   * Namespaces to match for PodMonitors discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
   *
   * @schema PrometheusAgentSpec#podMonitorNamespaceSelector
   */
  readonly podMonitorNamespaceSelector?:
    PrometheusAgentSpecPodMonitorNamespaceSelector;

  /**
   * *Experimental* PodMonitors to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
   *
   * @schema PrometheusAgentSpec#podMonitorSelector
   */
  readonly podMonitorSelector?: PrometheusAgentSpecPodMonitorSelector;

  /**
   * PodTargetLabels are appended to the `spec.podTargetLabels` field of all PodMonitor and ServiceMonitor objects.
   *
   * @schema PrometheusAgentSpec#podTargetLabels
   */
  readonly podTargetLabels?: string[];

  /**
   * Port name used for the pods and governing service. Default: "web"
   *
   * @schema PrometheusAgentSpec#portName
   */
  readonly portName?: string;

  /**
   * Priority class assigned to the Pods.
   *
   * @schema PrometheusAgentSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * *Experimental* Namespaces to match for Probe discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
   *
   * @schema PrometheusAgentSpec#probeNamespaceSelector
   */
  readonly probeNamespaceSelector?: PrometheusAgentSpecProbeNamespaceSelector;

  /**
   * *Experimental* Probes to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
   *
   * @schema PrometheusAgentSpec#probeSelector
   */
  readonly probeSelector?: PrometheusAgentSpecProbeSelector;

  /**
   * Name of Prometheus external label used to denote the Prometheus instance name. The external label will _not_ be added when the field is set to the empty string (`""`).
   * Default: "prometheus"
   *
   * @schema PrometheusAgentSpec#prometheusExternalLabelName
   */
  readonly prometheusExternalLabelName?: string;

  /**
   * Defines the strategy used to reload the Prometheus configuration. If not specified, the configuration is reloaded using the /-/reload HTTP endpoint.
   *
   * @schema PrometheusAgentSpec#reloadStrategy
   */
  readonly reloadStrategy?: PrometheusAgentSpecReloadStrategy;

  /**
   * Defines the list of remote write configurations.
   *
   * @schema PrometheusAgentSpec#remoteWrite
   */
  readonly remoteWrite?: PrometheusAgentSpecRemoteWrite[];

  /**
   * Name of Prometheus external label used to denote the replica name. The external label will _not_ be added when the field is set to the empty string (`""`).
   * Default: "prometheus_replica"
   *
   * @schema PrometheusAgentSpec#replicaExternalLabelName
   */
  readonly replicaExternalLabelName?: string;

  /**
   * Number of replicas of each shard to deploy for a Prometheus deployment. `spec.replicas` multiplied by `spec.shards` is the total number of Pods created.
   * Default: 1
   *
   * @schema PrometheusAgentSpec#replicas
   */
  readonly replicas?: number;

  /**
   * Defines the resources requests and limits of the 'prometheus' container.
   *
   * @schema PrometheusAgentSpec#resources
   */
  readonly resources?: PrometheusAgentSpecResources;

  /**
   * The route prefix Prometheus registers HTTP handlers for.
   * This is useful when using `spec.externalURL`, and a proxy is rewriting HTTP routes of a request, and the actual ExternalURL is still true, but the server serves requests under a different route prefix. For example for use with `kubectl proxy`.
   *
   * @schema PrometheusAgentSpec#routePrefix
   */
  readonly routePrefix?: string;

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusAgentSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * Namespaces to match for ScrapeConfig discovery. An empty label selector matches all namespaces. A null label selector matches the current current namespace only.
   *
   * @schema PrometheusAgentSpec#scrapeConfigNamespaceSelector
   */
  readonly scrapeConfigNamespaceSelector?:
    PrometheusAgentSpecScrapeConfigNamespaceSelector;

  /**
   * *Experimental* ScrapeConfigs to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
   *
   * @schema PrometheusAgentSpec#scrapeConfigSelector
   */
  readonly scrapeConfigSelector?: PrometheusAgentSpecScrapeConfigSelector;

  /**
   * Interval between consecutive scrapes.
   * Default: "30s"
   *
   * @schema PrometheusAgentSpec#scrapeInterval
   */
  readonly scrapeInterval?: string;

  /**
   * Number of seconds to wait until a scrape request times out.
   *
   * @schema PrometheusAgentSpec#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * Secrets is a list of Secrets in the same namespace as the Prometheus object, which shall be mounted into the Prometheus Pods. Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`. The Secrets are mounted into /etc/prometheus/secrets/<secret-name> in the 'prometheus' container.
   *
   * @schema PrometheusAgentSpec#secrets
   */
  readonly secrets?: string[];

  /**
   * SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.
   *
   * @schema PrometheusAgentSpec#securityContext
   */
  readonly securityContext?: PrometheusAgentSpecSecurityContext;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the Prometheus Pods.
   *
   * @schema PrometheusAgentSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Namespaces to match for ServicedMonitors discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
   *
   * @schema PrometheusAgentSpec#serviceMonitorNamespaceSelector
   */
  readonly serviceMonitorNamespaceSelector?:
    PrometheusAgentSpecServiceMonitorNamespaceSelector;

  /**
   * ServiceMonitors to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
   * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
   *
   * @schema PrometheusAgentSpec#serviceMonitorSelector
   */
  readonly serviceMonitorSelector?: PrometheusAgentSpecServiceMonitorSelector;

  /**
   * EXPERIMENTAL: Number of shards to distribute targets onto. `spec.replicas` multiplied by `spec.shards` is the total number of Pods created.
   * Note that scaling down shards will not reshard data onto remaining instances, it must be manually moved. Increasing shards will not reshard data either but it will continue to be available from the same instances. To query globally, use Thanos sidecar and Thanos querier or remote write data to a central location.
   * Sharding is performed on the content of the `__address__` target meta-label for PodMonitors and ServiceMonitors and `__param_target__` for Probes.
   * Default: 1
   *
   * @schema PrometheusAgentSpec#shards
   */
  readonly shards?: number;

  /**
   * Storage defines the storage used by Prometheus.
   *
   * @schema PrometheusAgentSpec#storage
   */
  readonly storage?: PrometheusAgentSpecStorage;

  /**
   * TargetLimit defines a limit on the number of scraped targets that will be accepted. Only valid in Prometheus versions 2.45.0 and newer.
   *
   * @schema PrometheusAgentSpec#targetLimit
   */
  readonly targetLimit?: number;

  /**
   * Defines the Pods' tolerations if specified.
   *
   * @schema PrometheusAgentSpec#tolerations
   */
  readonly tolerations?: PrometheusAgentSpecTolerations[];

  /**
   * Defines the pod's topology spread constraints if specified.
   *
   * @schema PrometheusAgentSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?:
    PrometheusAgentSpecTopologySpreadConstraints[];

  /**
   * EXPERIMENTAL: TracingConfig configures tracing in Prometheus. This is an experimental feature, it may change in any upcoming release in a breaking way.
   *
   * @schema PrometheusAgentSpec#tracingConfig
   */
  readonly tracingConfig?: PrometheusAgentSpecTracingConfig;

  /**
   * Version of Prometheus being deployed. The operator uses this information to generate the Prometheus StatefulSet + configuration files.
   * If not specified, the operator assumes the latest upstream version of Prometheus available at the time when the version of the operator was released.
   *
   * @schema PrometheusAgentSpec#version
   */
  readonly version?: string;

  /**
   * VolumeMounts allows the configuration of additional VolumeMounts.
   * VolumeMounts will be appended to other VolumeMounts in the 'prometheus' container, that are generated as a result of StorageSpec objects.
   *
   * @schema PrometheusAgentSpec#volumeMounts
   */
  readonly volumeMounts?: PrometheusAgentSpecVolumeMounts[];

  /**
   * Volumes allows the configuration of additional volumes on the output StatefulSet definition. Volumes specified will be appended to other volumes that are generated as a result of StorageSpec objects.
   *
   * @schema PrometheusAgentSpec#volumes
   */
  readonly volumes?: PrometheusAgentSpecVolumes[];

  /**
   * Configures compression of the write-ahead log (WAL) using Snappy.
   * WAL compression is enabled by default for Prometheus >= 2.20.0
   * Requires Prometheus v2.11.0 and above.
   *
   * @schema PrometheusAgentSpec#walCompression
   */
  readonly walCompression?: boolean;

  /**
   * Defines the configuration of the Prometheus web server.
   *
   * @schema PrometheusAgentSpec#web
   */
  readonly web?: PrometheusAgentSpecWeb;
}

/**
 * Converts an object of type 'PrometheusAgentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpec(
  obj: PrometheusAgentSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "additionalArgs": obj.additionalArgs?.map((y) =>
      toJson_PrometheusAgentSpecAdditionalArgs(y)
    ),
    "additionalScrapeConfigs":
      toJson_PrometheusAgentSpecAdditionalScrapeConfigs(
        obj.additionalScrapeConfigs,
      ),
    "affinity": toJson_PrometheusAgentSpecAffinity(obj.affinity),
    "apiserverConfig": toJson_PrometheusAgentSpecApiserverConfig(
      obj.apiserverConfig,
    ),
    "arbitraryFSAccessThroughSMs":
      toJson_PrometheusAgentSpecArbitraryFsAccessThroughSMs(
        obj.arbitraryFsAccessThroughSMs,
      ),
    "bodySizeLimit": obj.bodySizeLimit,
    "configMaps": obj.configMaps?.map((y) => y),
    "containers": obj.containers?.map((y) =>
      toJson_PrometheusAgentSpecContainers(y)
    ),
    "enableFeatures": obj.enableFeatures?.map((y) => y),
    "enableRemoteWriteReceiver": obj.enableRemoteWriteReceiver,
    "enforcedBodySizeLimit": obj.enforcedBodySizeLimit,
    "enforcedKeepDroppedTargets": obj.enforcedKeepDroppedTargets,
    "enforcedLabelLimit": obj.enforcedLabelLimit,
    "enforcedLabelNameLengthLimit": obj.enforcedLabelNameLengthLimit,
    "enforcedLabelValueLengthLimit": obj.enforcedLabelValueLengthLimit,
    "enforcedNamespaceLabel": obj.enforcedNamespaceLabel,
    "enforcedSampleLimit": obj.enforcedSampleLimit,
    "enforcedTargetLimit": obj.enforcedTargetLimit,
    "excludedFromEnforcement": obj.excludedFromEnforcement?.map((y) =>
      toJson_PrometheusAgentSpecExcludedFromEnforcement(y)
    ),
    "externalLabels": ((obj.externalLabels) === undefined)
      ? undefined
      : (Object.entries(obj.externalLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "externalUrl": obj.externalUrl,
    "hostAliases": obj.hostAliases?.map((y) =>
      toJson_PrometheusAgentSpecHostAliases(y)
    ),
    "hostNetwork": obj.hostNetwork,
    "ignoreNamespaceSelectors": obj.ignoreNamespaceSelectors,
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "imagePullSecrets": obj.imagePullSecrets?.map((y) =>
      toJson_PrometheusAgentSpecImagePullSecrets(y)
    ),
    "initContainers": obj.initContainers?.map((y) =>
      toJson_PrometheusAgentSpecInitContainers(y)
    ),
    "keepDroppedTargets": obj.keepDroppedTargets,
    "labelLimit": obj.labelLimit,
    "labelNameLengthLimit": obj.labelNameLengthLimit,
    "labelValueLengthLimit": obj.labelValueLengthLimit,
    "listenLocal": obj.listenLocal,
    "logFormat": obj.logFormat,
    "logLevel": obj.logLevel,
    "maximumStartupDurationSeconds": obj.maximumStartupDurationSeconds,
    "minReadySeconds": obj.minReadySeconds,
    "nodeSelector": ((obj.nodeSelector) === undefined)
      ? undefined
      : (Object.entries(obj.nodeSelector).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "overrideHonorLabels": obj.overrideHonorLabels,
    "overrideHonorTimestamps": obj.overrideHonorTimestamps,
    "paused": obj.paused,
    "persistentVolumeClaimRetentionPolicy":
      toJson_PrometheusAgentSpecPersistentVolumeClaimRetentionPolicy(
        obj.persistentVolumeClaimRetentionPolicy,
      ),
    "podMetadata": toJson_PrometheusAgentSpecPodMetadata(obj.podMetadata),
    "podMonitorNamespaceSelector":
      toJson_PrometheusAgentSpecPodMonitorNamespaceSelector(
        obj.podMonitorNamespaceSelector,
      ),
    "podMonitorSelector": toJson_PrometheusAgentSpecPodMonitorSelector(
      obj.podMonitorSelector,
    ),
    "podTargetLabels": obj.podTargetLabels?.map((y) => y),
    "portName": obj.portName,
    "priorityClassName": obj.priorityClassName,
    "probeNamespaceSelector": toJson_PrometheusAgentSpecProbeNamespaceSelector(
      obj.probeNamespaceSelector,
    ),
    "probeSelector": toJson_PrometheusAgentSpecProbeSelector(obj.probeSelector),
    "prometheusExternalLabelName": obj.prometheusExternalLabelName,
    "reloadStrategy": obj.reloadStrategy,
    "remoteWrite": obj.remoteWrite?.map((y) =>
      toJson_PrometheusAgentSpecRemoteWrite(y)
    ),
    "replicaExternalLabelName": obj.replicaExternalLabelName,
    "replicas": obj.replicas,
    "resources": toJson_PrometheusAgentSpecResources(obj.resources),
    "routePrefix": obj.routePrefix,
    "sampleLimit": obj.sampleLimit,
    "scrapeConfigNamespaceSelector":
      toJson_PrometheusAgentSpecScrapeConfigNamespaceSelector(
        obj.scrapeConfigNamespaceSelector,
      ),
    "scrapeConfigSelector": toJson_PrometheusAgentSpecScrapeConfigSelector(
      obj.scrapeConfigSelector,
    ),
    "scrapeInterval": obj.scrapeInterval,
    "scrapeTimeout": obj.scrapeTimeout,
    "secrets": obj.secrets?.map((y) => y),
    "securityContext": toJson_PrometheusAgentSpecSecurityContext(
      obj.securityContext,
    ),
    "serviceAccountName": obj.serviceAccountName,
    "serviceMonitorNamespaceSelector":
      toJson_PrometheusAgentSpecServiceMonitorNamespaceSelector(
        obj.serviceMonitorNamespaceSelector,
      ),
    "serviceMonitorSelector": toJson_PrometheusAgentSpecServiceMonitorSelector(
      obj.serviceMonitorSelector,
    ),
    "shards": obj.shards,
    "storage": toJson_PrometheusAgentSpecStorage(obj.storage),
    "targetLimit": obj.targetLimit,
    "tolerations": obj.tolerations?.map((y) =>
      toJson_PrometheusAgentSpecTolerations(y)
    ),
    "topologySpreadConstraints": obj.topologySpreadConstraints?.map((y) =>
      toJson_PrometheusAgentSpecTopologySpreadConstraints(y)
    ),
    "tracingConfig": toJson_PrometheusAgentSpecTracingConfig(obj.tracingConfig),
    "version": obj.version,
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_PrometheusAgentSpecVolumeMounts(y)
    ),
    "volumes": obj.volumes?.map((y) => toJson_PrometheusAgentSpecVolumes(y)),
    "walCompression": obj.walCompression,
    "web": toJson_PrometheusAgentSpecWeb(obj.web),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Argument as part of the AdditionalArgs list.
 *
 * @schema PrometheusAgentSpecAdditionalArgs
 */
export interface PrometheusAgentSpecAdditionalArgs {
  /**
   * Name of the argument, e.g. "scrape.discovery-reload-interval".
   *
   * @schema PrometheusAgentSpecAdditionalArgs#name
   */
  readonly name: string;

  /**
   * Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
   *
   * @schema PrometheusAgentSpecAdditionalArgs#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecAdditionalArgs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAdditionalArgs(
  obj: PrometheusAgentSpecAdditionalArgs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AdditionalScrapeConfigs allows specifying a key of a Secret containing additional Prometheus scrape configurations. Scrape configurations specified are appended to the configurations generated by the Prometheus Operator. Job configurations specified must have the form as specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config. As scrape configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible scrape configs are going to break Prometheus after the upgrade.
 *
 * @schema PrometheusAgentSpecAdditionalScrapeConfigs
 */
export interface PrometheusAgentSpecAdditionalScrapeConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecAdditionalScrapeConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecAdditionalScrapeConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecAdditionalScrapeConfigs#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecAdditionalScrapeConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAdditionalScrapeConfigs(
  obj: PrometheusAgentSpecAdditionalScrapeConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the Pods' affinity scheduling rules if specified.
 *
 * @schema PrometheusAgentSpecAffinity
 */
export interface PrometheusAgentSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema PrometheusAgentSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: PrometheusAgentSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema PrometheusAgentSpecAffinity#podAffinity
   */
  readonly podAffinity?: PrometheusAgentSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema PrometheusAgentSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: PrometheusAgentSpecAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinity(
  obj: PrometheusAgentSpecAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeAffinity": toJson_PrometheusAgentSpecAffinityNodeAffinity(
      obj.nodeAffinity,
    ),
    "podAffinity": toJson_PrometheusAgentSpecAffinityPodAffinity(
      obj.podAffinity,
    ),
    "podAntiAffinity": toJson_PrometheusAgentSpecAffinityPodAntiAffinity(
      obj.podAntiAffinity,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * APIServerConfig allows specifying a host and auth methods to access the Kuberntees API server. If null, Prometheus is assumed to run inside of the cluster: it will discover the API servers automatically and use the Pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
 *
 * @schema PrometheusAgentSpecApiserverConfig
 */
export interface PrometheusAgentSpecApiserverConfig {
  /**
   * Authorization section for the API server.
   * Cannot be set at the same time as `basicAuth`, `bearerToken`, or `bearerTokenFile`.
   *
   * @schema PrometheusAgentSpecApiserverConfig#authorization
   */
  readonly authorization?: PrometheusAgentSpecApiserverConfigAuthorization;

  /**
   * BasicAuth configuration for the API server.
   * Cannot be set at the same time as `authorization`, `bearerToken`, or `bearerTokenFile`.
   *
   * @schema PrometheusAgentSpecApiserverConfig#basicAuth
   */
  readonly basicAuth?: PrometheusAgentSpecApiserverConfigBasicAuth;

  /**
   * *Warning: this field shouldn't be used because the token value appears in clear-text. Prefer using `authorization`.*
   * Deprecated: this will be removed in a future release.
   *
   * @schema PrometheusAgentSpecApiserverConfig#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * File to read bearer token for accessing apiserver.
   * Cannot be set at the same time as `basicAuth`, `authorization`, or `bearerToken`.
   * Deprecated: this will be removed in a future release. Prefer using `authorization`.
   *
   * @schema PrometheusAgentSpecApiserverConfig#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Kubernetes API address consisting of a hostname or IP address followed by an optional port number.
   *
   * @schema PrometheusAgentSpecApiserverConfig#host
   */
  readonly host: string;

  /**
   * TLS Config to use for the API server.
   *
   * @schema PrometheusAgentSpecApiserverConfig#tlsConfig
   */
  readonly tlsConfig?: PrometheusAgentSpecApiserverConfigTlsConfig;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfig(
  obj: PrometheusAgentSpecApiserverConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization": toJson_PrometheusAgentSpecApiserverConfigAuthorization(
      obj.authorization,
    ),
    "basicAuth": toJson_PrometheusAgentSpecApiserverConfigBasicAuth(
      obj.basicAuth,
    ),
    "bearerToken": obj.bearerToken,
    "bearerTokenFile": obj.bearerTokenFile,
    "host": obj.host,
    "tlsConfig": toJson_PrometheusAgentSpecApiserverConfigTlsConfig(
      obj.tlsConfig,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * When true, ServiceMonitor, PodMonitor and Probe object are forbidden to reference arbitrary files on the file system of the 'prometheus' container. When a ServiceMonitor's endpoint specifies a `bearerTokenFile` value (e.g.  '/var/run/secrets/kubernetes.io/serviceaccount/token'), a malicious target can get access to the Prometheus service account's token in the Prometheus' scrape request. Setting `spec.arbitraryFSAccessThroughSM` to 'true' would prevent the attack. Users should instead provide the credentials using the `spec.bearerTokenSecret` field.
 *
 * @schema PrometheusAgentSpecArbitraryFsAccessThroughSMs
 */
export interface PrometheusAgentSpecArbitraryFsAccessThroughSMs {
  /**
   * @schema PrometheusAgentSpecArbitraryFsAccessThroughSMs#deny
   */
  readonly deny?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecArbitraryFsAccessThroughSMs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecArbitraryFsAccessThroughSMs(
  obj: PrometheusAgentSpecArbitraryFsAccessThroughSMs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "deny": obj.deny,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema PrometheusAgentSpecContainers
 */
export interface PrometheusAgentSpecContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusAgentSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusAgentSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PrometheusAgentSpecContainers#env
   */
  readonly env?: PrometheusAgentSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema PrometheusAgentSpecContainers#envFrom
   */
  readonly envFrom?: PrometheusAgentSpecContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema PrometheusAgentSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema PrometheusAgentSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema PrometheusAgentSpecContainers#lifecycle
   */
  readonly lifecycle?: PrometheusAgentSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecContainers#livenessProbe
   */
  readonly livenessProbe?: PrometheusAgentSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema PrometheusAgentSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema PrometheusAgentSpecContainers#ports
   */
  readonly ports?: PrometheusAgentSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecContainers#readinessProbe
   */
  readonly readinessProbe?: PrometheusAgentSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema PrometheusAgentSpecContainers#resizePolicy
   */
  readonly resizePolicy?: PrometheusAgentSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecContainers#resources
   */
  readonly resources?: PrometheusAgentSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is "Always". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as "Always" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy "Always" will be shut down. This lifecycle differs from normal init containers and is often referred to as a "sidecar" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.
   *
   * @schema PrometheusAgentSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema PrometheusAgentSpecContainers#securityContext
   */
  readonly securityContext?: PrometheusAgentSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecContainers#startupProbe
   */
  readonly startupProbe?: PrometheusAgentSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema PrometheusAgentSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema PrometheusAgentSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema PrometheusAgentSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema PrometheusAgentSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema PrometheusAgentSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema PrometheusAgentSpecContainers#volumeDevices
   */
  readonly volumeDevices?: PrometheusAgentSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema PrometheusAgentSpecContainers#volumeMounts
   */
  readonly volumeMounts?: PrometheusAgentSpecContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema PrometheusAgentSpecContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainers(
  obj: PrometheusAgentSpecContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "args": obj.args?.map((y) => y),
    "command": obj.command?.map((y) => y),
    "env": obj.env?.map((y) => toJson_PrometheusAgentSpecContainersEnv(y)),
    "envFrom": obj.envFrom?.map((y) =>
      toJson_PrometheusAgentSpecContainersEnvFrom(y)
    ),
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "lifecycle": toJson_PrometheusAgentSpecContainersLifecycle(obj.lifecycle),
    "livenessProbe": toJson_PrometheusAgentSpecContainersLivenessProbe(
      obj.livenessProbe,
    ),
    "name": obj.name,
    "ports": obj.ports?.map((y) =>
      toJson_PrometheusAgentSpecContainersPorts(y)
    ),
    "readinessProbe": toJson_PrometheusAgentSpecContainersReadinessProbe(
      obj.readinessProbe,
    ),
    "resizePolicy": obj.resizePolicy?.map((y) =>
      toJson_PrometheusAgentSpecContainersResizePolicy(y)
    ),
    "resources": toJson_PrometheusAgentSpecContainersResources(obj.resources),
    "restartPolicy": obj.restartPolicy,
    "securityContext": toJson_PrometheusAgentSpecContainersSecurityContext(
      obj.securityContext,
    ),
    "startupProbe": toJson_PrometheusAgentSpecContainersStartupProbe(
      obj.startupProbe,
    ),
    "stdin": obj.stdin,
    "stdinOnce": obj.stdinOnce,
    "terminationMessagePath": obj.terminationMessagePath,
    "terminationMessagePolicy": obj.terminationMessagePolicy,
    "tty": obj.tty,
    "volumeDevices": obj.volumeDevices?.map((y) =>
      toJson_PrometheusAgentSpecContainersVolumeDevices(y)
    ),
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_PrometheusAgentSpecContainersVolumeMounts(y)
    ),
    "workingDir": obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectReference references a PodMonitor, ServiceMonitor, Probe or PrometheusRule object.
 *
 * @schema PrometheusAgentSpecExcludedFromEnforcement
 */
export interface PrometheusAgentSpecExcludedFromEnforcement {
  /**
   * Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
   *
   * @schema PrometheusAgentSpecExcludedFromEnforcement#group
   */
  readonly group?: PrometheusAgentSpecExcludedFromEnforcementGroup;

  /**
   * Name of the referent. When not set, all resources in the namespace are matched.
   *
   * @schema PrometheusAgentSpecExcludedFromEnforcement#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema PrometheusAgentSpecExcludedFromEnforcement#namespace
   */
  readonly namespace: string;

  /**
   * Resource of the referent.
   *
   * @schema PrometheusAgentSpecExcludedFromEnforcement#resource
   */
  readonly resource: PrometheusAgentSpecExcludedFromEnforcementResource;
}

/**
 * Converts an object of type 'PrometheusAgentSpecExcludedFromEnforcement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecExcludedFromEnforcement(
  obj: PrometheusAgentSpecExcludedFromEnforcement | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "group": obj.group,
    "name": obj.name,
    "namespace": obj.namespace,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
 *
 * @schema PrometheusAgentSpecHostAliases
 */
export interface PrometheusAgentSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema PrometheusAgentSpecHostAliases#hostnames
   */
  readonly hostnames: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema PrometheusAgentSpecHostAliases#ip
   */
  readonly ip: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecHostAliases(
  obj: PrometheusAgentSpecHostAliases | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "hostnames": obj.hostnames?.map((y) => y),
    "ip": obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Image pull policy for the 'prometheus', 'init-config-reloader' and 'config-reloader' containers. See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
 *
 * @schema PrometheusAgentSpecImagePullPolicy
 */
export enum PrometheusAgentSpecImagePullPolicy {
  /** Always */
  ALWAYS = "Always",
  /** Never */
  NEVER = "Never",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PrometheusAgentSpecImagePullSecrets
 */
export interface PrometheusAgentSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecImagePullSecrets(
  obj: PrometheusAgentSpecImagePullSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema PrometheusAgentSpecInitContainers
 */
export interface PrometheusAgentSpecInitContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusAgentSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PrometheusAgentSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PrometheusAgentSpecInitContainers#env
   */
  readonly env?: PrometheusAgentSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema PrometheusAgentSpecInitContainers#envFrom
   */
  readonly envFrom?: PrometheusAgentSpecInitContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema PrometheusAgentSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema PrometheusAgentSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema PrometheusAgentSpecInitContainers#lifecycle
   */
  readonly lifecycle?: PrometheusAgentSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: PrometheusAgentSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema PrometheusAgentSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema PrometheusAgentSpecInitContainers#ports
   */
  readonly ports?: PrometheusAgentSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: PrometheusAgentSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema PrometheusAgentSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: PrometheusAgentSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecInitContainers#resources
   */
  readonly resources?: PrometheusAgentSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is "Always". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as "Always" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy "Always" will be shut down. This lifecycle differs from normal init containers and is often referred to as a "sidecar" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.
   *
   * @schema PrometheusAgentSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema PrometheusAgentSpecInitContainers#securityContext
   */
  readonly securityContext?: PrometheusAgentSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecInitContainers#startupProbe
   */
  readonly startupProbe?: PrometheusAgentSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema PrometheusAgentSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema PrometheusAgentSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema PrometheusAgentSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema PrometheusAgentSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema PrometheusAgentSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema PrometheusAgentSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: PrometheusAgentSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema PrometheusAgentSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: PrometheusAgentSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema PrometheusAgentSpecInitContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainers(
  obj: PrometheusAgentSpecInitContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "args": obj.args?.map((y) => y),
    "command": obj.command?.map((y) => y),
    "env": obj.env?.map((y) => toJson_PrometheusAgentSpecInitContainersEnv(y)),
    "envFrom": obj.envFrom?.map((y) =>
      toJson_PrometheusAgentSpecInitContainersEnvFrom(y)
    ),
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "lifecycle": toJson_PrometheusAgentSpecInitContainersLifecycle(
      obj.lifecycle,
    ),
    "livenessProbe": toJson_PrometheusAgentSpecInitContainersLivenessProbe(
      obj.livenessProbe,
    ),
    "name": obj.name,
    "ports": obj.ports?.map((y) =>
      toJson_PrometheusAgentSpecInitContainersPorts(y)
    ),
    "readinessProbe": toJson_PrometheusAgentSpecInitContainersReadinessProbe(
      obj.readinessProbe,
    ),
    "resizePolicy": obj.resizePolicy?.map((y) =>
      toJson_PrometheusAgentSpecInitContainersResizePolicy(y)
    ),
    "resources": toJson_PrometheusAgentSpecInitContainersResources(
      obj.resources,
    ),
    "restartPolicy": obj.restartPolicy,
    "securityContext": toJson_PrometheusAgentSpecInitContainersSecurityContext(
      obj.securityContext,
    ),
    "startupProbe": toJson_PrometheusAgentSpecInitContainersStartupProbe(
      obj.startupProbe,
    ),
    "stdin": obj.stdin,
    "stdinOnce": obj.stdinOnce,
    "terminationMessagePath": obj.terminationMessagePath,
    "terminationMessagePolicy": obj.terminationMessagePolicy,
    "tty": obj.tty,
    "volumeDevices": obj.volumeDevices?.map((y) =>
      toJson_PrometheusAgentSpecInitContainersVolumeDevices(y)
    ),
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_PrometheusAgentSpecInitContainersVolumeMounts(y)
    ),
    "workingDir": obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Log format for Log level for Prometheus and the config-reloader sidecar.
 *
 * @schema PrometheusAgentSpecLogFormat
 */
export enum PrometheusAgentSpecLogFormat {
  /** logfmt */
  LOGFMT = "logfmt",
  /** json */
  JSON = "json",
}

/**
 * Log level for Prometheus and the config-reloader sidecar.
 *
 * @schema PrometheusAgentSpecLogLevel
 */
export enum PrometheusAgentSpecLogLevel {
  /** debug */
  DEBUG = "debug",
  /** info */
  INFO = "info",
  /** warn */
  WARN = "warn",
  /** error */
  ERROR = "error",
}

/**
 * The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet. The default behavior is all PVCs are retained. This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26. It requires enabling the StatefulSetAutoDeletePVC feature gate.
 *
 * @schema PrometheusAgentSpecPersistentVolumeClaimRetentionPolicy
 */
export interface PrometheusAgentSpecPersistentVolumeClaimRetentionPolicy {
  /**
   * WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.
   *
   * @schema PrometheusAgentSpecPersistentVolumeClaimRetentionPolicy#whenDeleted
   */
  readonly whenDeleted?: string;

  /**
   * WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.
   *
   * @schema PrometheusAgentSpecPersistentVolumeClaimRetentionPolicy#whenScaled
   */
  readonly whenScaled?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecPersistentVolumeClaimRetentionPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecPersistentVolumeClaimRetentionPolicy(
  obj: PrometheusAgentSpecPersistentVolumeClaimRetentionPolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "whenDeleted": obj.whenDeleted,
    "whenScaled": obj.whenScaled,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PodMetadata configures labels and annotations which are propagated to the Prometheus pods.
 * The following items are reserved and cannot be overridden: * "prometheus" label, set to the name of the Prometheus object. * "app.kubernetes.io/instance" label, set to the name of the Prometheus object. * "app.kubernetes.io/managed-by" label, set to "prometheus-operator". * "app.kubernetes.io/name" label, set to "prometheus". * "app.kubernetes.io/version" label, set to the Prometheus version. * "operator.prometheus.io/name" label, set to the name of the Prometheus object. * "operator.prometheus.io/shard" label, set to the shard number of the Prometheus object. * "kubectl.kubernetes.io/default-container" annotation, set to "prometheus".
 *
 * @schema PrometheusAgentSpecPodMetadata
 */
export interface PrometheusAgentSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PrometheusAgentSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema PrometheusAgentSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema PrometheusAgentSpecPodMetadata#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecPodMetadata(
  obj: PrometheusAgentSpecPodMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "annotations": ((obj.annotations) === undefined)
      ? undefined
      : (Object.entries(obj.annotations).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for PodMonitors discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
 *
 * @schema PrometheusAgentSpecPodMonitorNamespaceSelector
 */
export interface PrometheusAgentSpecPodMonitorNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecPodMonitorNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecPodMonitorNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecPodMonitorNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecPodMonitorNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecPodMonitorNamespaceSelector(
  obj: PrometheusAgentSpecPodMonitorNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecPodMonitorNamespaceSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * *Experimental* PodMonitors to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
 *
 * @schema PrometheusAgentSpecPodMonitorSelector
 */
export interface PrometheusAgentSpecPodMonitorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecPodMonitorSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecPodMonitorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecPodMonitorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecPodMonitorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecPodMonitorSelector(
  obj: PrometheusAgentSpecPodMonitorSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecPodMonitorSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * *Experimental* Namespaces to match for Probe discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
 *
 * @schema PrometheusAgentSpecProbeNamespaceSelector
 */
export interface PrometheusAgentSpecProbeNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecProbeNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecProbeNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecProbeNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecProbeNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecProbeNamespaceSelector(
  obj: PrometheusAgentSpecProbeNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecProbeNamespaceSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * *Experimental* Probes to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
 *
 * @schema PrometheusAgentSpecProbeSelector
 */
export interface PrometheusAgentSpecProbeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecProbeSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecProbeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecProbeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecProbeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecProbeSelector(
  obj: PrometheusAgentSpecProbeSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecProbeSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the strategy used to reload the Prometheus configuration. If not specified, the configuration is reloaded using the /-/reload HTTP endpoint.
 *
 * @schema PrometheusAgentSpecReloadStrategy
 */
export enum PrometheusAgentSpecReloadStrategy {
  /** HTTP */
  HTTP = "HTTP",
  /** ProcessSignal */
  PROCESS_SIGNAL = "ProcessSignal",
}

/**
 * RemoteWriteSpec defines the configuration to write samples from Prometheus to a remote endpoint.
 *
 * @schema PrometheusAgentSpecRemoteWrite
 */
export interface PrometheusAgentSpecRemoteWrite {
  /**
   * Authorization section for the URL.
   * It requires Prometheus >= v2.26.0.
   * Cannot be set at the same time as `sigv4`, `basicAuth`, `oauth2`, or `azureAd`.
   *
   * @schema PrometheusAgentSpecRemoteWrite#authorization
   */
  readonly authorization?: PrometheusAgentSpecRemoteWriteAuthorization;

  /**
   * AzureAD for the URL.
   * It requires Prometheus >= v2.45.0.
   * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `sigv4`.
   *
   * @schema PrometheusAgentSpecRemoteWrite#azureAd
   */
  readonly azureAd?: PrometheusAgentSpecRemoteWriteAzureAd;

  /**
   * BasicAuth configuration for the URL.
   * Cannot be set at the same time as `sigv4`, `authorization`, `oauth2`, or `azureAd`.
   *
   * @schema PrometheusAgentSpecRemoteWrite#basicAuth
   */
  readonly basicAuth?: PrometheusAgentSpecRemoteWriteBasicAuth;

  /**
   * *Warning: this field shouldn't be used because the token value appears in clear-text. Prefer using `authorization`.*
   * Deprecated: this will be removed in a future release.
   *
   * @schema PrometheusAgentSpecRemoteWrite#bearerToken
   */
  readonly bearerToken?: string;

  /**
   * File from which to read bearer token for the URL.
   * Deprecated: this will be removed in a future release. Prefer using `authorization`.
   *
   * @schema PrometheusAgentSpecRemoteWrite#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * Whether to enable HTTP2.
   *
   * @schema PrometheusAgentSpecRemoteWrite#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Custom HTTP headers to be sent along with each remote write request. Be aware that headers that are set by Prometheus itself can't be overwritten.
   * It requires Prometheus >= v2.25.0.
   *
   * @schema PrometheusAgentSpecRemoteWrite#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * MetadataConfig configures the sending of series metadata to the remote storage.
   *
   * @schema PrometheusAgentSpecRemoteWrite#metadataConfig
   */
  readonly metadataConfig?: PrometheusAgentSpecRemoteWriteMetadataConfig;

  /**
   * The name of the remote write queue, it must be unique if specified. The name is used in metrics and logging in order to differentiate queues.
   * It requires Prometheus >= v2.15.0.
   *
   * @schema PrometheusAgentSpecRemoteWrite#name
   */
  readonly name?: string;

  /**
   * OAuth2 configuration for the URL.
   * It requires Prometheus >= v2.27.0.
   * Cannot be set at the same time as `sigv4`, `authorization`, `basicAuth`, or `azureAd`.
   *
   * @schema PrometheusAgentSpecRemoteWrite#oauth2
   */
  readonly oauth2?: PrometheusAgentSpecRemoteWriteOauth2;

  /**
   * Optional ProxyURL.
   *
   * @schema PrometheusAgentSpecRemoteWrite#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * QueueConfig allows tuning of the remote write queue parameters.
   *
   * @schema PrometheusAgentSpecRemoteWrite#queueConfig
   */
  readonly queueConfig?: PrometheusAgentSpecRemoteWriteQueueConfig;

  /**
   * Timeout for requests to the remote write endpoint.
   *
   * @schema PrometheusAgentSpecRemoteWrite#remoteTimeout
   */
  readonly remoteTimeout?: string;

  /**
   * Enables sending of exemplars over remote write. Note that exemplar-storage itself must be enabled using the `spec.enableFeature` option for exemplars to be scraped in the first place.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema PrometheusAgentSpecRemoteWrite#sendExemplars
   */
  readonly sendExemplars?: boolean;

  /**
   * Enables sending of native histograms, also known as sparse histograms over remote write.
   * It requires Prometheus >= v2.40.0.
   *
   * @schema PrometheusAgentSpecRemoteWrite#sendNativeHistograms
   */
  readonly sendNativeHistograms?: boolean;

  /**
   * Sigv4 allows to configures AWS's Signature Verification 4 for the URL.
   * It requires Prometheus >= v2.26.0.
   * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `azureAd`.
   *
   * @schema PrometheusAgentSpecRemoteWrite#sigv4
   */
  readonly sigv4?: PrometheusAgentSpecRemoteWriteSigv4;

  /**
   * TLS Config to use for the URL.
   *
   * @schema PrometheusAgentSpecRemoteWrite#tlsConfig
   */
  readonly tlsConfig?: PrometheusAgentSpecRemoteWriteTlsConfig;

  /**
   * The URL of the endpoint to send samples to.
   *
   * @schema PrometheusAgentSpecRemoteWrite#url
   */
  readonly url: string;

  /**
   * The list of remote write relabel configurations.
   *
   * @schema PrometheusAgentSpecRemoteWrite#writeRelabelConfigs
   */
  readonly writeRelabelConfigs?:
    PrometheusAgentSpecRemoteWriteWriteRelabelConfigs[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWrite(
  obj: PrometheusAgentSpecRemoteWrite | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization": toJson_PrometheusAgentSpecRemoteWriteAuthorization(
      obj.authorization,
    ),
    "azureAd": toJson_PrometheusAgentSpecRemoteWriteAzureAd(obj.azureAd),
    "basicAuth": toJson_PrometheusAgentSpecRemoteWriteBasicAuth(obj.basicAuth),
    "bearerToken": obj.bearerToken,
    "bearerTokenFile": obj.bearerTokenFile,
    "enableHTTP2": obj.enableHttp2,
    "headers": ((obj.headers) === undefined)
      ? undefined
      : (Object.entries(obj.headers).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "metadataConfig": toJson_PrometheusAgentSpecRemoteWriteMetadataConfig(
      obj.metadataConfig,
    ),
    "name": obj.name,
    "oauth2": toJson_PrometheusAgentSpecRemoteWriteOauth2(obj.oauth2),
    "proxyUrl": obj.proxyUrl,
    "queueConfig": toJson_PrometheusAgentSpecRemoteWriteQueueConfig(
      obj.queueConfig,
    ),
    "remoteTimeout": obj.remoteTimeout,
    "sendExemplars": obj.sendExemplars,
    "sendNativeHistograms": obj.sendNativeHistograms,
    "sigv4": toJson_PrometheusAgentSpecRemoteWriteSigv4(obj.sigv4),
    "tlsConfig": toJson_PrometheusAgentSpecRemoteWriteTlsConfig(obj.tlsConfig),
    "url": obj.url,
    "writeRelabelConfigs": obj.writeRelabelConfigs?.map((y) =>
      toJson_PrometheusAgentSpecRemoteWriteWriteRelabelConfigs(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the resources requests and limits of the 'prometheus' container.
 *
 * @schema PrometheusAgentSpecResources
 */
export interface PrometheusAgentSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusAgentSpecResources#claims
   */
  readonly claims?: PrometheusAgentSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecResources#limits
   */
  readonly limits?: { [key: string]: PrometheusAgentSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecResources#requests
   */
  readonly requests?: { [key: string]: PrometheusAgentSpecResourcesRequests };
}

/**
 * Converts an object of type 'PrometheusAgentSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecResources(
  obj: PrometheusAgentSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusAgentSpecResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for ScrapeConfig discovery. An empty label selector matches all namespaces. A null label selector matches the current current namespace only.
 *
 * @schema PrometheusAgentSpecScrapeConfigNamespaceSelector
 */
export interface PrometheusAgentSpecScrapeConfigNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecScrapeConfigNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecScrapeConfigNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecScrapeConfigNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecScrapeConfigNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecScrapeConfigNamespaceSelector(
  obj: PrometheusAgentSpecScrapeConfigNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecScrapeConfigNamespaceSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * *Experimental* ScrapeConfigs to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
 *
 * @schema PrometheusAgentSpecScrapeConfigSelector
 */
export interface PrometheusAgentSpecScrapeConfigSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecScrapeConfigSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecScrapeConfigSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecScrapeConfigSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecScrapeConfigSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecScrapeConfigSelector(
  obj: PrometheusAgentSpecScrapeConfigSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecScrapeConfigSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.
 *
 * @schema PrometheusAgentSpecSecurityContext
 */
export interface PrometheusAgentSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PrometheusAgentSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusAgentSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PrometheusAgentSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: PrometheusAgentSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process. If unspecified, no additional groups are added to any container. Note that group memberships defined in the container image for the uid of the container process are still effective, even if they are not included in this list. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecSecurityContext#sysctls
   */
  readonly sysctls?: PrometheusAgentSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PrometheusAgentSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: PrometheusAgentSpecSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'PrometheusAgentSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecSecurityContext(
  obj: PrometheusAgentSpecSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsGroup": obj.fsGroup,
    "fsGroupChangePolicy": obj.fsGroupChangePolicy,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions": toJson_PrometheusAgentSpecSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    "seccompProfile": toJson_PrometheusAgentSpecSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    "supplementalGroups": obj.supplementalGroups?.map((y) => y),
    "sysctls": obj.sysctls?.map((y) =>
      toJson_PrometheusAgentSpecSecurityContextSysctls(y)
    ),
    "windowsOptions": toJson_PrometheusAgentSpecSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to match for ServicedMonitors discovery. An empty label selector matches all namespaces. A null label selector matches the current namespace only.
 *
 * @schema PrometheusAgentSpecServiceMonitorNamespaceSelector
 */
export interface PrometheusAgentSpecServiceMonitorNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecServiceMonitorNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecServiceMonitorNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecServiceMonitorNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecServiceMonitorNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecServiceMonitorNamespaceSelector(
  obj: PrometheusAgentSpecServiceMonitorNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecServiceMonitorNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceMonitors to be selected for target discovery. An empty label selector matches all objects. A null label selector matches no objects.
 * If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector` and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged. The Prometheus operator will ensure that the Prometheus configuration's Secret exists, but it is the responsibility of the user to provide the raw gzipped Prometheus configuration under the `prometheus.yaml.gz` key. This behavior is *deprecated* and will be removed in the next major version of the custom resource definition. It is recommended to use `spec.additionalScrapeConfigs` instead.
 *
 * @schema PrometheusAgentSpecServiceMonitorSelector
 */
export interface PrometheusAgentSpecServiceMonitorSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecServiceMonitorSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecServiceMonitorSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecServiceMonitorSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecServiceMonitorSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecServiceMonitorSelector(
  obj: PrometheusAgentSpecServiceMonitorSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecServiceMonitorSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Storage defines the storage used by Prometheus.
 *
 * @schema PrometheusAgentSpecStorage
 */
export interface PrometheusAgentSpecStorage {
  /**
   * Deprecated: subPath usage will be removed in a future release.
   *
   * @schema PrometheusAgentSpecStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the StatefulSet. If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema PrometheusAgentSpecStorage#emptyDir
   */
  readonly emptyDir?: PrometheusAgentSpecStorageEmptyDir;

  /**
   * EphemeralVolumeSource to be used by the StatefulSet. This is a beta field in k8s 1.21 and GA in 1.15. For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
   *
   * @schema PrometheusAgentSpecStorage#ephemeral
   */
  readonly ephemeral?: PrometheusAgentSpecStorageEphemeral;

  /**
   * Defines the PVC spec to be used by the Prometheus StatefulSets. The easiest way to use a volume that cannot be automatically provisioned is to use a label selector alongside manually created PersistentVolumes.
   *
   * @schema PrometheusAgentSpecStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: PrometheusAgentSpecStorageVolumeClaimTemplate;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorage(
  obj: PrometheusAgentSpecStorage | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "disableMountSubPath": obj.disableMountSubPath,
    "emptyDir": toJson_PrometheusAgentSpecStorageEmptyDir(obj.emptyDir),
    "ephemeral": toJson_PrometheusAgentSpecStorageEphemeral(obj.ephemeral),
    "volumeClaimTemplate": toJson_PrometheusAgentSpecStorageVolumeClaimTemplate(
      obj.volumeClaimTemplate,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema PrometheusAgentSpecTolerations
 */
export interface PrometheusAgentSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema PrometheusAgentSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema PrometheusAgentSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema PrometheusAgentSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema PrometheusAgentSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema PrometheusAgentSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTolerations(
  obj: PrometheusAgentSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "effect": obj.effect,
    "key": obj.key,
    "operator": obj.operator,
    "tolerationSeconds": obj.tolerationSeconds,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusAgentSpecTopologySpreadConstraints
 */
export interface PrometheusAgentSpecTopologySpreadConstraints {
  /**
   * Defines what Prometheus Operator managed labels should be added to labelSelector on the topologySpreadConstraint.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraints#additionalLabelSelectors
   */
  readonly additionalLabelSelectors?:
    PrometheusAgentSpecTopologySpreadConstraintsAdditionalLabelSelectors;

  /**
   * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?:
    PrometheusAgentSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels are ANDed with labelSelector to select the group of existing pods over which spreading will be calculated for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector. MatchLabelKeys cannot be set when LabelSelector isn't set. Keys that don't exist in the incoming pod labels will be ignored. A null or empty list means only match against labelSelector.
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. The global minimum is the minimum number of matching pods in an eligible domain or zero if the number of eligible domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 2/2/1: In this case, the global minimum is 1. | zone1 | zone2 | zone3 | |  P P  |  P P  |   P   | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.
   * This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   * If this value is nil, the behavior is equivalent to the Honor policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.
   * If this value is nil, the behavior is equivalent to the Ignore policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology. And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology. It's a required field.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location, but giving higher precedence to topologies that would help reduce the skew. A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTopologySpreadConstraints(
  obj: PrometheusAgentSpecTopologySpreadConstraints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "additionalLabelSelectors": obj.additionalLabelSelectors,
    "labelSelector":
      toJson_PrometheusAgentSpecTopologySpreadConstraintsLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "maxSkew": obj.maxSkew,
    "minDomains": obj.minDomains,
    "nodeAffinityPolicy": obj.nodeAffinityPolicy,
    "nodeTaintsPolicy": obj.nodeTaintsPolicy,
    "topologyKey": obj.topologyKey,
    "whenUnsatisfiable": obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EXPERIMENTAL: TracingConfig configures tracing in Prometheus. This is an experimental feature, it may change in any upcoming release in a breaking way.
 *
 * @schema PrometheusAgentSpecTracingConfig
 */
export interface PrometheusAgentSpecTracingConfig {
  /**
   * Client used to export the traces. Supported values are `http` or `grpc`.
   *
   * @schema PrometheusAgentSpecTracingConfig#clientType
   */
  readonly clientType?: PrometheusAgentSpecTracingConfigClientType;

  /**
   * Compression key for supported compression types. The only supported value is `gzip`.
   *
   * @schema PrometheusAgentSpecTracingConfig#compression
   */
  readonly compression?: PrometheusAgentSpecTracingConfigCompression;

  /**
   * Endpoint to send the traces to. Should be provided in format <host>:<port>.
   *
   * @schema PrometheusAgentSpecTracingConfig#endpoint
   */
  readonly endpoint: string;

  /**
   * Key-value pairs to be used as headers associated with gRPC or HTTP requests.
   *
   * @schema PrometheusAgentSpecTracingConfig#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * If disabled, the client will use a secure connection.
   *
   * @schema PrometheusAgentSpecTracingConfig#insecure
   */
  readonly insecure?: boolean;

  /**
   * Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
   *
   * @schema PrometheusAgentSpecTracingConfig#samplingFraction
   */
  readonly samplingFraction?: PrometheusAgentSpecTracingConfigSamplingFraction;

  /**
   * Maximum time the exporter will wait for each batch export.
   *
   * @schema PrometheusAgentSpecTracingConfig#timeout
   */
  readonly timeout?: string;

  /**
   * TLS Config to use when sending traces.
   *
   * @schema PrometheusAgentSpecTracingConfig#tlsConfig
   */
  readonly tlsConfig?: PrometheusAgentSpecTracingConfigTlsConfig;
}

/**
 * Converts an object of type 'PrometheusAgentSpecTracingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTracingConfig(
  obj: PrometheusAgentSpecTracingConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientType": obj.clientType,
    "compression": obj.compression,
    "endpoint": obj.endpoint,
    "headers": ((obj.headers) === undefined)
      ? undefined
      : (Object.entries(obj.headers).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "insecure": obj.insecure,
    "samplingFraction": obj.samplingFraction?.value,
    "timeout": obj.timeout,
    "tlsConfig": toJson_PrometheusAgentSpecTracingConfigTlsConfig(
      obj.tlsConfig,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PrometheusAgentSpecVolumeMounts
 */
export interface PrometheusAgentSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PrometheusAgentSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PrometheusAgentSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PrometheusAgentSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PrometheusAgentSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PrometheusAgentSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema PrometheusAgentSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumeMounts(
  obj: PrometheusAgentSpecVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema PrometheusAgentSpecVolumes
 */
export interface PrometheusAgentSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PrometheusAgentSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?:
    PrometheusAgentSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema PrometheusAgentSpecVolumes#azureDisk
   */
  readonly azureDisk?: PrometheusAgentSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema PrometheusAgentSpecVolumes#azureFile
   */
  readonly azureFile?: PrometheusAgentSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema PrometheusAgentSpecVolumes#cephfs
   */
  readonly cephfs?: PrometheusAgentSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusAgentSpecVolumes#cinder
   */
  readonly cinder?: PrometheusAgentSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema PrometheusAgentSpecVolumes#configMap
   */
  readonly configMap?: PrometheusAgentSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema PrometheusAgentSpecVolumes#csi
   */
  readonly csi?: PrometheusAgentSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema PrometheusAgentSpecVolumes#downwardAPI
   */
  readonly downwardApi?: PrometheusAgentSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusAgentSpecVolumes#emptyDir
   */
  readonly emptyDir?: PrometheusAgentSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema PrometheusAgentSpecVolumes#ephemeral
   */
  readonly ephemeral?: PrometheusAgentSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema PrometheusAgentSpecVolumes#fc
   */
  readonly fc?: PrometheusAgentSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema PrometheusAgentSpecVolumes#flexVolume
   */
  readonly flexVolume?: PrometheusAgentSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema PrometheusAgentSpecVolumes#flocker
   */
  readonly flocker?: PrometheusAgentSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PrometheusAgentSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: PrometheusAgentSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema PrometheusAgentSpecVolumes#gitRepo
   */
  readonly gitRepo?: PrometheusAgentSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema PrometheusAgentSpecVolumes#glusterfs
   */
  readonly glusterfs?: PrometheusAgentSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema PrometheusAgentSpecVolumes#hostPath
   */
  readonly hostPath?: PrometheusAgentSpecVolumesHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema PrometheusAgentSpecVolumes#iscsi
   */
  readonly iscsi?: PrometheusAgentSpecVolumesIscsi;

  /**
   * name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PrometheusAgentSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PrometheusAgentSpecVolumes#nfs
   */
  readonly nfs?: PrometheusAgentSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PrometheusAgentSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?:
    PrometheusAgentSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema PrometheusAgentSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?:
    PrometheusAgentSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema PrometheusAgentSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: PrometheusAgentSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema PrometheusAgentSpecVolumes#projected
   */
  readonly projected?: PrometheusAgentSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema PrometheusAgentSpecVolumes#quobyte
   */
  readonly quobyte?: PrometheusAgentSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema PrometheusAgentSpecVolumes#rbd
   */
  readonly rbd?: PrometheusAgentSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema PrometheusAgentSpecVolumes#scaleIO
   */
  readonly scaleIo?: PrometheusAgentSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema PrometheusAgentSpecVolumes#secret
   */
  readonly secret?: PrometheusAgentSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema PrometheusAgentSpecVolumes#storageos
   */
  readonly storageos?: PrometheusAgentSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema PrometheusAgentSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: PrometheusAgentSpecVolumesVsphereVolume;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumes(
  obj: PrometheusAgentSpecVolumes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "awsElasticBlockStore":
      toJson_PrometheusAgentSpecVolumesAwsElasticBlockStore(
        obj.awsElasticBlockStore,
      ),
    "azureDisk": toJson_PrometheusAgentSpecVolumesAzureDisk(obj.azureDisk),
    "azureFile": toJson_PrometheusAgentSpecVolumesAzureFile(obj.azureFile),
    "cephfs": toJson_PrometheusAgentSpecVolumesCephfs(obj.cephfs),
    "cinder": toJson_PrometheusAgentSpecVolumesCinder(obj.cinder),
    "configMap": toJson_PrometheusAgentSpecVolumesConfigMap(obj.configMap),
    "csi": toJson_PrometheusAgentSpecVolumesCsi(obj.csi),
    "downwardAPI": toJson_PrometheusAgentSpecVolumesDownwardApi(
      obj.downwardApi,
    ),
    "emptyDir": toJson_PrometheusAgentSpecVolumesEmptyDir(obj.emptyDir),
    "ephemeral": toJson_PrometheusAgentSpecVolumesEphemeral(obj.ephemeral),
    "fc": toJson_PrometheusAgentSpecVolumesFc(obj.fc),
    "flexVolume": toJson_PrometheusAgentSpecVolumesFlexVolume(obj.flexVolume),
    "flocker": toJson_PrometheusAgentSpecVolumesFlocker(obj.flocker),
    "gcePersistentDisk": toJson_PrometheusAgentSpecVolumesGcePersistentDisk(
      obj.gcePersistentDisk,
    ),
    "gitRepo": toJson_PrometheusAgentSpecVolumesGitRepo(obj.gitRepo),
    "glusterfs": toJson_PrometheusAgentSpecVolumesGlusterfs(obj.glusterfs),
    "hostPath": toJson_PrometheusAgentSpecVolumesHostPath(obj.hostPath),
    "iscsi": toJson_PrometheusAgentSpecVolumesIscsi(obj.iscsi),
    "name": obj.name,
    "nfs": toJson_PrometheusAgentSpecVolumesNfs(obj.nfs),
    "persistentVolumeClaim":
      toJson_PrometheusAgentSpecVolumesPersistentVolumeClaim(
        obj.persistentVolumeClaim,
      ),
    "photonPersistentDisk":
      toJson_PrometheusAgentSpecVolumesPhotonPersistentDisk(
        obj.photonPersistentDisk,
      ),
    "portworxVolume": toJson_PrometheusAgentSpecVolumesPortworxVolume(
      obj.portworxVolume,
    ),
    "projected": toJson_PrometheusAgentSpecVolumesProjected(obj.projected),
    "quobyte": toJson_PrometheusAgentSpecVolumesQuobyte(obj.quobyte),
    "rbd": toJson_PrometheusAgentSpecVolumesRbd(obj.rbd),
    "scaleIO": toJson_PrometheusAgentSpecVolumesScaleIo(obj.scaleIo),
    "secret": toJson_PrometheusAgentSpecVolumesSecret(obj.secret),
    "storageos": toJson_PrometheusAgentSpecVolumesStorageos(obj.storageos),
    "vsphereVolume": toJson_PrometheusAgentSpecVolumesVsphereVolume(
      obj.vsphereVolume,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the configuration of the Prometheus web server.
 *
 * @schema PrometheusAgentSpecWeb
 */
export interface PrometheusAgentSpecWeb {
  /**
   * Defines HTTP parameters for web server.
   *
   * @schema PrometheusAgentSpecWeb#httpConfig
   */
  readonly httpConfig?: PrometheusAgentSpecWebHttpConfig;

  /**
   * Defines the maximum number of simultaneous connections A zero value means that Prometheus doesn't accept any incoming connection.
   *
   * @schema PrometheusAgentSpecWeb#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * The prometheus web page title.
   *
   * @schema PrometheusAgentSpecWeb#pageTitle
   */
  readonly pageTitle?: string;

  /**
   * Defines the TLS parameters for HTTPS.
   *
   * @schema PrometheusAgentSpecWeb#tlsConfig
   */
  readonly tlsConfig?: PrometheusAgentSpecWebTlsConfig;
}

/**
 * Converts an object of type 'PrometheusAgentSpecWeb' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecWeb(
  obj: PrometheusAgentSpecWeb | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "httpConfig": toJson_PrometheusAgentSpecWebHttpConfig(obj.httpConfig),
    "maxConnections": obj.maxConnections,
    "pageTitle": obj.pageTitle,
    "tlsConfig": toJson_PrometheusAgentSpecWebTlsConfig(obj.tlsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema PrometheusAgentSpecAffinityNodeAffinity
 */
export interface PrometheusAgentSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityNodeAffinity(
  obj: PrometheusAgentSpecAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution":
      toJson_PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema PrometheusAgentSpecAffinityPodAffinity
 */
export interface PrometheusAgentSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinity(
  obj: PrometheusAgentSpecAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinity
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinity(
  obj: PrometheusAgentSpecAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for the API server.
 * Cannot be set at the same time as `basicAuth`, `bearerToken`, or `bearerTokenFile`.
 *
 * @schema PrometheusAgentSpecApiserverConfigAuthorization
 */
export interface PrometheusAgentSpecApiserverConfigAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PrometheusAgentSpecApiserverConfigAuthorization#credentials
   */
  readonly credentials?:
    PrometheusAgentSpecApiserverConfigAuthorizationCredentials;

  /**
   * File to read a secret from, mutually exclusive with `credentials`.
   *
   * @schema PrometheusAgentSpecApiserverConfigAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema PrometheusAgentSpecApiserverConfigAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigAuthorization(
  obj: PrometheusAgentSpecApiserverConfigAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_PrometheusAgentSpecApiserverConfigAuthorizationCredentials(
        obj.credentials,
      ),
    "credentialsFile": obj.credentialsFile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth configuration for the API server.
 * Cannot be set at the same time as `authorization`, `bearerToken`, or `bearerTokenFile`.
 *
 * @schema PrometheusAgentSpecApiserverConfigBasicAuth
 */
export interface PrometheusAgentSpecApiserverConfigBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema PrometheusAgentSpecApiserverConfigBasicAuth#password
   */
  readonly password?: PrometheusAgentSpecApiserverConfigBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema PrometheusAgentSpecApiserverConfigBasicAuth#username
   */
  readonly username?: PrometheusAgentSpecApiserverConfigBasicAuthUsername;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigBasicAuth(
  obj: PrometheusAgentSpecApiserverConfigBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_PrometheusAgentSpecApiserverConfigBasicAuthPassword(
      obj.password,
    ),
    "username": toJson_PrometheusAgentSpecApiserverConfigBasicAuthUsername(
      obj.username,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS Config to use for the API server.
 *
 * @schema PrometheusAgentSpecApiserverConfigTlsConfig
 */
export interface PrometheusAgentSpecApiserverConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfig#ca
   */
  readonly ca?: PrometheusAgentSpecApiserverConfigTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfig#cert
   */
  readonly cert?: PrometheusAgentSpecApiserverConfigTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusAgentSpecApiserverConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigTlsConfig(
  obj: PrometheusAgentSpecApiserverConfigTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_PrometheusAgentSpecApiserverConfigTlsConfigCa(obj.ca),
    "caFile": obj.caFile,
    "cert": toJson_PrometheusAgentSpecApiserverConfigTlsConfigCert(obj.cert),
    "certFile": obj.certFile,
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keyFile": obj.keyFile,
    "keySecret": toJson_PrometheusAgentSpecApiserverConfigTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PrometheusAgentSpecContainersEnv
 */
export interface PrometheusAgentSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusAgentSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PrometheusAgentSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema PrometheusAgentSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: PrometheusAgentSpecContainersEnvValueFrom;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersEnv(
  obj: PrometheusAgentSpecContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
    "valueFrom": toJson_PrometheusAgentSpecContainersEnvValueFrom(
      obj.valueFrom,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PrometheusAgentSpecContainersEnvFrom
 */
export interface PrometheusAgentSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema PrometheusAgentSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: PrometheusAgentSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusAgentSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema PrometheusAgentSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: PrometheusAgentSpecContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersEnvFrom(
  obj: PrometheusAgentSpecContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapRef": toJson_PrometheusAgentSpecContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    "prefix": obj.prefix,
    "secretRef": toJson_PrometheusAgentSpecContainersEnvFromSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema PrometheusAgentSpecContainersLifecycle
 */
export interface PrometheusAgentSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusAgentSpecContainersLifecycle#postStart
   */
  readonly postStart?: PrometheusAgentSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusAgentSpecContainersLifecycle#preStop
   */
  readonly preStop?: PrometheusAgentSpecContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLifecycle(
  obj: PrometheusAgentSpecContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "postStart": toJson_PrometheusAgentSpecContainersLifecyclePostStart(
      obj.postStart,
    ),
    "preStop": toJson_PrometheusAgentSpecContainersLifecyclePreStop(
      obj.preStop,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusAgentSpecContainersLivenessProbe
 */
export interface PrometheusAgentSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbe#exec
   */
  readonly exec?: PrometheusAgentSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusAgentSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: PrometheusAgentSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: PrometheusAgentSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusAgentSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusAgentSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusAgentSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusAgentSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLivenessProbe(
  obj: PrometheusAgentSpecContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusAgentSpecContainersLivenessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusAgentSpecContainersLivenessProbeGrpc(obj.grpc),
    "httpGet": toJson_PrometheusAgentSpecContainersLivenessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_PrometheusAgentSpecContainersLivenessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema PrometheusAgentSpecContainersPorts
 */
export interface PrometheusAgentSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema PrometheusAgentSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema PrometheusAgentSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema PrometheusAgentSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema PrometheusAgentSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema PrometheusAgentSpecContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersPorts(
  obj: PrometheusAgentSpecContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerPort": obj.containerPort,
    "hostIP": obj.hostIp,
    "hostPort": obj.hostPort,
    "name": obj.name,
    "protocol": obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusAgentSpecContainersReadinessProbe
 */
export interface PrometheusAgentSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbe#exec
   */
  readonly exec?: PrometheusAgentSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusAgentSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: PrometheusAgentSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: PrometheusAgentSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusAgentSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusAgentSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusAgentSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusAgentSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersReadinessProbe(
  obj: PrometheusAgentSpecContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusAgentSpecContainersReadinessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusAgentSpecContainersReadinessProbeGrpc(obj.grpc),
    "httpGet": toJson_PrometheusAgentSpecContainersReadinessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_PrometheusAgentSpecContainersReadinessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema PrometheusAgentSpecContainersResizePolicy
 */
export interface PrometheusAgentSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies. Supported values: cpu, memory.
   *
   * @schema PrometheusAgentSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized. If not specified, it defaults to NotRequired.
   *
   * @schema PrometheusAgentSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersResizePolicy(
  obj: PrometheusAgentSpecContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "resourceName": obj.resourceName,
    "restartPolicy": obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema PrometheusAgentSpecContainersResources
 */
export interface PrometheusAgentSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusAgentSpecContainersResources#claims
   */
  readonly claims?: PrometheusAgentSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecContainersResources#limits
   */
  readonly limits?: {
    [key: string]: PrometheusAgentSpecContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecContainersResources#requests
   */
  readonly requests?: {
    [key: string]: PrometheusAgentSpecContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersResources(
  obj: PrometheusAgentSpecContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusAgentSpecContainersResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema PrometheusAgentSpecContainersSecurityContext
 */
export interface PrometheusAgentSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusAgentSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?:
    PrometheusAgentSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusAgentSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusAgentSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PrometheusAgentSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusAgentSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    PrometheusAgentSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    PrometheusAgentSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PrometheusAgentSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    PrometheusAgentSpecContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersSecurityContext(
  obj: PrometheusAgentSpecContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "allowPrivilegeEscalation": obj.allowPrivilegeEscalation,
    "capabilities":
      toJson_PrometheusAgentSpecContainersSecurityContextCapabilities(
        obj.capabilities,
      ),
    "privileged": obj.privileged,
    "procMount": obj.procMount,
    "readOnlyRootFilesystem": obj.readOnlyRootFilesystem,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_PrometheusAgentSpecContainersSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_PrometheusAgentSpecContainersSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "windowsOptions":
      toJson_PrometheusAgentSpecContainersSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusAgentSpecContainersStartupProbe
 */
export interface PrometheusAgentSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusAgentSpecContainersStartupProbe#exec
   */
  readonly exec?: PrometheusAgentSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusAgentSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusAgentSpecContainersStartupProbe#grpc
   */
  readonly grpc?: PrometheusAgentSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusAgentSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: PrometheusAgentSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusAgentSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusAgentSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusAgentSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusAgentSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusAgentSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusAgentSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersStartupProbe(
  obj: PrometheusAgentSpecContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusAgentSpecContainersStartupProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusAgentSpecContainersStartupProbeGrpc(obj.grpc),
    "httpGet": toJson_PrometheusAgentSpecContainersStartupProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_PrometheusAgentSpecContainersStartupProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema PrometheusAgentSpecContainersVolumeDevices
 */
export interface PrometheusAgentSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema PrometheusAgentSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema PrometheusAgentSpecContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersVolumeDevices(
  obj: PrometheusAgentSpecContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "devicePath": obj.devicePath,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PrometheusAgentSpecContainersVolumeMounts
 */
export interface PrometheusAgentSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PrometheusAgentSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PrometheusAgentSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PrometheusAgentSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PrometheusAgentSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PrometheusAgentSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema PrometheusAgentSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersVolumeMounts(
  obj: PrometheusAgentSpecContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
 *
 * @schema PrometheusAgentSpecExcludedFromEnforcementGroup
 */
export enum PrometheusAgentSpecExcludedFromEnforcementGroup {
  /** monitoring.coreos.com */
  MONITORING_PERIOD_COREOS_PERIOD_COM = "monitoring.coreos.com",
}

/**
 * Resource of the referent.
 *
 * @schema PrometheusAgentSpecExcludedFromEnforcementResource
 */
export enum PrometheusAgentSpecExcludedFromEnforcementResource {
  /** prometheusrules */
  PROMETHEUSRULES = "prometheusrules",
  /** servicemonitors */
  SERVICEMONITORS = "servicemonitors",
  /** podmonitors */
  PODMONITORS = "podmonitors",
  /** probes */
  PROBES = "probes",
  /** scrapeconfigs */
  SCRAPECONFIGS = "scrapeconfigs",
}

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PrometheusAgentSpecInitContainersEnv
 */
export interface PrometheusAgentSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusAgentSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PrometheusAgentSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema PrometheusAgentSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: PrometheusAgentSpecInitContainersEnvValueFrom;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersEnv(
  obj: PrometheusAgentSpecInitContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
    "valueFrom": toJson_PrometheusAgentSpecInitContainersEnvValueFrom(
      obj.valueFrom,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PrometheusAgentSpecInitContainersEnvFrom
 */
export interface PrometheusAgentSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema PrometheusAgentSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: PrometheusAgentSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PrometheusAgentSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema PrometheusAgentSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: PrometheusAgentSpecInitContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersEnvFrom(
  obj: PrometheusAgentSpecInitContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapRef": toJson_PrometheusAgentSpecInitContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    "prefix": obj.prefix,
    "secretRef": toJson_PrometheusAgentSpecInitContainersEnvFromSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema PrometheusAgentSpecInitContainersLifecycle
 */
export interface PrometheusAgentSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusAgentSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: PrometheusAgentSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema PrometheusAgentSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: PrometheusAgentSpecInitContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLifecycle(
  obj: PrometheusAgentSpecInitContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "postStart": toJson_PrometheusAgentSpecInitContainersLifecyclePostStart(
      obj.postStart,
    ),
    "preStop": toJson_PrometheusAgentSpecInitContainersLifecyclePreStop(
      obj.preStop,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusAgentSpecInitContainersLivenessProbe
 */
export interface PrometheusAgentSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: PrometheusAgentSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusAgentSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: PrometheusAgentSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: PrometheusAgentSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusAgentSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusAgentSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusAgentSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusAgentSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLivenessProbe(
  obj: PrometheusAgentSpecInitContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusAgentSpecInitContainersLivenessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusAgentSpecInitContainersLivenessProbeGrpc(obj.grpc),
    "httpGet": toJson_PrometheusAgentSpecInitContainersLivenessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_PrometheusAgentSpecInitContainersLivenessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema PrometheusAgentSpecInitContainersPorts
 */
export interface PrometheusAgentSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema PrometheusAgentSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema PrometheusAgentSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema PrometheusAgentSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema PrometheusAgentSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema PrometheusAgentSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersPorts(
  obj: PrometheusAgentSpecInitContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerPort": obj.containerPort,
    "hostIP": obj.hostIp,
    "hostPort": obj.hostPort,
    "name": obj.name,
    "protocol": obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusAgentSpecInitContainersReadinessProbe
 */
export interface PrometheusAgentSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: PrometheusAgentSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusAgentSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: PrometheusAgentSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: PrometheusAgentSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusAgentSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusAgentSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusAgentSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusAgentSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersReadinessProbe(
  obj: PrometheusAgentSpecInitContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusAgentSpecInitContainersReadinessProbeExec(
      obj.exec,
    ),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusAgentSpecInitContainersReadinessProbeGrpc(
      obj.grpc,
    ),
    "httpGet": toJson_PrometheusAgentSpecInitContainersReadinessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket":
      toJson_PrometheusAgentSpecInitContainersReadinessProbeTcpSocket(
        obj.tcpSocket,
      ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema PrometheusAgentSpecInitContainersResizePolicy
 */
export interface PrometheusAgentSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies. Supported values: cpu, memory.
   *
   * @schema PrometheusAgentSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized. If not specified, it defaults to NotRequired.
   *
   * @schema PrometheusAgentSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersResizePolicy(
  obj: PrometheusAgentSpecInitContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "resourceName": obj.resourceName,
    "restartPolicy": obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema PrometheusAgentSpecInitContainersResources
 */
export interface PrometheusAgentSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusAgentSpecInitContainersResources#claims
   */
  readonly claims?: PrometheusAgentSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecInitContainersResources#limits
   */
  readonly limits?: {
    [key: string]: PrometheusAgentSpecInitContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecInitContainersResources#requests
   */
  readonly requests?: {
    [key: string]: PrometheusAgentSpecInitContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersResources(
  obj: PrometheusAgentSpecInitContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusAgentSpecInitContainersResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema PrometheusAgentSpecInitContainersSecurityContext
 */
export interface PrometheusAgentSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusAgentSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?:
    PrometheusAgentSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusAgentSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusAgentSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema PrometheusAgentSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    PrometheusAgentSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    PrometheusAgentSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    PrometheusAgentSpecInitContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersSecurityContext(
  obj: PrometheusAgentSpecInitContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "allowPrivilegeEscalation": obj.allowPrivilegeEscalation,
    "capabilities":
      toJson_PrometheusAgentSpecInitContainersSecurityContextCapabilities(
        obj.capabilities,
      ),
    "privileged": obj.privileged,
    "procMount": obj.procMount,
    "readOnlyRootFilesystem": obj.readOnlyRootFilesystem,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_PrometheusAgentSpecInitContainersSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_PrometheusAgentSpecInitContainersSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "windowsOptions":
      toJson_PrometheusAgentSpecInitContainersSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema PrometheusAgentSpecInitContainersStartupProbe
 */
export interface PrometheusAgentSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbe#exec
   */
  readonly exec?: PrometheusAgentSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PrometheusAgentSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: PrometheusAgentSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: PrometheusAgentSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PrometheusAgentSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema PrometheusAgentSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: PrometheusAgentSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PrometheusAgentSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersStartupProbe(
  obj: PrometheusAgentSpecInitContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusAgentSpecInitContainersStartupProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_PrometheusAgentSpecInitContainersStartupProbeGrpc(obj.grpc),
    "httpGet": toJson_PrometheusAgentSpecInitContainersStartupProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_PrometheusAgentSpecInitContainersStartupProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema PrometheusAgentSpecInitContainersVolumeDevices
 */
export interface PrometheusAgentSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema PrometheusAgentSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema PrometheusAgentSpecInitContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersVolumeDevices(
  obj: PrometheusAgentSpecInitContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "devicePath": obj.devicePath,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PrometheusAgentSpecInitContainersVolumeMounts
 */
export interface PrometheusAgentSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PrometheusAgentSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PrometheusAgentSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PrometheusAgentSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PrometheusAgentSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PrometheusAgentSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema PrometheusAgentSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersVolumeMounts(
  obj: PrometheusAgentSpecInitContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecPodMonitorNamespaceSelectorMatchExpressions
 */
export interface PrometheusAgentSpecPodMonitorNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecPodMonitorNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecPodMonitorNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecPodMonitorNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecPodMonitorNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecPodMonitorNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecPodMonitorNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecPodMonitorSelectorMatchExpressions
 */
export interface PrometheusAgentSpecPodMonitorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecPodMonitorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecPodMonitorSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecPodMonitorSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecPodMonitorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecPodMonitorSelectorMatchExpressions(
  obj: PrometheusAgentSpecPodMonitorSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecProbeNamespaceSelectorMatchExpressions
 */
export interface PrometheusAgentSpecProbeNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecProbeNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecProbeNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecProbeNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecProbeNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecProbeNamespaceSelectorMatchExpressions(
  obj: PrometheusAgentSpecProbeNamespaceSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecProbeSelectorMatchExpressions
 */
export interface PrometheusAgentSpecProbeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecProbeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecProbeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecProbeSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecProbeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecProbeSelectorMatchExpressions(
  obj: PrometheusAgentSpecProbeSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization section for the URL.
 * It requires Prometheus >= v2.26.0.
 * Cannot be set at the same time as `sigv4`, `basicAuth`, `oauth2`, or `azureAd`.
 *
 * @schema PrometheusAgentSpecRemoteWriteAuthorization
 */
export interface PrometheusAgentSpecRemoteWriteAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema PrometheusAgentSpecRemoteWriteAuthorization#credentials
   */
  readonly credentials?: PrometheusAgentSpecRemoteWriteAuthorizationCredentials;

  /**
   * File to read a secret from, mutually exclusive with `credentials`.
   *
   * @schema PrometheusAgentSpecRemoteWriteAuthorization#credentialsFile
   */
  readonly credentialsFile?: string;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema PrometheusAgentSpecRemoteWriteAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteAuthorization(
  obj: PrometheusAgentSpecRemoteWriteAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_PrometheusAgentSpecRemoteWriteAuthorizationCredentials(
        obj.credentials,
      ),
    "credentialsFile": obj.credentialsFile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AzureAD for the URL.
 * It requires Prometheus >= v2.45.0.
 * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `sigv4`.
 *
 * @schema PrometheusAgentSpecRemoteWriteAzureAd
 */
export interface PrometheusAgentSpecRemoteWriteAzureAd {
  /**
   * The Azure Cloud. Options are 'AzurePublic', 'AzureChina', or 'AzureGovernment'.
   *
   * @schema PrometheusAgentSpecRemoteWriteAzureAd#cloud
   */
  readonly cloud?: PrometheusAgentSpecRemoteWriteAzureAdCloud;

  /**
   * ManagedIdentity defines the Azure User-assigned Managed identity. Cannot be set at the same time as `oauth`.
   *
   * @schema PrometheusAgentSpecRemoteWriteAzureAd#managedIdentity
   */
  readonly managedIdentity?:
    PrometheusAgentSpecRemoteWriteAzureAdManagedIdentity;

  /**
   * OAuth defines the oauth config that is being used to authenticate. Cannot be set at the same time as `managedIdentity`.
   * It requires Prometheus >= v2.48.0.
   *
   * @schema PrometheusAgentSpecRemoteWriteAzureAd#oauth
   */
  readonly oauth?: PrometheusAgentSpecRemoteWriteAzureAdOauth;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteAzureAd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteAzureAd(
  obj: PrometheusAgentSpecRemoteWriteAzureAd | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "cloud": obj.cloud,
    "managedIdentity":
      toJson_PrometheusAgentSpecRemoteWriteAzureAdManagedIdentity(
        obj.managedIdentity,
      ),
    "oauth": toJson_PrometheusAgentSpecRemoteWriteAzureAdOauth(obj.oauth),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth configuration for the URL.
 * Cannot be set at the same time as `sigv4`, `authorization`, `oauth2`, or `azureAd`.
 *
 * @schema PrometheusAgentSpecRemoteWriteBasicAuth
 */
export interface PrometheusAgentSpecRemoteWriteBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema PrometheusAgentSpecRemoteWriteBasicAuth#password
   */
  readonly password?: PrometheusAgentSpecRemoteWriteBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema PrometheusAgentSpecRemoteWriteBasicAuth#username
   */
  readonly username?: PrometheusAgentSpecRemoteWriteBasicAuthUsername;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteBasicAuth(
  obj: PrometheusAgentSpecRemoteWriteBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_PrometheusAgentSpecRemoteWriteBasicAuthPassword(
      obj.password,
    ),
    "username": toJson_PrometheusAgentSpecRemoteWriteBasicAuthUsername(
      obj.username,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * MetadataConfig configures the sending of series metadata to the remote storage.
 *
 * @schema PrometheusAgentSpecRemoteWriteMetadataConfig
 */
export interface PrometheusAgentSpecRemoteWriteMetadataConfig {
  /**
   * Defines whether metric metadata is sent to the remote storage or not.
   *
   * @schema PrometheusAgentSpecRemoteWriteMetadataConfig#send
   */
  readonly send?: boolean;

  /**
   * Defines how frequently metric metadata is sent to the remote storage.
   *
   * @schema PrometheusAgentSpecRemoteWriteMetadataConfig#sendInterval
   */
  readonly sendInterval?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteMetadataConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteMetadataConfig(
  obj: PrometheusAgentSpecRemoteWriteMetadataConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "send": obj.send,
    "sendInterval": obj.sendInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth2 configuration for the URL.
 * It requires Prometheus >= v2.27.0.
 * Cannot be set at the same time as `sigv4`, `authorization`, `basicAuth`, or `azureAd`.
 *
 * @schema PrometheusAgentSpecRemoteWriteOauth2
 */
export interface PrometheusAgentSpecRemoteWriteOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2#clientId
   */
  readonly clientId: PrometheusAgentSpecRemoteWriteOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2#clientSecret
   */
  readonly clientSecret: PrometheusAgentSpecRemoteWriteOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteOauth2(
  obj: PrometheusAgentSpecRemoteWriteOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": toJson_PrometheusAgentSpecRemoteWriteOauth2ClientId(
      obj.clientId,
    ),
    "clientSecret": toJson_PrometheusAgentSpecRemoteWriteOauth2ClientSecret(
      obj.clientSecret,
    ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * QueueConfig allows tuning of the remote write queue parameters.
 *
 * @schema PrometheusAgentSpecRemoteWriteQueueConfig
 */
export interface PrometheusAgentSpecRemoteWriteQueueConfig {
  /**
   * BatchSendDeadline is the maximum time a sample will wait in buffer.
   *
   * @schema PrometheusAgentSpecRemoteWriteQueueConfig#batchSendDeadline
   */
  readonly batchSendDeadline?: string;

  /**
   * Capacity is the number of samples to buffer per shard before we start dropping them.
   *
   * @schema PrometheusAgentSpecRemoteWriteQueueConfig#capacity
   */
  readonly capacity?: number;

  /**
   * MaxBackoff is the maximum retry delay.
   *
   * @schema PrometheusAgentSpecRemoteWriteQueueConfig#maxBackoff
   */
  readonly maxBackoff?: string;

  /**
   * MaxRetries is the maximum number of times to retry a batch on recoverable errors.
   *
   * @schema PrometheusAgentSpecRemoteWriteQueueConfig#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * MaxSamplesPerSend is the maximum number of samples per send.
   *
   * @schema PrometheusAgentSpecRemoteWriteQueueConfig#maxSamplesPerSend
   */
  readonly maxSamplesPerSend?: number;

  /**
   * MaxShards is the maximum number of shards, i.e. amount of concurrency.
   *
   * @schema PrometheusAgentSpecRemoteWriteQueueConfig#maxShards
   */
  readonly maxShards?: number;

  /**
   * MinBackoff is the initial retry delay. Gets doubled for every retry.
   *
   * @schema PrometheusAgentSpecRemoteWriteQueueConfig#minBackoff
   */
  readonly minBackoff?: string;

  /**
   * MinShards is the minimum number of shards, i.e. amount of concurrency.
   *
   * @schema PrometheusAgentSpecRemoteWriteQueueConfig#minShards
   */
  readonly minShards?: number;

  /**
   * Retry upon receiving a 429 status code from the remote-write storage. This is experimental feature and might change in the future.
   *
   * @schema PrometheusAgentSpecRemoteWriteQueueConfig#retryOnRateLimit
   */
  readonly retryOnRateLimit?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteQueueConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteQueueConfig(
  obj: PrometheusAgentSpecRemoteWriteQueueConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "batchSendDeadline": obj.batchSendDeadline,
    "capacity": obj.capacity,
    "maxBackoff": obj.maxBackoff,
    "maxRetries": obj.maxRetries,
    "maxSamplesPerSend": obj.maxSamplesPerSend,
    "maxShards": obj.maxShards,
    "minBackoff": obj.minBackoff,
    "minShards": obj.minShards,
    "retryOnRateLimit": obj.retryOnRateLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sigv4 allows to configures AWS's Signature Verification 4 for the URL.
 * It requires Prometheus >= v2.26.0.
 * Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `azureAd`.
 *
 * @schema PrometheusAgentSpecRemoteWriteSigv4
 */
export interface PrometheusAgentSpecRemoteWriteSigv4 {
  /**
   * AccessKey is the AWS API key. If not specified, the environment variable `AWS_ACCESS_KEY_ID` is used.
   *
   * @schema PrometheusAgentSpecRemoteWriteSigv4#accessKey
   */
  readonly accessKey?: PrometheusAgentSpecRemoteWriteSigv4AccessKey;

  /**
   * Profile is the named AWS profile used to authenticate.
   *
   * @schema PrometheusAgentSpecRemoteWriteSigv4#profile
   */
  readonly profile?: string;

  /**
   * Region is the AWS region. If blank, the region from the default credentials chain used.
   *
   * @schema PrometheusAgentSpecRemoteWriteSigv4#region
   */
  readonly region?: string;

  /**
   * RoleArn is the named AWS profile used to authenticate.
   *
   * @schema PrometheusAgentSpecRemoteWriteSigv4#roleArn
   */
  readonly roleArn?: string;

  /**
   * SecretKey is the AWS API secret. If not specified, the environment variable `AWS_SECRET_ACCESS_KEY` is used.
   *
   * @schema PrometheusAgentSpecRemoteWriteSigv4#secretKey
   */
  readonly secretKey?: PrometheusAgentSpecRemoteWriteSigv4SecretKey;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteSigv4' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteSigv4(
  obj: PrometheusAgentSpecRemoteWriteSigv4 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessKey": toJson_PrometheusAgentSpecRemoteWriteSigv4AccessKey(
      obj.accessKey,
    ),
    "profile": obj.profile,
    "region": obj.region,
    "roleArn": obj.roleArn,
    "secretKey": toJson_PrometheusAgentSpecRemoteWriteSigv4SecretKey(
      obj.secretKey,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS Config to use for the URL.
 *
 * @schema PrometheusAgentSpecRemoteWriteTlsConfig
 */
export interface PrometheusAgentSpecRemoteWriteTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfig#ca
   */
  readonly ca?: PrometheusAgentSpecRemoteWriteTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfig#cert
   */
  readonly cert?: PrometheusAgentSpecRemoteWriteTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusAgentSpecRemoteWriteTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteTlsConfig(
  obj: PrometheusAgentSpecRemoteWriteTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_PrometheusAgentSpecRemoteWriteTlsConfigCa(obj.ca),
    "caFile": obj.caFile,
    "cert": toJson_PrometheusAgentSpecRemoteWriteTlsConfigCert(obj.cert),
    "certFile": obj.certFile,
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keyFile": obj.keyFile,
    "keySecret": toJson_PrometheusAgentSpecRemoteWriteTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema PrometheusAgentSpecRemoteWriteWriteRelabelConfigs
 */
export interface PrometheusAgentSpecRemoteWriteWriteRelabelConfigs {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   *
   * @schema PrometheusAgentSpecRemoteWriteWriteRelabelConfigs#action
   */
  readonly action?: PrometheusAgentSpecRemoteWriteWriteRelabelConfigsAction;

  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   *
   * @schema PrometheusAgentSpecRemoteWriteWriteRelabelConfigs#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema PrometheusAgentSpecRemoteWriteWriteRelabelConfigs#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the regular expression matches.
   * Regex capture groups are available.
   *
   * @schema PrometheusAgentSpecRemoteWriteWriteRelabelConfigs#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema PrometheusAgentSpecRemoteWriteWriteRelabelConfigs#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
   *
   * @schema PrometheusAgentSpecRemoteWriteWriteRelabelConfigs#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions.
   * Regex capture groups are available.
   *
   * @schema PrometheusAgentSpecRemoteWriteWriteRelabelConfigs#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteWriteRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteWriteRelabelConfigs(
  obj: PrometheusAgentSpecRemoteWriteWriteRelabelConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "action": obj.action,
    "modulus": obj.modulus,
    "regex": obj.regex,
    "replacement": obj.replacement,
    "separator": obj.separator,
    "sourceLabels": obj.sourceLabels?.map((y) => y),
    "targetLabel": obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusAgentSpecResourcesClaims
 */
export interface PrometheusAgentSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusAgentSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecResourcesClaims(
  obj: PrometheusAgentSpecResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusAgentSpecResourcesLimits
 */
export class PrometheusAgentSpecResourcesLimits {
  public static fromNumber(value: number): PrometheusAgentSpecResourcesLimits {
    return new PrometheusAgentSpecResourcesLimits(value);
  }
  public static fromString(value: string): PrometheusAgentSpecResourcesLimits {
    return new PrometheusAgentSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusAgentSpecResourcesRequests
 */
export class PrometheusAgentSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecResourcesRequests {
    return new PrometheusAgentSpecResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecResourcesRequests {
    return new PrometheusAgentSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecScrapeConfigNamespaceSelectorMatchExpressions
 */
export interface PrometheusAgentSpecScrapeConfigNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecScrapeConfigNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecScrapeConfigNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecScrapeConfigNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecScrapeConfigNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecScrapeConfigNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecScrapeConfigNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecScrapeConfigSelectorMatchExpressions
 */
export interface PrometheusAgentSpecScrapeConfigSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecScrapeConfigSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecScrapeConfigSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecScrapeConfigSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecScrapeConfigSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecScrapeConfigSelectorMatchExpressions(
  obj: PrometheusAgentSpecScrapeConfigSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusAgentSpecSecurityContextSeLinuxOptions
 */
export interface PrometheusAgentSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PrometheusAgentSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PrometheusAgentSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PrometheusAgentSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PrometheusAgentSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecSecurityContextSeLinuxOptions(
  obj: PrometheusAgentSpecSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusAgentSpecSecurityContextSeccompProfile
 */
export interface PrometheusAgentSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema PrometheusAgentSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema PrometheusAgentSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecSecurityContextSeccompProfile(
  obj: PrometheusAgentSpecSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema PrometheusAgentSpecSecurityContextSysctls
 */
export interface PrometheusAgentSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema PrometheusAgentSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema PrometheusAgentSpecSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecSecurityContextSysctls(
  obj: PrometheusAgentSpecSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PrometheusAgentSpecSecurityContextWindowsOptions
 */
export interface PrometheusAgentSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PrometheusAgentSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PrometheusAgentSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PrometheusAgentSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PrometheusAgentSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecSecurityContextWindowsOptions(
  obj: PrometheusAgentSpecSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecServiceMonitorNamespaceSelectorMatchExpressions
 */
export interface PrometheusAgentSpecServiceMonitorNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecServiceMonitorNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecServiceMonitorNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecServiceMonitorNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecServiceMonitorNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecServiceMonitorNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecServiceMonitorNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecServiceMonitorSelectorMatchExpressions
 */
export interface PrometheusAgentSpecServiceMonitorSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecServiceMonitorSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecServiceMonitorSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecServiceMonitorSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecServiceMonitorSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecServiceMonitorSelectorMatchExpressions(
  obj: PrometheusAgentSpecServiceMonitorSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDirVolumeSource to be used by the StatefulSet. If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema PrometheusAgentSpecStorageEmptyDir
 */
export interface PrometheusAgentSpecStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusAgentSpecStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusAgentSpecStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: PrometheusAgentSpecStorageEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageEmptyDir(
  obj: PrometheusAgentSpecStorageEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "medium": obj.medium,
    "sizeLimit": obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EphemeralVolumeSource to be used by the StatefulSet. This is a beta field in k8s 1.21 and GA in 1.15. For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
 *
 * @schema PrometheusAgentSpecStorageEphemeral
 */
export interface PrometheusAgentSpecStorageEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema PrometheusAgentSpecStorageEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?:
    PrometheusAgentSpecStorageEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageEphemeral(
  obj: PrometheusAgentSpecStorageEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "volumeClaimTemplate":
      toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplate(
        obj.volumeClaimTemplate,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the PVC spec to be used by the Prometheus StatefulSets. The easiest way to use a volume that cannot be automatically provisioned is to use a label selector alongside manually created PersistentVolumes.
 *
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplate
 */
export interface PrometheusAgentSpecStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: PrometheusAgentSpecStorageVolumeClaimTemplateMetadata;

  /**
   * Defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplate#spec
   */
  readonly spec?: PrometheusAgentSpecStorageVolumeClaimTemplateSpec;

  /**
   * Deprecated: this field is never set.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplate#status
   */
  readonly status?: PrometheusAgentSpecStorageVolumeClaimTemplateStatus;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageVolumeClaimTemplate(
  obj: PrometheusAgentSpecStorageVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "kind": obj.kind,
    "metadata": toJson_PrometheusAgentSpecStorageVolumeClaimTemplateMetadata(
      obj.metadata,
    ),
    "spec": toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpec(obj.spec),
    "status": toJson_PrometheusAgentSpecStorageVolumeClaimTemplateStatus(
      obj.status,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines what Prometheus Operator managed labels should be added to labelSelector on the topologySpreadConstraint.
 *
 * @schema PrometheusAgentSpecTopologySpreadConstraintsAdditionalLabelSelectors
 */
export enum PrometheusAgentSpecTopologySpreadConstraintsAdditionalLabelSelectors {
  /** OnResource */
  ON_RESOURCE = "OnResource",
  /** OnShard */
  ON_SHARD = "OnShard",
}

/**
 * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
 *
 * @schema PrometheusAgentSpecTopologySpreadConstraintsLabelSelector
 */
export interface PrometheusAgentSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTopologySpreadConstraintsLabelSelector(
  obj: PrometheusAgentSpecTopologySpreadConstraintsLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client used to export the traces. Supported values are `http` or `grpc`.
 *
 * @schema PrometheusAgentSpecTracingConfigClientType
 */
export enum PrometheusAgentSpecTracingConfigClientType {
  /** http */
  HTTP = "http",
  /** grpc */
  GRPC = "grpc",
}

/**
 * Compression key for supported compression types. The only supported value is `gzip`.
 *
 * @schema PrometheusAgentSpecTracingConfigCompression
 */
export enum PrometheusAgentSpecTracingConfigCompression {
  /** gzip */
  GZIP = "gzip",
}

/**
 * Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
 *
 * @schema PrometheusAgentSpecTracingConfigSamplingFraction
 */
export class PrometheusAgentSpecTracingConfigSamplingFraction {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecTracingConfigSamplingFraction {
    return new PrometheusAgentSpecTracingConfigSamplingFraction(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecTracingConfigSamplingFraction {
    return new PrometheusAgentSpecTracingConfigSamplingFraction(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TLS Config to use when sending traces.
 *
 * @schema PrometheusAgentSpecTracingConfigTlsConfig
 */
export interface PrometheusAgentSpecTracingConfigTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfig#ca
   */
  readonly ca?: PrometheusAgentSpecTracingConfigTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfig#cert
   */
  readonly cert?: PrometheusAgentSpecTracingConfigTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfig#keySecret
   */
  readonly keySecret?: PrometheusAgentSpecTracingConfigTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecTracingConfigTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTracingConfigTlsConfig(
  obj: PrometheusAgentSpecTracingConfigTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_PrometheusAgentSpecTracingConfigTlsConfigCa(obj.ca),
    "caFile": obj.caFile,
    "cert": toJson_PrometheusAgentSpecTracingConfigTlsConfigCert(obj.cert),
    "certFile": obj.certFile,
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keyFile": obj.keyFile,
    "keySecret": toJson_PrometheusAgentSpecTracingConfigTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema PrometheusAgentSpecVolumesAwsElasticBlockStore
 */
export interface PrometheusAgentSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusAgentSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema PrometheusAgentSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PrometheusAgentSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PrometheusAgentSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesAwsElasticBlockStore(
  obj: PrometheusAgentSpecVolumesAwsElasticBlockStore | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "partition": obj.partition,
    "readOnly": obj.readOnly,
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema PrometheusAgentSpecVolumesAzureDisk
 */
export interface PrometheusAgentSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema PrometheusAgentSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema PrometheusAgentSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema PrometheusAgentSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusAgentSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema PrometheusAgentSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PrometheusAgentSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesAzureDisk(
  obj: PrometheusAgentSpecVolumesAzureDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "cachingMode": obj.cachingMode,
    "diskName": obj.diskName,
    "diskURI": obj.diskUri,
    "fsType": obj.fsType,
    "kind": obj.kind,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema PrometheusAgentSpecVolumesAzureFile
 */
export interface PrometheusAgentSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusAgentSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema PrometheusAgentSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema PrometheusAgentSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesAzureFile(
  obj: PrometheusAgentSpecVolumesAzureFile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "readOnly": obj.readOnly,
    "secretName": obj.secretName,
    "shareName": obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema PrometheusAgentSpecVolumesCephfs
 */
export interface PrometheusAgentSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusAgentSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema PrometheusAgentSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema PrometheusAgentSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusAgentSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusAgentSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: PrometheusAgentSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PrometheusAgentSpecVolumesCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesCephfs(
  obj: PrometheusAgentSpecVolumesCephfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "monitors": obj.monitors?.map((y) => y),
    "path": obj.path,
    "readOnly": obj.readOnly,
    "secretFile": obj.secretFile,
    "secretRef": toJson_PrometheusAgentSpecVolumesCephfsSecretRef(
      obj.secretRef,
    ),
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema PrometheusAgentSpecVolumesCinder
 */
export interface PrometheusAgentSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusAgentSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusAgentSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema PrometheusAgentSpecVolumesCinder#secretRef
   */
  readonly secretRef?: PrometheusAgentSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema PrometheusAgentSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesCinder(
  obj: PrometheusAgentSpecVolumesCinder | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusAgentSpecVolumesCinderSecretRef(
      obj.secretRef,
    ),
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema PrometheusAgentSpecVolumesConfigMap
 */
export interface PrometheusAgentSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PrometheusAgentSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusAgentSpecVolumesConfigMap#items
   */
  readonly items?: PrometheusAgentSpecVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema PrometheusAgentSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesConfigMap(
  obj: PrometheusAgentSpecVolumesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) =>
      toJson_PrometheusAgentSpecVolumesConfigMapItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema PrometheusAgentSpecVolumesCsi
 */
export interface PrometheusAgentSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema PrometheusAgentSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema PrometheusAgentSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema PrometheusAgentSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?:
    PrometheusAgentSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema PrometheusAgentSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema PrometheusAgentSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesCsi(
  obj: PrometheusAgentSpecVolumesCsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "driver": obj.driver,
    "fsType": obj.fsType,
    "nodePublishSecretRef":
      toJson_PrometheusAgentSpecVolumesCsiNodePublishSecretRef(
        obj.nodePublishSecretRef,
      ),
    "readOnly": obj.readOnly,
    "volumeAttributes": ((obj.volumeAttributes) === undefined)
      ? undefined
      : (Object.entries(obj.volumeAttributes).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema PrometheusAgentSpecVolumesDownwardApi
 */
export interface PrometheusAgentSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PrometheusAgentSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema PrometheusAgentSpecVolumesDownwardApi#items
   */
  readonly items?: PrometheusAgentSpecVolumesDownwardApiItems[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesDownwardApi(
  obj: PrometheusAgentSpecVolumesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) =>
      toJson_PrometheusAgentSpecVolumesDownwardApiItems(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema PrometheusAgentSpecVolumesEmptyDir
 */
export interface PrometheusAgentSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusAgentSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PrometheusAgentSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: PrometheusAgentSpecVolumesEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesEmptyDir(
  obj: PrometheusAgentSpecVolumesEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "medium": obj.medium,
    "sizeLimit": obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema PrometheusAgentSpecVolumesEphemeral
 */
export interface PrometheusAgentSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema PrometheusAgentSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?:
    PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesEphemeral(
  obj: PrometheusAgentSpecVolumesEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "volumeClaimTemplate":
      toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplate(
        obj.volumeClaimTemplate,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema PrometheusAgentSpecVolumesFc
 */
export interface PrometheusAgentSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusAgentSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema PrometheusAgentSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PrometheusAgentSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema PrometheusAgentSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema PrometheusAgentSpecVolumesFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesFc(
  obj: PrometheusAgentSpecVolumesFc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "lun": obj.lun,
    "readOnly": obj.readOnly,
    "targetWWNs": obj.targetWwNs?.map((y) => y),
    "wwids": obj.wwids?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema PrometheusAgentSpecVolumesFlexVolume
 */
export interface PrometheusAgentSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema PrometheusAgentSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema PrometheusAgentSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema PrometheusAgentSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusAgentSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema PrometheusAgentSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: PrometheusAgentSpecVolumesFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesFlexVolume(
  obj: PrometheusAgentSpecVolumesFlexVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "driver": obj.driver,
    "fsType": obj.fsType,
    "options": ((obj.options) === undefined)
      ? undefined
      : (Object.entries(obj.options).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusAgentSpecVolumesFlexVolumeSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema PrometheusAgentSpecVolumesFlocker
 */
export interface PrometheusAgentSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema PrometheusAgentSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema PrometheusAgentSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesFlocker(
  obj: PrometheusAgentSpecVolumesFlocker | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "datasetName": obj.datasetName,
    "datasetUUID": obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema PrometheusAgentSpecVolumesGcePersistentDisk
 */
export interface PrometheusAgentSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusAgentSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PrometheusAgentSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PrometheusAgentSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema PrometheusAgentSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesGcePersistentDisk(
  obj: PrometheusAgentSpecVolumesGcePersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "partition": obj.partition,
    "pdName": obj.pdName,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema PrometheusAgentSpecVolumesGitRepo
 */
export interface PrometheusAgentSpecVolumesGitRepo {
  /**
   * directory is the target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema PrometheusAgentSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema PrometheusAgentSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema PrometheusAgentSpecVolumesGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesGitRepo(
  obj: PrometheusAgentSpecVolumesGitRepo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "directory": obj.directory,
    "repository": obj.repository,
    "revision": obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema PrometheusAgentSpecVolumesGlusterfs
 */
export interface PrometheusAgentSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PrometheusAgentSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PrometheusAgentSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema PrometheusAgentSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesGlusterfs(
  obj: PrometheusAgentSpecVolumesGlusterfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "endpoints": obj.endpoints,
    "path": obj.path,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema PrometheusAgentSpecVolumesHostPath
 */
export interface PrometheusAgentSpecVolumesHostPath {
  /**
   * path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema PrometheusAgentSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema PrometheusAgentSpecVolumesHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesHostPath(
  obj: PrometheusAgentSpecVolumesHostPath | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "path": obj.path,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema PrometheusAgentSpecVolumesIscsi
 */
export interface PrometheusAgentSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema PrometheusAgentSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema PrometheusAgentSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusAgentSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema PrometheusAgentSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema PrometheusAgentSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema PrometheusAgentSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema PrometheusAgentSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PrometheusAgentSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema PrometheusAgentSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema PrometheusAgentSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: PrometheusAgentSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PrometheusAgentSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesIscsi(
  obj: PrometheusAgentSpecVolumesIscsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "chapAuthDiscovery": obj.chapAuthDiscovery,
    "chapAuthSession": obj.chapAuthSession,
    "fsType": obj.fsType,
    "initiatorName": obj.initiatorName,
    "iqn": obj.iqn,
    "iscsiInterface": obj.iscsiInterface,
    "lun": obj.lun,
    "portals": obj.portals?.map((y) => y),
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusAgentSpecVolumesIscsiSecretRef(obj.secretRef),
    "targetPortal": obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema PrometheusAgentSpecVolumesNfs
 */
export interface PrometheusAgentSpecVolumesNfs {
  /**
   * path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PrometheusAgentSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema PrometheusAgentSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PrometheusAgentSpecVolumesNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesNfs(
  obj: PrometheusAgentSpecVolumesNfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "path": obj.path,
    "readOnly": obj.readOnly,
    "server": obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema PrometheusAgentSpecVolumesPersistentVolumeClaim
 */
export interface PrometheusAgentSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PrometheusAgentSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema PrometheusAgentSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesPersistentVolumeClaim(
  obj: PrometheusAgentSpecVolumesPersistentVolumeClaim | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claimName": obj.claimName,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema PrometheusAgentSpecVolumesPhotonPersistentDisk
 */
export interface PrometheusAgentSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusAgentSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema PrometheusAgentSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesPhotonPersistentDisk(
  obj: PrometheusAgentSpecVolumesPhotonPersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "pdID": obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema PrometheusAgentSpecVolumesPortworxVolume
 */
export interface PrometheusAgentSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusAgentSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusAgentSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema PrometheusAgentSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesPortworxVolume(
  obj: PrometheusAgentSpecVolumesPortworxVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema PrometheusAgentSpecVolumesProjected
 */
export interface PrometheusAgentSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusAgentSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema PrometheusAgentSpecVolumesProjected#sources
   */
  readonly sources?: PrometheusAgentSpecVolumesProjectedSources[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesProjected(
  obj: PrometheusAgentSpecVolumesProjected | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "sources": obj.sources?.map((y) =>
      toJson_PrometheusAgentSpecVolumesProjectedSources(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema PrometheusAgentSpecVolumesQuobyte
 */
export interface PrometheusAgentSpecVolumesQuobyte {
  /**
   * group to map volume access to Default is no group
   *
   * @default no group
   * @schema PrometheusAgentSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema PrometheusAgentSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema PrometheusAgentSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema PrometheusAgentSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema PrometheusAgentSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema PrometheusAgentSpecVolumesQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesQuobyte(
  obj: PrometheusAgentSpecVolumesQuobyte | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "group": obj.group,
    "readOnly": obj.readOnly,
    "registry": obj.registry,
    "tenant": obj.tenant,
    "user": obj.user,
    "volume": obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema PrometheusAgentSpecVolumesRbd
 */
export interface PrometheusAgentSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema PrometheusAgentSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PrometheusAgentSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PrometheusAgentSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PrometheusAgentSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PrometheusAgentSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PrometheusAgentSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PrometheusAgentSpecVolumesRbd#secretRef
   */
  readonly secretRef?: PrometheusAgentSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema PrometheusAgentSpecVolumesRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesRbd(
  obj: PrometheusAgentSpecVolumesRbd | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "image": obj.image,
    "keyring": obj.keyring,
    "monitors": obj.monitors?.map((y) => y),
    "pool": obj.pool,
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusAgentSpecVolumesRbdSecretRef(obj.secretRef),
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema PrometheusAgentSpecVolumesScaleIo
 */
export interface PrometheusAgentSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema PrometheusAgentSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema PrometheusAgentSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema PrometheusAgentSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PrometheusAgentSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema PrometheusAgentSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: PrometheusAgentSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema PrometheusAgentSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema PrometheusAgentSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema PrometheusAgentSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema PrometheusAgentSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema PrometheusAgentSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesScaleIo(
  obj: PrometheusAgentSpecVolumesScaleIo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "gateway": obj.gateway,
    "protectionDomain": obj.protectionDomain,
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusAgentSpecVolumesScaleIoSecretRef(
      obj.secretRef,
    ),
    "sslEnabled": obj.sslEnabled,
    "storageMode": obj.storageMode,
    "storagePool": obj.storagePool,
    "system": obj.system,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema PrometheusAgentSpecVolumesSecret
 */
export interface PrometheusAgentSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PrometheusAgentSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusAgentSpecVolumesSecret#items
   */
  readonly items?: PrometheusAgentSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema PrometheusAgentSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema PrometheusAgentSpecVolumesSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesSecret(
  obj: PrometheusAgentSpecVolumesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) =>
      toJson_PrometheusAgentSpecVolumesSecretItems(y)
    ),
    "optional": obj.optional,
    "secretName": obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema PrometheusAgentSpecVolumesStorageos
 */
export interface PrometheusAgentSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusAgentSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema PrometheusAgentSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema PrometheusAgentSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: PrometheusAgentSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema PrometheusAgentSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema PrometheusAgentSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesStorageos(
  obj: PrometheusAgentSpecVolumesStorageos | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "secretRef": toJson_PrometheusAgentSpecVolumesStorageosSecretRef(
      obj.secretRef,
    ),
    "volumeName": obj.volumeName,
    "volumeNamespace": obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema PrometheusAgentSpecVolumesVsphereVolume
 */
export interface PrometheusAgentSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PrometheusAgentSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema PrometheusAgentSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema PrometheusAgentSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema PrometheusAgentSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesVsphereVolume(
  obj: PrometheusAgentSpecVolumesVsphereVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "storagePolicyID": obj.storagePolicyId,
    "storagePolicyName": obj.storagePolicyName,
    "volumePath": obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines HTTP parameters for web server.
 *
 * @schema PrometheusAgentSpecWebHttpConfig
 */
export interface PrometheusAgentSpecWebHttpConfig {
  /**
   * List of headers that can be added to HTTP responses.
   *
   * @schema PrometheusAgentSpecWebHttpConfig#headers
   */
  readonly headers?: PrometheusAgentSpecWebHttpConfigHeaders;

  /**
   * Enable HTTP/2 support. Note that HTTP/2 is only supported with TLS. When TLSConfig is not configured, HTTP/2 will be disabled. Whenever the value of the field changes, a rolling update will be triggered.
   *
   * @schema PrometheusAgentSpecWebHttpConfig#http2
   */
  readonly http2?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecWebHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecWebHttpConfig(
  obj: PrometheusAgentSpecWebHttpConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "headers": toJson_PrometheusAgentSpecWebHttpConfigHeaders(obj.headers),
    "http2": obj.http2,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the TLS parameters for HTTPS.
 *
 * @schema PrometheusAgentSpecWebTlsConfig
 */
export interface PrometheusAgentSpecWebTlsConfig {
  /**
   * Contains the TLS certificate for the server.
   *
   * @schema PrometheusAgentSpecWebTlsConfig#cert
   */
  readonly cert: PrometheusAgentSpecWebTlsConfigCert;

  /**
   * List of supported cipher suites for TLS versions up to TLS 1.2. If empty, Go default cipher suites are used. Available cipher suites are documented in the go documentation: https://golang.org/pkg/crypto/tls/#pkg-constants
   *
   * @schema PrometheusAgentSpecWebTlsConfig#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * Server policy for client authentication. Maps to ClientAuth Policies. For more detail on clientAuth options: https://golang.org/pkg/crypto/tls/#ClientAuthType
   *
   * @schema PrometheusAgentSpecWebTlsConfig#clientAuthType
   */
  readonly clientAuthType?: string;

  /**
   * Contains the CA certificate for client certificate authentication to the server.
   *
   * @schema PrometheusAgentSpecWebTlsConfig#client_ca
   */
  readonly clientCa?: PrometheusAgentSpecWebTlsConfigClientCa;

  /**
   * Elliptic curves that will be used in an ECDHE handshake, in preference order. Available curves are documented in the go documentation: https://golang.org/pkg/crypto/tls/#CurveID
   *
   * @schema PrometheusAgentSpecWebTlsConfig#curvePreferences
   */
  readonly curvePreferences?: string[];

  /**
   * Secret containing the TLS key for the server.
   *
   * @schema PrometheusAgentSpecWebTlsConfig#keySecret
   */
  readonly keySecret: PrometheusAgentSpecWebTlsConfigKeySecret;

  /**
   * Maximum TLS version that is acceptable. Defaults to TLS13.
   *
   * @default TLS13.
   * @schema PrometheusAgentSpecWebTlsConfig#maxVersion
   */
  readonly maxVersion?: string;

  /**
   * Minimum TLS version that is acceptable. Defaults to TLS12.
   *
   * @default TLS12.
   * @schema PrometheusAgentSpecWebTlsConfig#minVersion
   */
  readonly minVersion?: string;

  /**
   * Controls whether the server selects the client's most preferred cipher suite, or the server's most preferred cipher suite. If true then the server's preference, as expressed in the order of elements in cipherSuites, is used.
   *
   * @schema PrometheusAgentSpecWebTlsConfig#preferServerCipherSuites
   */
  readonly preferServerCipherSuites?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecWebTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecWebTlsConfig(
  obj: PrometheusAgentSpecWebTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "cert": toJson_PrometheusAgentSpecWebTlsConfigCert(obj.cert),
    "cipherSuites": obj.cipherSuites?.map((y) => y),
    "clientAuthType": obj.clientAuthType,
    "client_ca": toJson_PrometheusAgentSpecWebTlsConfigClientCa(obj.clientCa),
    "curvePreferences": obj.curvePreferences?.map((y) => y),
    "keySecret": toJson_PrometheusAgentSpecWebTlsConfigKeySecret(obj.keySecret),
    "maxVersion": obj.maxVersion,
    "minVersion": obj.minVersion,
    "preferServerCipherSuites": obj.preferServerCipherSuites,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference:
    PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preference":
      toJson_PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms:
    PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeSelectorTerms": obj.nodeSelectorTerms?.map((y) =>
      toJson_PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PrometheusAgentSpecApiserverConfigAuthorizationCredentials
 */
export interface PrometheusAgentSpecApiserverConfigAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecApiserverConfigAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecApiserverConfigAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecApiserverConfigAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigAuthorizationCredentials(
  obj: PrometheusAgentSpecApiserverConfigAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema PrometheusAgentSpecApiserverConfigBasicAuthPassword
 */
export interface PrometheusAgentSpecApiserverConfigBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecApiserverConfigBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecApiserverConfigBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecApiserverConfigBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigBasicAuthPassword(
  obj: PrometheusAgentSpecApiserverConfigBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema PrometheusAgentSpecApiserverConfigBasicAuthUsername
 */
export interface PrometheusAgentSpecApiserverConfigBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecApiserverConfigBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecApiserverConfigBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecApiserverConfigBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigBasicAuthUsername(
  obj: PrometheusAgentSpecApiserverConfigBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusAgentSpecApiserverConfigTlsConfigCa
 */
export interface PrometheusAgentSpecApiserverConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusAgentSpecApiserverConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCa#secret
   */
  readonly secret?: PrometheusAgentSpecApiserverConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigTlsConfigCa(
  obj: PrometheusAgentSpecApiserverConfigTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusAgentSpecApiserverConfigTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusAgentSpecApiserverConfigTlsConfigCaSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusAgentSpecApiserverConfigTlsConfigCert
 */
export interface PrometheusAgentSpecApiserverConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusAgentSpecApiserverConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCert#secret
   */
  readonly secret?: PrometheusAgentSpecApiserverConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigTlsConfigCert(
  obj: PrometheusAgentSpecApiserverConfigTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_PrometheusAgentSpecApiserverConfigTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret": toJson_PrometheusAgentSpecApiserverConfigTlsConfigCertSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusAgentSpecApiserverConfigTlsConfigKeySecret
 */
export interface PrometheusAgentSpecApiserverConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigTlsConfigKeySecret(
  obj: PrometheusAgentSpecApiserverConfigTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema PrometheusAgentSpecContainersEnvValueFrom
 */
export interface PrometheusAgentSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema PrometheusAgentSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?:
    PrometheusAgentSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema PrometheusAgentSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PrometheusAgentSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema PrometheusAgentSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?:
    PrometheusAgentSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema PrometheusAgentSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PrometheusAgentSpecContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersEnvValueFrom(
  obj: PrometheusAgentSpecContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapKeyRef":
      toJson_PrometheusAgentSpecContainersEnvValueFromConfigMapKeyRef(
        obj.configMapKeyRef,
      ),
    "fieldRef": toJson_PrometheusAgentSpecContainersEnvValueFromFieldRef(
      obj.fieldRef,
    ),
    "resourceFieldRef":
      toJson_PrometheusAgentSpecContainersEnvValueFromResourceFieldRef(
        obj.resourceFieldRef,
      ),
    "secretKeyRef":
      toJson_PrometheusAgentSpecContainersEnvValueFromSecretKeyRef(
        obj.secretKeyRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema PrometheusAgentSpecContainersEnvFromConfigMapRef
 */
export interface PrometheusAgentSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PrometheusAgentSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersEnvFromConfigMapRef(
  obj: PrometheusAgentSpecContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema PrometheusAgentSpecContainersEnvFromSecretRef
 */
export interface PrometheusAgentSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PrometheusAgentSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersEnvFromSecretRef(
  obj: PrometheusAgentSpecContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusAgentSpecContainersLifecyclePostStart
 */
export interface PrometheusAgentSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: PrometheusAgentSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: PrometheusAgentSpecContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PrometheusAgentSpecContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLifecyclePostStart(
  obj: PrometheusAgentSpecContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusAgentSpecContainersLifecyclePostStartExec(
      obj.exec,
    ),
    "httpGet": toJson_PrometheusAgentSpecContainersLifecyclePostStartHttpGet(
      obj.httpGet,
    ),
    "tcpSocket":
      toJson_PrometheusAgentSpecContainersLifecyclePostStartTcpSocket(
        obj.tcpSocket,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusAgentSpecContainersLifecyclePreStop
 */
export interface PrometheusAgentSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: PrometheusAgentSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: PrometheusAgentSpecContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PrometheusAgentSpecContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLifecyclePreStop(
  obj: PrometheusAgentSpecContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusAgentSpecContainersLifecyclePreStopExec(obj.exec),
    "httpGet": toJson_PrometheusAgentSpecContainersLifecyclePreStopHttpGet(
      obj.httpGet,
    ),
    "tcpSocket": toJson_PrometheusAgentSpecContainersLifecyclePreStopTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusAgentSpecContainersLivenessProbeExec
 */
export interface PrometheusAgentSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLivenessProbeExec(
  obj: PrometheusAgentSpecContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusAgentSpecContainersLivenessProbeGrpc
 */
export interface PrometheusAgentSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLivenessProbeGrpc(
  obj: PrometheusAgentSpecContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusAgentSpecContainersLivenessProbeHttpGet
 */
export interface PrometheusAgentSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusAgentSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: PrometheusAgentSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusAgentSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLivenessProbeHttpGet(
  obj: PrometheusAgentSpecContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusAgentSpecContainersLivenessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusAgentSpecContainersLivenessProbeTcpSocket
 */
export interface PrometheusAgentSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: PrometheusAgentSpecContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLivenessProbeTcpSocket(
  obj: PrometheusAgentSpecContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusAgentSpecContainersReadinessProbeExec
 */
export interface PrometheusAgentSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersReadinessProbeExec(
  obj: PrometheusAgentSpecContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusAgentSpecContainersReadinessProbeGrpc
 */
export interface PrometheusAgentSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersReadinessProbeGrpc(
  obj: PrometheusAgentSpecContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusAgentSpecContainersReadinessProbeHttpGet
 */
export interface PrometheusAgentSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusAgentSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: PrometheusAgentSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusAgentSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersReadinessProbeHttpGet(
  obj: PrometheusAgentSpecContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusAgentSpecContainersReadinessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusAgentSpecContainersReadinessProbeTcpSocket
 */
export interface PrometheusAgentSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: PrometheusAgentSpecContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersReadinessProbeTcpSocket(
  obj: PrometheusAgentSpecContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusAgentSpecContainersResourcesClaims
 */
export interface PrometheusAgentSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusAgentSpecContainersResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersResourcesClaims(
  obj: PrometheusAgentSpecContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusAgentSpecContainersResourcesLimits
 */
export class PrometheusAgentSpecContainersResourcesLimits {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersResourcesLimits {
    return new PrometheusAgentSpecContainersResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersResourcesLimits {
    return new PrometheusAgentSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusAgentSpecContainersResourcesRequests
 */
export class PrometheusAgentSpecContainersResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersResourcesRequests {
    return new PrometheusAgentSpecContainersResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersResourcesRequests {
    return new PrometheusAgentSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema PrometheusAgentSpecContainersSecurityContextCapabilities
 */
export interface PrometheusAgentSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PrometheusAgentSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PrometheusAgentSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersSecurityContextCapabilities(
  obj: PrometheusAgentSpecContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "add": obj.add?.map((y) => y),
    "drop": obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusAgentSpecContainersSecurityContextSeLinuxOptions
 */
export interface PrometheusAgentSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PrometheusAgentSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PrometheusAgentSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PrometheusAgentSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PrometheusAgentSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersSecurityContextSeLinuxOptions(
  obj: PrometheusAgentSpecContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusAgentSpecContainersSecurityContextSeccompProfile
 */
export interface PrometheusAgentSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema PrometheusAgentSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema PrometheusAgentSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersSecurityContextSeccompProfile(
  obj: PrometheusAgentSpecContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PrometheusAgentSpecContainersSecurityContextWindowsOptions
 */
export interface PrometheusAgentSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PrometheusAgentSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PrometheusAgentSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PrometheusAgentSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PrometheusAgentSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersSecurityContextWindowsOptions(
  obj: PrometheusAgentSpecContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusAgentSpecContainersStartupProbeExec
 */
export interface PrometheusAgentSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusAgentSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersStartupProbeExec(
  obj: PrometheusAgentSpecContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusAgentSpecContainersStartupProbeGrpc
 */
export interface PrometheusAgentSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusAgentSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusAgentSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersStartupProbeGrpc(
  obj: PrometheusAgentSpecContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusAgentSpecContainersStartupProbeHttpGet
 */
export interface PrometheusAgentSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusAgentSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusAgentSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusAgentSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusAgentSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecContainersStartupProbeHttpGet#port
   */
  readonly port: PrometheusAgentSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusAgentSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersStartupProbeHttpGet(
  obj: PrometheusAgentSpecContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusAgentSpecContainersStartupProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusAgentSpecContainersStartupProbeTcpSocket
 */
export interface PrometheusAgentSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusAgentSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: PrometheusAgentSpecContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersStartupProbeTcpSocket(
  obj: PrometheusAgentSpecContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema PrometheusAgentSpecInitContainersEnvValueFrom
 */
export interface PrometheusAgentSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?:
    PrometheusAgentSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PrometheusAgentSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?:
    PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?:
    PrometheusAgentSpecInitContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersEnvValueFrom(
  obj: PrometheusAgentSpecInitContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapKeyRef":
      toJson_PrometheusAgentSpecInitContainersEnvValueFromConfigMapKeyRef(
        obj.configMapKeyRef,
      ),
    "fieldRef": toJson_PrometheusAgentSpecInitContainersEnvValueFromFieldRef(
      obj.fieldRef,
    ),
    "resourceFieldRef":
      toJson_PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRef(
        obj.resourceFieldRef,
      ),
    "secretKeyRef":
      toJson_PrometheusAgentSpecInitContainersEnvValueFromSecretKeyRef(
        obj.secretKeyRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema PrometheusAgentSpecInitContainersEnvFromConfigMapRef
 */
export interface PrometheusAgentSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PrometheusAgentSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersEnvFromConfigMapRef(
  obj: PrometheusAgentSpecInitContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema PrometheusAgentSpecInitContainersEnvFromSecretRef
 */
export interface PrometheusAgentSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PrometheusAgentSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersEnvFromSecretRef(
  obj: PrometheusAgentSpecInitContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePostStart
 */
export interface PrometheusAgentSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: PrometheusAgentSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?:
    PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLifecyclePostStart(
  obj: PrometheusAgentSpecInitContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusAgentSpecInitContainersLifecyclePostStartExec(
      obj.exec,
    ),
    "httpGet":
      toJson_PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet(
        obj.httpGet,
      ),
    "tcpSocket":
      toJson_PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocket(
        obj.tcpSocket,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePreStop
 */
export interface PrometheusAgentSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: PrometheusAgentSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?:
    PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLifecyclePreStop(
  obj: PrometheusAgentSpecInitContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_PrometheusAgentSpecInitContainersLifecyclePreStopExec(
      obj.exec,
    ),
    "httpGet": toJson_PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet(
      obj.httpGet,
    ),
    "tcpSocket":
      toJson_PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocket(
        obj.tcpSocket,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusAgentSpecInitContainersLivenessProbeExec
 */
export interface PrometheusAgentSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLivenessProbeExec(
  obj: PrometheusAgentSpecInitContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusAgentSpecInitContainersLivenessProbeGrpc
 */
export interface PrometheusAgentSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLivenessProbeGrpc(
  obj: PrometheusAgentSpecInitContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusAgentSpecInitContainersLivenessProbeHttpGet
 */
export interface PrometheusAgentSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: PrometheusAgentSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusAgentSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLivenessProbeHttpGet(
  obj: PrometheusAgentSpecInitContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusAgentSpecInitContainersLivenessProbeTcpSocket
 */
export interface PrometheusAgentSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: PrometheusAgentSpecInitContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLivenessProbeTcpSocket(
  obj: PrometheusAgentSpecInitContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusAgentSpecInitContainersReadinessProbeExec
 */
export interface PrometheusAgentSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersReadinessProbeExec(
  obj: PrometheusAgentSpecInitContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusAgentSpecInitContainersReadinessProbeGrpc
 */
export interface PrometheusAgentSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersReadinessProbeGrpc(
  obj: PrometheusAgentSpecInitContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusAgentSpecInitContainersReadinessProbeHttpGet
 */
export interface PrometheusAgentSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: PrometheusAgentSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusAgentSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersReadinessProbeHttpGet(
  obj: PrometheusAgentSpecInitContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders(
        y,
      )
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusAgentSpecInitContainersReadinessProbeTcpSocket
 */
export interface PrometheusAgentSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: PrometheusAgentSpecInitContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersReadinessProbeTcpSocket(
  obj: PrometheusAgentSpecInitContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusAgentSpecInitContainersResourcesClaims
 */
export interface PrometheusAgentSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusAgentSpecInitContainersResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersResourcesClaims(
  obj: PrometheusAgentSpecInitContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusAgentSpecInitContainersResourcesLimits
 */
export class PrometheusAgentSpecInitContainersResourcesLimits {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersResourcesLimits {
    return new PrometheusAgentSpecInitContainersResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersResourcesLimits {
    return new PrometheusAgentSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusAgentSpecInitContainersResourcesRequests
 */
export class PrometheusAgentSpecInitContainersResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersResourcesRequests {
    return new PrometheusAgentSpecInitContainersResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersResourcesRequests {
    return new PrometheusAgentSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema PrometheusAgentSpecInitContainersSecurityContextCapabilities
 */
export interface PrometheusAgentSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersSecurityContextCapabilities(
  obj: PrometheusAgentSpecInitContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "add": obj.add?.map((y) => y),
    "drop": obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusAgentSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface PrometheusAgentSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersSecurityContextSeLinuxOptions(
  obj:
    | PrometheusAgentSpecInitContainersSecurityContextSeLinuxOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema PrometheusAgentSpecInitContainersSecurityContextSeccompProfile
 */
export interface PrometheusAgentSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersSecurityContextSeccompProfile(
  obj:
    | PrometheusAgentSpecInitContainersSecurityContextSeccompProfile
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema PrometheusAgentSpecInitContainersSecurityContextWindowsOptions
 */
export interface PrometheusAgentSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema PrometheusAgentSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PrometheusAgentSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersSecurityContextWindowsOptions(
  obj:
    | PrometheusAgentSpecInitContainersSecurityContextWindowsOptions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusAgentSpecInitContainersStartupProbeExec
 */
export interface PrometheusAgentSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersStartupProbeExec(
  obj: PrometheusAgentSpecInitContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema PrometheusAgentSpecInitContainersStartupProbeGrpc
 */
export interface PrometheusAgentSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersStartupProbeGrpc(
  obj: PrometheusAgentSpecInitContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusAgentSpecInitContainersStartupProbeHttpGet
 */
export interface PrometheusAgentSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusAgentSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: PrometheusAgentSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusAgentSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersStartupProbeHttpGet(
  obj: PrometheusAgentSpecInitContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusAgentSpecInitContainersStartupProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema PrometheusAgentSpecInitContainersStartupProbeTcpSocket
 */
export interface PrometheusAgentSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: PrometheusAgentSpecInitContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersStartupProbeTcpSocket(
  obj: PrometheusAgentSpecInitContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema PrometheusAgentSpecRemoteWriteAuthorizationCredentials
 */
export interface PrometheusAgentSpecRemoteWriteAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecRemoteWriteAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteAuthorizationCredentials(
  obj: PrometheusAgentSpecRemoteWriteAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure Cloud. Options are 'AzurePublic', 'AzureChina', or 'AzureGovernment'.
 *
 * @schema PrometheusAgentSpecRemoteWriteAzureAdCloud
 */
export enum PrometheusAgentSpecRemoteWriteAzureAdCloud {
  /** AzureChina */
  AZURE_CHINA = "AzureChina",
  /** AzureGovernment */
  AZURE_GOVERNMENT = "AzureGovernment",
  /** AzurePublic */
  AZURE_PUBLIC = "AzurePublic",
}

/**
 * ManagedIdentity defines the Azure User-assigned Managed identity. Cannot be set at the same time as `oauth`.
 *
 * @schema PrometheusAgentSpecRemoteWriteAzureAdManagedIdentity
 */
export interface PrometheusAgentSpecRemoteWriteAzureAdManagedIdentity {
  /**
   * The client id
   *
   * @schema PrometheusAgentSpecRemoteWriteAzureAdManagedIdentity#clientId
   */
  readonly clientId: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteAzureAdManagedIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteAzureAdManagedIdentity(
  obj: PrometheusAgentSpecRemoteWriteAzureAdManagedIdentity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": obj.clientId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth defines the oauth config that is being used to authenticate. Cannot be set at the same time as `managedIdentity`.
 * It requires Prometheus >= v2.48.0.
 *
 * @schema PrometheusAgentSpecRemoteWriteAzureAdOauth
 */
export interface PrometheusAgentSpecRemoteWriteAzureAdOauth {
  /**
   * `clientID` is the clientId of the Azure Active Directory application that is being used to authenticate.
   *
   * @schema PrometheusAgentSpecRemoteWriteAzureAdOauth#clientId
   */
  readonly clientId: string;

  /**
   * `clientSecret` specifies a key of a Secret containing the client secret of the Azure Active Directory application that is being used to authenticate.
   *
   * @schema PrometheusAgentSpecRemoteWriteAzureAdOauth#clientSecret
   */
  readonly clientSecret: PrometheusAgentSpecRemoteWriteAzureAdOauthClientSecret;

  /**
   * `tenantID` is the tenant ID of the Azure Active Directory application that is being used to authenticate.
   *
   * @schema PrometheusAgentSpecRemoteWriteAzureAdOauth#tenantId
   */
  readonly tenantId: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteAzureAdOauth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteAzureAdOauth(
  obj: PrometheusAgentSpecRemoteWriteAzureAdOauth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": obj.clientId,
    "clientSecret":
      toJson_PrometheusAgentSpecRemoteWriteAzureAdOauthClientSecret(
        obj.clientSecret,
      ),
    "tenantId": obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema PrometheusAgentSpecRemoteWriteBasicAuthPassword
 */
export interface PrometheusAgentSpecRemoteWriteBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecRemoteWriteBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteBasicAuthPassword(
  obj: PrometheusAgentSpecRemoteWriteBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema PrometheusAgentSpecRemoteWriteBasicAuthUsername
 */
export interface PrometheusAgentSpecRemoteWriteBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecRemoteWriteBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteBasicAuthUsername(
  obj: PrometheusAgentSpecRemoteWriteBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema PrometheusAgentSpecRemoteWriteOauth2ClientId
 */
export interface PrometheusAgentSpecRemoteWriteOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2ClientId#configMap
   */
  readonly configMap?: PrometheusAgentSpecRemoteWriteOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2ClientId#secret
   */
  readonly secret?: PrometheusAgentSpecRemoteWriteOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteOauth2ClientId(
  obj: PrometheusAgentSpecRemoteWriteOauth2ClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusAgentSpecRemoteWriteOauth2ClientIdConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusAgentSpecRemoteWriteOauth2ClientIdSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema PrometheusAgentSpecRemoteWriteOauth2ClientSecret
 */
export interface PrometheusAgentSpecRemoteWriteOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteOauth2ClientSecret(
  obj: PrometheusAgentSpecRemoteWriteOauth2ClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AccessKey is the AWS API key. If not specified, the environment variable `AWS_ACCESS_KEY_ID` is used.
 *
 * @schema PrometheusAgentSpecRemoteWriteSigv4AccessKey
 */
export interface PrometheusAgentSpecRemoteWriteSigv4AccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecRemoteWriteSigv4AccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteSigv4AccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteSigv4AccessKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteSigv4AccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteSigv4AccessKey(
  obj: PrometheusAgentSpecRemoteWriteSigv4AccessKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey is the AWS API secret. If not specified, the environment variable `AWS_SECRET_ACCESS_KEY` is used.
 *
 * @schema PrometheusAgentSpecRemoteWriteSigv4SecretKey
 */
export interface PrometheusAgentSpecRemoteWriteSigv4SecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecRemoteWriteSigv4SecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteSigv4SecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteSigv4SecretKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteSigv4SecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteSigv4SecretKey(
  obj: PrometheusAgentSpecRemoteWriteSigv4SecretKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusAgentSpecRemoteWriteTlsConfigCa
 */
export interface PrometheusAgentSpecRemoteWriteTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusAgentSpecRemoteWriteTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCa#secret
   */
  readonly secret?: PrometheusAgentSpecRemoteWriteTlsConfigCaSecret;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteTlsConfigCa(
  obj: PrometheusAgentSpecRemoteWriteTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusAgentSpecRemoteWriteTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusAgentSpecRemoteWriteTlsConfigCaSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusAgentSpecRemoteWriteTlsConfigCert
 */
export interface PrometheusAgentSpecRemoteWriteTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusAgentSpecRemoteWriteTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCert#secret
   */
  readonly secret?: PrometheusAgentSpecRemoteWriteTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteTlsConfigCert(
  obj: PrometheusAgentSpecRemoteWriteTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusAgentSpecRemoteWriteTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusAgentSpecRemoteWriteTlsConfigCertSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusAgentSpecRemoteWriteTlsConfigKeySecret
 */
export interface PrometheusAgentSpecRemoteWriteTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteTlsConfigKeySecret(
  obj: PrometheusAgentSpecRemoteWriteTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 *
 * @schema PrometheusAgentSpecRemoteWriteWriteRelabelConfigsAction
 */
export enum PrometheusAgentSpecRemoteWriteWriteRelabelConfigsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema PrometheusAgentSpecStorageEmptyDirSizeLimit
 */
export class PrometheusAgentSpecStorageEmptyDirSizeLimit {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecStorageEmptyDirSizeLimit {
    return new PrometheusAgentSpecStorageEmptyDirSizeLimit(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecStorageEmptyDirSizeLimit {
    return new PrometheusAgentSpecStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplate
 */
export interface PrometheusAgentSpecStorageEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplate(
  obj: PrometheusAgentSpecStorageEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec(
      obj.spec,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateMetadata
 */
export interface PrometheusAgentSpecStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageVolumeClaimTemplateMetadata(
  obj: PrometheusAgentSpecStorageVolumeClaimTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "annotations": ((obj.annotations) === undefined)
      ? undefined
      : (Object.entries(obj.annotations).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpec
 */
export interface PrometheusAgentSpecStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?:
    PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?:
    PrometheusAgentSpecStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpec(
  obj: PrometheusAgentSpecStorageVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource":
      toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSource(
        obj.dataSource,
      ),
    "dataSourceRef":
      toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources":
      toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecResources(
        obj.resources,
      ),
    "selector":
      toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelector(
        obj.selector,
      ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated: this field is never set.
 *
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatus
 */
export interface PrometheusAgentSpecStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC. Key names follow standard Kubernetes label syntax. Valid values are either: * Un-prefixed keys: - storage - the capacity of the volume. * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource" Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used.
   * ClaimResourceStatus can be in any of following states: - ControllerResizeInProgress: State set when resize controller starts resizing the volume in control-plane. - ControllerResizeFailed: State set when resize has failed in resize controller with a terminal error. - NodeResizePending: State set when resize controller has finished resizing the volume but further resizing of volume is needed on the node. - NodeResizeInProgress: State set when kubelet starts resizing the volume. - NodeResizeFailed: State set when resizing has failed in kubelet with a terminal error. Transient errors don't set NodeResizeFailed. For example: if expanding a PVC for more capacity - this field can be one of the following states: - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress" - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed" When this field is not set, it means that no resize operation is in progress for the given PVC.
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity. Key names follow standard Kubernetes label syntax. Valid values are either: * Un-prefixed keys: - storage - the capacity of the volume. * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource" Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used.
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation is requested. For storage quota, the larger value from allocatedResources and PVC.spec.resources is used. If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation. If a volume expansion capacity request is lowered, allocatedResources is only lowered if there are no expansion operations in progress and if the actual volume capacity is equal or lower than the requested capacity.
   * A controller that receives PVC update with previously unknown resourceName should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: {
    [key: string]:
      PrometheusAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources;
  };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: {
    [key: string]: PrometheusAgentSpecStorageVolumeClaimTemplateStatusCapacity;
  };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?:
    PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions[];

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageVolumeClaimTemplateStatus(
  obj: PrometheusAgentSpecStorageVolumeClaimTemplateStatus | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "allocatedResourceStatuses": ((obj.allocatedResourceStatuses) === undefined)
      ? undefined
      : (Object.entries(obj.allocatedResourceStatuses).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "allocatedResources": ((obj.allocatedResources) === undefined)
      ? undefined
      : (Object.entries(obj.allocatedResources).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "capacity": ((obj.capacity) === undefined)
      ? undefined
      : (Object.entries(obj.capacity).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "conditions": obj.conditions?.map((y) =>
      toJson_PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions(y)
    ),
    "phase": obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface PrometheusAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema PrometheusAgentSpecTracingConfigTlsConfigCa
 */
export interface PrometheusAgentSpecTracingConfigTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCa#configMap
   */
  readonly configMap?: PrometheusAgentSpecTracingConfigTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCa#secret
   */
  readonly secret?: PrometheusAgentSpecTracingConfigTlsConfigCaSecret;
}

/**
 * Converts an object of type 'PrometheusAgentSpecTracingConfigTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTracingConfigTlsConfigCa(
  obj: PrometheusAgentSpecTracingConfigTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusAgentSpecTracingConfigTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusAgentSpecTracingConfigTlsConfigCaSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema PrometheusAgentSpecTracingConfigTlsConfigCert
 */
export interface PrometheusAgentSpecTracingConfigTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusAgentSpecTracingConfigTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCert#secret
   */
  readonly secret?: PrometheusAgentSpecTracingConfigTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PrometheusAgentSpecTracingConfigTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTracingConfigTlsConfigCert(
  obj: PrometheusAgentSpecTracingConfigTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusAgentSpecTracingConfigTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusAgentSpecTracingConfigTlsConfigCertSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema PrometheusAgentSpecTracingConfigTlsConfigKeySecret
 */
export interface PrometheusAgentSpecTracingConfigTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecTracingConfigTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTracingConfigTlsConfigKeySecret(
  obj: PrometheusAgentSpecTracingConfigTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema PrometheusAgentSpecVolumesCephfsSecretRef
 */
export interface PrometheusAgentSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesCephfsSecretRef(
  obj: PrometheusAgentSpecVolumesCephfsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema PrometheusAgentSpecVolumesCinderSecretRef
 */
export interface PrometheusAgentSpecVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesCinderSecretRef(
  obj: PrometheusAgentSpecVolumesCinderSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusAgentSpecVolumesConfigMapItems
 */
export interface PrometheusAgentSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusAgentSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusAgentSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PrometheusAgentSpecVolumesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesConfigMapItems(
  obj: PrometheusAgentSpecVolumesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema PrometheusAgentSpecVolumesCsiNodePublishSecretRef
 */
export interface PrometheusAgentSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesCsiNodePublishSecretRef(
  obj: PrometheusAgentSpecVolumesCsiNodePublishSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PrometheusAgentSpecVolumesDownwardApiItems
 */
export interface PrometheusAgentSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema PrometheusAgentSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: PrometheusAgentSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusAgentSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PrometheusAgentSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema PrometheusAgentSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?:
    PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesDownwardApiItems(
  obj: PrometheusAgentSpecVolumesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fieldRef": toJson_PrometheusAgentSpecVolumesDownwardApiItemsFieldRef(
      obj.fieldRef,
    ),
    "mode": obj.mode,
    "path": obj.path,
    "resourceFieldRef":
      toJson_PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRef(
        obj.resourceFieldRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema PrometheusAgentSpecVolumesEmptyDirSizeLimit
 */
export class PrometheusAgentSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecVolumesEmptyDirSizeLimit {
    return new PrometheusAgentSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecVolumesEmptyDirSizeLimit {
    return new PrometheusAgentSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplate(
  obj: PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec(
      obj.spec,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema PrometheusAgentSpecVolumesFlexVolumeSecretRef
 */
export interface PrometheusAgentSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesFlexVolumeSecretRef(
  obj: PrometheusAgentSpecVolumesFlexVolumeSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema PrometheusAgentSpecVolumesIscsiSecretRef
 */
export interface PrometheusAgentSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesIscsiSecretRef(
  obj: PrometheusAgentSpecVolumesIscsiSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema PrometheusAgentSpecVolumesProjectedSources
 */
export interface PrometheusAgentSpecVolumesProjectedSources {
  /**
   * configMap information about the configMap data to project
   *
   * @schema PrometheusAgentSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: PrometheusAgentSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema PrometheusAgentSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: PrometheusAgentSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema PrometheusAgentSpecVolumesProjectedSources#secret
   */
  readonly secret?: PrometheusAgentSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema PrometheusAgentSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?:
    PrometheusAgentSpecVolumesProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesProjectedSources(
  obj: PrometheusAgentSpecVolumesProjectedSources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusAgentSpecVolumesProjectedSourcesConfigMap(
      obj.configMap,
    ),
    "downwardAPI": toJson_PrometheusAgentSpecVolumesProjectedSourcesDownwardApi(
      obj.downwardApi,
    ),
    "secret": toJson_PrometheusAgentSpecVolumesProjectedSourcesSecret(
      obj.secret,
    ),
    "serviceAccountToken":
      toJson_PrometheusAgentSpecVolumesProjectedSourcesServiceAccountToken(
        obj.serviceAccountToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema PrometheusAgentSpecVolumesRbdSecretRef
 */
export interface PrometheusAgentSpecVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesRbdSecretRef(
  obj: PrometheusAgentSpecVolumesRbdSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema PrometheusAgentSpecVolumesScaleIoSecretRef
 */
export interface PrometheusAgentSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesScaleIoSecretRef(
  obj: PrometheusAgentSpecVolumesScaleIoSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusAgentSpecVolumesSecretItems
 */
export interface PrometheusAgentSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusAgentSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusAgentSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PrometheusAgentSpecVolumesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesSecretItems(
  obj: PrometheusAgentSpecVolumesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema PrometheusAgentSpecVolumesStorageosSecretRef
 */
export interface PrometheusAgentSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesStorageosSecretRef(
  obj: PrometheusAgentSpecVolumesStorageosSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * List of headers that can be added to HTTP responses.
 *
 * @schema PrometheusAgentSpecWebHttpConfigHeaders
 */
export interface PrometheusAgentSpecWebHttpConfigHeaders {
  /**
   * Set the Content-Security-Policy header to HTTP responses. Unset if blank.
   *
   * @schema PrometheusAgentSpecWebHttpConfigHeaders#contentSecurityPolicy
   */
  readonly contentSecurityPolicy?: string;

  /**
   * Set the Strict-Transport-Security header to HTTP responses. Unset if blank. Please make sure that you use this with care as this header might force browsers to load Prometheus and the other applications hosted on the same domain and subdomains over HTTPS. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
   *
   * @schema PrometheusAgentSpecWebHttpConfigHeaders#strictTransportSecurity
   */
  readonly strictTransportSecurity?: string;

  /**
   * Set the X-Content-Type-Options header to HTTP responses. Unset if blank. Accepted value is nosniff. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
   *
   * @schema PrometheusAgentSpecWebHttpConfigHeaders#xContentTypeOptions
   */
  readonly xContentTypeOptions?:
    PrometheusAgentSpecWebHttpConfigHeadersXContentTypeOptions;

  /**
   * Set the X-Frame-Options header to HTTP responses. Unset if blank. Accepted values are deny and sameorigin. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
   *
   * @schema PrometheusAgentSpecWebHttpConfigHeaders#xFrameOptions
   */
  readonly xFrameOptions?: PrometheusAgentSpecWebHttpConfigHeadersXFrameOptions;

  /**
   * Set the X-XSS-Protection header to all responses. Unset if blank. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
   *
   * @schema PrometheusAgentSpecWebHttpConfigHeaders#xXSSProtection
   */
  readonly xXssProtection?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecWebHttpConfigHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecWebHttpConfigHeaders(
  obj: PrometheusAgentSpecWebHttpConfigHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "contentSecurityPolicy": obj.contentSecurityPolicy,
    "strictTransportSecurity": obj.strictTransportSecurity,
    "xContentTypeOptions": obj.xContentTypeOptions,
    "xFrameOptions": obj.xFrameOptions,
    "xXSSProtection": obj.xXssProtection,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the TLS certificate for the server.
 *
 * @schema PrometheusAgentSpecWebTlsConfigCert
 */
export interface PrometheusAgentSpecWebTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecWebTlsConfigCert#configMap
   */
  readonly configMap?: PrometheusAgentSpecWebTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecWebTlsConfigCert#secret
   */
  readonly secret?: PrometheusAgentSpecWebTlsConfigCertSecret;
}

/**
 * Converts an object of type 'PrometheusAgentSpecWebTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecWebTlsConfigCert(
  obj: PrometheusAgentSpecWebTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusAgentSpecWebTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusAgentSpecWebTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Contains the CA certificate for client certificate authentication to the server.
 *
 * @schema PrometheusAgentSpecWebTlsConfigClientCa
 */
export interface PrometheusAgentSpecWebTlsConfigClientCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecWebTlsConfigClientCa#configMap
   */
  readonly configMap?: PrometheusAgentSpecWebTlsConfigClientCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema PrometheusAgentSpecWebTlsConfigClientCa#secret
   */
  readonly secret?: PrometheusAgentSpecWebTlsConfigClientCaSecret;
}

/**
 * Converts an object of type 'PrometheusAgentSpecWebTlsConfigClientCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecWebTlsConfigClientCa(
  obj: PrometheusAgentSpecWebTlsConfigClientCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_PrometheusAgentSpecWebTlsConfigClientCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_PrometheusAgentSpecWebTlsConfigClientCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the TLS key for the server.
 *
 * @schema PrometheusAgentSpecWebTlsConfigKeySecret
 */
export interface PrometheusAgentSpecWebTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecWebTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecWebTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecWebTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecWebTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecWebTlsConfigKeySecret(
  obj: PrometheusAgentSpecWebTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?:
    PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?:
    PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecApiserverConfigTlsConfigCaConfigMap
 */
export interface PrometheusAgentSpecApiserverConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigTlsConfigCaConfigMap(
  obj: PrometheusAgentSpecApiserverConfigTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecApiserverConfigTlsConfigCaSecret
 */
export interface PrometheusAgentSpecApiserverConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigTlsConfigCaSecret(
  obj: PrometheusAgentSpecApiserverConfigTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecApiserverConfigTlsConfigCertConfigMap
 */
export interface PrometheusAgentSpecApiserverConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigTlsConfigCertConfigMap(
  obj: PrometheusAgentSpecApiserverConfigTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecApiserverConfigTlsConfigCertSecret
 */
export interface PrometheusAgentSpecApiserverConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecApiserverConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecApiserverConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecApiserverConfigTlsConfigCertSecret(
  obj: PrometheusAgentSpecApiserverConfigTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema PrometheusAgentSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface PrometheusAgentSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PrometheusAgentSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusAgentSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersEnvValueFromConfigMapKeyRef(
  obj: PrometheusAgentSpecContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema PrometheusAgentSpecContainersEnvValueFromFieldRef
 */
export interface PrometheusAgentSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusAgentSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusAgentSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersEnvValueFromFieldRef(
  obj: PrometheusAgentSpecContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema PrometheusAgentSpecContainersEnvValueFromResourceFieldRef
 */
export interface PrometheusAgentSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusAgentSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusAgentSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?:
    PrometheusAgentSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusAgentSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersEnvValueFromResourceFieldRef(
  obj: PrometheusAgentSpecContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema PrometheusAgentSpecContainersEnvValueFromSecretKeyRef
 */
export interface PrometheusAgentSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersEnvValueFromSecretKeyRef(
  obj: PrometheusAgentSpecContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusAgentSpecContainersLifecyclePostStartExec
 */
export interface PrometheusAgentSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLifecyclePostStartExec(
  obj: PrometheusAgentSpecContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusAgentSpecContainersLifecyclePostStartHttpGet
 */
export interface PrometheusAgentSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: PrometheusAgentSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusAgentSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLifecyclePostStartHttpGet(
  obj: PrometheusAgentSpecContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders(
        y,
      )
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusAgentSpecContainersLifecyclePostStartTcpSocket
 */
export interface PrometheusAgentSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: PrometheusAgentSpecContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLifecyclePostStartTcpSocket(
  obj: PrometheusAgentSpecContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusAgentSpecContainersLifecyclePreStopExec
 */
export interface PrometheusAgentSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLifecyclePreStopExec(
  obj: PrometheusAgentSpecContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusAgentSpecContainersLifecyclePreStopHttpGet
 */
export interface PrometheusAgentSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: PrometheusAgentSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusAgentSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLifecyclePreStopHttpGet(
  obj: PrometheusAgentSpecContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusAgentSpecContainersLifecyclePreStopTcpSocket
 */
export interface PrometheusAgentSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: PrometheusAgentSpecContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLifecyclePreStopTcpSocket(
  obj: PrometheusAgentSpecContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusAgentSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface PrometheusAgentSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusAgentSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusAgentSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLivenessProbeHttpGetHttpHeaders(
  obj: PrometheusAgentSpecContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecContainersLivenessProbeHttpGetPort
 */
export class PrometheusAgentSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersLivenessProbeHttpGetPort {
    return new PrometheusAgentSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersLivenessProbeHttpGetPort {
    return new PrometheusAgentSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecContainersLivenessProbeTcpSocketPort
 */
export class PrometheusAgentSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersLivenessProbeTcpSocketPort {
    return new PrometheusAgentSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersLivenessProbeTcpSocketPort {
    return new PrometheusAgentSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusAgentSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface PrometheusAgentSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusAgentSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusAgentSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersReadinessProbeHttpGetHttpHeaders(
  obj:
    | PrometheusAgentSpecContainersReadinessProbeHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecContainersReadinessProbeHttpGetPort
 */
export class PrometheusAgentSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersReadinessProbeHttpGetPort {
    return new PrometheusAgentSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersReadinessProbeHttpGetPort {
    return new PrometheusAgentSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecContainersReadinessProbeTcpSocketPort
 */
export class PrometheusAgentSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersReadinessProbeTcpSocketPort {
    return new PrometheusAgentSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersReadinessProbeTcpSocketPort {
    return new PrometheusAgentSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusAgentSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface PrometheusAgentSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusAgentSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusAgentSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersStartupProbeHttpGetHttpHeaders(
  obj: PrometheusAgentSpecContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecContainersStartupProbeHttpGetPort
 */
export class PrometheusAgentSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersStartupProbeHttpGetPort {
    return new PrometheusAgentSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersStartupProbeHttpGetPort {
    return new PrometheusAgentSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecContainersStartupProbeTcpSocketPort
 */
export class PrometheusAgentSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersStartupProbeTcpSocketPort {
    return new PrometheusAgentSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersStartupProbeTcpSocketPort {
    return new PrometheusAgentSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema PrometheusAgentSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface PrometheusAgentSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersEnvValueFromConfigMapKeyRef(
  obj: PrometheusAgentSpecInitContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema PrometheusAgentSpecInitContainersEnvValueFromFieldRef
 */
export interface PrometheusAgentSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersEnvValueFromFieldRef(
  obj: PrometheusAgentSpecInitContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?:
    PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRef(
  obj:
    | PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema PrometheusAgentSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface PrometheusAgentSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersEnvValueFromSecretKeyRef(
  obj: PrometheusAgentSpecInitContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePostStartExec
 */
export interface PrometheusAgentSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLifecyclePostStartExec(
  obj: PrometheusAgentSpecInitContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet
 */
export interface PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet(
  obj: PrometheusAgentSpecInitContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
        y,
      )
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port:
    PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocket(
  obj: PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePreStopExec
 */
export interface PrometheusAgentSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLifecyclePreStopExec(
  obj: PrometheusAgentSpecInitContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet
 */
export interface PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet(
  obj: PrometheusAgentSpecInitContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(
        y,
      )
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocket(
  obj: PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface PrometheusAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders(
  obj:
    | PrometheusAgentSpecInitContainersLivenessProbeHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecInitContainersLivenessProbeHttpGetPort
 */
export class PrometheusAgentSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersLivenessProbeHttpGetPort {
    return new PrometheusAgentSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersLivenessProbeHttpGetPort {
    return new PrometheusAgentSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecInitContainersLivenessProbeTcpSocketPort
 */
export class PrometheusAgentSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersLivenessProbeTcpSocketPort {
    return new PrometheusAgentSpecInitContainersLivenessProbeTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersLivenessProbeTcpSocketPort {
    return new PrometheusAgentSpecInitContainersLivenessProbeTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface PrometheusAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders(
  obj:
    | PrometheusAgentSpecInitContainersReadinessProbeHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecInitContainersReadinessProbeHttpGetPort
 */
export class PrometheusAgentSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersReadinessProbeHttpGetPort {
    return new PrometheusAgentSpecInitContainersReadinessProbeHttpGetPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersReadinessProbeHttpGetPort {
    return new PrometheusAgentSpecInitContainersReadinessProbeHttpGetPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecInitContainersReadinessProbeTcpSocketPort
 */
export class PrometheusAgentSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersReadinessProbeTcpSocketPort {
    return new PrometheusAgentSpecInitContainersReadinessProbeTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersReadinessProbeTcpSocketPort {
    return new PrometheusAgentSpecInitContainersReadinessProbeTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusAgentSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface PrometheusAgentSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusAgentSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersStartupProbeHttpGetHttpHeaders(
  obj:
    | PrometheusAgentSpecInitContainersStartupProbeHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecInitContainersStartupProbeHttpGetPort
 */
export class PrometheusAgentSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersStartupProbeHttpGetPort {
    return new PrometheusAgentSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersStartupProbeHttpGetPort {
    return new PrometheusAgentSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecInitContainersStartupProbeTcpSocketPort
 */
export class PrometheusAgentSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersStartupProbeTcpSocketPort {
    return new PrometheusAgentSpecInitContainersStartupProbeTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersStartupProbeTcpSocketPort {
    return new PrometheusAgentSpecInitContainersStartupProbeTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * `clientSecret` specifies a key of a Secret containing the client secret of the Azure Active Directory application that is being used to authenticate.
 *
 * @schema PrometheusAgentSpecRemoteWriteAzureAdOauthClientSecret
 */
export interface PrometheusAgentSpecRemoteWriteAzureAdOauthClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecRemoteWriteAzureAdOauthClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteAzureAdOauthClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteAzureAdOauthClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteAzureAdOauthClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteAzureAdOauthClientSecret(
  obj: PrometheusAgentSpecRemoteWriteAzureAdOauthClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecRemoteWriteOauth2ClientIdConfigMap
 */
export interface PrometheusAgentSpecRemoteWriteOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteOauth2ClientIdConfigMap(
  obj: PrometheusAgentSpecRemoteWriteOauth2ClientIdConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecRemoteWriteOauth2ClientIdSecret
 */
export interface PrometheusAgentSpecRemoteWriteOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteOauth2ClientIdSecret(
  obj: PrometheusAgentSpecRemoteWriteOauth2ClientIdSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecRemoteWriteTlsConfigCaConfigMap
 */
export interface PrometheusAgentSpecRemoteWriteTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteTlsConfigCaConfigMap(
  obj: PrometheusAgentSpecRemoteWriteTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecRemoteWriteTlsConfigCaSecret
 */
export interface PrometheusAgentSpecRemoteWriteTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteTlsConfigCaSecret(
  obj: PrometheusAgentSpecRemoteWriteTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecRemoteWriteTlsConfigCertConfigMap
 */
export interface PrometheusAgentSpecRemoteWriteTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteTlsConfigCertConfigMap(
  obj: PrometheusAgentSpecRemoteWriteTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecRemoteWriteTlsConfigCertSecret
 */
export interface PrometheusAgentSpecRemoteWriteTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecRemoteWriteTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecRemoteWriteTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecRemoteWriteTlsConfigCertSecret(
  obj: PrometheusAgentSpecRemoteWriteTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec
 */
export interface PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?:
    PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?:
    PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?:
    PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec(
  obj: PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource":
      toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(
        obj.dataSource,
      ),
    "dataSourceRef":
      toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources":
      toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources(
        obj.resources,
      ),
    "selector":
      toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector(
        obj.selector,
      ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSource
 */
export interface PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSource(
  obj: PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSource | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef(
  obj:
    | PrometheusAgentSpecStorageVolumeClaimTemplateSpecDataSourceRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecResources
 */
export interface PrometheusAgentSpecStorageVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]:
      PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecResources(
  obj: PrometheusAgentSpecStorageVolumeClaimTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelector
 */
export interface PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelector(
  obj: PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class PrometheusAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new PrometheusAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new PrometheusAgentSpecStorageVolumeClaimTemplateStatusAllocatedResources(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatusCapacity
 */
export class PrometheusAgentSpecStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecStorageVolumeClaimTemplateStatusCapacity {
    return new PrometheusAgentSpecStorageVolumeClaimTemplateStatusCapacity(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecStorageVolumeClaimTemplateStatusCapacity {
    return new PrometheusAgentSpecStorageVolumeClaimTemplateStatusCapacity(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions
 */
export interface PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports "ResizeStarted" that means the underlying persistent volume is being resized.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions(
  obj:
    | PrometheusAgentSpecStorageVolumeClaimTemplateStatusConditions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "lastProbeTime": obj.lastProbeTime?.toISOString(),
    "lastTransitionTime": obj.lastTransitionTime?.toISOString(),
    "message": obj.message,
    "reason": obj.reason,
    "status": obj.status,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecTracingConfigTlsConfigCaConfigMap
 */
export interface PrometheusAgentSpecTracingConfigTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecTracingConfigTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTracingConfigTlsConfigCaConfigMap(
  obj: PrometheusAgentSpecTracingConfigTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecTracingConfigTlsConfigCaSecret
 */
export interface PrometheusAgentSpecTracingConfigTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecTracingConfigTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTracingConfigTlsConfigCaSecret(
  obj: PrometheusAgentSpecTracingConfigTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecTracingConfigTlsConfigCertConfigMap
 */
export interface PrometheusAgentSpecTracingConfigTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecTracingConfigTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTracingConfigTlsConfigCertConfigMap(
  obj: PrometheusAgentSpecTracingConfigTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecTracingConfigTlsConfigCertSecret
 */
export interface PrometheusAgentSpecTracingConfigTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecTracingConfigTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecTracingConfigTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecTracingConfigTlsConfigCertSecret(
  obj: PrometheusAgentSpecTracingConfigTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema PrometheusAgentSpecVolumesDownwardApiItemsFieldRef
 */
export interface PrometheusAgentSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusAgentSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusAgentSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesDownwardApiItemsFieldRef(
  obj: PrometheusAgentSpecVolumesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?:
    PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRef(
  obj: PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?:
    PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?:
    PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?:
    PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec(
  obj: PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource":
      toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
        obj.dataSource,
      ),
    "dataSourceRef":
      toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources":
      toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
        obj.resources,
      ),
    "selector":
      toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
        obj.selector,
      ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema PrometheusAgentSpecVolumesProjectedSourcesConfigMap
 */
export interface PrometheusAgentSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: PrometheusAgentSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesProjectedSourcesConfigMap(
  obj: PrometheusAgentSpecVolumesProjectedSourcesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_PrometheusAgentSpecVolumesProjectedSourcesConfigMapItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApi
 */
export interface PrometheusAgentSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesProjectedSourcesDownwardApi(
  obj: PrometheusAgentSpecVolumesProjectedSourcesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItems(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema PrometheusAgentSpecVolumesProjectedSourcesSecret
 */
export interface PrometheusAgentSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: PrometheusAgentSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesProjectedSourcesSecret(
  obj: PrometheusAgentSpecVolumesProjectedSourcesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_PrometheusAgentSpecVolumesProjectedSourcesSecretItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema PrometheusAgentSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface PrometheusAgentSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema PrometheusAgentSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the token into.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesProjectedSourcesServiceAccountToken(
  obj:
    | PrometheusAgentSpecVolumesProjectedSourcesServiceAccountToken
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "audience": obj.audience,
    "expirationSeconds": obj.expirationSeconds,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Set the X-Content-Type-Options header to HTTP responses. Unset if blank. Accepted value is nosniff. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
 *
 * @schema PrometheusAgentSpecWebHttpConfigHeadersXContentTypeOptions
 */
export enum PrometheusAgentSpecWebHttpConfigHeadersXContentTypeOptions {
  /** NoSniff */
  NO_SNIFF = "NoSniff",
}

/**
 * Set the X-Frame-Options header to HTTP responses. Unset if blank. Accepted values are deny and sameorigin. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
 *
 * @schema PrometheusAgentSpecWebHttpConfigHeadersXFrameOptions
 */
export enum PrometheusAgentSpecWebHttpConfigHeadersXFrameOptions {
  /** Deny */
  DENY = "Deny",
  /** SameOrigin */
  SAME_ORIGIN = "SameOrigin",
}

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecWebTlsConfigCertConfigMap
 */
export interface PrometheusAgentSpecWebTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusAgentSpecWebTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecWebTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusAgentSpecWebTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecWebTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecWebTlsConfigCertConfigMap(
  obj: PrometheusAgentSpecWebTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecWebTlsConfigCertSecret
 */
export interface PrometheusAgentSpecWebTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecWebTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecWebTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecWebTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecWebTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecWebTlsConfigCertSecret(
  obj: PrometheusAgentSpecWebTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecWebTlsConfigClientCaConfigMap
 */
export interface PrometheusAgentSpecWebTlsConfigClientCaConfigMap {
  /**
   * The key to select.
   *
   * @schema PrometheusAgentSpecWebTlsConfigClientCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecWebTlsConfigClientCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema PrometheusAgentSpecWebTlsConfigClientCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecWebTlsConfigClientCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecWebTlsConfigClientCaConfigMap(
  obj: PrometheusAgentSpecWebTlsConfigClientCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema PrometheusAgentSpecWebTlsConfigClientCaSecret
 */
export interface PrometheusAgentSpecWebTlsConfigClientCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PrometheusAgentSpecWebTlsConfigClientCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema PrometheusAgentSpecWebTlsConfigClientCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PrometheusAgentSpecWebTlsConfigClientCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'PrometheusAgentSpecWebTlsConfigClientCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecWebTlsConfigClientCaSecret(
  obj: PrometheusAgentSpecWebTlsConfigClientCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | PrometheusAgentSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | PrometheusAgentSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusAgentSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class PrometheusAgentSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusAgentSpecContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusAgentSpecContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface PrometheusAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders(
  obj:
    | PrometheusAgentSpecContainersLifecyclePostStartHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecContainersLifecyclePostStartHttpGetPort
 */
export class PrometheusAgentSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersLifecyclePostStartHttpGetPort {
    return new PrometheusAgentSpecContainersLifecyclePostStartHttpGetPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersLifecyclePostStartHttpGetPort {
    return new PrometheusAgentSpecContainersLifecyclePostStartHttpGetPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecContainersLifecyclePostStartTcpSocketPort
 */
export class PrometheusAgentSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusAgentSpecContainersLifecyclePostStartTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusAgentSpecContainersLifecyclePostStartTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface PrometheusAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders(
  obj:
    | PrometheusAgentSpecContainersLifecyclePreStopHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecContainersLifecyclePreStopHttpGetPort
 */
export class PrometheusAgentSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersLifecyclePreStopHttpGetPort {
    return new PrometheusAgentSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersLifecyclePreStopHttpGetPort {
    return new PrometheusAgentSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecContainersLifecyclePreStopTcpSocketPort
 */
export class PrometheusAgentSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusAgentSpecContainersLifecyclePreStopTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusAgentSpecContainersLifecyclePreStopTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new PrometheusAgentSpecInitContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
  obj:
    | PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PrometheusAgentSpecInitContainersLifecyclePostStartHttpGetPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PrometheusAgentSpecInitContainersLifecyclePostStartTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(
  obj:
    | PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PrometheusAgentSpecInitContainersLifecyclePreStopHttpGetPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PrometheusAgentSpecInitContainersLifecyclePreStopTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(
  obj:
    | PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSource
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj:
    | PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources
 */
export interface PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]:
      PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources(
  obj:
    | PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResources
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims(
        y,
      )
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector
 */
export interface PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector(
  obj:
    | PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesClaims
 */
export interface PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesClaims(
  obj:
    | PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesClaims
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusAgentSpecStorageVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusAgentSpecVolumesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
  obj:
    | PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj:
    | PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]:
      PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
  obj:
    | PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResources
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims(
        y,
      )
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
  obj:
    | PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusAgentSpecVolumesProjectedSourcesConfigMapItems
 */
export interface PrometheusAgentSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesProjectedSourcesConfigMapItems(
  obj: PrometheusAgentSpecVolumesProjectedSourcesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?:
    PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?:
    PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItems(
  obj: PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fieldRef":
      toJson_PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
        obj.fieldRef,
      ),
    "mode": obj.mode,
    "path": obj.path,
    "resourceFieldRef":
      toJson_PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
        obj.resourceFieldRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PrometheusAgentSpecVolumesProjectedSourcesSecretItems
 */
export interface PrometheusAgentSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesProjectedSourcesSecretItems(
  obj: PrometheusAgentSpecVolumesProjectedSourcesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims
 */
export interface PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims(
  obj:
    | PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims
 */
export interface PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims(
  obj:
    | PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | PrometheusAgentSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
  obj:
    | PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?:
    PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
  obj:
    | PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new PrometheusAgentSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PrometheusRule defines recording and alerting rules for a Prometheus instance
 *
 * @schema PrometheusRule
 */
export class PrometheusRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PrometheusRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "monitoring.coreos.com/v1",
    kind: "PrometheusRule",
  };

  /**
   * Renders a Kubernetes manifest for "PrometheusRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PrometheusRuleProps): any {
    return {
      ...PrometheusRule.GVK,
      ...toJson_PrometheusRuleProps(props),
    };
  }

  /**
   * Defines a "PrometheusRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PrometheusRuleProps) {
    super(scope, id, {
      ...PrometheusRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PrometheusRule.GVK,
      ...toJson_PrometheusRuleProps(resolved),
    };
  }
}

/**
 * PrometheusRule defines recording and alerting rules for a Prometheus instance
 *
 * @schema PrometheusRule
 */
export interface PrometheusRuleProps {
  /**
   * @schema PrometheusRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of desired alerting rule definitions for Prometheus.
   *
   * @schema PrometheusRule#spec
   */
  readonly spec: PrometheusRuleSpec;
}

/**
 * Converts an object of type 'PrometheusRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusRuleProps(
  obj: PrometheusRuleProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_PrometheusRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of desired alerting rule definitions for Prometheus.
 *
 * @schema PrometheusRuleSpec
 */
export interface PrometheusRuleSpec {
  /**
   * Content of Prometheus rule file
   *
   * @schema PrometheusRuleSpec#groups
   */
  readonly groups?: PrometheusRuleSpecGroups[];
}

/**
 * Converts an object of type 'PrometheusRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusRuleSpec(
  obj: PrometheusRuleSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "groups": obj.groups?.map((y) => toJson_PrometheusRuleSpecGroups(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RuleGroup is a list of sequentially evaluated recording and alerting rules.
 *
 * @schema PrometheusRuleSpecGroups
 */
export interface PrometheusRuleSpecGroups {
  /**
   * Interval determines how often rules in the group are evaluated.
   *
   * @schema PrometheusRuleSpecGroups#interval
   */
  readonly interval?: string;

  /**
   * Limit the number of alerts an alerting rule and series a recording rule can produce. Limit is supported starting with Prometheus >= 2.31 and Thanos Ruler >= 0.24.
   *
   * @schema PrometheusRuleSpecGroups#limit
   */
  readonly limit?: number;

  /**
   * Name of the rule group.
   *
   * @schema PrometheusRuleSpecGroups#name
   */
  readonly name: string;

  /**
   * PartialResponseStrategy is only used by ThanosRuler and will be ignored by Prometheus instances. More info: https://github.com/thanos-io/thanos/blob/main/docs/components/rule.md#partial-response
   *
   * @schema PrometheusRuleSpecGroups#partial_response_strategy
   */
  readonly partialResponseStrategy?: string;

  /**
   * List of alerting and recording rules.
   *
   * @schema PrometheusRuleSpecGroups#rules
   */
  readonly rules?: PrometheusRuleSpecGroupsRules[];
}

/**
 * Converts an object of type 'PrometheusRuleSpecGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusRuleSpecGroups(
  obj: PrometheusRuleSpecGroups | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "interval": obj.interval,
    "limit": obj.limit,
    "name": obj.name,
    "partial_response_strategy": obj.partialResponseStrategy,
    "rules": obj.rules?.map((y) => toJson_PrometheusRuleSpecGroupsRules(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Rule describes an alerting or recording rule See Prometheus documentation: [alerting](https://www.prometheus.io/docs/prometheus/latest/configuration/alerting_rules/) or [recording](https://www.prometheus.io/docs/prometheus/latest/configuration/recording_rules/#recording-rules) rule
 *
 * @schema PrometheusRuleSpecGroupsRules
 */
export interface PrometheusRuleSpecGroupsRules {
  /**
   * Name of the alert. Must be a valid label value. Only one of `record` and `alert` must be set.
   *
   * @schema PrometheusRuleSpecGroupsRules#alert
   */
  readonly alert?: string;

  /**
   * Annotations to add to each alert. Only valid for alerting rules.
   *
   * @schema PrometheusRuleSpecGroupsRules#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * PromQL expression to evaluate.
   *
   * @schema PrometheusRuleSpecGroupsRules#expr
   */
  readonly expr: PrometheusRuleSpecGroupsRulesExpr;

  /**
   * Alerts are considered firing once they have been returned for this long.
   *
   * @schema PrometheusRuleSpecGroupsRules#for
   */
  readonly for?: string;

  /**
   * KeepFiringFor defines how long an alert will continue firing after the condition that triggered it has cleared.
   *
   * @schema PrometheusRuleSpecGroupsRules#keep_firing_for
   */
  readonly keepFiringFor?: string;

  /**
   * Labels to add or overwrite.
   *
   * @schema PrometheusRuleSpecGroupsRules#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the time series to output to. Must be a valid metric name. Only one of `record` and `alert` must be set.
   *
   * @schema PrometheusRuleSpecGroupsRules#record
   */
  readonly record?: string;
}

/**
 * Converts an object of type 'PrometheusRuleSpecGroupsRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrometheusRuleSpecGroupsRules(
  obj: PrometheusRuleSpecGroupsRules | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "alert": obj.alert,
    "annotations": ((obj.annotations) === undefined)
      ? undefined
      : (Object.entries(obj.annotations).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "expr": obj.expr?.value,
    "for": obj.for,
    "keep_firing_for": obj.keepFiringFor,
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "record": obj.record,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PromQL expression to evaluate.
 *
 * @schema PrometheusRuleSpecGroupsRulesExpr
 */
export class PrometheusRuleSpecGroupsRulesExpr {
  public static fromNumber(value: number): PrometheusRuleSpecGroupsRulesExpr {
    return new PrometheusRuleSpecGroupsRulesExpr(value);
  }
  public static fromString(value: string): PrometheusRuleSpecGroupsRulesExpr {
    return new PrometheusRuleSpecGroupsRulesExpr(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ScrapeConfig defines a namespaced Prometheus scrape_config to be aggregated across multiple namespaces into the Prometheus configuration.
 *
 * @schema ScrapeConfig
 */
export class ScrapeConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ScrapeConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "monitoring.coreos.com/v1alpha1",
    kind: "ScrapeConfig",
  };

  /**
   * Renders a Kubernetes manifest for "ScrapeConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScrapeConfigProps): any {
    return {
      ...ScrapeConfig.GVK,
      ...toJson_ScrapeConfigProps(props),
    };
  }

  /**
   * Defines a "ScrapeConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScrapeConfigProps) {
    super(scope, id, {
      ...ScrapeConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ScrapeConfig.GVK,
      ...toJson_ScrapeConfigProps(resolved),
    };
  }
}

/**
 * ScrapeConfig defines a namespaced Prometheus scrape_config to be aggregated across multiple namespaces into the Prometheus configuration.
 *
 * @schema ScrapeConfig
 */
export interface ScrapeConfigProps {
  /**
   * @schema ScrapeConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScrapeConfigSpec is a specification of the desired configuration for a scrape configuration.
   *
   * @schema ScrapeConfig#spec
   */
  readonly spec: ScrapeConfigSpec;
}

/**
 * Converts an object of type 'ScrapeConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigProps(
  obj: ScrapeConfigProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ScrapeConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ScrapeConfigSpec is a specification of the desired configuration for a scrape configuration.
 *
 * @schema ScrapeConfigSpec
 */
export interface ScrapeConfigSpec {
  /**
   * Authorization header to use on every scrape request.
   *
   * @schema ScrapeConfigSpec#authorization
   */
  readonly authorization?: ScrapeConfigSpecAuthorization;

  /**
   * AzureSDConfigs defines a list of Azure service discovery configurations.
   *
   * @schema ScrapeConfigSpec#azureSDConfigs
   */
  readonly azureSdConfigs?: ScrapeConfigSpecAzureSdConfigs[];

  /**
   * BasicAuth information to use on every scrape request.
   *
   * @schema ScrapeConfigSpec#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecBasicAuth;

  /**
   * ConsulSDConfigs defines a list of Consul service discovery configurations.
   *
   * @schema ScrapeConfigSpec#consulSDConfigs
   */
  readonly consulSdConfigs?: ScrapeConfigSpecConsulSdConfigs[];

  /**
   * DNSSDConfigs defines a list of DNS service discovery configurations.
   *
   * @schema ScrapeConfigSpec#dnsSDConfigs
   */
  readonly dnsSdConfigs?: ScrapeConfigSpecDnsSdConfigs[];

  /**
   * EC2SDConfigs defines a list of EC2 service discovery configurations.
   *
   * @schema ScrapeConfigSpec#ec2SDConfigs
   */
  readonly ec2SdConfigs?: ScrapeConfigSpecEc2SdConfigs[];

  /**
   * FileSDConfigs defines a list of file service discovery configurations.
   *
   * @schema ScrapeConfigSpec#fileSDConfigs
   */
  readonly fileSdConfigs?: ScrapeConfigSpecFileSdConfigs[];

  /**
   * GCESDConfigs defines a list of GCE service discovery configurations.
   *
   * @schema ScrapeConfigSpec#gceSDConfigs
   */
  readonly gceSdConfigs?: ScrapeConfigSpecGceSdConfigs[];

  /**
   * HonorLabels chooses the metric's labels on collisions with target labels.
   *
   * @schema ScrapeConfigSpec#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
   *
   * @schema ScrapeConfigSpec#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * HTTPSDConfigs defines a list of HTTP service discovery configurations.
   *
   * @schema ScrapeConfigSpec#httpSDConfigs
   */
  readonly httpSdConfigs?: ScrapeConfigSpecHttpSdConfigs[];

  /**
   * Per-scrape limit on the number of targets dropped by relabeling that will be kept in memory. 0 means no limit.
   * It requires Prometheus >= v2.47.0.
   *
   * @schema ScrapeConfigSpec#keepDroppedTargets
   */
  readonly keepDroppedTargets?: number;

  /**
   * KubernetesSDConfigs defines a list of Kubernetes service discovery configurations.
   *
   * @schema ScrapeConfigSpec#kubernetesSDConfigs
   */
  readonly kubernetesSdConfigs?: ScrapeConfigSpecKubernetesSdConfigs[];

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ScrapeConfigSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ScrapeConfigSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
   *
   * @schema ScrapeConfigSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * MetricRelabelConfigs to apply to samples before ingestion.
   *
   * @schema ScrapeConfigSpec#metricRelabelings
   */
  readonly metricRelabelings?: ScrapeConfigSpecMetricRelabelings[];

  /**
   * MetricsPath HTTP path to scrape for metrics. If empty, Prometheus uses the default value (e.g. /metrics).
   *
   * @schema ScrapeConfigSpec#metricsPath
   */
  readonly metricsPath?: string;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names that should be excluded from proxying. IP and domain names can contain port numbers.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpec#noProxy
   */
  readonly noProxy?: string;

  /**
   * OpenStackSDConfigs defines a list of OpenStack service discovery configurations.
   *
   * @schema ScrapeConfigSpec#openstackSDConfigs
   */
  readonly openstackSdConfigs?: ScrapeConfigSpecOpenstackSdConfigs[];

  /**
   * Optional HTTP URL parameters
   *
   * @schema ScrapeConfigSpec#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpec#proxyConnectHeader
   */
  readonly proxyConnectHeader?: {
    [key: string]: ScrapeConfigSpecProxyConnectHeader;
  };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY). If unset, Prometheus uses its default value.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpec#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpec#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * RelabelConfigs defines how to rewrite the target's labels before scraping. Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields. The original scrape job's name is available via the `__tmp_prometheus_job_name` label. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema ScrapeConfigSpec#relabelings
   */
  readonly relabelings?: ScrapeConfigSpecRelabelings[];

  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   *
   * @schema ScrapeConfigSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * Configures the protocol scheme used for requests. If empty, Prometheus uses HTTP by default.
   *
   * @schema ScrapeConfigSpec#scheme
   */
  readonly scheme?: ScrapeConfigSpecScheme;

  /**
   * ScrapeInterval is the interval between consecutive scrapes.
   *
   * @schema ScrapeConfigSpec#scrapeInterval
   */
  readonly scrapeInterval?: string;

  /**
   * ScrapeTimeout is the number of seconds to wait until a scrape request times out.
   *
   * @schema ScrapeConfigSpec#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * StaticConfigs defines a list of static targets with a common label set.
   *
   * @schema ScrapeConfigSpec#staticConfigs
   */
  readonly staticConfigs?: ScrapeConfigSpecStaticConfigs[];

  /**
   * TargetLimit defines a limit on the number of scraped targets that will be accepted.
   *
   * @schema ScrapeConfigSpec#targetLimit
   */
  readonly targetLimit?: number;

  /**
   * TLS configuration to use on every scrape request
   *
   * @schema ScrapeConfigSpec#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecTlsConfig;

  /**
   * TrackTimestampsStaleness whether Prometheus tracks staleness of the metrics that have an explicit timestamp present in scraped data. Has no effect if `honorTimestamps` is false. It requires Prometheus >= v2.48.0.
   *
   * @schema ScrapeConfigSpec#trackTimestampsStaleness
   */
  readonly trackTimestampsStaleness?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpec(
  obj: ScrapeConfigSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization": toJson_ScrapeConfigSpecAuthorization(obj.authorization),
    "azureSDConfigs": obj.azureSdConfigs?.map((y) =>
      toJson_ScrapeConfigSpecAzureSdConfigs(y)
    ),
    "basicAuth": toJson_ScrapeConfigSpecBasicAuth(obj.basicAuth),
    "consulSDConfigs": obj.consulSdConfigs?.map((y) =>
      toJson_ScrapeConfigSpecConsulSdConfigs(y)
    ),
    "dnsSDConfigs": obj.dnsSdConfigs?.map((y) =>
      toJson_ScrapeConfigSpecDnsSdConfigs(y)
    ),
    "ec2SDConfigs": obj.ec2SdConfigs?.map((y) =>
      toJson_ScrapeConfigSpecEc2SdConfigs(y)
    ),
    "fileSDConfigs": obj.fileSdConfigs?.map((y) =>
      toJson_ScrapeConfigSpecFileSdConfigs(y)
    ),
    "gceSDConfigs": obj.gceSdConfigs?.map((y) =>
      toJson_ScrapeConfigSpecGceSdConfigs(y)
    ),
    "honorLabels": obj.honorLabels,
    "honorTimestamps": obj.honorTimestamps,
    "httpSDConfigs": obj.httpSdConfigs?.map((y) =>
      toJson_ScrapeConfigSpecHttpSdConfigs(y)
    ),
    "keepDroppedTargets": obj.keepDroppedTargets,
    "kubernetesSDConfigs": obj.kubernetesSdConfigs?.map((y) =>
      toJson_ScrapeConfigSpecKubernetesSdConfigs(y)
    ),
    "labelLimit": obj.labelLimit,
    "labelNameLengthLimit": obj.labelNameLengthLimit,
    "labelValueLengthLimit": obj.labelValueLengthLimit,
    "metricRelabelings": obj.metricRelabelings?.map((y) =>
      toJson_ScrapeConfigSpecMetricRelabelings(y)
    ),
    "metricsPath": obj.metricsPath,
    "noProxy": obj.noProxy,
    "openstackSDConfigs": obj.openstackSdConfigs?.map((y) =>
      toJson_ScrapeConfigSpecOpenstackSdConfigs(y)
    ),
    "params": ((obj.params) === undefined)
      ? undefined
      : (Object.entries(obj.params).reduce(
        (r, i) =>
          (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map((y) => y) }),
        {},
      )),
    "proxyConnectHeader": ((obj.proxyConnectHeader) === undefined)
      ? undefined
      : (Object.entries(obj.proxyConnectHeader).reduce(
        (r, i) =>
          (i[1] === undefined) ? r : ({
            ...r,
            [i[0]]: toJson_ScrapeConfigSpecProxyConnectHeader(i[1]),
          }),
        {},
      )),
    "proxyFromEnvironment": obj.proxyFromEnvironment,
    "proxyUrl": obj.proxyUrl,
    "relabelings": obj.relabelings?.map((y) =>
      toJson_ScrapeConfigSpecRelabelings(y)
    ),
    "sampleLimit": obj.sampleLimit,
    "scheme": obj.scheme,
    "scrapeInterval": obj.scrapeInterval,
    "scrapeTimeout": obj.scrapeTimeout,
    "staticConfigs": obj.staticConfigs?.map((y) =>
      toJson_ScrapeConfigSpecStaticConfigs(y)
    ),
    "targetLimit": obj.targetLimit,
    "tlsConfig": toJson_ScrapeConfigSpecTlsConfig(obj.tlsConfig),
    "trackTimestampsStaleness": obj.trackTimestampsStaleness,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header to use on every scrape request.
 *
 * @schema ScrapeConfigSpecAuthorization
 */
export interface ScrapeConfigSpecAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecAuthorization(
  obj: ScrapeConfigSpecAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials": toJson_ScrapeConfigSpecAuthorizationCredentials(
      obj.credentials,
    ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AzureSDConfig allow retrieving scrape targets from Azure VMs. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#azure_sd_config
 *
 * @schema ScrapeConfigSpecAzureSdConfigs
 */
export interface ScrapeConfigSpecAzureSdConfigs {
  /**
   * # The authentication method, either OAuth or ManagedIdentity. See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#authenticationMethod
   */
  readonly authenticationMethod?:
    ScrapeConfigSpecAzureSdConfigsAuthenticationMethod;

  /**
   * Optional client ID. Only required with the OAuth authentication method.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#clientID
   */
  readonly clientId?: string;

  /**
   * Optional client secret. Only required with the OAuth authentication method.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#clientSecret
   */
  readonly clientSecret?: ScrapeConfigSpecAzureSdConfigsClientSecret;

  /**
   * The Azure environment.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#environment
   */
  readonly environment?: string;

  /**
   * The port to scrape metrics from. If using the public IP address, this must instead be specified in the relabeling rule.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#port
   */
  readonly port?: number;

  /**
   * RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * Optional resource group name. Limits discovery to this resource group.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#resourceGroup
   */
  readonly resourceGroup?: string;

  /**
   * The subscription ID. Always required.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#subscriptionID
   */
  readonly subscriptionId: string;

  /**
   * Optional tenant ID. Only required with the OAuth authentication method.
   *
   * @schema ScrapeConfigSpecAzureSdConfigs#tenantID
   */
  readonly tenantId?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecAzureSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecAzureSdConfigs(
  obj: ScrapeConfigSpecAzureSdConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authenticationMethod": obj.authenticationMethod,
    "clientID": obj.clientId,
    "clientSecret": toJson_ScrapeConfigSpecAzureSdConfigsClientSecret(
      obj.clientSecret,
    ),
    "environment": obj.environment,
    "port": obj.port,
    "refreshInterval": obj.refreshInterval,
    "resourceGroup": obj.resourceGroup,
    "subscriptionID": obj.subscriptionId,
    "tenantID": obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to use on every scrape request.
 *
 * @schema ScrapeConfigSpecBasicAuth
 */
export interface ScrapeConfigSpecBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema ScrapeConfigSpecBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema ScrapeConfigSpecBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecBasicAuthUsername;
}

/**
 * Converts an object of type 'ScrapeConfigSpecBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecBasicAuth(
  obj: ScrapeConfigSpecBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_ScrapeConfigSpecBasicAuthPassword(obj.password),
    "username": toJson_ScrapeConfigSpecBasicAuthUsername(obj.username),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConsulSDConfig defines a Consul service discovery configuration See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config
 *
 * @schema ScrapeConfigSpecConsulSdConfigs
 */
export interface ScrapeConfigSpecConsulSdConfigs {
  /**
   * Allow stale Consul results (see https://www.consul.io/api/features/consistency.html). Will reduce load on Consul. If unset, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#allowStale
   */
  readonly allowStale?: boolean;

  /**
   * Authorization header configuration to authenticate against the Consul Server.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecConsulSdConfigsAuthorization;

  /**
   * BasicAuth information to authenticate against the Consul Server. More info: https://prometheus.io/docs/operating/configuration/#endpoints
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecConsulSdConfigsBasicAuth;

  /**
   * Consul Datacenter name, if not provided it will use the local Consul Agent Datacenter.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#datacenter
   */
  readonly datacenter?: string;

  /**
   * Whether to enable HTTP2. If unset, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects. If unset, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * Namespaces are only supported in Consul Enterprise.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#namespace
   */
  readonly namespace?: string;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names that should be excluded from proxying. IP and domain names can contain port numbers.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * Node metadata key/value pairs to filter nodes for a given service.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#nodeMeta
   */
  readonly nodeMeta?: { [key: string]: string };

  /**
   * Optional OAuth 2.0 configuration.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#oauth2
   */
  readonly oauth2?: ScrapeConfigSpecConsulSdConfigsOauth2;

  /**
   * Admin Partitions are only supported in Consul Enterprise.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#partition
   */
  readonly partition?: string;

  /**
   * ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: {
    [key: string]: ScrapeConfigSpecConsulSdConfigsProxyConnectHeader;
  };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY). If unset, Prometheus uses its default value.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * The time after which the provided names are refreshed. On large setup it might be a good idea to increase this value because the catalog will change all the time. If unset, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * HTTP Scheme default "http"
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#scheme
   */
  readonly scheme?: ScrapeConfigSpecConsulSdConfigsScheme;

  /**
   * A valid string consisting of a hostname or IP followed by an optional port number.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#server
   */
  readonly server: string;

  /**
   * A list of services for which targets are retrieved. If omitted, all services are scraped.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#services
   */
  readonly services?: string[];

  /**
   * The string by which Consul tags are joined into the tag label. If unset, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#tagSeparator
   */
  readonly tagSeparator?: string;

  /**
   * An optional list of tags used to filter nodes for a given service. Services must contain all tags in the list.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#tags
   */
  readonly tags?: string[];

  /**
   * TLS Config
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecConsulSdConfigsTlsConfig;

  /**
   * Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
   *
   * @schema ScrapeConfigSpecConsulSdConfigs#tokenRef
   */
  readonly tokenRef?: ScrapeConfigSpecConsulSdConfigsTokenRef;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigs(
  obj: ScrapeConfigSpecConsulSdConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "allowStale": obj.allowStale,
    "authorization": toJson_ScrapeConfigSpecConsulSdConfigsAuthorization(
      obj.authorization,
    ),
    "basicAuth": toJson_ScrapeConfigSpecConsulSdConfigsBasicAuth(obj.basicAuth),
    "datacenter": obj.datacenter,
    "enableHTTP2": obj.enableHttp2,
    "followRedirects": obj.followRedirects,
    "namespace": obj.namespace,
    "noProxy": obj.noProxy,
    "nodeMeta": ((obj.nodeMeta) === undefined)
      ? undefined
      : (Object.entries(obj.nodeMeta).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "oauth2": toJson_ScrapeConfigSpecConsulSdConfigsOauth2(obj.oauth2),
    "partition": obj.partition,
    "proxyConnectHeader": ((obj.proxyConnectHeader) === undefined)
      ? undefined
      : (Object.entries(obj.proxyConnectHeader).reduce(
        (r, i) =>
          (i[1] === undefined) ? r : ({
            ...r,
            [i[0]]: toJson_ScrapeConfigSpecConsulSdConfigsProxyConnectHeader(
              i[1],
            ),
          }),
        {},
      )),
    "proxyFromEnvironment": obj.proxyFromEnvironment,
    "proxyUrl": obj.proxyUrl,
    "refreshInterval": obj.refreshInterval,
    "scheme": obj.scheme,
    "server": obj.server,
    "services": obj.services?.map((y) => y),
    "tagSeparator": obj.tagSeparator,
    "tags": obj.tags?.map((y) => y),
    "tlsConfig": toJson_ScrapeConfigSpecConsulSdConfigsTlsConfig(obj.tlsConfig),
    "tokenRef": toJson_ScrapeConfigSpecConsulSdConfigsTokenRef(obj.tokenRef),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * DNSSDConfig allows specifying a set of DNS domain names which are periodically queried to discover a list of targets. The DNS servers to be contacted are read from /etc/resolv.conf. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dns_sd_config
 *
 * @schema ScrapeConfigSpecDnsSdConfigs
 */
export interface ScrapeConfigSpecDnsSdConfigs {
  /**
   * A list of DNS domain names to be queried.
   *
   * @schema ScrapeConfigSpecDnsSdConfigs#names
   */
  readonly names: string[];

  /**
   * The port number used if the query type is not SRV Ignored for SRV records
   *
   * @schema ScrapeConfigSpecDnsSdConfigs#port
   */
  readonly port?: number;

  /**
   * RefreshInterval configures the time after which the provided names are refreshed. If not set, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecDnsSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * The type of DNS query to perform. One of SRV, A, AAAA or MX. If not set, Prometheus uses its default value.
   *
   * @schema ScrapeConfigSpecDnsSdConfigs#type
   */
  readonly type?: ScrapeConfigSpecDnsSdConfigsType;
}

/**
 * Converts an object of type 'ScrapeConfigSpecDnsSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecDnsSdConfigs(
  obj: ScrapeConfigSpecDnsSdConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "names": obj.names?.map((y) => y),
    "port": obj.port,
    "refreshInterval": obj.refreshInterval,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EC2SDConfig allow retrieving scrape targets from AWS EC2 instances. The private IP address is used by default, but may be changed to the public IP address with relabeling. The IAM credentials used must have the ec2:DescribeInstances permission to discover scrape targets See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#ec2_sd_config
 *
 * @schema ScrapeConfigSpecEc2SdConfigs
 */
export interface ScrapeConfigSpecEc2SdConfigs {
  /**
   * AccessKey is the AWS API key.
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#accessKey
   */
  readonly accessKey?: ScrapeConfigSpecEc2SdConfigsAccessKey;

  /**
   * Filters can be used optionally to filter the instance list by other criteria. Available filter criteria can be found here: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html Filter API documentation: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Filter.html
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#filters
   */
  readonly filters?: ScrapeConfigSpecEc2SdConfigsFilters[];

  /**
   * The port to scrape metrics from. If using the public IP address, this must instead be specified in the relabeling rule.
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#port
   */
  readonly port?: number;

  /**
   * RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * The AWS region
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#region
   */
  readonly region?: string;

  /**
   * AWS Role ARN, an alternative to using AWS API keys.
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#roleARN
   */
  readonly roleArn?: string;

  /**
   * SecretKey is the AWS API secret.
   *
   * @schema ScrapeConfigSpecEc2SdConfigs#secretKey
   */
  readonly secretKey?: ScrapeConfigSpecEc2SdConfigsSecretKey;
}

/**
 * Converts an object of type 'ScrapeConfigSpecEc2SdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEc2SdConfigs(
  obj: ScrapeConfigSpecEc2SdConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessKey": toJson_ScrapeConfigSpecEc2SdConfigsAccessKey(obj.accessKey),
    "filters": obj.filters?.map((y) =>
      toJson_ScrapeConfigSpecEc2SdConfigsFilters(y)
    ),
    "port": obj.port,
    "refreshInterval": obj.refreshInterval,
    "region": obj.region,
    "roleARN": obj.roleArn,
    "secretKey": toJson_ScrapeConfigSpecEc2SdConfigsSecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * FileSDConfig defines a Prometheus file service discovery configuration See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#file_sd_config
 *
 * @schema ScrapeConfigSpecFileSdConfigs
 */
export interface ScrapeConfigSpecFileSdConfigs {
  /**
   * List of files to be used for file discovery. Recommendation: use absolute paths. While relative paths work, the prometheus-operator project makes no guarantees about the working directory where the configuration file is stored. Files must be mounted using Prometheus.ConfigMaps or Prometheus.Secrets.
   *
   * @schema ScrapeConfigSpecFileSdConfigs#files
   */
  readonly files: string[];

  /**
   * RefreshInterval configures the refresh interval at which Prometheus will reload the content of the files.
   *
   * @schema ScrapeConfigSpecFileSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecFileSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecFileSdConfigs(
  obj: ScrapeConfigSpecFileSdConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "files": obj.files?.map((y) => y),
    "refreshInterval": obj.refreshInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GCESDConfig configures scrape targets from GCP GCE instances. The private IP address is used by default, but may be changed to the public IP address with relabeling. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#gce_sd_config
 * The GCE service discovery will load the Google Cloud credentials from the file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable. See https://cloud.google.com/kubernetes-engine/docs/tutorials/authenticating-to-cloud-platform
 * A pre-requisite for using GCESDConfig is that a Secret containing valid Google Cloud credentials is mounted into the Prometheus or PrometheusAgent pod via the `.spec.secrets` field and that the GOOGLE_APPLICATION_CREDENTIALS environment variable is set to /etc/prometheus/secrets/<secret-name>/<credentials-filename.json>.
 *
 * @schema ScrapeConfigSpecGceSdConfigs
 */
export interface ScrapeConfigSpecGceSdConfigs {
  /**
   * Filter can be used optionally to filter the instance list by other criteria Syntax of this filter is described in the filter query parameter section: https://cloud.google.com/compute/docs/reference/latest/instances/list
   *
   * @schema ScrapeConfigSpecGceSdConfigs#filter
   */
  readonly filter?: string;

  /**
   * The port to scrape metrics from. If using the public IP address, this must instead be specified in the relabeling rule.
   *
   * @schema ScrapeConfigSpecGceSdConfigs#port
   */
  readonly port?: number;

  /**
   * The Google Cloud Project ID
   *
   * @schema ScrapeConfigSpecGceSdConfigs#project
   */
  readonly project: string;

  /**
   * RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
   *
   * @schema ScrapeConfigSpecGceSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * The tag separator is used to separate the tags on concatenation
   *
   * @schema ScrapeConfigSpecGceSdConfigs#tagSeparator
   */
  readonly tagSeparator?: string;

  /**
   * The zone of the scrape targets. If you need multiple zones use multiple GCESDConfigs.
   *
   * @schema ScrapeConfigSpecGceSdConfigs#zone
   */
  readonly zone: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecGceSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecGceSdConfigs(
  obj: ScrapeConfigSpecGceSdConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "filter": obj.filter,
    "port": obj.port,
    "project": obj.project,
    "refreshInterval": obj.refreshInterval,
    "tagSeparator": obj.tagSeparator,
    "zone": obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPSDConfig defines a prometheus HTTP service discovery configuration See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#http_sd_config
 *
 * @schema ScrapeConfigSpecHttpSdConfigs
 */
export interface ScrapeConfigSpecHttpSdConfigs {
  /**
   * Authorization header configuration to authenticate against the target HTTP endpoint.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecHttpSdConfigsAuthorization;

  /**
   * BasicAuth information to authenticate against the target HTTP endpoint. More info: https://prometheus.io/docs/operating/configuration/#endpoints
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecHttpSdConfigsBasicAuth;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names that should be excluded from proxying. IP and domain names can contain port numbers.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: {
    [key: string]: ScrapeConfigSpecHttpSdConfigsProxyConnectHeader;
  };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY). If unset, Prometheus uses its default value.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * RefreshInterval configures the refresh interval at which Prometheus will re-query the endpoint to update the target list.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * TLS configuration applying to the target HTTP endpoint.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecHttpSdConfigsTlsConfig;

  /**
   * URL from which the targets are fetched.
   *
   * @schema ScrapeConfigSpecHttpSdConfigs#url
   */
  readonly url: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigs(
  obj: ScrapeConfigSpecHttpSdConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization": toJson_ScrapeConfigSpecHttpSdConfigsAuthorization(
      obj.authorization,
    ),
    "basicAuth": toJson_ScrapeConfigSpecHttpSdConfigsBasicAuth(obj.basicAuth),
    "noProxy": obj.noProxy,
    "proxyConnectHeader": ((obj.proxyConnectHeader) === undefined)
      ? undefined
      : (Object.entries(obj.proxyConnectHeader).reduce(
        (r, i) =>
          (i[1] === undefined) ? r : ({
            ...r,
            [i[0]]: toJson_ScrapeConfigSpecHttpSdConfigsProxyConnectHeader(
              i[1],
            ),
          }),
        {},
      )),
    "proxyFromEnvironment": obj.proxyFromEnvironment,
    "proxyUrl": obj.proxyUrl,
    "refreshInterval": obj.refreshInterval,
    "tlsConfig": toJson_ScrapeConfigSpecHttpSdConfigsTlsConfig(obj.tlsConfig),
    "url": obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * KubernetesSDConfig allows retrieving scrape targets from Kubernetes' REST API. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigs
 */
export interface ScrapeConfigSpecKubernetesSdConfigs {
  /**
   * The API server address consisting of a hostname or IP address followed by an optional port number. If left empty, Prometheus is assumed to run inside of the cluster. It will discover API servers automatically and use the pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#apiServer
   */
  readonly apiServer?: string;

  /**
   * Optional metadata to attach to discovered targets. It requires Prometheus >= v2.35.0 for `pod` role and Prometheus >= v2.37.0 for `endpoints` and `endpointslice` roles.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#attachMetadata
   */
  readonly attachMetadata?: ScrapeConfigSpecKubernetesSdConfigsAttachMetadata;

  /**
   * Authorization header to use on every scrape request. Cannot be set at the same time as `basicAuth`, or `oauth2`.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#authorization
   */
  readonly authorization?: ScrapeConfigSpecKubernetesSdConfigsAuthorization;

  /**
   * BasicAuth information to use on every scrape request. Cannot be set at the same time as `authorization`, or `oauth2`.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#basicAuth
   */
  readonly basicAuth?: ScrapeConfigSpecKubernetesSdConfigsBasicAuth;

  /**
   * Whether to enable HTTP2.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#enableHTTP2
   */
  readonly enableHttp2?: boolean;

  /**
   * Configure whether HTTP requests follow HTTP 3xx redirects.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * Optional namespace discovery. If omitted, Prometheus discovers targets across all namespaces.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#namespaces
   */
  readonly namespaces?: ScrapeConfigSpecKubernetesSdConfigsNamespaces;

  /**
   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names that should be excluded from proxying. IP and domain names can contain port numbers.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#noProxy
   */
  readonly noProxy?: string;

  /**
   * Optional OAuth 2.0 configuration. Cannot be set at the same time as `authorization`, or `basicAuth`.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#oauth2
   */
  readonly oauth2?: ScrapeConfigSpecKubernetesSdConfigsOauth2;

  /**
   * ProxyConnectHeader optionally specifies headers to send to proxies during CONNECT requests.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#proxyConnectHeader
   */
  readonly proxyConnectHeader?: {
    [key: string]: ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader;
  };

  /**
   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY). If unset, Prometheus uses its default value.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#proxyFromEnvironment
   */
  readonly proxyFromEnvironment?: boolean;

  /**
   * `proxyURL` defines the HTTP proxy server to use.
   * It requires Prometheus >= v2.43.0.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * Role of the Kubernetes entities that should be discovered.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#role
   */
  readonly role: ScrapeConfigSpecKubernetesSdConfigsRole;

  /**
   * Selector to select objects.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#selectors
   */
  readonly selectors?: ScrapeConfigSpecKubernetesSdConfigsSelectors[];

  /**
   * TLS configuration to use on every scrape request.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecKubernetesSdConfigsTlsConfig;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigs(
  obj: ScrapeConfigSpecKubernetesSdConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiServer": obj.apiServer,
    "attachMetadata": toJson_ScrapeConfigSpecKubernetesSdConfigsAttachMetadata(
      obj.attachMetadata,
    ),
    "authorization": toJson_ScrapeConfigSpecKubernetesSdConfigsAuthorization(
      obj.authorization,
    ),
    "basicAuth": toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuth(
      obj.basicAuth,
    ),
    "enableHTTP2": obj.enableHttp2,
    "followRedirects": obj.followRedirects,
    "namespaces": toJson_ScrapeConfigSpecKubernetesSdConfigsNamespaces(
      obj.namespaces,
    ),
    "noProxy": obj.noProxy,
    "oauth2": toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2(obj.oauth2),
    "proxyConnectHeader": ((obj.proxyConnectHeader) === undefined)
      ? undefined
      : (Object.entries(obj.proxyConnectHeader).reduce(
        (r, i) =>
          (i[1] === undefined) ? r : ({
            ...r,
            [i[0]]:
              toJson_ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader(
                i[1],
              ),
          }),
        {},
      )),
    "proxyFromEnvironment": obj.proxyFromEnvironment,
    "proxyUrl": obj.proxyUrl,
    "role": obj.role,
    "selectors": obj.selectors?.map((y) =>
      toJson_ScrapeConfigSpecKubernetesSdConfigsSelectors(y)
    ),
    "tlsConfig": toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfig(
      obj.tlsConfig,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ScrapeConfigSpecMetricRelabelings
 */
export interface ScrapeConfigSpecMetricRelabelings {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   *
   * @schema ScrapeConfigSpecMetricRelabelings#action
   */
  readonly action?: ScrapeConfigSpecMetricRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the regular expression matches.
   * Regex capture groups are available.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions.
   * Regex capture groups are available.
   *
   * @schema ScrapeConfigSpecMetricRelabelings#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecMetricRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecMetricRelabelings(
  obj: ScrapeConfigSpecMetricRelabelings | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "action": obj.action,
    "modulus": obj.modulus,
    "regex": obj.regex,
    "replacement": obj.replacement,
    "separator": obj.separator,
    "sourceLabels": obj.sourceLabels?.map((y) => y),
    "targetLabel": obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * OpenStackSDConfig allow retrieving scrape targets from OpenStack Nova instances. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#openstack_sd_config
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigs
 */
export interface ScrapeConfigSpecOpenstackSdConfigs {
  /**
   * Whether the service discovery should list all instances for all projects. It is only relevant for the 'instance' role and usually requires admin permissions.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#allTenants
   */
  readonly allTenants?: boolean;

  /**
   * ApplicationCredentialID
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#applicationCredentialId
   */
  readonly applicationCredentialId?: string;

  /**
   * The ApplicationCredentialID or ApplicationCredentialName fields are required if using an application credential to authenticate. Some providers allow you to create an application credential to authenticate rather than a password.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#applicationCredentialName
   */
  readonly applicationCredentialName?: string;

  /**
   * The applicationCredentialSecret field is required if using an application credential to authenticate.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#applicationCredentialSecret
   */
  readonly applicationCredentialSecret?:
    ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret;

  /**
   * Availability of the endpoint to connect to.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#availability
   */
  readonly availability?: ScrapeConfigSpecOpenstackSdConfigsAvailability;

  /**
   * DomainID
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#domainID
   */
  readonly domainId?: string;

  /**
   * At most one of domainId and domainName must be provided if using username with Identity V3. Otherwise, either are optional.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#domainName
   */
  readonly domainName?: string;

  /**
   * IdentityEndpoint specifies the HTTP endpoint that is required to work with the Identity API of the appropriate version.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#identityEndpoint
   */
  readonly identityEndpoint?: string;

  /**
   * Password for the Identity V2 and V3 APIs. Consult with your provider's control panel to discover your account's preferred method of authentication.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#password
   */
  readonly password?: ScrapeConfigSpecOpenstackSdConfigsPassword;

  /**
   * The port to scrape metrics from. If using the public IP address, this must instead be specified in the relabeling rule.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#port
   */
  readonly port?: number;

  /**
   * ProjectID
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#projectID
   */
  readonly projectId?: string;

  /**
   * The ProjectId and ProjectName fields are optional for the Identity V2 API. Some providers allow you to specify a ProjectName instead of the ProjectId. Some require both. Your provider's authentication policies will determine how these fields influence authentication.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#projectName
   */
  readonly projectName?: string;

  /**
   * Refresh interval to re-read the instance list.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * The OpenStack Region.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#region
   */
  readonly region: string;

  /**
   * The OpenStack role of entities that should be discovered.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#role
   */
  readonly role: ScrapeConfigSpecOpenstackSdConfigsRole;

  /**
   * TLS configuration applying to the target HTTP endpoint.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#tlsConfig
   */
  readonly tlsConfig?: ScrapeConfigSpecOpenstackSdConfigsTlsConfig;

  /**
   * UserID
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#userid
   */
  readonly userid?: string;

  /**
   * Username is required if using Identity V2 API. Consult with your provider's control panel to discover your account's username. In Identity V3, either userid or a combination of username and domainId or domainName are needed
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigs#username
   */
  readonly username?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigs(
  obj: ScrapeConfigSpecOpenstackSdConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "allTenants": obj.allTenants,
    "applicationCredentialId": obj.applicationCredentialId,
    "applicationCredentialName": obj.applicationCredentialName,
    "applicationCredentialSecret":
      toJson_ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret(
        obj.applicationCredentialSecret,
      ),
    "availability": obj.availability,
    "domainID": obj.domainId,
    "domainName": obj.domainName,
    "identityEndpoint": obj.identityEndpoint,
    "password": toJson_ScrapeConfigSpecOpenstackSdConfigsPassword(obj.password),
    "port": obj.port,
    "projectID": obj.projectId,
    "projectName": obj.projectName,
    "refreshInterval": obj.refreshInterval,
    "region": obj.region,
    "role": obj.role,
    "tlsConfig": toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfig(
      obj.tlsConfig,
    ),
    "userid": obj.userid,
    "username": obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecProxyConnectHeader
 */
export interface ScrapeConfigSpecProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecProxyConnectHeader#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecProxyConnectHeader(
  obj: ScrapeConfigSpecProxyConnectHeader | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ScrapeConfigSpecRelabelings
 */
export interface ScrapeConfigSpecRelabelings {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   *
   * @schema ScrapeConfigSpecRelabelings#action
   */
  readonly action?: ScrapeConfigSpecRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   *
   * @schema ScrapeConfigSpecRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ScrapeConfigSpecRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the regular expression matches.
   * Regex capture groups are available.
   *
   * @schema ScrapeConfigSpecRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ScrapeConfigSpecRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
   *
   * @schema ScrapeConfigSpecRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions.
   * Regex capture groups are available.
   *
   * @schema ScrapeConfigSpecRelabelings#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecRelabelings(
  obj: ScrapeConfigSpecRelabelings | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "action": obj.action,
    "modulus": obj.modulus,
    "regex": obj.regex,
    "replacement": obj.replacement,
    "separator": obj.separator,
    "sourceLabels": obj.sourceLabels?.map((y) => y),
    "targetLabel": obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Configures the protocol scheme used for requests. If empty, Prometheus uses HTTP by default.
 *
 * @schema ScrapeConfigSpecScheme
 */
export enum ScrapeConfigSpecScheme {
  /** HTTP */
  HTTP = "HTTP",
  /** HTTPS */
  HTTPS = "HTTPS",
}

/**
 * StaticConfig defines a Prometheus static configuration. See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config
 *
 * @schema ScrapeConfigSpecStaticConfigs
 */
export interface ScrapeConfigSpecStaticConfigs {
  /**
   * Labels assigned to all metrics scraped from the targets.
   *
   * @schema ScrapeConfigSpecStaticConfigs#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * List of targets for this static configuration.
   *
   * @schema ScrapeConfigSpecStaticConfigs#targets
   */
  readonly targets?: string[];
}

/**
 * Converts an object of type 'ScrapeConfigSpecStaticConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecStaticConfigs(
  obj: ScrapeConfigSpecStaticConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "targets": obj.targets?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration to use on every scrape request
 *
 * @schema ScrapeConfigSpecTlsConfig
 */
export interface ScrapeConfigSpecTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfig(
  obj: ScrapeConfigSpecTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_ScrapeConfigSpecTlsConfigCa(obj.ca),
    "cert": toJson_ScrapeConfigSpecTlsConfigCert(obj.cert),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret": toJson_ScrapeConfigSpecTlsConfigKeySecret(obj.keySecret),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecAuthorizationCredentials
 */
export interface ScrapeConfigSpecAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecAuthorizationCredentials(
  obj: ScrapeConfigSpecAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * # The authentication method, either OAuth or ManagedIdentity. See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
 *
 * @schema ScrapeConfigSpecAzureSdConfigsAuthenticationMethod
 */
export enum ScrapeConfigSpecAzureSdConfigsAuthenticationMethod {
  /** OAuth */
  O_AUTH = "OAuth",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
}

/**
 * Optional client secret. Only required with the OAuth authentication method.
 *
 * @schema ScrapeConfigSpecAzureSdConfigsClientSecret
 */
export interface ScrapeConfigSpecAzureSdConfigsClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecAzureSdConfigsClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecAzureSdConfigsClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecAzureSdConfigsClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecAzureSdConfigsClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecAzureSdConfigsClientSecret(
  obj: ScrapeConfigSpecAzureSdConfigsClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema ScrapeConfigSpecBasicAuthPassword
 */
export interface ScrapeConfigSpecBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecBasicAuthPassword(
  obj: ScrapeConfigSpecBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema ScrapeConfigSpecBasicAuthUsername
 */
export interface ScrapeConfigSpecBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecBasicAuthUsername(
  obj: ScrapeConfigSpecBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration to authenticate against the Consul Server.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsAuthorization
 */
export interface ScrapeConfigSpecConsulSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsAuthorization#credentials
   */
  readonly credentials?:
    ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecConsulSdConfigsAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsAuthorization(
  obj: ScrapeConfigSpecConsulSdConfigsAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to authenticate against the Consul Server. More info: https://prometheus.io/docs/operating/configuration/#endpoints
 *
 * @schema ScrapeConfigSpecConsulSdConfigsBasicAuth
 */
export interface ScrapeConfigSpecConsulSdConfigsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecConsulSdConfigsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecConsulSdConfigsBasicAuthUsername;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsBasicAuth(
  obj: ScrapeConfigSpecConsulSdConfigsBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_ScrapeConfigSpecConsulSdConfigsBasicAuthPassword(
      obj.password,
    ),
    "username": toJson_ScrapeConfigSpecConsulSdConfigsBasicAuthUsername(
      obj.username,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional OAuth 2.0 configuration.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsOauth2
 */
export interface ScrapeConfigSpecConsulSdConfigsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2#clientId
   */
  readonly clientId: ScrapeConfigSpecConsulSdConfigsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2#clientSecret
   */
  readonly clientSecret: ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsOauth2(
  obj: ScrapeConfigSpecConsulSdConfigsOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientId(
      obj.clientId,
    ),
    "clientSecret": toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret(
      obj.clientSecret,
    ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecConsulSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsProxyConnectHeader(
  obj: ScrapeConfigSpecConsulSdConfigsProxyConnectHeader | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP Scheme default "http"
 *
 * @schema ScrapeConfigSpecConsulSdConfigsScheme
 */
export enum ScrapeConfigSpecConsulSdConfigsScheme {
  /** HTTP */
  HTTP = "HTTP",
  /** HTTPS */
  HTTPS = "HTTPS",
}

/**
 * TLS Config
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecConsulSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecConsulSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfig(
  obj: ScrapeConfigSpecConsulSdConfigsTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCa(obj.ca),
    "cert": toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCert(obj.cert),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret": toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTokenRef
 */
export interface ScrapeConfigSpecConsulSdConfigsTokenRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTokenRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTokenRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTokenRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTokenRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTokenRef(
  obj: ScrapeConfigSpecConsulSdConfigsTokenRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The type of DNS query to perform. One of SRV, A, AAAA or MX. If not set, Prometheus uses its default value.
 *
 * @schema ScrapeConfigSpecDnsSdConfigsType
 */
export enum ScrapeConfigSpecDnsSdConfigsType {
  /** SRV */
  SRV = "SRV",
  /** A */
  A = "A",
  /** AAAA */
  AAAA = "AAAA",
  /** MX */
  MX = "MX",
}

/**
 * AccessKey is the AWS API key.
 *
 * @schema ScrapeConfigSpecEc2SdConfigsAccessKey
 */
export interface ScrapeConfigSpecEc2SdConfigsAccessKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEc2SdConfigsAccessKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEc2SdConfigsAccessKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEc2SdConfigsAccessKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecEc2SdConfigsAccessKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEc2SdConfigsAccessKey(
  obj: ScrapeConfigSpecEc2SdConfigsAccessKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EC2Filter is the configuration for filtering EC2 instances.
 *
 * @schema ScrapeConfigSpecEc2SdConfigsFilters
 */
export interface ScrapeConfigSpecEc2SdConfigsFilters {
  /**
   * @schema ScrapeConfigSpecEc2SdConfigsFilters#name
   */
  readonly name: string;

  /**
   * @schema ScrapeConfigSpecEc2SdConfigsFilters#values
   */
  readonly values: string[];
}

/**
 * Converts an object of type 'ScrapeConfigSpecEc2SdConfigsFilters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEc2SdConfigsFilters(
  obj: ScrapeConfigSpecEc2SdConfigsFilters | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKey is the AWS API secret.
 *
 * @schema ScrapeConfigSpecEc2SdConfigsSecretKey
 */
export interface ScrapeConfigSpecEc2SdConfigsSecretKey {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecEc2SdConfigsSecretKey#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecEc2SdConfigsSecretKey#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecEc2SdConfigsSecretKey#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecEc2SdConfigsSecretKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecEc2SdConfigsSecretKey(
  obj: ScrapeConfigSpecEc2SdConfigsSecretKey | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header configuration to authenticate against the target HTTP endpoint.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsAuthorization
 */
export interface ScrapeConfigSpecHttpSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsAuthorization#credentials
   */
  readonly credentials?: ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecHttpSdConfigsAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsAuthorization(
  obj: ScrapeConfigSpecHttpSdConfigsAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials": toJson_ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials(
      obj.credentials,
    ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to authenticate against the target HTTP endpoint. More info: https://prometheus.io/docs/operating/configuration/#endpoints
 *
 * @schema ScrapeConfigSpecHttpSdConfigsBasicAuth
 */
export interface ScrapeConfigSpecHttpSdConfigsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecHttpSdConfigsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecHttpSdConfigsBasicAuthUsername;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsBasicAuth(
  obj: ScrapeConfigSpecHttpSdConfigsBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_ScrapeConfigSpecHttpSdConfigsBasicAuthPassword(
      obj.password,
    ),
    "username": toJson_ScrapeConfigSpecHttpSdConfigsBasicAuthUsername(
      obj.username,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecHttpSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsProxyConnectHeader(
  obj: ScrapeConfigSpecHttpSdConfigsProxyConnectHeader | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration applying to the target HTTP endpoint.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecHttpSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecHttpSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfig(
  obj: ScrapeConfigSpecHttpSdConfigsTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCa(obj.ca),
    "cert": toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCert(obj.cert),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret": toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional metadata to attach to discovered targets. It requires Prometheus >= v2.35.0 for `pod` role and Prometheus >= v2.37.0 for `endpoints` and `endpointslice` roles.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsAttachMetadata
 */
export interface ScrapeConfigSpecKubernetesSdConfigsAttachMetadata {
  /**
   * Attaches node metadata to discovered targets. When set to true, Prometheus must have the `get` permission on the `Nodes` objects. Only valid for Pod, Endpoint and Endpointslice roles.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAttachMetadata#node
   */
  readonly node?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsAttachMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsAttachMetadata(
  obj: ScrapeConfigSpecKubernetesSdConfigsAttachMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "node": obj.node,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Authorization header to use on every scrape request. Cannot be set at the same time as `basicAuth`, or `oauth2`.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorization
 */
export interface ScrapeConfigSpecKubernetesSdConfigsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorization#credentials
   */
  readonly credentials?:
    ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsAuthorization(
  obj: ScrapeConfigSpecKubernetesSdConfigsAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials":
      toJson_ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials(
        obj.credentials,
      ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth information to use on every scrape request. Cannot be set at the same time as `authorization`, or `oauth2`.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuth
 */
export interface ScrapeConfigSpecKubernetesSdConfigsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuth#password
   */
  readonly password?: ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuth#username
   */
  readonly username?: ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuth(
  obj: ScrapeConfigSpecKubernetesSdConfigsBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword(
      obj.password,
    ),
    "username": toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername(
      obj.username,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional namespace discovery. If omitted, Prometheus discovers targets across all namespaces.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsNamespaces
 */
export interface ScrapeConfigSpecKubernetesSdConfigsNamespaces {
  /**
   * List of namespaces where to watch for resources. If empty and `ownNamespace` isn't true, Prometheus watches for resources in all namespaces.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsNamespaces#names
   */
  readonly names?: string[];

  /**
   * Includes the namespace in which the Prometheus pod exists to the list of watched namesapces.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsNamespaces#ownNamespace
   */
  readonly ownNamespace?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsNamespaces' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsNamespaces(
  obj: ScrapeConfigSpecKubernetesSdConfigsNamespaces | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "names": obj.names?.map((y) => y),
    "ownNamespace": obj.ownNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Optional OAuth 2.0 configuration. Cannot be set at the same time as `authorization`, or `basicAuth`.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2
 */
export interface ScrapeConfigSpecKubernetesSdConfigsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2#clientId
   */
  readonly clientId: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2#clientSecret
   */
  readonly clientSecret: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2(
  obj: ScrapeConfigSpecKubernetesSdConfigsOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId(
      obj.clientId,
    ),
    "clientSecret":
      toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret(
        obj.clientSecret,
      ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader
 */
export interface ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader(
  obj: ScrapeConfigSpecKubernetesSdConfigsProxyConnectHeader | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Role of the Kubernetes entities that should be discovered.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsRole
 */
export enum ScrapeConfigSpecKubernetesSdConfigsRole {
  /** Node */
  NODE = "Node",
  /** Service */
  SERVICE = "Service",
  /** Pod */
  POD = "Pod",
  /** Endpoints */
  ENDPOINTS = "Endpoints",
  /** EndpointSlice */
  ENDPOINT_SLICE = "EndpointSlice",
  /** Ingress */
  INGRESS = "Ingress",
}

/**
 * K8SSelectorConfig is Kubernetes Selector Config
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsSelectors
 */
export interface ScrapeConfigSpecKubernetesSdConfigsSelectors {
  /**
   * @schema ScrapeConfigSpecKubernetesSdConfigsSelectors#field
   */
  readonly field?: string;

  /**
   * @schema ScrapeConfigSpecKubernetesSdConfigsSelectors#label
   */
  readonly label?: string;

  /**
   * Role is role of the service in Kubernetes.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsSelectors#role
   */
  readonly role: ScrapeConfigSpecKubernetesSdConfigsSelectorsRole;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsSelectors(
  obj: ScrapeConfigSpecKubernetesSdConfigsSelectors | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "field": obj.field,
    "label": obj.label,
    "role": obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration to use on every scrape request.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfig(
  obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa(obj.ca),
    "cert": toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert(obj.cert),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret": toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 *
 * @schema ScrapeConfigSpecMetricRelabelingsAction
 */
export enum ScrapeConfigSpecMetricRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * The applicationCredentialSecret field is required if using an application credential to authenticate.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret
 */
export interface ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret(
  obj:
    | ScrapeConfigSpecOpenstackSdConfigsApplicationCredentialSecret
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Availability of the endpoint to connect to.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsAvailability
 */
export enum ScrapeConfigSpecOpenstackSdConfigsAvailability {
  /** Public */
  PUBLIC = "Public",
  /** Admin */
  ADMIN = "Admin",
  /** Internal */
  INTERNAL = "Internal",
}

/**
 * Password for the Identity V2 and V3 APIs. Consult with your provider's control panel to discover your account's preferred method of authentication.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsPassword
 */
export interface ScrapeConfigSpecOpenstackSdConfigsPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsPassword(
  obj: ScrapeConfigSpecOpenstackSdConfigsPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The OpenStack role of entities that should be discovered.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsRole
 */
export enum ScrapeConfigSpecOpenstackSdConfigsRole {
  /** Instance */
  INSTANCE = "Instance",
  /** Hypervisor */
  HYPERVISOR = "Hypervisor",
}

/**
 * TLS configuration applying to the target HTTP endpoint.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig#ca
   */
  readonly ca?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig#cert
   */
  readonly cert?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert;

  /**
   * Disable target certificate validation.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig#keySecret
   */
  readonly keySecret?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfig(
  obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa(obj.ca),
    "cert": toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert(obj.cert),
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keySecret": toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 *
 * @schema ScrapeConfigSpecRelabelingsAction
 */
export enum ScrapeConfigSpecRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecTlsConfigCa
 */
export interface ScrapeConfigSpecTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecTlsConfigCaSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCa(
  obj: ScrapeConfigSpecTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ScrapeConfigSpecTlsConfigCaConfigMap(obj.configMap),
    "secret": toJson_ScrapeConfigSpecTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecTlsConfigCert
 */
export interface ScrapeConfigSpecTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecTlsConfigCertSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCert(
  obj: ScrapeConfigSpecTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ScrapeConfigSpecTlsConfigCertConfigMap(obj.configMap),
    "secret": toJson_ScrapeConfigSpecTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecTlsConfigKeySecret
 */
export interface ScrapeConfigSpecTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigKeySecret(
  obj: ScrapeConfigSpecTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials(
  obj: ScrapeConfigSpecConsulSdConfigsAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthPassword
 */
export interface ScrapeConfigSpecConsulSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsBasicAuthPassword(
  obj: ScrapeConfigSpecConsulSdConfigsBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthUsername
 */
export interface ScrapeConfigSpecConsulSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsBasicAuthUsername(
  obj: ScrapeConfigSpecConsulSdConfigsBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientId
 */
export interface ScrapeConfigSpecConsulSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?: ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientId#secret
   */
  readonly secret?: ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientId(
  obj: ScrapeConfigSpecConsulSdConfigsOauth2ClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret
 */
export interface ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret(
  obj: ScrapeConfigSpecConsulSdConfigsOauth2ClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCa(
  obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCert(
  obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret(
  obj: ScrapeConfigSpecConsulSdConfigsTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials(
  obj: ScrapeConfigSpecHttpSdConfigsAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthPassword
 */
export interface ScrapeConfigSpecHttpSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsBasicAuthPassword(
  obj: ScrapeConfigSpecHttpSdConfigsBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthUsername
 */
export interface ScrapeConfigSpecHttpSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsBasicAuthUsername(
  obj: ScrapeConfigSpecHttpSdConfigsBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCa(
  obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCert(
  obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret(
  obj: ScrapeConfigSpecHttpSdConfigsTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials
 */
export interface ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials(
  obj: ScrapeConfigSpecKubernetesSdConfigsAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword
 */
export interface ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword(
  obj: ScrapeConfigSpecKubernetesSdConfigsBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername
 */
export interface ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername(
  obj: ScrapeConfigSpecKubernetesSdConfigsBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId
 */
export interface ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId#configMap
   */
  readonly configMap?:
    ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId#secret
   */
  readonly secret?: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId(
  obj: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap(
        obj.configMap,
      ),
    "secret": toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret
 */
export interface ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret(
  obj: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Role is role of the service in Kubernetes.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsSelectorsRole
 */
export enum ScrapeConfigSpecKubernetesSdConfigsSelectorsRole {
  /** Node */
  NODE = "Node",
  /** Service */
  SERVICE = "Service",
  /** Pod */
  POD = "Pod",
  /** Endpoints */
  ENDPOINTS = "Endpoints",
  /** EndpointSlice */
  ENDPOINT_SLICE = "EndpointSlice",
  /** Ingress */
  INGRESS = "Ingress",
}

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa(
  obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?:
    ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert(
  obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret": toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret(
  obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa#configMap
   */
  readonly configMap?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa#secret
   */
  readonly secret?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa(
  obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert#configMap
   */
  readonly configMap?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert#secret
   */
  readonly secret?: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret;
}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert(
  obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap":
      toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap(
        obj.configMap,
      ),
    "secret": toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret(
  obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCaConfigMap(
  obj: ScrapeConfigSpecTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecTlsConfigCaSecret
 */
export interface ScrapeConfigSpecTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCaSecret(
  obj: ScrapeConfigSpecTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCertConfigMap(
  obj: ScrapeConfigSpecTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecTlsConfigCertSecret
 */
export interface ScrapeConfigSpecTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecTlsConfigCertSecret(
  obj: ScrapeConfigSpecTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap
 */
export interface ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap(
  obj: ScrapeConfigSpecConsulSdConfigsOauth2ClientIdConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret
 */
export interface ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret(
  obj: ScrapeConfigSpecConsulSdConfigsOauth2ClientIdSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap(
  obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret(
  obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap(
  obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret(
  obj: ScrapeConfigSpecConsulSdConfigsTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap(
  obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret(
  obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap(
  obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret(
  obj: ScrapeConfigSpecHttpSdConfigsTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap
 */
export interface ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap(
  obj: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret
 */
export interface ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret(
  obj: ScrapeConfigSpecKubernetesSdConfigsOauth2ClientIdSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap(
  obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret(
  obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap(
  obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret(
  obj: ScrapeConfigSpecKubernetesSdConfigsTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap(
  obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret(
  obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap(
  obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret
 */
export interface ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret(
  obj: ScrapeConfigSpecOpenstackSdConfigsTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceMonitor defines monitoring for a set of services.
 *
 * @schema ServiceMonitor
 */
export class ServiceMonitor extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceMonitor"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "monitoring.coreos.com/v1",
    kind: "ServiceMonitor",
  };

  /**
   * Renders a Kubernetes manifest for "ServiceMonitor".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceMonitorProps): any {
    return {
      ...ServiceMonitor.GVK,
      ...toJson_ServiceMonitorProps(props),
    };
  }

  /**
   * Defines a "ServiceMonitor" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceMonitorProps) {
    super(scope, id, {
      ...ServiceMonitor.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceMonitor.GVK,
      ...toJson_ServiceMonitorProps(resolved),
    };
  }
}

/**
 * ServiceMonitor defines monitoring for a set of services.
 *
 * @schema ServiceMonitor
 */
export interface ServiceMonitorProps {
  /**
   * @schema ServiceMonitor#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of desired Service selection for target discovery by Prometheus.
   *
   * @schema ServiceMonitor#spec
   */
  readonly spec: ServiceMonitorSpec;
}

/**
 * Converts an object of type 'ServiceMonitorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorProps(
  obj: ServiceMonitorProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ServiceMonitorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of desired Service selection for target discovery by Prometheus.
 *
 * @schema ServiceMonitorSpec
 */
export interface ServiceMonitorSpec {
  /**
   * `attachMetadata` defines additional metadata which is added to the discovered targets.
   * It requires Prometheus >= v2.37.0.
   *
   * @schema ServiceMonitorSpec#attachMetadata
   */
  readonly attachMetadata?: ServiceMonitorSpecAttachMetadata;

  /**
   * List of endpoints part of this ServiceMonitor.
   *
   * @schema ServiceMonitorSpec#endpoints
   */
  readonly endpoints?: ServiceMonitorSpecEndpoints[];

  /**
   * `jobLabel` selects the label from the associated Kubernetes `Service` object which will be used as the `job` label for all metrics.
   * For example if `jobLabel` is set to `foo` and the Kubernetes `Service` object is labeled with `foo: bar`, then Prometheus adds the `job="bar"` label to all ingested metrics.
   * If the value of this field is empty or if the label doesn't exist for the given Service, the `job` label of the metrics defaults to the name of the associated Kubernetes `Service`.
   *
   * @schema ServiceMonitorSpec#jobLabel
   */
  readonly jobLabel?: string;

  /**
   * Per-scrape limit on the number of targets dropped by relabeling that will be kept in memory. 0 means no limit.
   * It requires Prometheus >= v2.47.0.
   *
   * @schema ServiceMonitorSpec#keepDroppedTargets
   */
  readonly keepDroppedTargets?: number;

  /**
   * Per-scrape limit on number of labels that will be accepted for a sample.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema ServiceMonitorSpec#labelLimit
   */
  readonly labelLimit?: number;

  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema ServiceMonitorSpec#labelNameLengthLimit
   */
  readonly labelNameLengthLimit?: number;

  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample.
   * It requires Prometheus >= v2.27.0.
   *
   * @schema ServiceMonitorSpec#labelValueLengthLimit
   */
  readonly labelValueLengthLimit?: number;

  /**
   * Selector to select which namespaces the Kubernetes `Endpoints` objects are discovered from.
   *
   * @schema ServiceMonitorSpec#namespaceSelector
   */
  readonly namespaceSelector?: ServiceMonitorSpecNamespaceSelector;

  /**
   * `podTargetLabels` defines the labels which are transferred from the associated Kubernetes `Pod` object onto the ingested metrics.
   *
   * @schema ServiceMonitorSpec#podTargetLabels
   */
  readonly podTargetLabels?: string[];

  /**
   * `sampleLimit` defines a per-scrape limit on the number of scraped samples that will be accepted.
   *
   * @schema ServiceMonitorSpec#sampleLimit
   */
  readonly sampleLimit?: number;

  /**
   * Label selector to select the Kubernetes `Endpoints` objects.
   *
   * @schema ServiceMonitorSpec#selector
   */
  readonly selector: ServiceMonitorSpecSelector;

  /**
   * `targetLabels` defines the labels which are transferred from the associated Kubernetes `Service` object onto the ingested metrics.
   *
   * @schema ServiceMonitorSpec#targetLabels
   */
  readonly targetLabels?: string[];

  /**
   * `targetLimit` defines a limit on the number of scraped targets that will be accepted.
   *
   * @schema ServiceMonitorSpec#targetLimit
   */
  readonly targetLimit?: number;
}

/**
 * Converts an object of type 'ServiceMonitorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpec(
  obj: ServiceMonitorSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "attachMetadata": toJson_ServiceMonitorSpecAttachMetadata(
      obj.attachMetadata,
    ),
    "endpoints": obj.endpoints?.map((y) =>
      toJson_ServiceMonitorSpecEndpoints(y)
    ),
    "jobLabel": obj.jobLabel,
    "keepDroppedTargets": obj.keepDroppedTargets,
    "labelLimit": obj.labelLimit,
    "labelNameLengthLimit": obj.labelNameLengthLimit,
    "labelValueLengthLimit": obj.labelValueLengthLimit,
    "namespaceSelector": toJson_ServiceMonitorSpecNamespaceSelector(
      obj.namespaceSelector,
    ),
    "podTargetLabels": obj.podTargetLabels?.map((y) => y),
    "sampleLimit": obj.sampleLimit,
    "selector": toJson_ServiceMonitorSpecSelector(obj.selector),
    "targetLabels": obj.targetLabels?.map((y) => y),
    "targetLimit": obj.targetLimit,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `attachMetadata` defines additional metadata which is added to the discovered targets.
 * It requires Prometheus >= v2.37.0.
 *
 * @schema ServiceMonitorSpecAttachMetadata
 */
export interface ServiceMonitorSpecAttachMetadata {
  /**
   * When set to true, Prometheus must have the `get` permission on the `Nodes` objects.
   *
   * @schema ServiceMonitorSpecAttachMetadata#node
   */
  readonly node?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecAttachMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecAttachMetadata(
  obj: ServiceMonitorSpecAttachMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "node": obj.node,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Endpoint defines an endpoint serving Prometheus metrics to be scraped by Prometheus.
 *
 * @schema ServiceMonitorSpecEndpoints
 */
export interface ServiceMonitorSpecEndpoints {
  /**
   * `authorization` configures the Authorization header credentials to use when scraping the target.
   * Cannot be set at the same time as `basicAuth`, or `oauth2`.
   *
   * @schema ServiceMonitorSpecEndpoints#authorization
   */
  readonly authorization?: ServiceMonitorSpecEndpointsAuthorization;

  /**
   * `basicAuth` configures the Basic Authentication credentials to use when scraping the target.
   * Cannot be set at the same time as `authorization`, or `oauth2`.
   *
   * @schema ServiceMonitorSpecEndpoints#basicAuth
   */
  readonly basicAuth?: ServiceMonitorSpecEndpointsBasicAuth;

  /**
   * File to read bearer token for scraping the target.
   * Deprecated: use `authorization` instead.
   *
   * @schema ServiceMonitorSpecEndpoints#bearerTokenFile
   */
  readonly bearerTokenFile?: string;

  /**
   * `bearerTokenSecret` specifies a key of a Secret containing the bearer token for scraping targets. The secret needs to be in the same namespace as the ServiceMonitor object and readable by the Prometheus Operator.
   * Deprecated: use `authorization` instead.
   *
   * @schema ServiceMonitorSpecEndpoints#bearerTokenSecret
   */
  readonly bearerTokenSecret?: ServiceMonitorSpecEndpointsBearerTokenSecret;

  /**
   * `enableHttp2` can be used to disable HTTP2 when scraping the target.
   *
   * @schema ServiceMonitorSpecEndpoints#enableHttp2
   */
  readonly enableHttp2?: boolean;

  /**
   * When true, the pods which are not running (e.g. either in Failed or Succeeded state) are dropped during the target discovery.
   * If unset, the filtering is enabled.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
   *
   * @schema ServiceMonitorSpecEndpoints#filterRunning
   */
  readonly filterRunning?: boolean;

  /**
   * `followRedirects` defines whether the scrape requests should follow HTTP 3xx redirects.
   *
   * @schema ServiceMonitorSpecEndpoints#followRedirects
   */
  readonly followRedirects?: boolean;

  /**
   * When true, `honorLabels` preserves the metric's labels when they collide with the target's labels.
   *
   * @schema ServiceMonitorSpecEndpoints#honorLabels
   */
  readonly honorLabels?: boolean;

  /**
   * `honorTimestamps` controls whether Prometheus preserves the timestamps when exposed by the target.
   *
   * @schema ServiceMonitorSpecEndpoints#honorTimestamps
   */
  readonly honorTimestamps?: boolean;

  /**
   * Interval at which Prometheus scrapes the metrics from the target.
   * If empty, Prometheus uses the global scrape interval.
   *
   * @schema ServiceMonitorSpecEndpoints#interval
   */
  readonly interval?: string;

  /**
   * `metricRelabelings` configures the relabeling rules to apply to the samples before ingestion.
   *
   * @schema ServiceMonitorSpecEndpoints#metricRelabelings
   */
  readonly metricRelabelings?: ServiceMonitorSpecEndpointsMetricRelabelings[];

  /**
   * `oauth2` configures the OAuth2 settings to use when scraping the target.
   * It requires Prometheus >= 2.27.0.
   * Cannot be set at the same time as `authorization`, or `basicAuth`.
   *
   * @schema ServiceMonitorSpecEndpoints#oauth2
   */
  readonly oauth2?: ServiceMonitorSpecEndpointsOauth2;

  /**
   * params define optional HTTP URL parameters.
   *
   * @schema ServiceMonitorSpecEndpoints#params
   */
  readonly params?: { [key: string]: string[] };

  /**
   * HTTP path from which to scrape for metrics.
   * If empty, Prometheus uses the default value (e.g. `/metrics`).
   *
   * @schema ServiceMonitorSpecEndpoints#path
   */
  readonly path?: string;

  /**
   * Name of the Service port which this endpoint refers to.
   * It takes precedence over `targetPort`.
   *
   * @schema ServiceMonitorSpecEndpoints#port
   */
  readonly port?: string;

  /**
   * `proxyURL` configures the HTTP Proxy URL (e.g. "http://proxyserver:2195") to go through when scraping the target.
   *
   * @schema ServiceMonitorSpecEndpoints#proxyUrl
   */
  readonly proxyUrl?: string;

  /**
   * `relabelings` configures the relabeling rules to apply the target's metadata labels.
   * The Operator automatically adds relabelings for a few standard Kubernetes fields.
   * The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
   * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   *
   * @schema ServiceMonitorSpecEndpoints#relabelings
   */
  readonly relabelings?: ServiceMonitorSpecEndpointsRelabelings[];

  /**
   * HTTP scheme to use for scraping.
   * `http` and `https` are the expected values unless you rewrite the `__scheme__` label via relabeling.
   * If empty, Prometheus uses the default value `http`.
   *
   * @schema ServiceMonitorSpecEndpoints#scheme
   */
  readonly scheme?: ServiceMonitorSpecEndpointsScheme;

  /**
   * Timeout after which Prometheus considers the scrape to be failed.
   * If empty, Prometheus uses the global scrape timeout unless it is less than the target's scrape interval value in which the latter is used.
   *
   * @schema ServiceMonitorSpecEndpoints#scrapeTimeout
   */
  readonly scrapeTimeout?: string;

  /**
   * Name or number of the target port of the `Pod` object behind the Service, the port must be specified with container port property.
   * Deprecated: use `port` instead.
   *
   * @schema ServiceMonitorSpecEndpoints#targetPort
   */
  readonly targetPort?: ServiceMonitorSpecEndpointsTargetPort;

  /**
   * TLS configuration to use when scraping the target.
   *
   * @schema ServiceMonitorSpecEndpoints#tlsConfig
   */
  readonly tlsConfig?: ServiceMonitorSpecEndpointsTlsConfig;

  /**
   * `trackTimestampsStaleness` defines whether Prometheus tracks staleness of the metrics that have an explicit timestamp present in scraped data. Has no effect if `honorTimestamps` is false.
   * It requires Prometheus >= v2.48.0.
   *
   * @schema ServiceMonitorSpecEndpoints#trackTimestampsStaleness
   */
  readonly trackTimestampsStaleness?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpoints(
  obj: ServiceMonitorSpecEndpoints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "authorization": toJson_ServiceMonitorSpecEndpointsAuthorization(
      obj.authorization,
    ),
    "basicAuth": toJson_ServiceMonitorSpecEndpointsBasicAuth(obj.basicAuth),
    "bearerTokenFile": obj.bearerTokenFile,
    "bearerTokenSecret": toJson_ServiceMonitorSpecEndpointsBearerTokenSecret(
      obj.bearerTokenSecret,
    ),
    "enableHttp2": obj.enableHttp2,
    "filterRunning": obj.filterRunning,
    "followRedirects": obj.followRedirects,
    "honorLabels": obj.honorLabels,
    "honorTimestamps": obj.honorTimestamps,
    "interval": obj.interval,
    "metricRelabelings": obj.metricRelabelings?.map((y) =>
      toJson_ServiceMonitorSpecEndpointsMetricRelabelings(y)
    ),
    "oauth2": toJson_ServiceMonitorSpecEndpointsOauth2(obj.oauth2),
    "params": ((obj.params) === undefined)
      ? undefined
      : (Object.entries(obj.params).reduce(
        (r, i) =>
          (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map((y) => y) }),
        {},
      )),
    "path": obj.path,
    "port": obj.port,
    "proxyUrl": obj.proxyUrl,
    "relabelings": obj.relabelings?.map((y) =>
      toJson_ServiceMonitorSpecEndpointsRelabelings(y)
    ),
    "scheme": obj.scheme,
    "scrapeTimeout": obj.scrapeTimeout,
    "targetPort": obj.targetPort?.value,
    "tlsConfig": toJson_ServiceMonitorSpecEndpointsTlsConfig(obj.tlsConfig),
    "trackTimestampsStaleness": obj.trackTimestampsStaleness,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selector to select which namespaces the Kubernetes `Endpoints` objects are discovered from.
 *
 * @schema ServiceMonitorSpecNamespaceSelector
 */
export interface ServiceMonitorSpecNamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a list restricting them.
   *
   * @schema ServiceMonitorSpecNamespaceSelector#any
   */
  readonly any?: boolean;

  /**
   * List of namespace names to select from.
   *
   * @schema ServiceMonitorSpecNamespaceSelector#matchNames
   */
  readonly matchNames?: string[];
}

/**
 * Converts an object of type 'ServiceMonitorSpecNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecNamespaceSelector(
  obj: ServiceMonitorSpecNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "any": obj.any,
    "matchNames": obj.matchNames?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Label selector to select the Kubernetes `Endpoints` objects.
 *
 * @schema ServiceMonitorSpecSelector
 */
export interface ServiceMonitorSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ServiceMonitorSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ServiceMonitorSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ServiceMonitorSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ServiceMonitorSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecSelector(
  obj: ServiceMonitorSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ServiceMonitorSpecSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `authorization` configures the Authorization header credentials to use when scraping the target.
 * Cannot be set at the same time as `basicAuth`, or `oauth2`.
 *
 * @schema ServiceMonitorSpecEndpointsAuthorization
 */
export interface ServiceMonitorSpecEndpointsAuthorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for authentication.
   *
   * @schema ServiceMonitorSpecEndpointsAuthorization#credentials
   */
  readonly credentials?: ServiceMonitorSpecEndpointsAuthorizationCredentials;

  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   *
   * @schema ServiceMonitorSpecEndpointsAuthorization#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsAuthorization(
  obj: ServiceMonitorSpecEndpointsAuthorization | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "credentials": toJson_ServiceMonitorSpecEndpointsAuthorizationCredentials(
      obj.credentials,
    ),
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `basicAuth` configures the Basic Authentication credentials to use when scraping the target.
 * Cannot be set at the same time as `authorization`, or `oauth2`.
 *
 * @schema ServiceMonitorSpecEndpointsBasicAuth
 */
export interface ServiceMonitorSpecEndpointsBasicAuth {
  /**
   * `password` specifies a key of a Secret containing the password for authentication.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuth#password
   */
  readonly password?: ServiceMonitorSpecEndpointsBasicAuthPassword;

  /**
   * `username` specifies a key of a Secret containing the username for authentication.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuth#username
   */
  readonly username?: ServiceMonitorSpecEndpointsBasicAuthUsername;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBasicAuth(
  obj: ServiceMonitorSpecEndpointsBasicAuth | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "password": toJson_ServiceMonitorSpecEndpointsBasicAuthPassword(
      obj.password,
    ),
    "username": toJson_ServiceMonitorSpecEndpointsBasicAuthUsername(
      obj.username,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `bearerTokenSecret` specifies a key of a Secret containing the bearer token for scraping targets. The secret needs to be in the same namespace as the ServiceMonitor object and readable by the Prometheus Operator.
 * Deprecated: use `authorization` instead.
 *
 * @schema ServiceMonitorSpecEndpointsBearerTokenSecret
 */
export interface ServiceMonitorSpecEndpointsBearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsBearerTokenSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsBearerTokenSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsBearerTokenSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBearerTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBearerTokenSecret(
  obj: ServiceMonitorSpecEndpointsBearerTokenSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ServiceMonitorSpecEndpointsMetricRelabelings
 */
export interface ServiceMonitorSpecEndpointsMetricRelabelings {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#action
   */
  readonly action?: ServiceMonitorSpecEndpointsMetricRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the regular expression matches.
   * Regex capture groups are available.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions.
   * Regex capture groups are available.
   *
   * @schema ServiceMonitorSpecEndpointsMetricRelabelings#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsMetricRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsMetricRelabelings(
  obj: ServiceMonitorSpecEndpointsMetricRelabelings | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "action": obj.action,
    "modulus": obj.modulus,
    "regex": obj.regex,
    "replacement": obj.replacement,
    "separator": obj.separator,
    "sourceLabels": obj.sourceLabels?.map((y) => y),
    "targetLabel": obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `oauth2` configures the OAuth2 settings to use when scraping the target.
 * It requires Prometheus >= 2.27.0.
 * Cannot be set at the same time as `authorization`, or `basicAuth`.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2
 */
export interface ServiceMonitorSpecEndpointsOauth2 {
  /**
   * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#clientId
   */
  readonly clientId: ServiceMonitorSpecEndpointsOauth2ClientId;

  /**
   * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#clientSecret
   */
  readonly clientSecret: ServiceMonitorSpecEndpointsOauth2ClientSecret;

  /**
   * `endpointParams` configures the HTTP parameters to append to the token URL.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#endpointParams
   */
  readonly endpointParams?: { [key: string]: string };

  /**
   * `scopes` defines the OAuth2 scopes used for the token request.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#scopes
   */
  readonly scopes?: string[];

  /**
   * `tokenURL` configures the URL to fetch the token from.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2#tokenUrl
   */
  readonly tokenUrl: string;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2(
  obj: ServiceMonitorSpecEndpointsOauth2 | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "clientId": toJson_ServiceMonitorSpecEndpointsOauth2ClientId(obj.clientId),
    "clientSecret": toJson_ServiceMonitorSpecEndpointsOauth2ClientSecret(
      obj.clientSecret,
    ),
    "endpointParams": ((obj.endpointParams) === undefined)
      ? undefined
      : (Object.entries(obj.endpointParams).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "scopes": obj.scopes?.map((y) => y),
    "tokenUrl": obj.tokenUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped samples and remote write samples.
 * More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 *
 * @schema ServiceMonitorSpecEndpointsRelabelings
 */
export interface ServiceMonitorSpecEndpointsRelabelings {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#action
   */
  readonly action?: ServiceMonitorSpecEndpointsRelabelingsAction;

  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#modulus
   */
  readonly modulus?: number;

  /**
   * Regular expression against which the extracted value is matched.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#regex
   */
  readonly regex?: string;

  /**
   * Replacement value against which a Replace action is performed if the regular expression matches.
   * Regex capture groups are available.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#replacement
   */
  readonly replacement?: string;

  /**
   * Separator is the string between concatenated SourceLabels.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#separator
   */
  readonly separator?: string;

  /**
   * The source labels select values from existing labels. Their content is concatenated using the configured Separator and matched against the configured regular expression.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#sourceLabels
   */
  readonly sourceLabels?: string[];

  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and `DropEqual` actions.
   * Regex capture groups are available.
   *
   * @schema ServiceMonitorSpecEndpointsRelabelings#targetLabel
   */
  readonly targetLabel?: string;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsRelabelings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsRelabelings(
  obj: ServiceMonitorSpecEndpointsRelabelings | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "action": obj.action,
    "modulus": obj.modulus,
    "regex": obj.regex,
    "replacement": obj.replacement,
    "separator": obj.separator,
    "sourceLabels": obj.sourceLabels?.map((y) => y),
    "targetLabel": obj.targetLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP scheme to use for scraping.
 * `http` and `https` are the expected values unless you rewrite the `__scheme__` label via relabeling.
 * If empty, Prometheus uses the default value `http`.
 *
 * @schema ServiceMonitorSpecEndpointsScheme
 */
export enum ServiceMonitorSpecEndpointsScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * Name or number of the target port of the `Pod` object behind the Service, the port must be specified with container port property.
 * Deprecated: use `port` instead.
 *
 * @schema ServiceMonitorSpecEndpointsTargetPort
 */
export class ServiceMonitorSpecEndpointsTargetPort {
  public static fromNumber(
    value: number,
  ): ServiceMonitorSpecEndpointsTargetPort {
    return new ServiceMonitorSpecEndpointsTargetPort(value);
  }
  public static fromString(
    value: string,
  ): ServiceMonitorSpecEndpointsTargetPort {
    return new ServiceMonitorSpecEndpointsTargetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * TLS configuration to use when scraping the target.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfig
 */
export interface ServiceMonitorSpecEndpointsTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#ca
   */
  readonly ca?: ServiceMonitorSpecEndpointsTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#cert
   */
  readonly cert?: ServiceMonitorSpecEndpointsTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#keySecret
   */
  readonly keySecret?: ServiceMonitorSpecEndpointsTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfig(
  obj: ServiceMonitorSpecEndpointsTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_ServiceMonitorSpecEndpointsTlsConfigCa(obj.ca),
    "caFile": obj.caFile,
    "cert": toJson_ServiceMonitorSpecEndpointsTlsConfigCert(obj.cert),
    "certFile": obj.certFile,
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keyFile": obj.keyFile,
    "keySecret": toJson_ServiceMonitorSpecEndpointsTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ServiceMonitorSpecSelectorMatchExpressions
 */
export interface ServiceMonitorSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ServiceMonitorSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ServiceMonitorSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ServiceMonitorSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ServiceMonitorSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecSelectorMatchExpressions(
  obj: ServiceMonitorSpecSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a Secret in the namespace that contains the credentials for authentication.
 *
 * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials
 */
export interface ServiceMonitorSpecEndpointsAuthorizationCredentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsAuthorizationCredentials#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsAuthorizationCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsAuthorizationCredentials(
  obj: ServiceMonitorSpecEndpointsAuthorizationCredentials | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `password` specifies a key of a Secret containing the password for authentication.
 *
 * @schema ServiceMonitorSpecEndpointsBasicAuthPassword
 */
export interface ServiceMonitorSpecEndpointsBasicAuthPassword {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthPassword#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthPassword#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthPassword#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBasicAuthPassword' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBasicAuthPassword(
  obj: ServiceMonitorSpecEndpointsBasicAuthPassword | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `username` specifies a key of a Secret containing the username for authentication.
 *
 * @schema ServiceMonitorSpecEndpointsBasicAuthUsername
 */
export interface ServiceMonitorSpecEndpointsBasicAuthUsername {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthUsername#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthUsername#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsBasicAuthUsername#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsBasicAuthUsername' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsBasicAuthUsername(
  obj: ServiceMonitorSpecEndpointsBasicAuthUsername | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 *
 * @schema ServiceMonitorSpecEndpointsMetricRelabelingsAction
 */
export enum ServiceMonitorSpecEndpointsMetricRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * `clientId` specifies a key of a Secret or ConfigMap containing the OAuth2 client's ID.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientId
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientId {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientId#configMap
   */
  readonly configMap?: ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientId#secret
   */
  readonly secret?: ServiceMonitorSpecEndpointsOauth2ClientIdSecret;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientId(
  obj: ServiceMonitorSpecEndpointsOauth2ClientId | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ServiceMonitorSpecEndpointsOauth2ClientIdSecret(
      obj.secret,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * `clientSecret` specifies a key of a Secret containing the OAuth2 client's secret.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientSecret(
  obj: ServiceMonitorSpecEndpointsOauth2ClientSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 *
 * @schema ServiceMonitorSpecEndpointsRelabelingsAction
 */
export enum ServiceMonitorSpecEndpointsRelabelingsAction {
  /** replace */
  REPLACE = "replace",
  /** keep */
  KEEP = "keep",
  /** drop */
  DROP = "drop",
  /** hashmod */
  HASHMOD = "hashmod",
  /** labelmap */
  LABELMAP = "labelmap",
  /** labeldrop */
  LABELDROP = "labeldrop",
  /** labelkeep */
  LABELKEEP = "labelkeep",
  /** lowercase */
  LOWERCASE = "lowercase",
  /** uppercase */
  UPPERCASE = "uppercase",
  /** keepequal */
  KEEPEQUAL = "keepequal",
  /** dropequal */
  DROPEQUAL = "dropequal",
}

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCa
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCa#configMap
   */
  readonly configMap?: ServiceMonitorSpecEndpointsTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCa#secret
   */
  readonly secret?: ServiceMonitorSpecEndpointsTlsConfigCaSecret;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCa(
  obj: ServiceMonitorSpecEndpointsTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ServiceMonitorSpecEndpointsTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ServiceMonitorSpecEndpointsTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCert
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCert#configMap
   */
  readonly configMap?: ServiceMonitorSpecEndpointsTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCert#secret
   */
  readonly secret?: ServiceMonitorSpecEndpointsTlsConfigCertSecret;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCert(
  obj: ServiceMonitorSpecEndpointsTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ServiceMonitorSpecEndpointsTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ServiceMonitorSpecEndpointsTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret
 */
export interface ServiceMonitorSpecEndpointsTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigKeySecret(
  obj: ServiceMonitorSpecEndpointsTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap {
  /**
   * The key to select.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap(
  obj: ServiceMonitorSpecEndpointsOauth2ClientIdConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret
 */
export interface ServiceMonitorSpecEndpointsOauth2ClientIdSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsOauth2ClientIdSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsOauth2ClientIdSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsOauth2ClientIdSecret(
  obj: ServiceMonitorSpecEndpointsOauth2ClientIdSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCaConfigMap(
  obj: ServiceMonitorSpecEndpointsTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCaSecret(
  obj: ServiceMonitorSpecEndpointsTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCertConfigMap(
  obj: ServiceMonitorSpecEndpointsTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret
 */
export interface ServiceMonitorSpecEndpointsTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ServiceMonitorSpecEndpointsTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ServiceMonitorSpecEndpointsTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceMonitorSpecEndpointsTlsConfigCertSecret(
  obj: ServiceMonitorSpecEndpointsTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ThanosRuler defines a ThanosRuler deployment.
 *
 * @schema ThanosRuler
 */
export class ThanosRuler extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ThanosRuler"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "monitoring.coreos.com/v1",
    kind: "ThanosRuler",
  };

  /**
   * Renders a Kubernetes manifest for "ThanosRuler".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ThanosRulerProps): any {
    return {
      ...ThanosRuler.GVK,
      ...toJson_ThanosRulerProps(props),
    };
  }

  /**
   * Defines a "ThanosRuler" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ThanosRulerProps) {
    super(scope, id, {
      ...ThanosRuler.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ThanosRuler.GVK,
      ...toJson_ThanosRulerProps(resolved),
    };
  }
}

/**
 * ThanosRuler defines a ThanosRuler deployment.
 *
 * @schema ThanosRuler
 */
export interface ThanosRulerProps {
  /**
   * @schema ThanosRuler#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of the desired behavior of the ThanosRuler cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema ThanosRuler#spec
   */
  readonly spec: ThanosRulerSpec;
}

/**
 * Converts an object of type 'ThanosRulerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerProps(
  obj: ThanosRulerProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ThanosRulerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired behavior of the ThanosRuler cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema ThanosRulerSpec
 */
export interface ThanosRulerSpec {
  /**
   * AdditionalArgs allows setting additional arguments for the ThanosRuler container. It is intended for e.g. activating hidden flags which are not supported by the dedicated configuration options yet. The arguments are passed as-is to the ThanosRuler container which may cause issues if they are invalid or not supported by the given ThanosRuler version. In case of an argument conflict (e.g. an argument which is already set by the operator itself) or when providing an invalid argument the reconciliation will fail and an error will be logged.
   *
   * @schema ThanosRulerSpec#additionalArgs
   */
  readonly additionalArgs?: ThanosRulerSpecAdditionalArgs[];

  /**
   * If specified, the pod's scheduling constraints.
   *
   * @schema ThanosRulerSpec#affinity
   */
  readonly affinity?: ThanosRulerSpecAffinity;

  /**
   * AlertDropLabels configure the label names which should be dropped in ThanosRuler alerts. The replica label `thanos_ruler_replica` will always be dropped in alerts.
   *
   * @schema ThanosRulerSpec#alertDropLabels
   */
  readonly alertDropLabels?: string[];

  /**
   * The external Query URL the Thanos Ruler will set in the 'Source' field of all alerts. Maps to the '--alert.query-url' CLI arg.
   *
   * @schema ThanosRulerSpec#alertQueryUrl
   */
  readonly alertQueryUrl?: string;

  /**
   * AlertRelabelConfigFile specifies the path of the alert relabeling configuration file. When used alongside with AlertRelabelConfigs, alertRelabelConfigFile takes precedence.
   *
   * @schema ThanosRulerSpec#alertRelabelConfigFile
   */
  readonly alertRelabelConfigFile?: string;

  /**
   * AlertRelabelConfigs configures alert relabeling in ThanosRuler. Alert relabel configurations must have the form as specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs Alternative to AlertRelabelConfigFile, and lower order priority.
   *
   * @schema ThanosRulerSpec#alertRelabelConfigs
   */
  readonly alertRelabelConfigs?: ThanosRulerSpecAlertRelabelConfigs;

  /**
   * Define configuration for connecting to alertmanager.  Only available with thanos v0.10.0 and higher.  Maps to the `alertmanagers.config` arg.
   *
   * @schema ThanosRulerSpec#alertmanagersConfig
   */
  readonly alertmanagersConfig?: ThanosRulerSpecAlertmanagersConfig;

  /**
   * Define URLs to send alerts to Alertmanager.  For Thanos v0.10.0 and higher, AlertManagersConfig should be used instead.  Note: this field will be ignored if AlertManagersConfig is specified. Maps to the `alertmanagers.url` arg.
   *
   * @schema ThanosRulerSpec#alertmanagersUrl
   */
  readonly alertmanagersUrl?: string[];

  /**
   * Containers allows injecting additional containers or modifying operator generated containers. This can be used to allow adding an authentication proxy to a ThanosRuler pod or to change the behavior of an operator generated container. Containers described here modify an operator generated container if they share the same name and modifications are done via a strategic merge patch. The current container names are: `thanos-ruler` and `config-reloader`. Overriding containers is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   *
   * @schema ThanosRulerSpec#containers
   */
  readonly containers?: ThanosRulerSpecContainers[];

  /**
   * EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert and metric that is user created. The label value will always be the namespace of the object that is being created.
   *
   * @schema ThanosRulerSpec#enforcedNamespaceLabel
   */
  readonly enforcedNamespaceLabel?: string;

  /**
   * Interval between consecutive evaluations.
   *
   * @schema ThanosRulerSpec#evaluationInterval
   */
  readonly evaluationInterval?: string;

  /**
   * List of references to PrometheusRule objects to be excluded from enforcing a namespace label of origin. Applies only if enforcedNamespaceLabel set to true.
   *
   * @schema ThanosRulerSpec#excludedFromEnforcement
   */
  readonly excludedFromEnforcement?: ThanosRulerSpecExcludedFromEnforcement[];

  /**
   * The external URL the Thanos Ruler instances will be available under. This is necessary to generate correct URLs. This is necessary if Thanos Ruler is not served from root of a DNS name.
   *
   * @schema ThanosRulerSpec#externalPrefix
   */
  readonly externalPrefix?: string;

  /**
   * GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads recorded rule data. Note: Currently only the CAFile, CertFile, and KeyFile fields are supported. Maps to the '--grpc-server-tls-*' CLI args.
   *
   * @schema ThanosRulerSpec#grpcServerTlsConfig
   */
  readonly grpcServerTlsConfig?: ThanosRulerSpecGrpcServerTlsConfig;

  /**
   * Pods' hostAliases configuration
   *
   * @schema ThanosRulerSpec#hostAliases
   */
  readonly hostAliases?: ThanosRulerSpecHostAliases[];

  /**
   * Thanos container image URL.
   *
   * @schema ThanosRulerSpec#image
   */
  readonly image?: string;

  /**
   * Image pull policy for the 'thanos', 'init-config-reloader' and 'config-reloader' containers. See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
   *
   * @schema ThanosRulerSpec#imagePullPolicy
   */
  readonly imagePullPolicy?: ThanosRulerSpecImagePullPolicy;

  /**
   * An optional list of references to secrets in the same namespace to use for pulling thanos images from registries see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
   *
   * @schema ThanosRulerSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: ThanosRulerSpecImagePullSecrets[];

  /**
   * InitContainers allows adding initContainers to the pod definition. Those can be used to e.g. fetch secrets for injection into the ThanosRuler configuration from external sources. Any errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ Using initContainers for any use case other then secret fetching is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   *
   * @schema ThanosRulerSpec#initContainers
   */
  readonly initContainers?: ThanosRulerSpecInitContainers[];

  /**
   * Labels configure the external label pairs to ThanosRuler. A default replica label `thanos_ruler_replica` will be always added  as a label with the value of the pod's name and it will be dropped in the alerts.
   *
   * @schema ThanosRulerSpec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * ListenLocal makes the Thanos ruler listen on loopback, so that it does not bind against the Pod IP.
   *
   * @schema ThanosRulerSpec#listenLocal
   */
  readonly listenLocal?: boolean;

  /**
   * Log format for ThanosRuler to be configured with.
   *
   * @schema ThanosRulerSpec#logFormat
   */
  readonly logFormat?: ThanosRulerSpecLogFormat;

  /**
   * Log level for ThanosRuler to be configured with.
   *
   * @schema ThanosRulerSpec#logLevel
   */
  readonly logLevel?: ThanosRulerSpecLogLevel;

  /**
   * Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
   *
   * @default 0 (pod will be considered available as soon as it is ready) This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
   * @schema ThanosRulerSpec#minReadySeconds
   */
  readonly minReadySeconds?: number;

  /**
   * Define which Nodes the Pods are scheduled on.
   *
   * @schema ThanosRulerSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * ObjectStorageConfig configures object storage in Thanos. Alternative to ObjectStorageConfigFile, and lower order priority.
   *
   * @schema ThanosRulerSpec#objectStorageConfig
   */
  readonly objectStorageConfig?: ThanosRulerSpecObjectStorageConfig;

  /**
   * ObjectStorageConfigFile specifies the path of the object storage configuration file. When used alongside with ObjectStorageConfig, ObjectStorageConfigFile takes precedence.
   *
   * @schema ThanosRulerSpec#objectStorageConfigFile
   */
  readonly objectStorageConfigFile?: string;

  /**
   * When a ThanosRuler deployment is paused, no actions except for deletion will be performed on the underlying objects.
   *
   * @schema ThanosRulerSpec#paused
   */
  readonly paused?: boolean;

  /**
   * PodMetadata configures labels and annotations which are propagated to the ThanosRuler pods.
   * The following items are reserved and cannot be overridden: * "app.kubernetes.io/name" label, set to "thanos-ruler". * "app.kubernetes.io/managed-by" label, set to "prometheus-operator". * "app.kubernetes.io/instance" label, set to the name of the ThanosRuler instance. * "thanos-ruler" label, set to the name of the ThanosRuler instance. * "kubectl.kubernetes.io/default-container" annotation, set to "thanos-ruler".
   *
   * @schema ThanosRulerSpec#podMetadata
   */
  readonly podMetadata?: ThanosRulerSpecPodMetadata;

  /**
   * Port name used for the pods and governing service. Defaults to `web`.
   *
   * @default web`.
   * @schema ThanosRulerSpec#portName
   */
  readonly portName?: string;

  /**
   * Priority class assigned to the Pods
   *
   * @schema ThanosRulerSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * PrometheusRulesExcludedFromEnforce - list of Prometheus rules to be excluded from enforcing of adding namespace labels. Works only if enforcedNamespaceLabel set to true. Make sure both ruleNamespace and ruleName are set for each pair Deprecated: use excludedFromEnforcement instead.
   *
   * @schema ThanosRulerSpec#prometheusRulesExcludedFromEnforce
   */
  readonly prometheusRulesExcludedFromEnforce?:
    ThanosRulerSpecPrometheusRulesExcludedFromEnforce[];

  /**
   * Define configuration for connecting to thanos query instances. If this is defined, the QueryEndpoints field will be ignored. Maps to the `query.config` CLI argument. Only available with thanos v0.11.0 and higher.
   *
   * @schema ThanosRulerSpec#queryConfig
   */
  readonly queryConfig?: ThanosRulerSpecQueryConfig;

  /**
   * QueryEndpoints defines Thanos querier endpoints from which to query metrics. Maps to the --query flag of thanos ruler.
   *
   * @schema ThanosRulerSpec#queryEndpoints
   */
  readonly queryEndpoints?: string[];

  /**
   * Number of thanos ruler instances to deploy.
   *
   * @schema ThanosRulerSpec#replicas
   */
  readonly replicas?: number;

  /**
   * Resources defines the resource requirements for single Pods. If not provided, no requests/limits will be set
   *
   * @schema ThanosRulerSpec#resources
   */
  readonly resources?: ThanosRulerSpecResources;

  /**
   * Time duration ThanosRuler shall retain data for. Default is '24h', and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)` (milliseconds seconds minutes hours days weeks years).
   *
   * @default 24h', and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)` (milliseconds seconds minutes hours days weeks years).
   * @schema ThanosRulerSpec#retention
   */
  readonly retention?: string;

  /**
   * The route prefix ThanosRuler registers HTTP handlers for. This allows thanos UI to be served on a sub-path.
   *
   * @schema ThanosRulerSpec#routePrefix
   */
  readonly routePrefix?: string;

  /**
   * Namespaces to be selected for Rules discovery. If unspecified, only the same namespace as the ThanosRuler object is in is used.
   *
   * @schema ThanosRulerSpec#ruleNamespaceSelector
   */
  readonly ruleNamespaceSelector?: ThanosRulerSpecRuleNamespaceSelector;

  /**
   * A label selector to select which PrometheusRules to mount for alerting and recording.
   *
   * @schema ThanosRulerSpec#ruleSelector
   */
  readonly ruleSelector?: ThanosRulerSpecRuleSelector;

  /**
   * SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.
   *
   * @schema ThanosRulerSpec#securityContext
   */
  readonly securityContext?: ThanosRulerSpecSecurityContext;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the Thanos Ruler Pods.
   *
   * @schema ThanosRulerSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Storage spec to specify how storage shall be used.
   *
   * @schema ThanosRulerSpec#storage
   */
  readonly storage?: ThanosRulerSpecStorage;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema ThanosRulerSpec#tolerations
   */
  readonly tolerations?: ThanosRulerSpecTolerations[];

  /**
   * If specified, the pod's topology spread constraints.
   *
   * @schema ThanosRulerSpec#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?:
    ThanosRulerSpecTopologySpreadConstraints[];

  /**
   * TracingConfig configures tracing in Thanos. This is an experimental feature, it may change in any upcoming release in a breaking way.
   *
   * @schema ThanosRulerSpec#tracingConfig
   */
  readonly tracingConfig?: ThanosRulerSpecTracingConfig;

  /**
   * TracingConfig specifies the path of the tracing configuration file. When used alongside with TracingConfig, TracingConfigFile takes precedence.
   *
   * @schema ThanosRulerSpec#tracingConfigFile
   */
  readonly tracingConfigFile?: string;

  /**
   * Version of Thanos to be deployed.
   *
   * @schema ThanosRulerSpec#version
   */
  readonly version?: string;

  /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition. VolumeMounts specified will be appended to other VolumeMounts in the ruler container, that are generated as a result of StorageSpec objects.
   *
   * @schema ThanosRulerSpec#volumeMounts
   */
  readonly volumeMounts?: ThanosRulerSpecVolumeMounts[];

  /**
   * Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will be appended to other volumes that are generated as a result of StorageSpec objects.
   *
   * @schema ThanosRulerSpec#volumes
   */
  readonly volumes?: ThanosRulerSpecVolumes[];
}

/**
 * Converts an object of type 'ThanosRulerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpec(
  obj: ThanosRulerSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "additionalArgs": obj.additionalArgs?.map((y) =>
      toJson_ThanosRulerSpecAdditionalArgs(y)
    ),
    "affinity": toJson_ThanosRulerSpecAffinity(obj.affinity),
    "alertDropLabels": obj.alertDropLabels?.map((y) => y),
    "alertQueryUrl": obj.alertQueryUrl,
    "alertRelabelConfigFile": obj.alertRelabelConfigFile,
    "alertRelabelConfigs": toJson_ThanosRulerSpecAlertRelabelConfigs(
      obj.alertRelabelConfigs,
    ),
    "alertmanagersConfig": toJson_ThanosRulerSpecAlertmanagersConfig(
      obj.alertmanagersConfig,
    ),
    "alertmanagersUrl": obj.alertmanagersUrl?.map((y) => y),
    "containers": obj.containers?.map((y) =>
      toJson_ThanosRulerSpecContainers(y)
    ),
    "enforcedNamespaceLabel": obj.enforcedNamespaceLabel,
    "evaluationInterval": obj.evaluationInterval,
    "excludedFromEnforcement": obj.excludedFromEnforcement?.map((y) =>
      toJson_ThanosRulerSpecExcludedFromEnforcement(y)
    ),
    "externalPrefix": obj.externalPrefix,
    "grpcServerTlsConfig": toJson_ThanosRulerSpecGrpcServerTlsConfig(
      obj.grpcServerTlsConfig,
    ),
    "hostAliases": obj.hostAliases?.map((y) =>
      toJson_ThanosRulerSpecHostAliases(y)
    ),
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "imagePullSecrets": obj.imagePullSecrets?.map((y) =>
      toJson_ThanosRulerSpecImagePullSecrets(y)
    ),
    "initContainers": obj.initContainers?.map((y) =>
      toJson_ThanosRulerSpecInitContainers(y)
    ),
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "listenLocal": obj.listenLocal,
    "logFormat": obj.logFormat,
    "logLevel": obj.logLevel,
    "minReadySeconds": obj.minReadySeconds,
    "nodeSelector": ((obj.nodeSelector) === undefined)
      ? undefined
      : (Object.entries(obj.nodeSelector).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "objectStorageConfig": toJson_ThanosRulerSpecObjectStorageConfig(
      obj.objectStorageConfig,
    ),
    "objectStorageConfigFile": obj.objectStorageConfigFile,
    "paused": obj.paused,
    "podMetadata": toJson_ThanosRulerSpecPodMetadata(obj.podMetadata),
    "portName": obj.portName,
    "priorityClassName": obj.priorityClassName,
    "prometheusRulesExcludedFromEnforce": obj.prometheusRulesExcludedFromEnforce
      ?.map((y) => toJson_ThanosRulerSpecPrometheusRulesExcludedFromEnforce(y)),
    "queryConfig": toJson_ThanosRulerSpecQueryConfig(obj.queryConfig),
    "queryEndpoints": obj.queryEndpoints?.map((y) => y),
    "replicas": obj.replicas,
    "resources": toJson_ThanosRulerSpecResources(obj.resources),
    "retention": obj.retention,
    "routePrefix": obj.routePrefix,
    "ruleNamespaceSelector": toJson_ThanosRulerSpecRuleNamespaceSelector(
      obj.ruleNamespaceSelector,
    ),
    "ruleSelector": toJson_ThanosRulerSpecRuleSelector(obj.ruleSelector),
    "securityContext": toJson_ThanosRulerSpecSecurityContext(
      obj.securityContext,
    ),
    "serviceAccountName": obj.serviceAccountName,
    "storage": toJson_ThanosRulerSpecStorage(obj.storage),
    "tolerations": obj.tolerations?.map((y) =>
      toJson_ThanosRulerSpecTolerations(y)
    ),
    "topologySpreadConstraints": obj.topologySpreadConstraints?.map((y) =>
      toJson_ThanosRulerSpecTopologySpreadConstraints(y)
    ),
    "tracingConfig": toJson_ThanosRulerSpecTracingConfig(obj.tracingConfig),
    "tracingConfigFile": obj.tracingConfigFile,
    "version": obj.version,
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_ThanosRulerSpecVolumeMounts(y)
    ),
    "volumes": obj.volumes?.map((y) => toJson_ThanosRulerSpecVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Argument as part of the AdditionalArgs list.
 *
 * @schema ThanosRulerSpecAdditionalArgs
 */
export interface ThanosRulerSpecAdditionalArgs {
  /**
   * Name of the argument, e.g. "scrape.discovery-reload-interval".
   *
   * @schema ThanosRulerSpecAdditionalArgs#name
   */
  readonly name: string;

  /**
   * Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
   *
   * @schema ThanosRulerSpecAdditionalArgs#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecAdditionalArgs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAdditionalArgs(
  obj: ThanosRulerSpecAdditionalArgs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's scheduling constraints.
 *
 * @schema ThanosRulerSpecAffinity
 */
export interface ThanosRulerSpecAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema ThanosRulerSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: ThanosRulerSpecAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ThanosRulerSpecAffinity#podAffinity
   */
  readonly podAffinity?: ThanosRulerSpecAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema ThanosRulerSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: ThanosRulerSpecAffinityPodAntiAffinity;
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinity(
  obj: ThanosRulerSpecAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeAffinity": toJson_ThanosRulerSpecAffinityNodeAffinity(
      obj.nodeAffinity,
    ),
    "podAffinity": toJson_ThanosRulerSpecAffinityPodAffinity(obj.podAffinity),
    "podAntiAffinity": toJson_ThanosRulerSpecAffinityPodAntiAffinity(
      obj.podAntiAffinity,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * AlertRelabelConfigs configures alert relabeling in ThanosRuler. Alert relabel configurations must have the form as specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs Alternative to AlertRelabelConfigFile, and lower order priority.
 *
 * @schema ThanosRulerSpecAlertRelabelConfigs
 */
export interface ThanosRulerSpecAlertRelabelConfigs {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecAlertRelabelConfigs#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecAlertRelabelConfigs#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecAlertRelabelConfigs#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecAlertRelabelConfigs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAlertRelabelConfigs(
  obj: ThanosRulerSpecAlertRelabelConfigs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Define configuration for connecting to alertmanager.  Only available with thanos v0.10.0 and higher.  Maps to the `alertmanagers.config` arg.
 *
 * @schema ThanosRulerSpecAlertmanagersConfig
 */
export interface ThanosRulerSpecAlertmanagersConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecAlertmanagersConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecAlertmanagersConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecAlertmanagersConfig#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecAlertmanagersConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAlertmanagersConfig(
  obj: ThanosRulerSpecAlertmanagersConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema ThanosRulerSpecContainers
 */
export interface ThanosRulerSpecContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ThanosRulerSpecContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ThanosRulerSpecContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#env
   */
  readonly env?: ThanosRulerSpecContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#envFrom
   */
  readonly envFrom?: ThanosRulerSpecContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema ThanosRulerSpecContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema ThanosRulerSpecContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#lifecycle
   */
  readonly lifecycle?: ThanosRulerSpecContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainers#livenessProbe
   */
  readonly livenessProbe?: ThanosRulerSpecContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#ports
   */
  readonly ports?: ThanosRulerSpecContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainers#readinessProbe
   */
  readonly readinessProbe?: ThanosRulerSpecContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema ThanosRulerSpecContainers#resizePolicy
   */
  readonly resizePolicy?: ThanosRulerSpecContainersResizePolicy[];

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecContainers#resources
   */
  readonly resources?: ThanosRulerSpecContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is "Always". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as "Always" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy "Always" will be shut down. This lifecycle differs from normal init containers and is often referred to as a "sidecar" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.
   *
   * @schema ThanosRulerSpecContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema ThanosRulerSpecContainers#securityContext
   */
  readonly securityContext?: ThanosRulerSpecContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainers#startupProbe
   */
  readonly startupProbe?: ThanosRulerSpecContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema ThanosRulerSpecContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema ThanosRulerSpecContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema ThanosRulerSpecContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema ThanosRulerSpecContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema ThanosRulerSpecContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema ThanosRulerSpecContainers#volumeDevices
   */
  readonly volumeDevices?: ThanosRulerSpecContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#volumeMounts
   */
  readonly volumeMounts?: ThanosRulerSpecContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema ThanosRulerSpecContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainers(
  obj: ThanosRulerSpecContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "args": obj.args?.map((y) => y),
    "command": obj.command?.map((y) => y),
    "env": obj.env?.map((y) => toJson_ThanosRulerSpecContainersEnv(y)),
    "envFrom": obj.envFrom?.map((y) =>
      toJson_ThanosRulerSpecContainersEnvFrom(y)
    ),
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "lifecycle": toJson_ThanosRulerSpecContainersLifecycle(obj.lifecycle),
    "livenessProbe": toJson_ThanosRulerSpecContainersLivenessProbe(
      obj.livenessProbe,
    ),
    "name": obj.name,
    "ports": obj.ports?.map((y) => toJson_ThanosRulerSpecContainersPorts(y)),
    "readinessProbe": toJson_ThanosRulerSpecContainersReadinessProbe(
      obj.readinessProbe,
    ),
    "resizePolicy": obj.resizePolicy?.map((y) =>
      toJson_ThanosRulerSpecContainersResizePolicy(y)
    ),
    "resources": toJson_ThanosRulerSpecContainersResources(obj.resources),
    "restartPolicy": obj.restartPolicy,
    "securityContext": toJson_ThanosRulerSpecContainersSecurityContext(
      obj.securityContext,
    ),
    "startupProbe": toJson_ThanosRulerSpecContainersStartupProbe(
      obj.startupProbe,
    ),
    "stdin": obj.stdin,
    "stdinOnce": obj.stdinOnce,
    "terminationMessagePath": obj.terminationMessagePath,
    "terminationMessagePolicy": obj.terminationMessagePolicy,
    "tty": obj.tty,
    "volumeDevices": obj.volumeDevices?.map((y) =>
      toJson_ThanosRulerSpecContainersVolumeDevices(y)
    ),
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_ThanosRulerSpecContainersVolumeMounts(y)
    ),
    "workingDir": obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectReference references a PodMonitor, ServiceMonitor, Probe or PrometheusRule object.
 *
 * @schema ThanosRulerSpecExcludedFromEnforcement
 */
export interface ThanosRulerSpecExcludedFromEnforcement {
  /**
   * Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
   *
   * @schema ThanosRulerSpecExcludedFromEnforcement#group
   */
  readonly group?: ThanosRulerSpecExcludedFromEnforcementGroup;

  /**
   * Name of the referent. When not set, all resources in the namespace are matched.
   *
   * @schema ThanosRulerSpecExcludedFromEnforcement#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ThanosRulerSpecExcludedFromEnforcement#namespace
   */
  readonly namespace: string;

  /**
   * Resource of the referent.
   *
   * @schema ThanosRulerSpecExcludedFromEnforcement#resource
   */
  readonly resource: ThanosRulerSpecExcludedFromEnforcementResource;
}

/**
 * Converts an object of type 'ThanosRulerSpecExcludedFromEnforcement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecExcludedFromEnforcement(
  obj: ThanosRulerSpecExcludedFromEnforcement | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "group": obj.group,
    "name": obj.name,
    "namespace": obj.namespace,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads recorded rule data. Note: Currently only the CAFile, CertFile, and KeyFile fields are supported. Maps to the '--grpc-server-tls-*' CLI args.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfig
 */
export interface ThanosRulerSpecGrpcServerTlsConfig {
  /**
   * Certificate authority used when verifying server certificates.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#ca
   */
  readonly ca?: ThanosRulerSpecGrpcServerTlsConfigCa;

  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate to present when doing client-authentication.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#cert
   */
  readonly cert?: ThanosRulerSpecGrpcServerTlsConfigCert;

  /**
   * Path to the client cert file in the Prometheus container for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#certFile
   */
  readonly certFile?: string;

  /**
   * Disable target certificate validation.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Path to the client key file in the Prometheus container for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#keyFile
   */
  readonly keyFile?: string;

  /**
   * Secret containing the client key file for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#keySecret
   */
  readonly keySecret?: ThanosRulerSpecGrpcServerTlsConfigKeySecret;

  /**
   * Used to verify the hostname for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfig#serverName
   */
  readonly serverName?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfig(
  obj: ThanosRulerSpecGrpcServerTlsConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ca": toJson_ThanosRulerSpecGrpcServerTlsConfigCa(obj.ca),
    "caFile": obj.caFile,
    "cert": toJson_ThanosRulerSpecGrpcServerTlsConfigCert(obj.cert),
    "certFile": obj.certFile,
    "insecureSkipVerify": obj.insecureSkipVerify,
    "keyFile": obj.keyFile,
    "keySecret": toJson_ThanosRulerSpecGrpcServerTlsConfigKeySecret(
      obj.keySecret,
    ),
    "serverName": obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
 *
 * @schema ThanosRulerSpecHostAliases
 */
export interface ThanosRulerSpecHostAliases {
  /**
   * Hostnames for the above IP address.
   *
   * @schema ThanosRulerSpecHostAliases#hostnames
   */
  readonly hostnames: string[];

  /**
   * IP address of the host file entry.
   *
   * @schema ThanosRulerSpecHostAliases#ip
   */
  readonly ip: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecHostAliases(
  obj: ThanosRulerSpecHostAliases | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "hostnames": obj.hostnames?.map((y) => y),
    "ip": obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Image pull policy for the 'thanos', 'init-config-reloader' and 'config-reloader' containers. See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
 *
 * @schema ThanosRulerSpecImagePullPolicy
 */
export enum ThanosRulerSpecImagePullPolicy {
  /** Always */
  ALWAYS = "Always",
  /** Never */
  NEVER = "Never",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema ThanosRulerSpecImagePullSecrets
 */
export interface ThanosRulerSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecImagePullSecrets#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecImagePullSecrets(
  obj: ThanosRulerSpecImagePullSecrets | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A single application container that you want to run within a pod.
 *
 * @schema ThanosRulerSpecInitContainers
 */
export interface ThanosRulerSpecInitContainers {
  /**
   * Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ThanosRulerSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema ThanosRulerSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#env
   */
  readonly env?: ThanosRulerSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#envFrom
   */
  readonly envFrom?: ThanosRulerSpecInitContainersEnvFrom[];

  /**
   * Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema ThanosRulerSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema ThanosRulerSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#lifecycle
   */
  readonly lifecycle?: ThanosRulerSpecInitContainersLifecycle;

  /**
   * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: ThanosRulerSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#ports
   */
  readonly ports?: ThanosRulerSpecInitContainersPorts[];

  /**
   * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: ThanosRulerSpecInitContainersReadinessProbe;

  /**
   * Resources resize policy for the container.
   *
   * @schema ThanosRulerSpecInitContainers#resizePolicy
   */
  readonly resizePolicy?: ThanosRulerSpecInitContainersResizePolicy[];

  /**
   * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecInitContainers#resources
   */
  readonly resources?: ThanosRulerSpecInitContainersResources;

  /**
   * RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is "Always". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as "Always" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy "Always" will be shut down. This lifecycle differs from normal init containers and is often referred to as a "sidecar" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.
   *
   * @schema ThanosRulerSpecInitContainers#restartPolicy
   */
  readonly restartPolicy?: string;

  /**
   * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   *
   * @schema ThanosRulerSpecInitContainers#securityContext
   */
  readonly securityContext?: ThanosRulerSpecInitContainersSecurityContext;

  /**
   * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainers#startupProbe
   */
  readonly startupProbe?: ThanosRulerSpecInitContainersStartupProbe;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema ThanosRulerSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema ThanosRulerSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema ThanosRulerSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema ThanosRulerSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema ThanosRulerSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container.
   *
   * @schema ThanosRulerSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: ThanosRulerSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: ThanosRulerSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema ThanosRulerSpecInitContainers#workingDir
   */
  readonly workingDir?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainers(
  obj: ThanosRulerSpecInitContainers | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "args": obj.args?.map((y) => y),
    "command": obj.command?.map((y) => y),
    "env": obj.env?.map((y) => toJson_ThanosRulerSpecInitContainersEnv(y)),
    "envFrom": obj.envFrom?.map((y) =>
      toJson_ThanosRulerSpecInitContainersEnvFrom(y)
    ),
    "image": obj.image,
    "imagePullPolicy": obj.imagePullPolicy,
    "lifecycle": toJson_ThanosRulerSpecInitContainersLifecycle(obj.lifecycle),
    "livenessProbe": toJson_ThanosRulerSpecInitContainersLivenessProbe(
      obj.livenessProbe,
    ),
    "name": obj.name,
    "ports": obj.ports?.map((y) =>
      toJson_ThanosRulerSpecInitContainersPorts(y)
    ),
    "readinessProbe": toJson_ThanosRulerSpecInitContainersReadinessProbe(
      obj.readinessProbe,
    ),
    "resizePolicy": obj.resizePolicy?.map((y) =>
      toJson_ThanosRulerSpecInitContainersResizePolicy(y)
    ),
    "resources": toJson_ThanosRulerSpecInitContainersResources(obj.resources),
    "restartPolicy": obj.restartPolicy,
    "securityContext": toJson_ThanosRulerSpecInitContainersSecurityContext(
      obj.securityContext,
    ),
    "startupProbe": toJson_ThanosRulerSpecInitContainersStartupProbe(
      obj.startupProbe,
    ),
    "stdin": obj.stdin,
    "stdinOnce": obj.stdinOnce,
    "terminationMessagePath": obj.terminationMessagePath,
    "terminationMessagePolicy": obj.terminationMessagePolicy,
    "tty": obj.tty,
    "volumeDevices": obj.volumeDevices?.map((y) =>
      toJson_ThanosRulerSpecInitContainersVolumeDevices(y)
    ),
    "volumeMounts": obj.volumeMounts?.map((y) =>
      toJson_ThanosRulerSpecInitContainersVolumeMounts(y)
    ),
    "workingDir": obj.workingDir,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Log format for ThanosRuler to be configured with.
 *
 * @schema ThanosRulerSpecLogFormat
 */
export enum ThanosRulerSpecLogFormat {
  /** logfmt */
  LOGFMT = "logfmt",
  /** json */
  JSON = "json",
}

/**
 * Log level for ThanosRuler to be configured with.
 *
 * @schema ThanosRulerSpecLogLevel
 */
export enum ThanosRulerSpecLogLevel {
  /** debug */
  DEBUG = "debug",
  /** info */
  INFO = "info",
  /** warn */
  WARN = "warn",
  /** error */
  ERROR = "error",
}

/**
 * ObjectStorageConfig configures object storage in Thanos. Alternative to ObjectStorageConfigFile, and lower order priority.
 *
 * @schema ThanosRulerSpecObjectStorageConfig
 */
export interface ThanosRulerSpecObjectStorageConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecObjectStorageConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecObjectStorageConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecObjectStorageConfig#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecObjectStorageConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecObjectStorageConfig(
  obj: ThanosRulerSpecObjectStorageConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PodMetadata configures labels and annotations which are propagated to the ThanosRuler pods.
 * The following items are reserved and cannot be overridden: * "app.kubernetes.io/name" label, set to "thanos-ruler". * "app.kubernetes.io/managed-by" label, set to "prometheus-operator". * "app.kubernetes.io/instance" label, set to the name of the ThanosRuler instance. * "thanos-ruler" label, set to the name of the ThanosRuler instance. * "kubectl.kubernetes.io/default-container" annotation, set to "thanos-ruler".
 *
 * @schema ThanosRulerSpecPodMetadata
 */
export interface ThanosRulerSpecPodMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema ThanosRulerSpecPodMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema ThanosRulerSpecPodMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema ThanosRulerSpecPodMetadata#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecPodMetadata(
  obj: ThanosRulerSpecPodMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "annotations": ((obj.annotations) === undefined)
      ? undefined
      : (Object.entries(obj.annotations).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PrometheusRuleExcludeConfig enables users to configure excluded PrometheusRule names and their namespaces to be ignored while enforcing namespace label for alerts and metrics.
 *
 * @schema ThanosRulerSpecPrometheusRulesExcludedFromEnforce
 */
export interface ThanosRulerSpecPrometheusRulesExcludedFromEnforce {
  /**
   * Name of the excluded PrometheusRule object.
   *
   * @schema ThanosRulerSpecPrometheusRulesExcludedFromEnforce#ruleName
   */
  readonly ruleName: string;

  /**
   * Namespace of the excluded PrometheusRule object.
   *
   * @schema ThanosRulerSpecPrometheusRulesExcludedFromEnforce#ruleNamespace
   */
  readonly ruleNamespace: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecPrometheusRulesExcludedFromEnforce' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecPrometheusRulesExcludedFromEnforce(
  obj: ThanosRulerSpecPrometheusRulesExcludedFromEnforce | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ruleName": obj.ruleName,
    "ruleNamespace": obj.ruleNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Define configuration for connecting to thanos query instances. If this is defined, the QueryEndpoints field will be ignored. Maps to the `query.config` CLI argument. Only available with thanos v0.11.0 and higher.
 *
 * @schema ThanosRulerSpecQueryConfig
 */
export interface ThanosRulerSpecQueryConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecQueryConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecQueryConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecQueryConfig#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecQueryConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecQueryConfig(
  obj: ThanosRulerSpecQueryConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Resources defines the resource requirements for single Pods. If not provided, no requests/limits will be set
 *
 * @schema ThanosRulerSpecResources
 */
export interface ThanosRulerSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema ThanosRulerSpecResources#claims
   */
  readonly claims?: ThanosRulerSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecResources#limits
   */
  readonly limits?: { [key: string]: ThanosRulerSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecResources#requests
   */
  readonly requests?: { [key: string]: ThanosRulerSpecResourcesRequests };
}

/**
 * Converts an object of type 'ThanosRulerSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecResources(
  obj: ThanosRulerSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) => toJson_ThanosRulerSpecResourcesClaims(y)),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Namespaces to be selected for Rules discovery. If unspecified, only the same namespace as the ThanosRuler object is in is used.
 *
 * @schema ThanosRulerSpecRuleNamespaceSelector
 */
export interface ThanosRulerSpecRuleNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecRuleNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecRuleNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecRuleNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecRuleNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecRuleNamespaceSelector(
  obj: ThanosRulerSpecRuleNamespaceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecRuleNamespaceSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector to select which PrometheusRules to mount for alerting and recording.
 *
 * @schema ThanosRulerSpecRuleSelector
 */
export interface ThanosRulerSpecRuleSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecRuleSelector#matchExpressions
   */
  readonly matchExpressions?: ThanosRulerSpecRuleSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecRuleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecRuleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecRuleSelector(
  obj: ThanosRulerSpecRuleSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecRuleSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.
 *
 * @schema ThanosRulerSpecSecurityContext
 */
export interface ThanosRulerSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ThanosRulerSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema ThanosRulerSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: ThanosRulerSpecSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#seccompProfile
   */
  readonly seccompProfile?: ThanosRulerSpecSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process. If unspecified, no additional groups are added to any container. Note that group memberships defined in the container image for the uid of the container process are still effective, even if they are not included in this list. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecSecurityContext#sysctls
   */
  readonly sysctls?: ThanosRulerSpecSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ThanosRulerSpecSecurityContext#windowsOptions
   */
  readonly windowsOptions?: ThanosRulerSpecSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ThanosRulerSpecSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecSecurityContext(
  obj: ThanosRulerSpecSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsGroup": obj.fsGroup,
    "fsGroupChangePolicy": obj.fsGroupChangePolicy,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions": toJson_ThanosRulerSpecSecurityContextSeLinuxOptions(
      obj.seLinuxOptions,
    ),
    "seccompProfile": toJson_ThanosRulerSpecSecurityContextSeccompProfile(
      obj.seccompProfile,
    ),
    "supplementalGroups": obj.supplementalGroups?.map((y) => y),
    "sysctls": obj.sysctls?.map((y) =>
      toJson_ThanosRulerSpecSecurityContextSysctls(y)
    ),
    "windowsOptions": toJson_ThanosRulerSpecSecurityContextWindowsOptions(
      obj.windowsOptions,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Storage spec to specify how storage shall be used.
 *
 * @schema ThanosRulerSpecStorage
 */
export interface ThanosRulerSpecStorage {
  /**
   * Deprecated: subPath usage will be removed in a future release.
   *
   * @schema ThanosRulerSpecStorage#disableMountSubPath
   */
  readonly disableMountSubPath?: boolean;

  /**
   * EmptyDirVolumeSource to be used by the StatefulSet. If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
   *
   * @schema ThanosRulerSpecStorage#emptyDir
   */
  readonly emptyDir?: ThanosRulerSpecStorageEmptyDir;

  /**
   * EphemeralVolumeSource to be used by the StatefulSet. This is a beta field in k8s 1.21 and GA in 1.15. For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
   *
   * @schema ThanosRulerSpecStorage#ephemeral
   */
  readonly ephemeral?: ThanosRulerSpecStorageEphemeral;

  /**
   * Defines the PVC spec to be used by the Prometheus StatefulSets. The easiest way to use a volume that cannot be automatically provisioned is to use a label selector alongside manually created PersistentVolumes.
   *
   * @schema ThanosRulerSpecStorage#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: ThanosRulerSpecStorageVolumeClaimTemplate;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorage(
  obj: ThanosRulerSpecStorage | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "disableMountSubPath": obj.disableMountSubPath,
    "emptyDir": toJson_ThanosRulerSpecStorageEmptyDir(obj.emptyDir),
    "ephemeral": toJson_ThanosRulerSpecStorageEphemeral(obj.ephemeral),
    "volumeClaimTemplate": toJson_ThanosRulerSpecStorageVolumeClaimTemplate(
      obj.volumeClaimTemplate,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ThanosRulerSpecTolerations
 */
export interface ThanosRulerSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ThanosRulerSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ThanosRulerSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema ThanosRulerSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ThanosRulerSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ThanosRulerSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecTolerations(
  obj: ThanosRulerSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "effect": obj.effect,
    "key": obj.key,
    "operator": obj.operator,
    "tolerationSeconds": obj.tolerationSeconds,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @schema ThanosRulerSpecTopologySpreadConstraints
 */
export interface ThanosRulerSpecTopologySpreadConstraints {
  /**
   * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?:
    ThanosRulerSpecTopologySpreadConstraintsLabelSelector;

  /**
   * MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels are ANDed with labelSelector to select the group of existing pods over which spreading will be calculated for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector. MatchLabelKeys cannot be set when LabelSelector isn't set. Keys that don't exist in the incoming pod labels will be ignored. A null or empty list means only match against labelSelector.
   * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. The global minimum is the minimum number of matching pods in an eligible domain or zero if the number of eligible domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 2/2/1: In this case, the global minimum is 1. | zone1 | zone2 | zone3 | |  P P  |  P P  |   P   | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew: number;

  /**
   * MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
   * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.
   * This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
   * If this value is nil, the behavior is equivalent to the Honor policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.
   * If this value is nil, the behavior is equivalent to the Ignore policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a "bucket", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology. And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology. It's a required field.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location, but giving higher precedence to topologies that would help reduce the skew. A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecTopologySpreadConstraints(
  obj: ThanosRulerSpecTopologySpreadConstraints | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ThanosRulerSpecTopologySpreadConstraintsLabelSelector(
        obj.labelSelector,
      ),
    "matchLabelKeys": obj.matchLabelKeys?.map((y) => y),
    "maxSkew": obj.maxSkew,
    "minDomains": obj.minDomains,
    "nodeAffinityPolicy": obj.nodeAffinityPolicy,
    "nodeTaintsPolicy": obj.nodeTaintsPolicy,
    "topologyKey": obj.topologyKey,
    "whenUnsatisfiable": obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TracingConfig configures tracing in Thanos. This is an experimental feature, it may change in any upcoming release in a breaking way.
 *
 * @schema ThanosRulerSpecTracingConfig
 */
export interface ThanosRulerSpecTracingConfig {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecTracingConfig#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecTracingConfig#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecTracingConfig#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecTracingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecTracingConfig(
  obj: ThanosRulerSpecTracingConfig | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema ThanosRulerSpecVolumeMounts
 */
export interface ThanosRulerSpecVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema ThanosRulerSpecVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema ThanosRulerSpecVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema ThanosRulerSpecVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema ThanosRulerSpecVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema ThanosRulerSpecVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema ThanosRulerSpecVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumeMounts(
  obj: ThanosRulerSpecVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema ThanosRulerSpecVolumes
 */
export interface ThanosRulerSpecVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ThanosRulerSpecVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: ThanosRulerSpecVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema ThanosRulerSpecVolumes#azureDisk
   */
  readonly azureDisk?: ThanosRulerSpecVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema ThanosRulerSpecVolumes#azureFile
   */
  readonly azureFile?: ThanosRulerSpecVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema ThanosRulerSpecVolumes#cephfs
   */
  readonly cephfs?: ThanosRulerSpecVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ThanosRulerSpecVolumes#cinder
   */
  readonly cinder?: ThanosRulerSpecVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema ThanosRulerSpecVolumes#configMap
   */
  readonly configMap?: ThanosRulerSpecVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema ThanosRulerSpecVolumes#csi
   */
  readonly csi?: ThanosRulerSpecVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema ThanosRulerSpecVolumes#downwardAPI
   */
  readonly downwardApi?: ThanosRulerSpecVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ThanosRulerSpecVolumes#emptyDir
   */
  readonly emptyDir?: ThanosRulerSpecVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema ThanosRulerSpecVolumes#ephemeral
   */
  readonly ephemeral?: ThanosRulerSpecVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema ThanosRulerSpecVolumes#fc
   */
  readonly fc?: ThanosRulerSpecVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema ThanosRulerSpecVolumes#flexVolume
   */
  readonly flexVolume?: ThanosRulerSpecVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema ThanosRulerSpecVolumes#flocker
   */
  readonly flocker?: ThanosRulerSpecVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ThanosRulerSpecVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: ThanosRulerSpecVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema ThanosRulerSpecVolumes#gitRepo
   */
  readonly gitRepo?: ThanosRulerSpecVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema ThanosRulerSpecVolumes#glusterfs
   */
  readonly glusterfs?: ThanosRulerSpecVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema ThanosRulerSpecVolumes#hostPath
   */
  readonly hostPath?: ThanosRulerSpecVolumesHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema ThanosRulerSpecVolumes#iscsi
   */
  readonly iscsi?: ThanosRulerSpecVolumesIscsi;

  /**
   * name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ThanosRulerSpecVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ThanosRulerSpecVolumes#nfs
   */
  readonly nfs?: ThanosRulerSpecVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ThanosRulerSpecVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: ThanosRulerSpecVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema ThanosRulerSpecVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: ThanosRulerSpecVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema ThanosRulerSpecVolumes#portworxVolume
   */
  readonly portworxVolume?: ThanosRulerSpecVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema ThanosRulerSpecVolumes#projected
   */
  readonly projected?: ThanosRulerSpecVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema ThanosRulerSpecVolumes#quobyte
   */
  readonly quobyte?: ThanosRulerSpecVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema ThanosRulerSpecVolumes#rbd
   */
  readonly rbd?: ThanosRulerSpecVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema ThanosRulerSpecVolumes#scaleIO
   */
  readonly scaleIo?: ThanosRulerSpecVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ThanosRulerSpecVolumes#secret
   */
  readonly secret?: ThanosRulerSpecVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema ThanosRulerSpecVolumes#storageos
   */
  readonly storageos?: ThanosRulerSpecVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema ThanosRulerSpecVolumes#vsphereVolume
   */
  readonly vsphereVolume?: ThanosRulerSpecVolumesVsphereVolume;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumes(
  obj: ThanosRulerSpecVolumes | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "awsElasticBlockStore": toJson_ThanosRulerSpecVolumesAwsElasticBlockStore(
      obj.awsElasticBlockStore,
    ),
    "azureDisk": toJson_ThanosRulerSpecVolumesAzureDisk(obj.azureDisk),
    "azureFile": toJson_ThanosRulerSpecVolumesAzureFile(obj.azureFile),
    "cephfs": toJson_ThanosRulerSpecVolumesCephfs(obj.cephfs),
    "cinder": toJson_ThanosRulerSpecVolumesCinder(obj.cinder),
    "configMap": toJson_ThanosRulerSpecVolumesConfigMap(obj.configMap),
    "csi": toJson_ThanosRulerSpecVolumesCsi(obj.csi),
    "downwardAPI": toJson_ThanosRulerSpecVolumesDownwardApi(obj.downwardApi),
    "emptyDir": toJson_ThanosRulerSpecVolumesEmptyDir(obj.emptyDir),
    "ephemeral": toJson_ThanosRulerSpecVolumesEphemeral(obj.ephemeral),
    "fc": toJson_ThanosRulerSpecVolumesFc(obj.fc),
    "flexVolume": toJson_ThanosRulerSpecVolumesFlexVolume(obj.flexVolume),
    "flocker": toJson_ThanosRulerSpecVolumesFlocker(obj.flocker),
    "gcePersistentDisk": toJson_ThanosRulerSpecVolumesGcePersistentDisk(
      obj.gcePersistentDisk,
    ),
    "gitRepo": toJson_ThanosRulerSpecVolumesGitRepo(obj.gitRepo),
    "glusterfs": toJson_ThanosRulerSpecVolumesGlusterfs(obj.glusterfs),
    "hostPath": toJson_ThanosRulerSpecVolumesHostPath(obj.hostPath),
    "iscsi": toJson_ThanosRulerSpecVolumesIscsi(obj.iscsi),
    "name": obj.name,
    "nfs": toJson_ThanosRulerSpecVolumesNfs(obj.nfs),
    "persistentVolumeClaim": toJson_ThanosRulerSpecVolumesPersistentVolumeClaim(
      obj.persistentVolumeClaim,
    ),
    "photonPersistentDisk": toJson_ThanosRulerSpecVolumesPhotonPersistentDisk(
      obj.photonPersistentDisk,
    ),
    "portworxVolume": toJson_ThanosRulerSpecVolumesPortworxVolume(
      obj.portworxVolume,
    ),
    "projected": toJson_ThanosRulerSpecVolumesProjected(obj.projected),
    "quobyte": toJson_ThanosRulerSpecVolumesQuobyte(obj.quobyte),
    "rbd": toJson_ThanosRulerSpecVolumesRbd(obj.rbd),
    "scaleIO": toJson_ThanosRulerSpecVolumesScaleIo(obj.scaleIo),
    "secret": toJson_ThanosRulerSpecVolumesSecret(obj.secret),
    "storageos": toJson_ThanosRulerSpecVolumesStorageos(obj.storageos),
    "vsphereVolume": toJson_ThanosRulerSpecVolumesVsphereVolume(
      obj.vsphereVolume,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinity
 */
export interface ThanosRulerSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinity(
  obj: ThanosRulerSpecAffinityNodeAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution":
      toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
        obj.requiredDuringSchedulingIgnoredDuringExecution,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ThanosRulerSpecAffinityPodAffinity
 */
export interface ThanosRulerSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema ThanosRulerSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ThanosRulerSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinity(
  obj: ThanosRulerSpecAffinityPodAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinity
 */
export interface ThanosRulerSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?:
    ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?:
    ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinity(
  obj: ThanosRulerSpecAffinityPodAntiAffinity | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preferredDuringSchedulingIgnoredDuringExecution": obj
      .preferredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
    "requiredDuringSchedulingIgnoredDuringExecution": obj
      .requiredDuringSchedulingIgnoredDuringExecution?.map((y) =>
        toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
          y,
        )
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema ThanosRulerSpecContainersEnv
 */
export interface ThanosRulerSpecContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema ThanosRulerSpecContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema ThanosRulerSpecContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema ThanosRulerSpecContainersEnv#valueFrom
   */
  readonly valueFrom?: ThanosRulerSpecContainersEnvValueFrom;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnv(
  obj: ThanosRulerSpecContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
    "valueFrom": toJson_ThanosRulerSpecContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ThanosRulerSpecContainersEnvFrom
 */
export interface ThanosRulerSpecContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ThanosRulerSpecContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: ThanosRulerSpecContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ThanosRulerSpecContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ThanosRulerSpecContainersEnvFrom#secretRef
   */
  readonly secretRef?: ThanosRulerSpecContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvFrom(
  obj: ThanosRulerSpecContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapRef": toJson_ThanosRulerSpecContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    "prefix": obj.prefix,
    "secretRef": toJson_ThanosRulerSpecContainersEnvFromSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema ThanosRulerSpecContainersLifecycle
 */
export interface ThanosRulerSpecContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ThanosRulerSpecContainersLifecycle#postStart
   */
  readonly postStart?: ThanosRulerSpecContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ThanosRulerSpecContainersLifecycle#preStop
   */
  readonly preStop?: ThanosRulerSpecContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecycle(
  obj: ThanosRulerSpecContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "postStart": toJson_ThanosRulerSpecContainersLifecyclePostStart(
      obj.postStart,
    ),
    "preStop": toJson_ThanosRulerSpecContainersLifecyclePreStop(obj.preStop),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecContainersLivenessProbe
 */
export interface ThanosRulerSpecContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#exec
   */
  readonly exec?: ThanosRulerSpecContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema ThanosRulerSpecContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbe(
  obj: ThanosRulerSpecContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_ThanosRulerSpecContainersLivenessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_ThanosRulerSpecContainersLivenessProbeGrpc(obj.grpc),
    "httpGet": toJson_ThanosRulerSpecContainersLivenessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_ThanosRulerSpecContainersLivenessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema ThanosRulerSpecContainersPorts
 */
export interface ThanosRulerSpecContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema ThanosRulerSpecContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema ThanosRulerSpecContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema ThanosRulerSpecContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema ThanosRulerSpecContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema ThanosRulerSpecContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersPorts(
  obj: ThanosRulerSpecContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerPort": obj.containerPort,
    "hostIP": obj.hostIp,
    "hostPort": obj.hostPort,
    "name": obj.name,
    "protocol": obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecContainersReadinessProbe
 */
export interface ThanosRulerSpecContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#exec
   */
  readonly exec?: ThanosRulerSpecContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema ThanosRulerSpecContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbe(
  obj: ThanosRulerSpecContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_ThanosRulerSpecContainersReadinessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_ThanosRulerSpecContainersReadinessProbeGrpc(obj.grpc),
    "httpGet": toJson_ThanosRulerSpecContainersReadinessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_ThanosRulerSpecContainersReadinessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema ThanosRulerSpecContainersResizePolicy
 */
export interface ThanosRulerSpecContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies. Supported values: cpu, memory.
   *
   * @schema ThanosRulerSpecContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized. If not specified, it defaults to NotRequired.
   *
   * @schema ThanosRulerSpecContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersResizePolicy(
  obj: ThanosRulerSpecContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "resourceName": obj.resourceName,
    "restartPolicy": obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema ThanosRulerSpecContainersResources
 */
export interface ThanosRulerSpecContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema ThanosRulerSpecContainersResources#claims
   */
  readonly claims?: ThanosRulerSpecContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecContainersResources#limits
   */
  readonly limits?: { [key: string]: ThanosRulerSpecContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecContainersResources#requests
   */
  readonly requests?: {
    [key: string]: ThanosRulerSpecContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersResources(
  obj: ThanosRulerSpecContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ThanosRulerSpecContainersResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema ThanosRulerSpecContainersSecurityContext
 */
export interface ThanosRulerSpecContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema ThanosRulerSpecContainersSecurityContext#capabilities
   */
  readonly capabilities?: ThanosRulerSpecContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema ThanosRulerSpecContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema ThanosRulerSpecContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema ThanosRulerSpecContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    ThanosRulerSpecContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    ThanosRulerSpecContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ThanosRulerSpecContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    ThanosRulerSpecContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersSecurityContext(
  obj: ThanosRulerSpecContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "allowPrivilegeEscalation": obj.allowPrivilegeEscalation,
    "capabilities": toJson_ThanosRulerSpecContainersSecurityContextCapabilities(
      obj.capabilities,
    ),
    "privileged": obj.privileged,
    "procMount": obj.procMount,
    "readOnlyRootFilesystem": obj.readOnlyRootFilesystem,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_ThanosRulerSpecContainersSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_ThanosRulerSpecContainersSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "windowsOptions":
      toJson_ThanosRulerSpecContainersSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecContainersStartupProbe
 */
export interface ThanosRulerSpecContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecContainersStartupProbe#exec
   */
  readonly exec?: ThanosRulerSpecContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecContainersStartupProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecContainersStartupProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema ThanosRulerSpecContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbe(
  obj: ThanosRulerSpecContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_ThanosRulerSpecContainersStartupProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_ThanosRulerSpecContainersStartupProbeGrpc(obj.grpc),
    "httpGet": toJson_ThanosRulerSpecContainersStartupProbeHttpGet(obj.httpGet),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_ThanosRulerSpecContainersStartupProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema ThanosRulerSpecContainersVolumeDevices
 */
export interface ThanosRulerSpecContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema ThanosRulerSpecContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema ThanosRulerSpecContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersVolumeDevices(
  obj: ThanosRulerSpecContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "devicePath": obj.devicePath,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema ThanosRulerSpecContainersVolumeMounts
 */
export interface ThanosRulerSpecContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema ThanosRulerSpecContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema ThanosRulerSpecContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema ThanosRulerSpecContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema ThanosRulerSpecContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema ThanosRulerSpecContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema ThanosRulerSpecContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersVolumeMounts(
  obj: ThanosRulerSpecContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
 *
 * @schema ThanosRulerSpecExcludedFromEnforcementGroup
 */
export enum ThanosRulerSpecExcludedFromEnforcementGroup {
  /** monitoring.coreos.com */
  MONITORING_PERIOD_COREOS_PERIOD_COM = "monitoring.coreos.com",
}

/**
 * Resource of the referent.
 *
 * @schema ThanosRulerSpecExcludedFromEnforcementResource
 */
export enum ThanosRulerSpecExcludedFromEnforcementResource {
  /** prometheusrules */
  PROMETHEUSRULES = "prometheusrules",
  /** servicemonitors */
  SERVICEMONITORS = "servicemonitors",
  /** podmonitors */
  PODMONITORS = "podmonitors",
  /** probes */
  PROBES = "probes",
  /** scrapeconfigs */
  SCRAPECONFIGS = "scrapeconfigs",
}

/**
 * Certificate authority used when verifying server certificates.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCa
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCa {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCa#configMap
   */
  readonly configMap?: ThanosRulerSpecGrpcServerTlsConfigCaConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCa#secret
   */
  readonly secret?: ThanosRulerSpecGrpcServerTlsConfigCaSecret;
}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCa' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCa(
  obj: ThanosRulerSpecGrpcServerTlsConfigCa | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ThanosRulerSpecGrpcServerTlsConfigCaConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ThanosRulerSpecGrpcServerTlsConfigCaSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Client certificate to present when doing client-authentication.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCert
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCert {
  /**
   * ConfigMap containing data to use for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCert#configMap
   */
  readonly configMap?: ThanosRulerSpecGrpcServerTlsConfigCertConfigMap;

  /**
   * Secret containing data to use for the targets.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCert#secret
   */
  readonly secret?: ThanosRulerSpecGrpcServerTlsConfigCertSecret;
}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCert' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCert(
  obj: ThanosRulerSpecGrpcServerTlsConfigCert | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ThanosRulerSpecGrpcServerTlsConfigCertConfigMap(
      obj.configMap,
    ),
    "secret": toJson_ThanosRulerSpecGrpcServerTlsConfigCertSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing the client key file for the targets.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigKeySecret
 */
export interface ThanosRulerSpecGrpcServerTlsConfigKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigKeySecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigKeySecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigKeySecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigKeySecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigKeySecret(
  obj: ThanosRulerSpecGrpcServerTlsConfigKeySecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema ThanosRulerSpecInitContainersEnv
 */
export interface ThanosRulerSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema ThanosRulerSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema ThanosRulerSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema ThanosRulerSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: ThanosRulerSpecInitContainersEnvValueFrom;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnv(
  obj: ThanosRulerSpecInitContainersEnv | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
    "valueFrom": toJson_ThanosRulerSpecInitContainersEnvValueFrom(
      obj.valueFrom,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema ThanosRulerSpecInitContainersEnvFrom
 */
export interface ThanosRulerSpecInitContainersEnvFrom {
  /**
   * The ConfigMap to select from
   *
   * @schema ThanosRulerSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: ThanosRulerSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema ThanosRulerSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * The Secret to select from
   *
   * @schema ThanosRulerSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: ThanosRulerSpecInitContainersEnvFromSecretRef;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvFrom(
  obj: ThanosRulerSpecInitContainersEnvFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapRef": toJson_ThanosRulerSpecInitContainersEnvFromConfigMapRef(
      obj.configMapRef,
    ),
    "prefix": obj.prefix,
    "secretRef": toJson_ThanosRulerSpecInitContainersEnvFromSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Actions that the management system should take in response to container lifecycle events. Cannot be updated.
 *
 * @schema ThanosRulerSpecInitContainersLifecycle
 */
export interface ThanosRulerSpecInitContainersLifecycle {
  /**
   * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ThanosRulerSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: ThanosRulerSpecInitContainersLifecyclePostStart;

  /**
   * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   *
   * @schema ThanosRulerSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: ThanosRulerSpecInitContainersLifecyclePreStop;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecycle' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecycle(
  obj: ThanosRulerSpecInitContainersLifecycle | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "postStart": toJson_ThanosRulerSpecInitContainersLifecyclePostStart(
      obj.postStart,
    ),
    "preStop": toJson_ThanosRulerSpecInitContainersLifecyclePreStop(
      obj.preStop,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbe
 */
export interface ThanosRulerSpecInitContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: ThanosRulerSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecInitContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema ThanosRulerSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbe(
  obj: ThanosRulerSpecInitContainersLivenessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_ThanosRulerSpecInitContainersLivenessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_ThanosRulerSpecInitContainersLivenessProbeGrpc(obj.grpc),
    "httpGet": toJson_ThanosRulerSpecInitContainersLivenessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_ThanosRulerSpecInitContainersLivenessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema ThanosRulerSpecInitContainersPorts
 */
export interface ThanosRulerSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema ThanosRulerSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema ThanosRulerSpecInitContainersPorts#hostIP
   */
  readonly hostIp?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema ThanosRulerSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema ThanosRulerSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema ThanosRulerSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersPorts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersPorts(
  obj: ThanosRulerSpecInitContainersPorts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerPort": obj.containerPort,
    "hostIP": obj.hostIp,
    "hostPort": obj.hostPort,
    "name": obj.name,
    "protocol": obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbe
 */
export interface ThanosRulerSpecInitContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: ThanosRulerSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecInitContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema ThanosRulerSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbe(
  obj: ThanosRulerSpecInitContainersReadinessProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_ThanosRulerSpecInitContainersReadinessProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_ThanosRulerSpecInitContainersReadinessProbeGrpc(obj.grpc),
    "httpGet": toJson_ThanosRulerSpecInitContainersReadinessProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_ThanosRulerSpecInitContainersReadinessProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ContainerResizePolicy represents resource resize policy for the container.
 *
 * @schema ThanosRulerSpecInitContainersResizePolicy
 */
export interface ThanosRulerSpecInitContainersResizePolicy {
  /**
   * Name of the resource to which this resource resize policy applies. Supported values: cpu, memory.
   *
   * @schema ThanosRulerSpecInitContainersResizePolicy#resourceName
   */
  readonly resourceName: string;

  /**
   * Restart policy to apply when specified resource is resized. If not specified, it defaults to NotRequired.
   *
   * @schema ThanosRulerSpecInitContainersResizePolicy#restartPolicy
   */
  readonly restartPolicy: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersResizePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersResizePolicy(
  obj: ThanosRulerSpecInitContainersResizePolicy | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "resourceName": obj.resourceName,
    "restartPolicy": obj.restartPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema ThanosRulerSpecInitContainersResources
 */
export interface ThanosRulerSpecInitContainersResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema ThanosRulerSpecInitContainersResources#claims
   */
  readonly claims?: ThanosRulerSpecInitContainersResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecInitContainersResources#limits
   */
  readonly limits?: {
    [key: string]: ThanosRulerSpecInitContainersResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecInitContainersResources#requests
   */
  readonly requests?: {
    [key: string]: ThanosRulerSpecInitContainersResourcesRequests;
  };
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersResources(
  obj: ThanosRulerSpecInitContainersResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ThanosRulerSpecInitContainersResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 *
 * @schema ThanosRulerSpecInitContainersSecurityContext
 */
export interface ThanosRulerSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema ThanosRulerSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?:
    ThanosRulerSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema ThanosRulerSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema ThanosRulerSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema ThanosRulerSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?:
    ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?:
    ThanosRulerSpecInitContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?:
    ThanosRulerSpecInitContainersSecurityContextWindowsOptions;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersSecurityContext(
  obj: ThanosRulerSpecInitContainersSecurityContext | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "allowPrivilegeEscalation": obj.allowPrivilegeEscalation,
    "capabilities":
      toJson_ThanosRulerSpecInitContainersSecurityContextCapabilities(
        obj.capabilities,
      ),
    "privileged": obj.privileged,
    "procMount": obj.procMount,
    "readOnlyRootFilesystem": obj.readOnlyRootFilesystem,
    "runAsGroup": obj.runAsGroup,
    "runAsNonRoot": obj.runAsNonRoot,
    "runAsUser": obj.runAsUser,
    "seLinuxOptions":
      toJson_ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions(
        obj.seLinuxOptions,
      ),
    "seccompProfile":
      toJson_ThanosRulerSpecInitContainersSecurityContextSeccompProfile(
        obj.seccompProfile,
      ),
    "windowsOptions":
      toJson_ThanosRulerSpecInitContainersSecurityContextWindowsOptions(
        obj.windowsOptions,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
 *
 * @schema ThanosRulerSpecInitContainersStartupProbe
 */
export interface ThanosRulerSpecInitContainersStartupProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#exec
   */
  readonly exec?: ThanosRulerSpecInitContainersStartupProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersStartupProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#grpc
   */
  readonly grpc?: ThanosRulerSpecInitContainersStartupProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#httpGet
   */
  readonly httpGet?: ThanosRulerSpecInitContainersStartupProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersStartupProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema ThanosRulerSpecInitContainersStartupProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecInitContainersStartupProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema ThanosRulerSpecInitContainersStartupProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbe(
  obj: ThanosRulerSpecInitContainersStartupProbe | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_ThanosRulerSpecInitContainersStartupProbeExec(obj.exec),
    "failureThreshold": obj.failureThreshold,
    "grpc": toJson_ThanosRulerSpecInitContainersStartupProbeGrpc(obj.grpc),
    "httpGet": toJson_ThanosRulerSpecInitContainersStartupProbeHttpGet(
      obj.httpGet,
    ),
    "initialDelaySeconds": obj.initialDelaySeconds,
    "periodSeconds": obj.periodSeconds,
    "successThreshold": obj.successThreshold,
    "tcpSocket": toJson_ThanosRulerSpecInitContainersStartupProbeTcpSocket(
      obj.tcpSocket,
    ),
    "terminationGracePeriodSeconds": obj.terminationGracePeriodSeconds,
    "timeoutSeconds": obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema ThanosRulerSpecInitContainersVolumeDevices
 */
export interface ThanosRulerSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema ThanosRulerSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema ThanosRulerSpecInitContainersVolumeDevices#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersVolumeDevices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersVolumeDevices(
  obj: ThanosRulerSpecInitContainersVolumeDevices | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "devicePath": obj.devicePath,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema ThanosRulerSpecInitContainersVolumeMounts
 */
export interface ThanosRulerSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema ThanosRulerSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema ThanosRulerSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema ThanosRulerSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema ThanosRulerSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema ThanosRulerSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema ThanosRulerSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersVolumeMounts(
  obj: ThanosRulerSpecInitContainersVolumeMounts | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "mountPath": obj.mountPath,
    "mountPropagation": obj.mountPropagation,
    "name": obj.name,
    "readOnly": obj.readOnly,
    "subPath": obj.subPath,
    "subPathExpr": obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ThanosRulerSpecResourcesClaims
 */
export interface ThanosRulerSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema ThanosRulerSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecResourcesClaims(
  obj: ThanosRulerSpecResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecResourcesLimits
 */
export class ThanosRulerSpecResourcesLimits {
  public static fromNumber(value: number): ThanosRulerSpecResourcesLimits {
    return new ThanosRulerSpecResourcesLimits(value);
  }
  public static fromString(value: string): ThanosRulerSpecResourcesLimits {
    return new ThanosRulerSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecResourcesRequests
 */
export class ThanosRulerSpecResourcesRequests {
  public static fromNumber(value: number): ThanosRulerSpecResourcesRequests {
    return new ThanosRulerSpecResourcesRequests(value);
  }
  public static fromString(value: string): ThanosRulerSpecResourcesRequests {
    return new ThanosRulerSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecRuleNamespaceSelectorMatchExpressions
 */
export interface ThanosRulerSpecRuleNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecRuleNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecRuleNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecRuleNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecRuleNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecRuleNamespaceSelectorMatchExpressions(
  obj: ThanosRulerSpecRuleNamespaceSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecRuleSelectorMatchExpressions
 */
export interface ThanosRulerSpecRuleSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecRuleSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecRuleSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecRuleSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecRuleSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecRuleSelectorMatchExpressions(
  obj: ThanosRulerSpecRuleSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecSecurityContextSeLinuxOptions
 */
export interface ThanosRulerSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ThanosRulerSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ThanosRulerSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ThanosRulerSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ThanosRulerSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecSecurityContextSeLinuxOptions(
  obj: ThanosRulerSpecSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecSecurityContextSeccompProfile
 */
export interface ThanosRulerSpecSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ThanosRulerSpecSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema ThanosRulerSpecSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecSecurityContextSeccompProfile(
  obj: ThanosRulerSpecSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema ThanosRulerSpecSecurityContextSysctls
 */
export interface ThanosRulerSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema ThanosRulerSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema ThanosRulerSpecSecurityContextSysctls#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecSecurityContextSysctls(
  obj: ThanosRulerSpecSecurityContextSysctls | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ThanosRulerSpecSecurityContextWindowsOptions
 */
export interface ThanosRulerSpecSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ThanosRulerSpecSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ThanosRulerSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ThanosRulerSpecSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema ThanosRulerSpecSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecSecurityContextWindowsOptions(
  obj: ThanosRulerSpecSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDirVolumeSource to be used by the StatefulSet. If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
 *
 * @schema ThanosRulerSpecStorageEmptyDir
 */
export interface ThanosRulerSpecStorageEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ThanosRulerSpecStorageEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ThanosRulerSpecStorageEmptyDir#sizeLimit
   */
  readonly sizeLimit?: ThanosRulerSpecStorageEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEmptyDir(
  obj: ThanosRulerSpecStorageEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "medium": obj.medium,
    "sizeLimit": obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EphemeralVolumeSource to be used by the StatefulSet. This is a beta field in k8s 1.21 and GA in 1.15. For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
 *
 * @schema ThanosRulerSpecStorageEphemeral
 */
export interface ThanosRulerSpecStorageEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema ThanosRulerSpecStorageEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?:
    ThanosRulerSpecStorageEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeral(
  obj: ThanosRulerSpecStorageEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "volumeClaimTemplate":
      toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplate(
        obj.volumeClaimTemplate,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the PVC spec to be used by the Prometheus StatefulSets. The easiest way to use a volume that cannot be automatically provisioned is to use a label selector alongside manually created PersistentVolumes.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplate
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplate {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplate#kind
   */
  readonly kind?: string;

  /**
   * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplate#metadata
   */
  readonly metadata?: ThanosRulerSpecStorageVolumeClaimTemplateMetadata;

  /**
   * Defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplate#spec
   */
  readonly spec?: ThanosRulerSpecStorageVolumeClaimTemplateSpec;

  /**
   * Deprecated: this field is never set.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplate#status
   */
  readonly status?: ThanosRulerSpecStorageVolumeClaimTemplateStatus;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplate(
  obj: ThanosRulerSpecStorageVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "kind": obj.kind,
    "metadata": toJson_ThanosRulerSpecStorageVolumeClaimTemplateMetadata(
      obj.metadata,
    ),
    "spec": toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpec(obj.spec),
    "status": toJson_ThanosRulerSpecStorageVolumeClaimTemplateStatus(
      obj.status,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
 *
 * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelector
 */
export interface ThanosRulerSpecTopologySpreadConstraintsLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecTopologySpreadConstraintsLabelSelector(
  obj: ThanosRulerSpecTopologySpreadConstraintsLabelSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema ThanosRulerSpecVolumesAwsElasticBlockStore
 */
export interface ThanosRulerSpecVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ThanosRulerSpecVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema ThanosRulerSpecVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ThanosRulerSpecVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ThanosRulerSpecVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesAwsElasticBlockStore(
  obj: ThanosRulerSpecVolumesAwsElasticBlockStore | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "partition": obj.partition,
    "readOnly": obj.readOnly,
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema ThanosRulerSpecVolumesAzureDisk
 */
export interface ThanosRulerSpecVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema ThanosRulerSpecVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema ThanosRulerSpecVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema ThanosRulerSpecVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ThanosRulerSpecVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema ThanosRulerSpecVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema ThanosRulerSpecVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesAzureDisk(
  obj: ThanosRulerSpecVolumesAzureDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "cachingMode": obj.cachingMode,
    "diskName": obj.diskName,
    "diskURI": obj.diskUri,
    "fsType": obj.fsType,
    "kind": obj.kind,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema ThanosRulerSpecVolumesAzureFile
 */
export interface ThanosRulerSpecVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema ThanosRulerSpecVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema ThanosRulerSpecVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema ThanosRulerSpecVolumesAzureFile#shareName
   */
  readonly shareName: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesAzureFile(
  obj: ThanosRulerSpecVolumesAzureFile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "readOnly": obj.readOnly,
    "secretName": obj.secretName,
    "shareName": obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema ThanosRulerSpecVolumesCephfs
 */
export interface ThanosRulerSpecVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema ThanosRulerSpecVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema ThanosRulerSpecVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesCephfs#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesCephfs#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCephfs(
  obj: ThanosRulerSpecVolumesCephfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "monitors": obj.monitors?.map((y) => y),
    "path": obj.path,
    "readOnly": obj.readOnly,
    "secretFile": obj.secretFile,
    "secretRef": toJson_ThanosRulerSpecVolumesCephfsSecretRef(obj.secretRef),
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema ThanosRulerSpecVolumesCinder
 */
export interface ThanosRulerSpecVolumesCinder {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ThanosRulerSpecVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ThanosRulerSpecVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema ThanosRulerSpecVolumesCinder#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ThanosRulerSpecVolumesCinder#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCinder(
  obj: ThanosRulerSpecVolumesCinder | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "secretRef": toJson_ThanosRulerSpecVolumesCinderSecretRef(obj.secretRef),
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema ThanosRulerSpecVolumesConfigMap
 */
export interface ThanosRulerSpecVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema ThanosRulerSpecVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema ThanosRulerSpecVolumesConfigMap#items
   */
  readonly items?: ThanosRulerSpecVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ThanosRulerSpecVolumesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesConfigMap(
  obj: ThanosRulerSpecVolumesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) =>
      toJson_ThanosRulerSpecVolumesConfigMapItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema ThanosRulerSpecVolumesCsi
 */
export interface ThanosRulerSpecVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema ThanosRulerSpecVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema ThanosRulerSpecVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema ThanosRulerSpecVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: ThanosRulerSpecVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema ThanosRulerSpecVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema ThanosRulerSpecVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCsi(
  obj: ThanosRulerSpecVolumesCsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "driver": obj.driver,
    "fsType": obj.fsType,
    "nodePublishSecretRef":
      toJson_ThanosRulerSpecVolumesCsiNodePublishSecretRef(
        obj.nodePublishSecretRef,
      ),
    "readOnly": obj.readOnly,
    "volumeAttributes": ((obj.volumeAttributes) === undefined)
      ? undefined
      : (Object.entries(obj.volumeAttributes).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema ThanosRulerSpecVolumesDownwardApi
 */
export interface ThanosRulerSpecVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema ThanosRulerSpecVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema ThanosRulerSpecVolumesDownwardApi#items
   */
  readonly items?: ThanosRulerSpecVolumesDownwardApiItems[];
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesDownwardApi(
  obj: ThanosRulerSpecVolumesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) =>
      toJson_ThanosRulerSpecVolumesDownwardApiItems(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ThanosRulerSpecVolumesEmptyDir
 */
export interface ThanosRulerSpecVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ThanosRulerSpecVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ThanosRulerSpecVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: ThanosRulerSpecVolumesEmptyDirSizeLimit;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEmptyDir(
  obj: ThanosRulerSpecVolumesEmptyDir | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "medium": obj.medium,
    "sizeLimit": obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema ThanosRulerSpecVolumesEphemeral
 */
export interface ThanosRulerSpecVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema ThanosRulerSpecVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?:
    ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeral(
  obj: ThanosRulerSpecVolumesEphemeral | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "volumeClaimTemplate":
      toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate(
        obj.volumeClaimTemplate,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema ThanosRulerSpecVolumesFc
 */
export interface ThanosRulerSpecVolumesFc {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ThanosRulerSpecVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema ThanosRulerSpecVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema ThanosRulerSpecVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema ThanosRulerSpecVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema ThanosRulerSpecVolumesFc#wwids
   */
  readonly wwids?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesFc(
  obj: ThanosRulerSpecVolumesFc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "lun": obj.lun,
    "readOnly": obj.readOnly,
    "targetWWNs": obj.targetWwNs?.map((y) => y),
    "wwids": obj.wwids?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema ThanosRulerSpecVolumesFlexVolume
 */
export interface ThanosRulerSpecVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema ThanosRulerSpecVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema ThanosRulerSpecVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema ThanosRulerSpecVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema ThanosRulerSpecVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema ThanosRulerSpecVolumesFlexVolume#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesFlexVolumeSecretRef;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesFlexVolume(
  obj: ThanosRulerSpecVolumesFlexVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "driver": obj.driver,
    "fsType": obj.fsType,
    "options": ((obj.options) === undefined)
      ? undefined
      : (Object.entries(obj.options).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "readOnly": obj.readOnly,
    "secretRef": toJson_ThanosRulerSpecVolumesFlexVolumeSecretRef(
      obj.secretRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema ThanosRulerSpecVolumesFlocker
 */
export interface ThanosRulerSpecVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema ThanosRulerSpecVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema ThanosRulerSpecVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesFlocker(
  obj: ThanosRulerSpecVolumesFlocker | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "datasetName": obj.datasetName,
    "datasetUUID": obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema ThanosRulerSpecVolumesGcePersistentDisk
 */
export interface ThanosRulerSpecVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ThanosRulerSpecVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ThanosRulerSpecVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ThanosRulerSpecVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema ThanosRulerSpecVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesGcePersistentDisk(
  obj: ThanosRulerSpecVolumesGcePersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "partition": obj.partition,
    "pdName": obj.pdName,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema ThanosRulerSpecVolumesGitRepo
 */
export interface ThanosRulerSpecVolumesGitRepo {
  /**
   * directory is the target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema ThanosRulerSpecVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema ThanosRulerSpecVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema ThanosRulerSpecVolumesGitRepo#revision
   */
  readonly revision?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesGitRepo(
  obj: ThanosRulerSpecVolumesGitRepo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "directory": obj.directory,
    "repository": obj.repository,
    "revision": obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema ThanosRulerSpecVolumesGlusterfs
 */
export interface ThanosRulerSpecVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ThanosRulerSpecVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ThanosRulerSpecVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema ThanosRulerSpecVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesGlusterfs(
  obj: ThanosRulerSpecVolumesGlusterfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "endpoints": obj.endpoints,
    "path": obj.path,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema ThanosRulerSpecVolumesHostPath
 */
export interface ThanosRulerSpecVolumesHostPath {
  /**
   * path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema ThanosRulerSpecVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema ThanosRulerSpecVolumesHostPath#type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesHostPath(
  obj: ThanosRulerSpecVolumesHostPath | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "path": obj.path,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema ThanosRulerSpecVolumesIscsi
 */
export interface ThanosRulerSpecVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema ThanosRulerSpecVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema ThanosRulerSpecVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ThanosRulerSpecVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema ThanosRulerSpecVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema ThanosRulerSpecVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema ThanosRulerSpecVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema ThanosRulerSpecVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ThanosRulerSpecVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema ThanosRulerSpecVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema ThanosRulerSpecVolumesIscsi#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ThanosRulerSpecVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesIscsi(
  obj: ThanosRulerSpecVolumesIscsi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "chapAuthDiscovery": obj.chapAuthDiscovery,
    "chapAuthSession": obj.chapAuthSession,
    "fsType": obj.fsType,
    "initiatorName": obj.initiatorName,
    "iqn": obj.iqn,
    "iscsiInterface": obj.iscsiInterface,
    "lun": obj.lun,
    "portals": obj.portals?.map((y) => y),
    "readOnly": obj.readOnly,
    "secretRef": toJson_ThanosRulerSpecVolumesIscsiSecretRef(obj.secretRef),
    "targetPortal": obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema ThanosRulerSpecVolumesNfs
 */
export interface ThanosRulerSpecVolumesNfs {
  /**
   * path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ThanosRulerSpecVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema ThanosRulerSpecVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ThanosRulerSpecVolumesNfs#server
   */
  readonly server: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesNfs(
  obj: ThanosRulerSpecVolumesNfs | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "path": obj.path,
    "readOnly": obj.readOnly,
    "server": obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema ThanosRulerSpecVolumesPersistentVolumeClaim
 */
export interface ThanosRulerSpecVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ThanosRulerSpecVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema ThanosRulerSpecVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesPersistentVolumeClaim(
  obj: ThanosRulerSpecVolumesPersistentVolumeClaim | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claimName": obj.claimName,
    "readOnly": obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema ThanosRulerSpecVolumesPhotonPersistentDisk
 */
export interface ThanosRulerSpecVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ThanosRulerSpecVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema ThanosRulerSpecVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesPhotonPersistentDisk(
  obj: ThanosRulerSpecVolumesPhotonPersistentDisk | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "pdID": obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema ThanosRulerSpecVolumesPortworxVolume
 */
export interface ThanosRulerSpecVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ThanosRulerSpecVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema ThanosRulerSpecVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema ThanosRulerSpecVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesPortworxVolume(
  obj: ThanosRulerSpecVolumesPortworxVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "volumeID": obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema ThanosRulerSpecVolumesProjected
 */
export interface ThanosRulerSpecVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema ThanosRulerSpecVolumesProjected#sources
   */
  readonly sources?: ThanosRulerSpecVolumesProjectedSources[];
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjected(
  obj: ThanosRulerSpecVolumesProjected | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "sources": obj.sources?.map((y) =>
      toJson_ThanosRulerSpecVolumesProjectedSources(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema ThanosRulerSpecVolumesQuobyte
 */
export interface ThanosRulerSpecVolumesQuobyte {
  /**
   * group to map volume access to Default is no group
   *
   * @default no group
   * @schema ThanosRulerSpecVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema ThanosRulerSpecVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema ThanosRulerSpecVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema ThanosRulerSpecVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema ThanosRulerSpecVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema ThanosRulerSpecVolumesQuobyte#volume
   */
  readonly volume: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesQuobyte(
  obj: ThanosRulerSpecVolumesQuobyte | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "group": obj.group,
    "readOnly": obj.readOnly,
    "registry": obj.registry,
    "tenant": obj.tenant,
    "user": obj.user,
    "volume": obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema ThanosRulerSpecVolumesRbd
 */
export interface ThanosRulerSpecVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ThanosRulerSpecVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema ThanosRulerSpecVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ThanosRulerSpecVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema ThanosRulerSpecVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema ThanosRulerSpecVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema ThanosRulerSpecVolumesRbd#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesRbdSecretRef;

  /**
   * user is the rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema ThanosRulerSpecVolumesRbd#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesRbd(
  obj: ThanosRulerSpecVolumesRbd | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "image": obj.image,
    "keyring": obj.keyring,
    "monitors": obj.monitors?.map((y) => y),
    "pool": obj.pool,
    "readOnly": obj.readOnly,
    "secretRef": toJson_ThanosRulerSpecVolumesRbdSecretRef(obj.secretRef),
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema ThanosRulerSpecVolumesScaleIo
 */
export interface ThanosRulerSpecVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema ThanosRulerSpecVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema ThanosRulerSpecVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#secretRef
   */
  readonly secretRef: ThanosRulerSpecVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema ThanosRulerSpecVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema ThanosRulerSpecVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema ThanosRulerSpecVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesScaleIo(
  obj: ThanosRulerSpecVolumesScaleIo | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "gateway": obj.gateway,
    "protectionDomain": obj.protectionDomain,
    "readOnly": obj.readOnly,
    "secretRef": toJson_ThanosRulerSpecVolumesScaleIoSecretRef(obj.secretRef),
    "sslEnabled": obj.sslEnabled,
    "storageMode": obj.storageMode,
    "storagePool": obj.storagePool,
    "system": obj.system,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema ThanosRulerSpecVolumesSecret
 */
export interface ThanosRulerSpecVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema ThanosRulerSpecVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema ThanosRulerSpecVolumesSecret#items
   */
  readonly items?: ThanosRulerSpecVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema ThanosRulerSpecVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ThanosRulerSpecVolumesSecret#secretName
   */
  readonly secretName?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesSecret(
  obj: ThanosRulerSpecVolumesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "defaultMode": obj.defaultMode,
    "items": obj.items?.map((y) => toJson_ThanosRulerSpecVolumesSecretItems(y)),
    "optional": obj.optional,
    "secretName": obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema ThanosRulerSpecVolumesStorageos
 */
export interface ThanosRulerSpecVolumesStorageos {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ThanosRulerSpecVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema ThanosRulerSpecVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema ThanosRulerSpecVolumesStorageos#secretRef
   */
  readonly secretRef?: ThanosRulerSpecVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema ThanosRulerSpecVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema ThanosRulerSpecVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesStorageos(
  obj: ThanosRulerSpecVolumesStorageos | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "readOnly": obj.readOnly,
    "secretRef": toJson_ThanosRulerSpecVolumesStorageosSecretRef(obj.secretRef),
    "volumeName": obj.volumeName,
    "volumeNamespace": obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema ThanosRulerSpecVolumesVsphereVolume
 */
export interface ThanosRulerSpecVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ThanosRulerSpecVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema ThanosRulerSpecVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema ThanosRulerSpecVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema ThanosRulerSpecVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesVsphereVolume(
  obj: ThanosRulerSpecVolumesVsphereVolume | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fsType": obj.fsType,
    "storagePolicyID": obj.storagePolicyId,
    "storagePolicyName": obj.storagePolicyName,
    "volumePath": obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference:
    ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "preference":
      toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
        obj.preference,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms:
    ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "nodeSelectorTerms": obj.nodeSelectorTerms?.map((y) =>
      toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm:
    ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "podAffinityTerm":
      toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
        obj.podAffinityTerm,
      ),
    "weight": obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?:
    ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?:
    ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(
  obj:
    | ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema ThanosRulerSpecContainersEnvValueFrom
 */
export interface ThanosRulerSpecContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema ThanosRulerSpecContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?:
    ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema ThanosRulerSpecContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: ThanosRulerSpecContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema ThanosRulerSpecContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?:
    ThanosRulerSpecContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema ThanosRulerSpecContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ThanosRulerSpecContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvValueFrom(
  obj: ThanosRulerSpecContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapKeyRef":
      toJson_ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef(
        obj.configMapKeyRef,
      ),
    "fieldRef": toJson_ThanosRulerSpecContainersEnvValueFromFieldRef(
      obj.fieldRef,
    ),
    "resourceFieldRef":
      toJson_ThanosRulerSpecContainersEnvValueFromResourceFieldRef(
        obj.resourceFieldRef,
      ),
    "secretKeyRef": toJson_ThanosRulerSpecContainersEnvValueFromSecretKeyRef(
      obj.secretKeyRef,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ThanosRulerSpecContainersEnvFromConfigMapRef
 */
export interface ThanosRulerSpecContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ThanosRulerSpecContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvFromConfigMapRef(
  obj: ThanosRulerSpecContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ThanosRulerSpecContainersEnvFromSecretRef
 */
export interface ThanosRulerSpecContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ThanosRulerSpecContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvFromSecretRef(
  obj: ThanosRulerSpecContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStart
 */
export interface ThanosRulerSpecContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStart#exec
   */
  readonly exec?: ThanosRulerSpecContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: ThanosRulerSpecContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePostStart(
  obj: ThanosRulerSpecContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_ThanosRulerSpecContainersLifecyclePostStartExec(obj.exec),
    "httpGet": toJson_ThanosRulerSpecContainersLifecyclePostStartHttpGet(
      obj.httpGet,
    ),
    "tcpSocket": toJson_ThanosRulerSpecContainersLifecyclePostStartTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStop
 */
export interface ThanosRulerSpecContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStop#exec
   */
  readonly exec?: ThanosRulerSpecContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: ThanosRulerSpecContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePreStop(
  obj: ThanosRulerSpecContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_ThanosRulerSpecContainersLifecyclePreStopExec(obj.exec),
    "httpGet": toJson_ThanosRulerSpecContainersLifecyclePreStopHttpGet(
      obj.httpGet,
    ),
    "tcpSocket": toJson_ThanosRulerSpecContainersLifecyclePreStopTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeExec
 */
export interface ThanosRulerSpecContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbeExec(
  obj: ThanosRulerSpecContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeGrpc
 */
export interface ThanosRulerSpecContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbeGrpc(
  obj: ThanosRulerSpecContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeHttpGet
 */
export interface ThanosRulerSpecContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbeHttpGet(
  obj: ThanosRulerSpecContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeTcpSocket
 */
export interface ThanosRulerSpecContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbeTcpSocket(
  obj: ThanosRulerSpecContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeExec
 */
export interface ThanosRulerSpecContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbeExec(
  obj: ThanosRulerSpecContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeGrpc
 */
export interface ThanosRulerSpecContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbeGrpc(
  obj: ThanosRulerSpecContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeHttpGet
 */
export interface ThanosRulerSpecContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbeHttpGet(
  obj: ThanosRulerSpecContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeTcpSocket
 */
export interface ThanosRulerSpecContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbeTcpSocket(
  obj: ThanosRulerSpecContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ThanosRulerSpecContainersResourcesClaims
 */
export interface ThanosRulerSpecContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema ThanosRulerSpecContainersResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersResourcesClaims(
  obj: ThanosRulerSpecContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecContainersResourcesLimits
 */
export class ThanosRulerSpecContainersResourcesLimits {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersResourcesLimits {
    return new ThanosRulerSpecContainersResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersResourcesLimits {
    return new ThanosRulerSpecContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecContainersResourcesRequests
 */
export class ThanosRulerSpecContainersResourcesRequests {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersResourcesRequests {
    return new ThanosRulerSpecContainersResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersResourcesRequests {
    return new ThanosRulerSpecContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema ThanosRulerSpecContainersSecurityContextCapabilities
 */
export interface ThanosRulerSpecContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema ThanosRulerSpecContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema ThanosRulerSpecContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersSecurityContextCapabilities(
  obj: ThanosRulerSpecContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "add": obj.add?.map((y) => y),
    "drop": obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecContainersSecurityContextSeLinuxOptions
 */
export interface ThanosRulerSpecContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersSecurityContextSeLinuxOptions(
  obj: ThanosRulerSpecContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecContainersSecurityContextSeccompProfile
 */
export interface ThanosRulerSpecContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema ThanosRulerSpecContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersSecurityContextSeccompProfile(
  obj: ThanosRulerSpecContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ThanosRulerSpecContainersSecurityContextWindowsOptions
 */
export interface ThanosRulerSpecContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ThanosRulerSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ThanosRulerSpecContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ThanosRulerSpecContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema ThanosRulerSpecContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersSecurityContextWindowsOptions(
  obj: ThanosRulerSpecContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecContainersStartupProbeExec
 */
export interface ThanosRulerSpecContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbeExec(
  obj: ThanosRulerSpecContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecContainersStartupProbeGrpc
 */
export interface ThanosRulerSpecContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbeGrpc(
  obj: ThanosRulerSpecContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecContainersStartupProbeHttpGet
 */
export interface ThanosRulerSpecContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbeHttpGet(
  obj: ThanosRulerSpecContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecContainersStartupProbeTcpSocket
 */
export interface ThanosRulerSpecContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersStartupProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbeTcpSocket(
  obj: ThanosRulerSpecContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCaConfigMap
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCaConfigMap {
  /**
   * The key to select.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCaConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCaConfigMap(
  obj: ThanosRulerSpecGrpcServerTlsConfigCaConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCaSecret
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCaSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCaSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCaSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCaSecret(
  obj: ThanosRulerSpecGrpcServerTlsConfigCaSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap containing data to use for the targets.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCertConfigMap
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCertConfigMap {
  /**
   * The key to select.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertConfigMap#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCertConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCertConfigMap(
  obj: ThanosRulerSpecGrpcServerTlsConfigCertConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Secret containing data to use for the targets.
 *
 * @schema ThanosRulerSpecGrpcServerTlsConfigCertSecret
 */
export interface ThanosRulerSpecGrpcServerTlsConfigCertSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertSecret#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecGrpcServerTlsConfigCertSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecGrpcServerTlsConfigCertSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecGrpcServerTlsConfigCertSecret(
  obj: ThanosRulerSpecGrpcServerTlsConfigCertSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFrom
 */
export interface ThanosRulerSpecInitContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?:
    ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: ThanosRulerSpecInitContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?:
    ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvValueFrom(
  obj: ThanosRulerSpecInitContainersEnvValueFrom | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMapKeyRef":
      toJson_ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef(
        obj.configMapKeyRef,
      ),
    "fieldRef": toJson_ThanosRulerSpecInitContainersEnvValueFromFieldRef(
      obj.fieldRef,
    ),
    "resourceFieldRef":
      toJson_ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef(
        obj.resourceFieldRef,
      ),
    "secretKeyRef":
      toJson_ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef(
        obj.secretKeyRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The ConfigMap to select from
 *
 * @schema ThanosRulerSpecInitContainersEnvFromConfigMapRef
 */
export interface ThanosRulerSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema ThanosRulerSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvFromConfigMapRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvFromConfigMapRef(
  obj: ThanosRulerSpecInitContainersEnvFromConfigMapRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Secret to select from
 *
 * @schema ThanosRulerSpecInitContainersEnvFromSecretRef
 */
export interface ThanosRulerSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema ThanosRulerSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvFromSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvFromSecretRef(
  obj: ThanosRulerSpecInitContainersEnvFromSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStart
 */
export interface ThanosRulerSpecInitContainersLifecyclePostStart {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: ThanosRulerSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: ThanosRulerSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePostStart' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePostStart(
  obj: ThanosRulerSpecInitContainersLifecyclePostStart | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_ThanosRulerSpecInitContainersLifecyclePostStartExec(
      obj.exec,
    ),
    "httpGet": toJson_ThanosRulerSpecInitContainersLifecyclePostStartHttpGet(
      obj.httpGet,
    ),
    "tcpSocket":
      toJson_ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket(
        obj.tcpSocket,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStop
 */
export interface ThanosRulerSpecInitContainersLifecyclePreStop {
  /**
   * Exec specifies the action to take.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: ThanosRulerSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: ThanosRulerSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePreStop' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePreStop(
  obj: ThanosRulerSpecInitContainersLifecyclePreStop | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "exec": toJson_ThanosRulerSpecInitContainersLifecyclePreStopExec(obj.exec),
    "httpGet": toJson_ThanosRulerSpecInitContainersLifecyclePreStopHttpGet(
      obj.httpGet,
    ),
    "tcpSocket": toJson_ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket(
      obj.tcpSocket,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeExec
 */
export interface ThanosRulerSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbeExec(
  obj: ThanosRulerSpecInitContainersLivenessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeGrpc
 */
export interface ThanosRulerSpecInitContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbeGrpc(
  obj: ThanosRulerSpecInitContainersLivenessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet
 */
export interface ThanosRulerSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbeHttpGet(
  obj: ThanosRulerSpecInitContainersLivenessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeTcpSocket
 */
export interface ThanosRulerSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbeTcpSocket(
  obj: ThanosRulerSpecInitContainersLivenessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeExec
 */
export interface ThanosRulerSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbeExec(
  obj: ThanosRulerSpecInitContainersReadinessProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeGrpc
 */
export interface ThanosRulerSpecInitContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbeGrpc(
  obj: ThanosRulerSpecInitContainersReadinessProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet
 */
export interface ThanosRulerSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbeHttpGet(
  obj: ThanosRulerSpecInitContainersReadinessProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeTcpSocket
 */
export interface ThanosRulerSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbeTcpSocket(
  obj: ThanosRulerSpecInitContainersReadinessProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ThanosRulerSpecInitContainersResourcesClaims
 */
export interface ThanosRulerSpecInitContainersResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema ThanosRulerSpecInitContainersResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersResourcesClaims(
  obj: ThanosRulerSpecInitContainersResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecInitContainersResourcesLimits
 */
export class ThanosRulerSpecInitContainersResourcesLimits {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersResourcesLimits {
    return new ThanosRulerSpecInitContainersResourcesLimits(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersResourcesLimits {
    return new ThanosRulerSpecInitContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecInitContainersResourcesRequests
 */
export class ThanosRulerSpecInitContainersResourcesRequests {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersResourcesRequests {
    return new ThanosRulerSpecInitContainersResourcesRequests(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersResourcesRequests {
    return new ThanosRulerSpecInitContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema ThanosRulerSpecInitContainersSecurityContextCapabilities
 */
export interface ThanosRulerSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersSecurityContextCapabilities(
  obj: ThanosRulerSpecInitContainersSecurityContextCapabilities | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "add": obj.add?.map((y) => y),
    "drop": obj.drop?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions(
  obj: ThanosRulerSpecInitContainersSecurityContextSeLinuxOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "level": obj.level,
    "role": obj.role,
    "type": obj.type,
    "user": obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema ThanosRulerSpecInitContainersSecurityContextSeccompProfile
 */
export interface ThanosRulerSpecInitContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must be set if type is "Localhost". Must NOT be set for any other type.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersSecurityContextSeccompProfile(
  obj: ThanosRulerSpecInitContainersSecurityContextSeccompProfile | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "localhostProfile": obj.localhostProfile,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema ThanosRulerSpecInitContainersSecurityContextWindowsOptions
 */
export interface ThanosRulerSpecInitContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema ThanosRulerSpecInitContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema ThanosRulerSpecInitContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersSecurityContextWindowsOptions(
  obj: ThanosRulerSpecInitContainersSecurityContextWindowsOptions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "gmsaCredentialSpec": obj.gmsaCredentialSpec,
    "gmsaCredentialSpecName": obj.gmsaCredentialSpecName,
    "hostProcess": obj.hostProcess,
    "runAsUserName": obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeExec
 */
export interface ThanosRulerSpecInitContainersStartupProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbeExec(
  obj: ThanosRulerSpecInitContainersStartupProbeExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeGrpc
 */
export interface ThanosRulerSpecInitContainersStartupProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeGrpc#service
   */
  readonly service?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbeGrpc(
  obj: ThanosRulerSpecInitContainersStartupProbeGrpc | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "port": obj.port,
    "service": obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet
 */
export interface ThanosRulerSpecInitContainersStartupProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet#port
   */
  readonly port: ThanosRulerSpecInitContainersStartupProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbeHttpGet(
  obj: ThanosRulerSpecInitContainersStartupProbeHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeTcpSocket
 */
export interface ThanosRulerSpecInitContainersStartupProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeTcpSocket#port
   */
  readonly port: ThanosRulerSpecInitContainersStartupProbeTcpSocketPort;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbeTcpSocket(
  obj: ThanosRulerSpecInitContainersStartupProbeTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ThanosRulerSpecStorageEmptyDirSizeLimit
 */
export class ThanosRulerSpecStorageEmptyDirSizeLimit {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecStorageEmptyDirSizeLimit {
    return new ThanosRulerSpecStorageEmptyDirSizeLimit(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecStorageEmptyDirSizeLimit {
    return new ThanosRulerSpecStorageEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplate
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplate(
  obj: ThanosRulerSpecStorageEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec(
      obj.spec,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateMetadata
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateMetadata#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateMetadata(
  obj: ThanosRulerSpecStorageVolumeClaimTemplateMetadata | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "annotations": ((obj.annotations) === undefined)
      ? undefined
      : (Object.entries(obj.annotations).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "labels": ((obj.labels) === undefined)
      ? undefined
      : (Object.entries(obj.labels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#resources
   */
  readonly resources?: ThanosRulerSpecStorageVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#selector
   */
  readonly selector?: ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpec(
  obj: ThanosRulerSpecStorageVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource":
      toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource(
        obj.dataSource,
      ),
    "dataSourceRef":
      toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources": toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecResources(
      obj.resources,
    ),
    "selector": toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector(
      obj.selector,
    ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated: this field is never set.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateStatus {
  /**
   * accessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#accessModes
   */
  readonly accessModes?: string[];

  /**
   * allocatedResourceStatuses stores status of resource being resized for the given PVC. Key names follow standard Kubernetes label syntax. Valid values are either: * Un-prefixed keys: - storage - the capacity of the volume. * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource" Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used.
   * ClaimResourceStatus can be in any of following states: - ControllerResizeInProgress: State set when resize controller starts resizing the volume in control-plane. - ControllerResizeFailed: State set when resize has failed in resize controller with a terminal error. - NodeResizePending: State set when resize controller has finished resizing the volume but further resizing of volume is needed on the node. - NodeResizeInProgress: State set when kubelet starts resizing the volume. - NodeResizeFailed: State set when resizing has failed in kubelet with a terminal error. Transient errors don't set NodeResizeFailed. For example: if expanding a PVC for more capacity - this field can be one of the following states: - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress" - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress" - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed" When this field is not set, it means that no resize operation is in progress for the given PVC.
   * A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#allocatedResourceStatuses
   */
  readonly allocatedResourceStatuses?: { [key: string]: string };

  /**
   * allocatedResources tracks the resources allocated to a PVC including its capacity. Key names follow standard Kubernetes label syntax. Valid values are either: * Un-prefixed keys: - storage - the capacity of the volume. * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource" Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered reserved and hence may not be used.
   * Capacity reported here may be larger than the actual capacity when a volume expansion operation is requested. For storage quota, the larger value from allocatedResources and PVC.spec.resources is used. If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation. If a volume expansion capacity request is lowered, allocatedResources is only lowered if there are no expansion operations in progress and if the actual volume capacity is equal or lower than the requested capacity.
   * A controller that receives PVC update with previously unknown resourceName should ignore the update for the purpose it was designed. For example - a controller that only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid resources associated with PVC.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#allocatedResources
   */
  readonly allocatedResources?: {
    [key: string]:
      ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources;
  };

  /**
   * capacity represents the actual resources of the underlying volume.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#capacity
   */
  readonly capacity?: {
    [key: string]: ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity;
  };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#conditions
   */
  readonly conditions?:
    ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions[];

  /**
   * phase represents the current phase of PersistentVolumeClaim.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatus#phase
   */
  readonly phase?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateStatus' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateStatus(
  obj: ThanosRulerSpecStorageVolumeClaimTemplateStatus | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "allocatedResourceStatuses": ((obj.allocatedResourceStatuses) === undefined)
      ? undefined
      : (Object.entries(obj.allocatedResourceStatuses).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "allocatedResources": ((obj.allocatedResources) === undefined)
      ? undefined
      : (Object.entries(obj.allocatedResources).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "capacity": ((obj.capacity) === undefined)
      ? undefined
      : (Object.entries(obj.capacity).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "conditions": obj.conditions?.map((y) =>
      toJson_ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions(y)
    ),
    "phase": obj.phase,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecTopologySpreadConstraintsLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema ThanosRulerSpecVolumesCephfsSecretRef
 */
export interface ThanosRulerSpecVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesCephfsSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCephfsSecretRef(
  obj: ThanosRulerSpecVolumesCephfsSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema ThanosRulerSpecVolumesCinderSecretRef
 */
export interface ThanosRulerSpecVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesCinderSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCinderSecretRef(
  obj: ThanosRulerSpecVolumesCinderSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ThanosRulerSpecVolumesConfigMapItems
 */
export interface ThanosRulerSpecVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ThanosRulerSpecVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema ThanosRulerSpecVolumesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesConfigMapItems(
  obj: ThanosRulerSpecVolumesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema ThanosRulerSpecVolumesCsiNodePublishSecretRef
 */
export interface ThanosRulerSpecVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesCsiNodePublishSecretRef(
  obj: ThanosRulerSpecVolumesCsiNodePublishSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ThanosRulerSpecVolumesDownwardApiItems
 */
export interface ThanosRulerSpecVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ThanosRulerSpecVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?:
    ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesDownwardApiItems(
  obj: ThanosRulerSpecVolumesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fieldRef": toJson_ThanosRulerSpecVolumesDownwardApiItemsFieldRef(
      obj.fieldRef,
    ),
    "mode": obj.mode,
    "path": obj.path,
    "resourceFieldRef":
      toJson_ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef(
        obj.resourceFieldRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ThanosRulerSpecVolumesEmptyDirSizeLimit
 */
export class ThanosRulerSpecVolumesEmptyDirSizeLimit {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecVolumesEmptyDirSizeLimit {
    return new ThanosRulerSpecVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecVolumesEmptyDirSizeLimit {
    return new ThanosRulerSpecVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate(
  obj: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplate | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec(
      obj.spec,
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema ThanosRulerSpecVolumesFlexVolumeSecretRef
 */
export interface ThanosRulerSpecVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesFlexVolumeSecretRef(
  obj: ThanosRulerSpecVolumesFlexVolumeSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema ThanosRulerSpecVolumesIscsiSecretRef
 */
export interface ThanosRulerSpecVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesIscsiSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesIscsiSecretRef(
  obj: ThanosRulerSpecVolumesIscsiSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema ThanosRulerSpecVolumesProjectedSources
 */
export interface ThanosRulerSpecVolumesProjectedSources {
  /**
   * configMap information about the configMap data to project
   *
   * @schema ThanosRulerSpecVolumesProjectedSources#configMap
   */
  readonly configMap?: ThanosRulerSpecVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema ThanosRulerSpecVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: ThanosRulerSpecVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema ThanosRulerSpecVolumesProjectedSources#secret
   */
  readonly secret?: ThanosRulerSpecVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema ThanosRulerSpecVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?:
    ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSources(
  obj: ThanosRulerSpecVolumesProjectedSources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "configMap": toJson_ThanosRulerSpecVolumesProjectedSourcesConfigMap(
      obj.configMap,
    ),
    "downwardAPI": toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApi(
      obj.downwardApi,
    ),
    "secret": toJson_ThanosRulerSpecVolumesProjectedSourcesSecret(obj.secret),
    "serviceAccountToken":
      toJson_ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken(
        obj.serviceAccountToken,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema ThanosRulerSpecVolumesRbdSecretRef
 */
export interface ThanosRulerSpecVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesRbdSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesRbdSecretRef(
  obj: ThanosRulerSpecVolumesRbdSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema ThanosRulerSpecVolumesScaleIoSecretRef
 */
export interface ThanosRulerSpecVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesScaleIoSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesScaleIoSecretRef(
  obj: ThanosRulerSpecVolumesScaleIoSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ThanosRulerSpecVolumesSecretItems
 */
export interface ThanosRulerSpecVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ThanosRulerSpecVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema ThanosRulerSpecVolumesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesSecretItems(
  obj: ThanosRulerSpecVolumesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema ThanosRulerSpecVolumesStorageosSecretRef
 */
export interface ThanosRulerSpecVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesStorageosSecretRef#name
   */
  readonly name?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesStorageosSecretRef(
  obj: ThanosRulerSpecVolumesStorageosSecretRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?:
    ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(
  obj:
    | ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?:
    ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(
  obj:
    | ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
        y,
      )
    ),
    "matchFields": obj.matchFields?.map((y) =>
      toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
        y,
      )
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?:
    ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?:
    ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(
  obj:
    | ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "labelSelector":
      toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
        obj.labelSelector,
      ),
    "namespaceSelector":
      toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
        obj.namespaceSelector,
      ),
    "namespaces": obj.namespaces?.map((y) => y),
    "topologyKey": obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(
  obj:
    | ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(
  obj:
    | ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef
 */
export interface ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef(
  obj: ThanosRulerSpecContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema ThanosRulerSpecContainersEnvValueFromFieldRef
 */
export interface ThanosRulerSpecContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ThanosRulerSpecContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ThanosRulerSpecContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvValueFromFieldRef(
  obj: ThanosRulerSpecContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema ThanosRulerSpecContainersEnvValueFromResourceFieldRef
 */
export interface ThanosRulerSpecContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ThanosRulerSpecContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ThanosRulerSpecContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?:
    ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ThanosRulerSpecContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvValueFromResourceFieldRef(
  obj: ThanosRulerSpecContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema ThanosRulerSpecContainersEnvValueFromSecretKeyRef
 */
export interface ThanosRulerSpecContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersEnvValueFromSecretKeyRef(
  obj: ThanosRulerSpecContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartExec
 */
export interface ThanosRulerSpecContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePostStartExec(
  obj: ThanosRulerSpecContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet
 */
export interface ThanosRulerSpecContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet#port
   */
  readonly port: ThanosRulerSpecContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePostStartHttpGet(
  obj: ThanosRulerSpecContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartTcpSocket
 */
export interface ThanosRulerSpecContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePostStartTcpSocket(
  obj: ThanosRulerSpecContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopExec
 */
export interface ThanosRulerSpecContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePreStopExec(
  obj: ThanosRulerSpecContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet
 */
export interface ThanosRulerSpecContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet#port
   */
  readonly port: ThanosRulerSpecContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePreStopHttpGet(
  obj: ThanosRulerSpecContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopTcpSocket
 */
export interface ThanosRulerSpecContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePreStopTcpSocket(
  obj: ThanosRulerSpecContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders(
  obj: ThanosRulerSpecContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeHttpGetPort
 */
export class ThanosRulerSpecContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersLivenessProbeHttpGetPort {
    return new ThanosRulerSpecContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersLivenessProbeHttpGetPort {
    return new ThanosRulerSpecContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLivenessProbeTcpSocketPort
 */
export class ThanosRulerSpecContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersLivenessProbeTcpSocketPort {
    return new ThanosRulerSpecContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersLivenessProbeTcpSocketPort {
    return new ThanosRulerSpecContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders(
  obj: ThanosRulerSpecContainersReadinessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeHttpGetPort
 */
export class ThanosRulerSpecContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersReadinessProbeHttpGetPort {
    return new ThanosRulerSpecContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersReadinessProbeHttpGetPort {
    return new ThanosRulerSpecContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersReadinessProbeTcpSocketPort
 */
export class ThanosRulerSpecContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersReadinessProbeTcpSocketPort {
    return new ThanosRulerSpecContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersReadinessProbeTcpSocketPort {
    return new ThanosRulerSpecContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders(
  obj: ThanosRulerSpecContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersStartupProbeHttpGetPort
 */
export class ThanosRulerSpecContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersStartupProbeHttpGetPort {
    return new ThanosRulerSpecContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersStartupProbeHttpGetPort {
    return new ThanosRulerSpecContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersStartupProbeTcpSocketPort
 */
export class ThanosRulerSpecContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersStartupProbeTcpSocketPort {
    return new ThanosRulerSpecContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersStartupProbeTcpSocketPort {
    return new ThanosRulerSpecContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef(
  obj: ThanosRulerSpecInitContainersEnvValueFromConfigMapKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFromFieldRef
 */
export interface ThanosRulerSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvValueFromFieldRef(
  obj: ThanosRulerSpecInitContainersEnvValueFromFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?:
    ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef(
  obj: ThanosRulerSpecInitContainersEnvValueFromResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef(
  obj: ThanosRulerSpecInitContainersEnvValueFromSecretKeyRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartExec
 */
export interface ThanosRulerSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePostStartExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePostStartExec(
  obj: ThanosRulerSpecInitContainersLifecyclePostStartExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet
 */
export interface ThanosRulerSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePostStartHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePostStartHttpGet(
  obj: ThanosRulerSpecInitContainersLifecyclePostStartHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
        y,
      )
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket(
  obj: ThanosRulerSpecInitContainersLifecyclePostStartTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopExec
 */
export interface ThanosRulerSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePreStopExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePreStopExec(
  obj: ThanosRulerSpecInitContainersLifecyclePreStopExec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "command": obj.command?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet
 */
export interface ThanosRulerSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?:
    ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePreStopHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePreStopHttpGet(
  obj: ThanosRulerSpecInitContainersLifecyclePreStopHttpGet | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "httpHeaders": obj.httpHeaders?.map((y) =>
      toJson_ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(y)
    ),
    "path": obj.path,
    "port": obj.port?.value,
    "scheme": obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket(
  obj: ThanosRulerSpecInitContainersLifecyclePreStopTcpSocket | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "host": obj.host,
    "port": obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders(
  obj: ThanosRulerSpecInitContainersLivenessProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeHttpGetPort
 */
export class ThanosRulerSpecInitContainersLivenessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersLivenessProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersLivenessProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort
 */
export class ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders(
  obj:
    | ThanosRulerSpecInitContainersReadinessProbeHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeHttpGetPort
 */
export class ThanosRulerSpecInitContainersReadinessProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersReadinessProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersReadinessProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort
 */
export class ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders
 */
export interface ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders(
  obj: ThanosRulerSpecInitContainersStartupProbeHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeHttpGetPort
 */
export class ThanosRulerSpecInitContainersStartupProbeHttpGetPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersStartupProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersStartupProbeHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersStartupProbeHttpGetPort {
    return new ThanosRulerSpecInitContainersStartupProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersStartupProbeTcpSocketPort
 */
export class ThanosRulerSpecInitContainersStartupProbeTcpSocketPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersStartupProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersStartupProbeTcpSocketPort {
    return new ThanosRulerSpecInitContainersStartupProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?:
    ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?:
    ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?:
    ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec(
  obj: ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource":
      toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(
        obj.dataSource,
      ),
    "dataSourceRef":
      toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources":
      toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources(
        obj.resources,
      ),
    "selector":
      toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector(
        obj.selector,
      ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource(
  obj: ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSource | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef(
  obj: ThanosRulerSpecStorageVolumeClaimTemplateSpecDataSourceRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResources
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]: ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecResources(
  obj: ThanosRulerSpecStorageVolumeClaimTemplateSpecResources | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesClaims(y)
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector(
  obj: ThanosRulerSpecStorageVolumeClaimTemplateSpecSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources
 */
export class ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources {
    return new ThanosRulerSpecStorageVolumeClaimTemplateStatusAllocatedResources(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity
 */
export class ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity {
    return new ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity {
    return new ThanosRulerSpecStorageVolumeClaimTemplateStatusCapacity(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * PersistentVolumeClaimCondition contains details about state of pvc
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions {
  /**
   * lastProbeTime is the time we probed the condition.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#lastProbeTime
   */
  readonly lastProbeTime?: Date;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#lastTransitionTime
   */
  readonly lastTransitionTime?: Date;

  /**
   * message is the human-readable message indicating details about last transition.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#message
   */
  readonly message?: string;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports "ResizeStarted" that means the underlying persistent volume is being resized.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#reason
   */
  readonly reason?: string;

  /**
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#status
   */
  readonly status: string;

  /**
   * PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions#type
   */
  readonly type: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions(
  obj: ThanosRulerSpecStorageVolumeClaimTemplateStatusConditions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "lastProbeTime": obj.lastProbeTime?.toISOString(),
    "lastTransitionTime": obj.lastTransitionTime?.toISOString(),
    "message": obj.message,
    "reason": obj.reason,
    "status": obj.status,
    "type": obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema ThanosRulerSpecVolumesDownwardApiItemsFieldRef
 */
export interface ThanosRulerSpecVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesDownwardApiItemsFieldRef(
  obj: ThanosRulerSpecVolumesDownwardApiItemsFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef
 */
export interface ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?:
    ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef(
  obj: ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?:
    ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?:
    ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?:
    ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?:
    ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec(
  obj: ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "accessModes": obj.accessModes?.map((y) => y),
    "dataSource":
      toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
        obj.dataSource,
      ),
    "dataSourceRef":
      toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
        obj.dataSourceRef,
      ),
    "resources":
      toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
        obj.resources,
      ),
    "selector":
      toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
        obj.selector,
      ),
    "storageClassName": obj.storageClassName,
    "volumeMode": obj.volumeMode,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMap
 */
export interface ThanosRulerSpecVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: ThanosRulerSpecVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesConfigMap(
  obj: ThanosRulerSpecVolumesProjectedSourcesConfigMap | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_ThanosRulerSpecVolumesProjectedSourcesConfigMapItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApi
 */
export interface ThanosRulerSpecVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems[];
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApi(
  obj: ThanosRulerSpecVolumesProjectedSourcesDownwardApi | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesSecret
 */
export interface ThanosRulerSpecVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecret#items
   */
  readonly items?: ThanosRulerSpecVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesSecret(
  obj: ThanosRulerSpecVolumesProjectedSourcesSecret | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "items": obj.items?.map((y) =>
      toJson_ThanosRulerSpecVolumesProjectedSourcesSecretItems(y)
    ),
    "name": obj.name,
    "optional": obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken
 */
export interface ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the token into.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken(
  obj: ThanosRulerSpecVolumesProjectedSourcesServiceAccountToken | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "audience": obj.audience,
    "expirationSeconds": obj.expirationSeconds,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(
  obj:
    | ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(
  obj:
    | ThanosRulerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(
  obj:
    | ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(
  obj:
    | ThanosRulerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(
  obj:
    | ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(
  obj:
    | ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor
 */
export class ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor {
    return new ThanosRulerSpecContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders(
  obj:
    | ThanosRulerSpecContainersLifecyclePostStartHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartHttpGetPort
 */
export class ThanosRulerSpecContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersLifecyclePostStartHttpGetPort {
    return new ThanosRulerSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersLifecyclePostStartHttpGetPort {
    return new ThanosRulerSpecContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort
 */
export class ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort {
    return new ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort {
    return new ThanosRulerSpecContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders(
  obj: ThanosRulerSpecContainersLifecyclePreStopHttpGetHttpHeaders | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopHttpGetPort
 */
export class ThanosRulerSpecContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersLifecyclePreStopHttpGetPort {
    return new ThanosRulerSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersLifecyclePreStopHttpGetPort {
    return new ThanosRulerSpecContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort
 */
export class ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort {
    return new ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort {
    return new ThanosRulerSpecContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor
 */
export class ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor {
    return new ThanosRulerSpecInitContainersEnvValueFromResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders(
  obj:
    | ThanosRulerSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort {
    return new ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort {
    return new ThanosRulerSpecInitContainersLifecyclePostStartHttpGetPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new ThanosRulerSpecInitContainersLifecyclePostStartTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name. This will be canonicalized upon output, so case-variant names will be understood as the same header.
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders(
  obj:
    | ThanosRulerSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort {
    return new ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort {
    return new ThanosRulerSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new ThanosRulerSpecInitContainersLifecyclePreStopTcpSocketPort(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource(
  obj:
    | ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSource
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj:
    | ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecDataSourceRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]:
      ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources(
  obj:
    | ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResources
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims(
        y,
      )
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector(
  obj:
    | ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesClaims
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesClaims(
  obj: ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesClaims | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits
 */
export class ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests
 */
export class ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecStorageVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecStorageVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new ThanosRulerSpecVolumesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource(
  obj:
    | ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSource
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(
  obj:
    | ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiGroup": obj.apiGroup,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?:
    ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: {
    [key: string]:
      ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits;
  };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: {
    [key: string]:
      ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests;
  };
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources(
  obj:
    | ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResources
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "claims": obj.claims?.map((y) =>
      toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims(
        y,
      )
    ),
    "limits": ((obj.limits) === undefined)
      ? undefined
      : (Object.entries(obj.limits).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
    "requests": ((obj.requests) === undefined)
      ? undefined
      : (Object.entries(obj.requests).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?:
    ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector(
  obj:
    | ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelector
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
        y,
      )
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMapItems
 */
export interface ThanosRulerSpecVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesConfigMapItems(
  obj: ThanosRulerSpecVolumesProjectedSourcesConfigMapItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems
 */
export interface ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?:
    ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?:
    ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems(
  obj: ThanosRulerSpecVolumesProjectedSourcesDownwardApiItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "fieldRef":
      toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
        obj.fieldRef,
      ),
    "mode": obj.mode,
    "path": obj.path,
    "resourceFieldRef":
      toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
        obj.resourceFieldRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesSecretItems
 */
export interface ThanosRulerSpecVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesSecretItems(
  obj: ThanosRulerSpecVolumesProjectedSourcesSecretItems | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "mode": obj.mode,
    "path": obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims(
  obj:
    | ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesClaims
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecStorageEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims(
  obj:
    | ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "name": obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(
  obj:
    | ThanosRulerSpecVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef(
  obj:
    | ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsFieldRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?:
    ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;
}

/**
 * Converts an object of type 'ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(
  obj:
    | ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
    | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "containerName": obj.containerName,
    "divisor": obj.divisor?.value,
    "resource": obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(
    value: number,
  ): ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  public static fromString(
    value: string,
  ): ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ThanosRulerSpecVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
      value,
    );
  }
  private constructor(public readonly value: number | string) {
  }
}
