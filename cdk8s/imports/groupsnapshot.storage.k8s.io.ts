// deno-lint-ignore-file
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "cdk8s";
import { Construct } from "constructs";

/**
 * VolumeGroupSnapshot is a user's request for creating either a point-in-time
group snapshot or binding to a pre-existing group snapshot.
 *
 * @schema VolumeGroupSnapshot
 */
export class VolumeGroupSnapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VolumeGroupSnapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "groupsnapshot.storage.k8s.io/v1beta1",
    kind: "VolumeGroupSnapshot",
  };

  /**
   * Renders a Kubernetes manifest for "VolumeGroupSnapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VolumeGroupSnapshotProps): any {
    return {
      ...VolumeGroupSnapshot.GVK,
      ...toJson_VolumeGroupSnapshotProps(props),
    };
  }

  /**
   * Defines a "VolumeGroupSnapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: VolumeGroupSnapshotProps,
  ) {
    super(scope, id, {
      ...VolumeGroupSnapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VolumeGroupSnapshot.GVK,
      ...toJson_VolumeGroupSnapshotProps(resolved),
    };
  }
}

/**
 * VolumeGroupSnapshot is a user's request for creating either a point-in-time
 * group snapshot or binding to a pre-existing group snapshot.
 *
 * @schema VolumeGroupSnapshot
 */
export interface VolumeGroupSnapshotProps {
  /**
   * @schema VolumeGroupSnapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines the desired characteristics of a group snapshot requested by a user.
   * Required.
   *
   * @schema VolumeGroupSnapshot#spec
   */
  readonly spec: VolumeGroupSnapshotSpec;
}

/**
 * Converts an object of type 'VolumeGroupSnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeGroupSnapshotProps(
  obj: VolumeGroupSnapshotProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_VolumeGroupSnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines the desired characteristics of a group snapshot requested by a user.
 * Required.
 *
 * @schema VolumeGroupSnapshotSpec
 */
export interface VolumeGroupSnapshotSpec {
  /**
   * Source specifies where a group snapshot will be created from.
   * This field is immutable after creation.
   * Required.
   *
   * @schema VolumeGroupSnapshotSpec#source
   */
  readonly source: VolumeGroupSnapshotSpecSource;

  /**
   * VolumeGroupSnapshotClassName is the name of the VolumeGroupSnapshotClass
   * requested by the VolumeGroupSnapshot.
   * VolumeGroupSnapshotClassName may be left nil to indicate that the default
   * class will be used.
   * Empty string is not allowed for this field.
   *
   * @schema VolumeGroupSnapshotSpec#volumeGroupSnapshotClassName
   */
  readonly volumeGroupSnapshotClassName?: string;
}

/**
 * Converts an object of type 'VolumeGroupSnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeGroupSnapshotSpec(
  obj: VolumeGroupSnapshotSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "source": toJson_VolumeGroupSnapshotSpecSource(obj.source),
    "volumeGroupSnapshotClassName": obj.volumeGroupSnapshotClassName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Source specifies where a group snapshot will be created from.
 * This field is immutable after creation.
 * Required.
 *
 * @schema VolumeGroupSnapshotSpecSource
 */
export interface VolumeGroupSnapshotSpecSource {
  /**
   * Selector is a label query over persistent volume claims that are to be
   * grouped together for snapshotting.
   * This labelSelector will be used to match the label added to a PVC.
   * If the label is added or removed to a volume after a group snapshot
   * is created, the existing group snapshots won't be modified.
   * Once a VolumeGroupSnapshotContent is created and the sidecar starts to process
   * it, the volume list will not change with retries.
   *
   * @schema VolumeGroupSnapshotSpecSource#selector
   */
  readonly selector?: VolumeGroupSnapshotSpecSourceSelector;

  /**
   * VolumeGroupSnapshotContentName specifies the name of a pre-existing VolumeGroupSnapshotContent
   * object representing an existing volume group snapshot.
   * This field should be set if the volume group snapshot already exists and
   * only needs a representation in Kubernetes.
   * This field is immutable.
   *
   * @schema VolumeGroupSnapshotSpecSource#volumeGroupSnapshotContentName
   */
  readonly volumeGroupSnapshotContentName?: string;
}

/**
 * Converts an object of type 'VolumeGroupSnapshotSpecSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeGroupSnapshotSpecSource(
  obj: VolumeGroupSnapshotSpecSource | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "selector": toJson_VolumeGroupSnapshotSpecSourceSelector(obj.selector),
    "volumeGroupSnapshotContentName": obj.volumeGroupSnapshotContentName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Selector is a label query over persistent volume claims that are to be
 * grouped together for snapshotting.
 * This labelSelector will be used to match the label added to a PVC.
 * If the label is added or removed to a volume after a group snapshot
 * is created, the existing group snapshots won't be modified.
 * Once a VolumeGroupSnapshotContent is created and the sidecar starts to process
 * it, the volume list will not change with retries.
 *
 * @schema VolumeGroupSnapshotSpecSourceSelector
 */
export interface VolumeGroupSnapshotSpecSourceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema VolumeGroupSnapshotSpecSourceSelector#matchExpressions
   */
  readonly matchExpressions?:
    VolumeGroupSnapshotSpecSourceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema VolumeGroupSnapshotSpecSourceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };
}

/**
 * Converts an object of type 'VolumeGroupSnapshotSpecSourceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeGroupSnapshotSpecSourceSelector(
  obj: VolumeGroupSnapshotSpecSourceSelector | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "matchExpressions": obj.matchExpressions?.map((y) =>
      toJson_VolumeGroupSnapshotSpecSourceSelectorMatchExpressions(y)
    ),
    "matchLabels": ((obj.matchLabels) === undefined)
      ? undefined
      : (Object.entries(obj.matchLabels).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema VolumeGroupSnapshotSpecSourceSelectorMatchExpressions
 */
export interface VolumeGroupSnapshotSpecSourceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema VolumeGroupSnapshotSpecSourceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema VolumeGroupSnapshotSpecSourceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema VolumeGroupSnapshotSpecSourceSelectorMatchExpressions#values
   */
  readonly values?: string[];
}

/**
 * Converts an object of type 'VolumeGroupSnapshotSpecSourceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeGroupSnapshotSpecSourceSelectorMatchExpressions(
  obj: VolumeGroupSnapshotSpecSourceSelectorMatchExpressions | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "key": obj.key,
    "operator": obj.operator,
    "values": obj.values?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeGroupSnapshotClass specifies parameters that a underlying storage system
uses when creating a volume group snapshot. A specific VolumeGroupSnapshotClass
is used by specifying its name in a VolumeGroupSnapshot object.
VolumeGroupSnapshotClasses are non-namespaced.
 *
 * @schema VolumeGroupSnapshotClass
 */
export class VolumeGroupSnapshotClass extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VolumeGroupSnapshotClass"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "groupsnapshot.storage.k8s.io/v1beta1",
    kind: "VolumeGroupSnapshotClass",
  };

  /**
   * Renders a Kubernetes manifest for "VolumeGroupSnapshotClass".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VolumeGroupSnapshotClassProps): any {
    return {
      ...VolumeGroupSnapshotClass.GVK,
      ...toJson_VolumeGroupSnapshotClassProps(props),
    };
  }

  /**
   * Defines a "VolumeGroupSnapshotClass" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: VolumeGroupSnapshotClassProps,
  ) {
    super(scope, id, {
      ...VolumeGroupSnapshotClass.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VolumeGroupSnapshotClass.GVK,
      ...toJson_VolumeGroupSnapshotClassProps(resolved),
    };
  }
}

/**
 * VolumeGroupSnapshotClass specifies parameters that a underlying storage system
 * uses when creating a volume group snapshot. A specific VolumeGroupSnapshotClass
 * is used by specifying its name in a VolumeGroupSnapshot object.
 * VolumeGroupSnapshotClasses are non-namespaced.
 *
 * @schema VolumeGroupSnapshotClass
 */
export interface VolumeGroupSnapshotClassProps {
  /**
   * @schema VolumeGroupSnapshotClass#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeletionPolicy determines whether a VolumeGroupSnapshotContent created
   * through the VolumeGroupSnapshotClass should be deleted when its bound
   * VolumeGroupSnapshot is deleted.
   * Supported values are "Retain" and "Delete".
   * "Retain" means that the VolumeGroupSnapshotContent and its physical group
   * snapshot on underlying storage system are kept.
   * "Delete" means that the VolumeGroupSnapshotContent and its physical group
   * snapshot on underlying storage system are deleted.
   * Required.
   *
   * @schema VolumeGroupSnapshotClass#deletionPolicy
   */
  readonly deletionPolicy: VolumeGroupSnapshotClassDeletionPolicy;

  /**
   * Driver is the name of the storage driver expected to handle this VolumeGroupSnapshotClass.
   * Required.
   *
   * @schema VolumeGroupSnapshotClass#driver
   */
  readonly driver: string;

  /**
   * Parameters is a key-value map with storage driver specific parameters for
   * creating group snapshots.
   * These values are opaque to Kubernetes and are passed directly to the driver.
   *
   * @schema VolumeGroupSnapshotClass#parameters
   */
  readonly parameters?: { [key: string]: string };
}

/**
 * Converts an object of type 'VolumeGroupSnapshotClassProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeGroupSnapshotClassProps(
  obj: VolumeGroupSnapshotClassProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "deletionPolicy": obj.deletionPolicy,
    "driver": obj.driver,
    "parameters": ((obj.parameters) === undefined)
      ? undefined
      : (Object.entries(obj.parameters).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy determines whether a VolumeGroupSnapshotContent created
 * through the VolumeGroupSnapshotClass should be deleted when its bound
 * VolumeGroupSnapshot is deleted.
 * Supported values are "Retain" and "Delete".
 * "Retain" means that the VolumeGroupSnapshotContent and its physical group
 * snapshot on underlying storage system are kept.
 * "Delete" means that the VolumeGroupSnapshotContent and its physical group
 * snapshot on underlying storage system are deleted.
 * Required.
 *
 * @schema VolumeGroupSnapshotClassDeletionPolicy
 */
export enum VolumeGroupSnapshotClassDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** Retain */
  RETAIN = "Retain",
}

/**
 * VolumeGroupSnapshotContent represents the actual "on-disk" group snapshot object
in the underlying storage system
 *
 * @schema VolumeGroupSnapshotContent
 */
export class VolumeGroupSnapshotContent extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VolumeGroupSnapshotContent"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "groupsnapshot.storage.k8s.io/v1beta1",
    kind: "VolumeGroupSnapshotContent",
  };

  /**
   * Renders a Kubernetes manifest for "VolumeGroupSnapshotContent".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VolumeGroupSnapshotContentProps): any {
    return {
      ...VolumeGroupSnapshotContent.GVK,
      ...toJson_VolumeGroupSnapshotContentProps(props),
    };
  }

  /**
   * Defines a "VolumeGroupSnapshotContent" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: VolumeGroupSnapshotContentProps,
  ) {
    super(scope, id, {
      ...VolumeGroupSnapshotContent.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VolumeGroupSnapshotContent.GVK,
      ...toJson_VolumeGroupSnapshotContentProps(resolved),
    };
  }
}

/**
 * VolumeGroupSnapshotContent represents the actual "on-disk" group snapshot object
 * in the underlying storage system
 *
 * @schema VolumeGroupSnapshotContent
 */
export interface VolumeGroupSnapshotContentProps {
  /**
   * @schema VolumeGroupSnapshotContent#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec defines properties of a VolumeGroupSnapshotContent created by the underlying storage system.
   * Required.
   *
   * @schema VolumeGroupSnapshotContent#spec
   */
  readonly spec: VolumeGroupSnapshotContentSpec;
}

/**
 * Converts an object of type 'VolumeGroupSnapshotContentProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeGroupSnapshotContentProps(
  obj: VolumeGroupSnapshotContentProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_VolumeGroupSnapshotContentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec defines properties of a VolumeGroupSnapshotContent created by the underlying storage system.
 * Required.
 *
 * @schema VolumeGroupSnapshotContentSpec
 */
export interface VolumeGroupSnapshotContentSpec {
  /**
   * DeletionPolicy determines whether this VolumeGroupSnapshotContent and the
   * physical group snapshot on the underlying storage system should be deleted
   * when the bound VolumeGroupSnapshot is deleted.
   * Supported values are "Retain" and "Delete".
   * "Retain" means that the VolumeGroupSnapshotContent and its physical group
   * snapshot on underlying storage system are kept.
   * "Delete" means that the VolumeGroupSnapshotContent and its physical group
   * snapshot on underlying storage system are deleted.
   * For dynamically provisioned group snapshots, this field will automatically
   * be filled in by the CSI snapshotter sidecar with the "DeletionPolicy" field
   * defined in the corresponding VolumeGroupSnapshotClass.
   * For pre-existing snapshots, users MUST specify this field when creating the
   * VolumeGroupSnapshotContent object.
   * Required.
   *
   * @schema VolumeGroupSnapshotContentSpec#deletionPolicy
   */
  readonly deletionPolicy: VolumeGroupSnapshotContentSpecDeletionPolicy;

  /**
   * Driver is the name of the CSI driver used to create the physical group snapshot on
   * the underlying storage system.
   * This MUST be the same as the name returned by the CSI GetPluginName() call for
   * that driver.
   * Required.
   *
   * @schema VolumeGroupSnapshotContentSpec#driver
   */
  readonly driver: string;

  /**
   * Source specifies whether the snapshot is (or should be) dynamically provisioned
   * or already exists, and just requires a Kubernetes object representation.
   * This field is immutable after creation.
   * Required.
   *
   * @schema VolumeGroupSnapshotContentSpec#source
   */
  readonly source: VolumeGroupSnapshotContentSpecSource;

  /**
   * VolumeGroupSnapshotClassName is the name of the VolumeGroupSnapshotClass from
   * which this group snapshot was (or will be) created.
   * Note that after provisioning, the VolumeGroupSnapshotClass may be deleted or
   * recreated with different set of values, and as such, should not be referenced
   * post-snapshot creation.
   * For dynamic provisioning, this field must be set.
   * This field may be unset for pre-provisioned snapshots.
   *
   * @schema VolumeGroupSnapshotContentSpec#volumeGroupSnapshotClassName
   */
  readonly volumeGroupSnapshotClassName?: string;

  /**
   * VolumeGroupSnapshotRef specifies the VolumeGroupSnapshot object to which this
   * VolumeGroupSnapshotContent object is bound.
   * VolumeGroupSnapshot.Spec.VolumeGroupSnapshotContentName field must reference to
   * this VolumeGroupSnapshotContent's name for the bidirectional binding to be valid.
   * For a pre-existing VolumeGroupSnapshotContent object, name and namespace of the
   * VolumeGroupSnapshot object MUST be provided for binding to happen.
   * This field is immutable after creation.
   * Required.
   *
   * @schema VolumeGroupSnapshotContentSpec#volumeGroupSnapshotRef
   */
  readonly volumeGroupSnapshotRef:
    VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef;
}

/**
 * Converts an object of type 'VolumeGroupSnapshotContentSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeGroupSnapshotContentSpec(
  obj: VolumeGroupSnapshotContentSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "deletionPolicy": obj.deletionPolicy,
    "driver": obj.driver,
    "source": toJson_VolumeGroupSnapshotContentSpecSource(obj.source),
    "volumeGroupSnapshotClassName": obj.volumeGroupSnapshotClassName,
    "volumeGroupSnapshotRef":
      toJson_VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef(
        obj.volumeGroupSnapshotRef,
      ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DeletionPolicy determines whether this VolumeGroupSnapshotContent and the
 * physical group snapshot on the underlying storage system should be deleted
 * when the bound VolumeGroupSnapshot is deleted.
 * Supported values are "Retain" and "Delete".
 * "Retain" means that the VolumeGroupSnapshotContent and its physical group
 * snapshot on underlying storage system are kept.
 * "Delete" means that the VolumeGroupSnapshotContent and its physical group
 * snapshot on underlying storage system are deleted.
 * For dynamically provisioned group snapshots, this field will automatically
 * be filled in by the CSI snapshotter sidecar with the "DeletionPolicy" field
 * defined in the corresponding VolumeGroupSnapshotClass.
 * For pre-existing snapshots, users MUST specify this field when creating the
 * VolumeGroupSnapshotContent object.
 * Required.
 *
 * @schema VolumeGroupSnapshotContentSpecDeletionPolicy
 */
export enum VolumeGroupSnapshotContentSpecDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** Retain */
  RETAIN = "Retain",
}

/**
 * Source specifies whether the snapshot is (or should be) dynamically provisioned
 * or already exists, and just requires a Kubernetes object representation.
 * This field is immutable after creation.
 * Required.
 *
 * @schema VolumeGroupSnapshotContentSpecSource
 */
export interface VolumeGroupSnapshotContentSpecSource {
  /**
   * GroupSnapshotHandles specifies the CSI "group_snapshot_id" of a pre-existing
   * group snapshot and a list of CSI "snapshot_id" of pre-existing snapshots
   * on the underlying storage system for which a Kubernetes object
   * representation was (or should be) created.
   * This field is immutable.
   *
   * @schema VolumeGroupSnapshotContentSpecSource#groupSnapshotHandles
   */
  readonly groupSnapshotHandles?:
    VolumeGroupSnapshotContentSpecSourceGroupSnapshotHandles;

  /**
   * VolumeHandles is a list of volume handles on the backend to be snapshotted
   * together. It is specified for dynamic provisioning of the VolumeGroupSnapshot.
   * This field is immutable.
   *
   * @schema VolumeGroupSnapshotContentSpecSource#volumeHandles
   */
  readonly volumeHandles?: string[];
}

/**
 * Converts an object of type 'VolumeGroupSnapshotContentSpecSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeGroupSnapshotContentSpecSource(
  obj: VolumeGroupSnapshotContentSpecSource | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "groupSnapshotHandles":
      toJson_VolumeGroupSnapshotContentSpecSourceGroupSnapshotHandles(
        obj.groupSnapshotHandles,
      ),
    "volumeHandles": obj.volumeHandles?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeGroupSnapshotRef specifies the VolumeGroupSnapshot object to which this
 * VolumeGroupSnapshotContent object is bound.
 * VolumeGroupSnapshot.Spec.VolumeGroupSnapshotContentName field must reference to
 * this VolumeGroupSnapshotContent's name for the bidirectional binding to be valid.
 * For a pre-existing VolumeGroupSnapshotContent object, name and namespace of the
 * VolumeGroupSnapshot object MUST be provided for binding to happen.
 * This field is immutable after creation.
 * Required.
 *
 * @schema VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef
 */
export interface VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef {
  /**
   * API version of the referent.
   *
   * @schema VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * If referring to a piece of an object instead of an entire object, this string
   * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
   * For example, if the object reference is to a container within a pod, this would take on a value like:
   * "spec.containers{name}" (where "name" refers to the name of the container that triggered
   * the event) or if no container name is specified "spec.containers[2]" (container with
   * index 2 in this pod). This syntax is chosen only to have some well-defined way of
   * referencing a part of an object.
   * TODO: this design is not final and this field is subject to change in the future.
   *
   * @schema VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef#fieldPath
   */
  readonly fieldPath?: string;

  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef#namespace
   */
  readonly namespace?: string;

  /**
   * Specific resourceVersion to which this reference is made, if any.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   *
   * @schema VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * UID of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
   *
   * @schema VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef#uid
   */
  readonly uid?: string;
}

/**
 * Converts an object of type 'VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef(
  obj: VolumeGroupSnapshotContentSpecVolumeGroupSnapshotRef | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "apiVersion": obj.apiVersion,
    "fieldPath": obj.fieldPath,
    "kind": obj.kind,
    "name": obj.name,
    "namespace": obj.namespace,
    "resourceVersion": obj.resourceVersion,
    "uid": obj.uid,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GroupSnapshotHandles specifies the CSI "group_snapshot_id" of a pre-existing
 * group snapshot and a list of CSI "snapshot_id" of pre-existing snapshots
 * on the underlying storage system for which a Kubernetes object
 * representation was (or should be) created.
 * This field is immutable.
 *
 * @schema VolumeGroupSnapshotContentSpecSourceGroupSnapshotHandles
 */
export interface VolumeGroupSnapshotContentSpecSourceGroupSnapshotHandles {
  /**
   * VolumeGroupSnapshotHandle specifies the CSI "group_snapshot_id" of a pre-existing
   * group snapshot on the underlying storage system for which a Kubernetes object
   * representation was (or should be) created.
   * This field is immutable.
   * Required.
   *
   * @schema VolumeGroupSnapshotContentSpecSourceGroupSnapshotHandles#volumeGroupSnapshotHandle
   */
  readonly volumeGroupSnapshotHandle: string;

  /**
   * VolumeSnapshotHandles is a list of CSI "snapshot_id" of pre-existing
   * snapshots on the underlying storage system for which Kubernetes objects
   * representation were (or should be) created.
   * This field is immutable.
   * Required.
   *
   * @schema VolumeGroupSnapshotContentSpecSourceGroupSnapshotHandles#volumeSnapshotHandles
   */
  readonly volumeSnapshotHandles: string[];
}

/**
 * Converts an object of type 'VolumeGroupSnapshotContentSpecSourceGroupSnapshotHandles' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VolumeGroupSnapshotContentSpecSourceGroupSnapshotHandles(
  obj: VolumeGroupSnapshotContentSpecSourceGroupSnapshotHandles | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "volumeGroupSnapshotHandle": obj.volumeGroupSnapshotHandle,
    "volumeSnapshotHandles": obj.volumeSnapshotHandles?.map((y) => y),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
