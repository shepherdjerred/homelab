// deno-lint-ignore-file
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "cdk8s";
import { Construct } from "constructs";

/**
 * DlbDevicePlugin is the Schema for the dlbdeviceplugins API. It represents
the DLB device plugin responsible for advertising Intel DLB hardware resources to
the kubelet.
 *
 * @schema DlbDevicePlugin
 */
export class DlbDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DlbDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "DlbDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "DlbDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DlbDevicePluginProps = {}): any {
    return {
      ...DlbDevicePlugin.GVK,
      ...toJson_DlbDevicePluginProps(props),
    };
  }

  /**
   * Defines a "DlbDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: DlbDevicePluginProps = {},
  ) {
    super(scope, id, {
      ...DlbDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...DlbDevicePlugin.GVK,
      ...toJson_DlbDevicePluginProps(resolved),
    };
  }
}

/**
 * DlbDevicePlugin is the Schema for the dlbdeviceplugins API. It represents
 * the DLB device plugin responsible for advertising Intel DLB hardware resources to
 * the kubelet.
 *
 * @schema DlbDevicePlugin
 */
export interface DlbDevicePluginProps {
  /**
   * @schema DlbDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DlbDevicePluginSpec defines the desired state of DlbDevicePlugin.
   *
   * @schema DlbDevicePlugin#spec
   */
  readonly spec?: DlbDevicePluginSpec;
}

/**
 * Converts an object of type 'DlbDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DlbDevicePluginProps(
  obj: DlbDevicePluginProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_DlbDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DlbDevicePluginSpec defines the desired state of DlbDevicePlugin.
 *
 * @schema DlbDevicePluginSpec
 */
export interface DlbDevicePluginSpec {
  /**
   * Image is a container image with DLB device plugin executable.
   *
   * @schema DlbDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is a container image with a script that initializes devices.
   *
   * @schema DlbDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema DlbDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema DlbDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema DlbDevicePluginSpec#tolerations
   */
  readonly tolerations?: DlbDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'DlbDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DlbDevicePluginSpec(
  obj: DlbDevicePluginSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "image": obj.image,
    "initImage": obj.initImage,
    "logLevel": obj.logLevel,
    "nodeSelector": ((obj.nodeSelector) === undefined)
      ? undefined
      : (Object.entries(obj.nodeSelector).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "tolerations": obj.tolerations?.map((y) =>
      toJson_DlbDevicePluginSpecTolerations(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DlbDevicePluginSpecTolerations
 */
export interface DlbDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DlbDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DlbDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DlbDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema DlbDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DlbDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'DlbDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DlbDevicePluginSpecTolerations(
  obj: DlbDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "effect": obj.effect,
    "key": obj.key,
    "operator": obj.operator,
    "tolerationSeconds": obj.tolerationSeconds,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DsaDevicePlugin is the Schema for the dsadeviceplugins API. It represents
the DSA device plugin responsible for advertising Intel DSA hardware resources to
the kubelet.
 *
 * @schema DsaDevicePlugin
 */
export class DsaDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DsaDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "DsaDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "DsaDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DsaDevicePluginProps = {}): any {
    return {
      ...DsaDevicePlugin.GVK,
      ...toJson_DsaDevicePluginProps(props),
    };
  }

  /**
   * Defines a "DsaDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: DsaDevicePluginProps = {},
  ) {
    super(scope, id, {
      ...DsaDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...DsaDevicePlugin.GVK,
      ...toJson_DsaDevicePluginProps(resolved),
    };
  }
}

/**
 * DsaDevicePlugin is the Schema for the dsadeviceplugins API. It represents
 * the DSA device plugin responsible for advertising Intel DSA hardware resources to
 * the kubelet.
 *
 * @schema DsaDevicePlugin
 */
export interface DsaDevicePluginProps {
  /**
   * @schema DsaDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DsaDevicePluginSpec defines the desired state of DsaDevicePlugin.
   *
   * @schema DsaDevicePlugin#spec
   */
  readonly spec?: DsaDevicePluginSpec;
}

/**
 * Converts an object of type 'DsaDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DsaDevicePluginProps(
  obj: DsaDevicePluginProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_DsaDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DsaDevicePluginSpec defines the desired state of DsaDevicePlugin.
 *
 * @schema DsaDevicePluginSpec
 */
export interface DsaDevicePluginSpec {
  /**
   * Image is a container image with DSA device plugin executable.
   *
   * @schema DsaDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is an initcontainer image to configure and enable DSA devices and workqueues with idxd-config (accel-config) utility
   *
   * @schema DsaDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema DsaDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema DsaDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * ProvisioningConfig is a ConfigMap used to pass the DSA devices and workqueues configuration into idxd-config initcontainer.
   *
   * @schema DsaDevicePluginSpec#provisioningConfig
   */
  readonly provisioningConfig?: string;

  /**
   * SharedDevNum is a number of containers that can share the same DSA device.
   *
   * @schema DsaDevicePluginSpec#sharedDevNum
   */
  readonly sharedDevNum?: number;

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema DsaDevicePluginSpec#tolerations
   */
  readonly tolerations?: DsaDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'DsaDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DsaDevicePluginSpec(
  obj: DsaDevicePluginSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "image": obj.image,
    "initImage": obj.initImage,
    "logLevel": obj.logLevel,
    "nodeSelector": ((obj.nodeSelector) === undefined)
      ? undefined
      : (Object.entries(obj.nodeSelector).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "provisioningConfig": obj.provisioningConfig,
    "sharedDevNum": obj.sharedDevNum,
    "tolerations": obj.tolerations?.map((y) =>
      toJson_DsaDevicePluginSpecTolerations(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DsaDevicePluginSpecTolerations
 */
export interface DsaDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DsaDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DsaDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema DsaDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema DsaDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DsaDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'DsaDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DsaDevicePluginSpecTolerations(
  obj: DsaDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "effect": obj.effect,
    "key": obj.key,
    "operator": obj.operator,
    "tolerationSeconds": obj.tolerationSeconds,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FpgaDevicePlugin is the Schema for the fpgadeviceplugins API. It represents
the FPGA device plugin responsible for advertising Intel FPGA hardware resources to
the kubelet.
 *
 * @schema FpgaDevicePlugin
 */
export class FpgaDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "FpgaDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "FpgaDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "FpgaDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FpgaDevicePluginProps = {}): any {
    return {
      ...FpgaDevicePlugin.GVK,
      ...toJson_FpgaDevicePluginProps(props),
    };
  }

  /**
   * Defines a "FpgaDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: FpgaDevicePluginProps = {},
  ) {
    super(scope, id, {
      ...FpgaDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...FpgaDevicePlugin.GVK,
      ...toJson_FpgaDevicePluginProps(resolved),
    };
  }
}

/**
 * FpgaDevicePlugin is the Schema for the fpgadeviceplugins API. It represents
 * the FPGA device plugin responsible for advertising Intel FPGA hardware resources to
 * the kubelet.
 *
 * @schema FpgaDevicePlugin
 */
export interface FpgaDevicePluginProps {
  /**
   * @schema FpgaDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FpgaDevicePluginSpec defines the desired state of FpgaDevicePlugin.
   *
   * @schema FpgaDevicePlugin#spec
   */
  readonly spec?: FpgaDevicePluginSpec;
}

/**
 * Converts an object of type 'FpgaDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FpgaDevicePluginProps(
  obj: FpgaDevicePluginProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_FpgaDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FpgaDevicePluginSpec defines the desired state of FpgaDevicePlugin.
 *
 * @schema FpgaDevicePluginSpec
 */
export interface FpgaDevicePluginSpec {
  /**
   * Image is a container image with FPGA device plugin executable.
   *
   * @schema FpgaDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is a container image with tools used to initialize the host before starting FPGA workloads on it.
   *
   * @schema FpgaDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema FpgaDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * Mode is a mode of the plugin's operation.
   *
   * @schema FpgaDevicePluginSpec#mode
   */
  readonly mode?: FpgaDevicePluginSpecMode;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema FpgaDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema FpgaDevicePluginSpec#tolerations
   */
  readonly tolerations?: FpgaDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'FpgaDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FpgaDevicePluginSpec(
  obj: FpgaDevicePluginSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "image": obj.image,
    "initImage": obj.initImage,
    "logLevel": obj.logLevel,
    "mode": obj.mode,
    "nodeSelector": ((obj.nodeSelector) === undefined)
      ? undefined
      : (Object.entries(obj.nodeSelector).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "tolerations": obj.tolerations?.map((y) =>
      toJson_FpgaDevicePluginSpecTolerations(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mode is a mode of the plugin's operation.
 *
 * @schema FpgaDevicePluginSpecMode
 */
export enum FpgaDevicePluginSpecMode {
  /** af */
  AF = "af",
  /** region */
  REGION = "region",
  /** regiondevel */
  REGIONDEVEL = "regiondevel",
}

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema FpgaDevicePluginSpecTolerations
 */
export interface FpgaDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema FpgaDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema FpgaDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema FpgaDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema FpgaDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema FpgaDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'FpgaDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FpgaDevicePluginSpecTolerations(
  obj: FpgaDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "effect": obj.effect,
    "key": obj.key,
    "operator": obj.operator,
    "tolerationSeconds": obj.tolerationSeconds,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GpuDevicePlugin is the Schema for the gpudeviceplugins API. It represents
the GPU device plugin responsible for advertising Intel GPU hardware resources to
the kubelet.
 *
 * @schema GpuDevicePlugin
 */
export class GpuDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GpuDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "GpuDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "GpuDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GpuDevicePluginProps = {}): any {
    return {
      ...GpuDevicePlugin.GVK,
      ...toJson_GpuDevicePluginProps(props),
    };
  }

  /**
   * Defines a "GpuDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: GpuDevicePluginProps = {},
  ) {
    super(scope, id, {
      ...GpuDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GpuDevicePlugin.GVK,
      ...toJson_GpuDevicePluginProps(resolved),
    };
  }
}

/**
 * GpuDevicePlugin is the Schema for the gpudeviceplugins API. It represents
 * the GPU device plugin responsible for advertising Intel GPU hardware resources to
 * the kubelet.
 *
 * @schema GpuDevicePlugin
 */
export interface GpuDevicePluginProps {
  /**
   * @schema GpuDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GpuDevicePluginSpec defines the desired state of GpuDevicePlugin.
   *
   * @schema GpuDevicePlugin#spec
   */
  readonly spec?: GpuDevicePluginSpec;
}

/**
 * Converts an object of type 'GpuDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GpuDevicePluginProps(
  obj: GpuDevicePluginProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_GpuDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GpuDevicePluginSpec defines the desired state of GpuDevicePlugin.
 *
 * @schema GpuDevicePluginSpec
 */
export interface GpuDevicePluginSpec {
  /**
   * EnableMonitoring enables the monitoring resource ('i915_monitoring')
   * which gives access to all GPU devices on given node. Typically used with Intel XPU-Manager.
   *
   * @schema GpuDevicePluginSpec#enableMonitoring
   */
  readonly enableMonitoring?: boolean;

  /**
   * Image is a container image with GPU device plugin executable.
   *
   * @schema GpuDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is a container image with tools (e.g., GPU NFD source hook) installed on each node.
   *
   * @schema GpuDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema GpuDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema GpuDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PreferredAllocationPolicy sets the mode of allocating GPU devices on a node.
   * See documentation for detailed description of the policies. Only valid when SharedDevNum > 1 is set.
   * Not applicable with ResourceManager.
   *
   * @schema GpuDevicePluginSpec#preferredAllocationPolicy
   */
  readonly preferredAllocationPolicy?:
    GpuDevicePluginSpecPreferredAllocationPolicy;

  /**
   * ResourceManager handles the fractional resource management for multi-GPU nodes. Enable only for clusters with GPU Aware Scheduling.
   *
   * @schema GpuDevicePluginSpec#resourceManager
   */
  readonly resourceManager?: boolean;

  /**
   * SharedDevNum is a number of containers that can share the same GPU device.
   *
   * @schema GpuDevicePluginSpec#sharedDevNum
   */
  readonly sharedDevNum?: number;

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema GpuDevicePluginSpec#tolerations
   */
  readonly tolerations?: GpuDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'GpuDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GpuDevicePluginSpec(
  obj: GpuDevicePluginSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "enableMonitoring": obj.enableMonitoring,
    "image": obj.image,
    "initImage": obj.initImage,
    "logLevel": obj.logLevel,
    "nodeSelector": ((obj.nodeSelector) === undefined)
      ? undefined
      : (Object.entries(obj.nodeSelector).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "preferredAllocationPolicy": obj.preferredAllocationPolicy,
    "resourceManager": obj.resourceManager,
    "sharedDevNum": obj.sharedDevNum,
    "tolerations": obj.tolerations?.map((y) =>
      toJson_GpuDevicePluginSpecTolerations(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PreferredAllocationPolicy sets the mode of allocating GPU devices on a node.
 * See documentation for detailed description of the policies. Only valid when SharedDevNum > 1 is set.
 * Not applicable with ResourceManager.
 *
 * @schema GpuDevicePluginSpecPreferredAllocationPolicy
 */
export enum GpuDevicePluginSpecPreferredAllocationPolicy {
  /** balanced */
  BALANCED = "balanced",
  /** packed */
  PACKED = "packed",
  /** none */
  NONE = "none",
}

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema GpuDevicePluginSpecTolerations
 */
export interface GpuDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema GpuDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema GpuDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema GpuDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema GpuDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema GpuDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'GpuDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GpuDevicePluginSpecTolerations(
  obj: GpuDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "effect": obj.effect,
    "key": obj.key,
    "operator": obj.operator,
    "tolerationSeconds": obj.tolerationSeconds,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IaaDevicePlugin is the Schema for the iaadeviceplugins API. It represents
the IAA device plugin responsible for advertising Intel IAA hardware resources to
the kubelet.
 *
 * @schema IaaDevicePlugin
 */
export class IaaDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IaaDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "IaaDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "IaaDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IaaDevicePluginProps = {}): any {
    return {
      ...IaaDevicePlugin.GVK,
      ...toJson_IaaDevicePluginProps(props),
    };
  }

  /**
   * Defines a "IaaDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: IaaDevicePluginProps = {},
  ) {
    super(scope, id, {
      ...IaaDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...IaaDevicePlugin.GVK,
      ...toJson_IaaDevicePluginProps(resolved),
    };
  }
}

/**
 * IaaDevicePlugin is the Schema for the iaadeviceplugins API. It represents
 * the IAA device plugin responsible for advertising Intel IAA hardware resources to
 * the kubelet.
 *
 * @schema IaaDevicePlugin
 */
export interface IaaDevicePluginProps {
  /**
   * @schema IaaDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IaaDevicePluginSpec defines the desired state of IaaDevicePlugin.
   *
   * @schema IaaDevicePlugin#spec
   */
  readonly spec?: IaaDevicePluginSpec;
}

/**
 * Converts an object of type 'IaaDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IaaDevicePluginProps(
  obj: IaaDevicePluginProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_IaaDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IaaDevicePluginSpec defines the desired state of IaaDevicePlugin.
 *
 * @schema IaaDevicePluginSpec
 */
export interface IaaDevicePluginSpec {
  /**
   * Image is a container image with IAA device plugin executable.
   *
   * @schema IaaDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is an initcontainer image to configure and enable IAA devices and workqueues with accel-config utility
   *
   * @schema IaaDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema IaaDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema IaaDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * ProvisioningConfig is a ConfigMap used to pass the IAA configuration into idxd initcontainer.
   *
   * @schema IaaDevicePluginSpec#provisioningConfig
   */
  readonly provisioningConfig?: string;

  /**
   * SharedDevNum is a number of containers that can share the same IAA device.
   *
   * @schema IaaDevicePluginSpec#sharedDevNum
   */
  readonly sharedDevNum?: number;

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema IaaDevicePluginSpec#tolerations
   */
  readonly tolerations?: IaaDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'IaaDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IaaDevicePluginSpec(
  obj: IaaDevicePluginSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "image": obj.image,
    "initImage": obj.initImage,
    "logLevel": obj.logLevel,
    "nodeSelector": ((obj.nodeSelector) === undefined)
      ? undefined
      : (Object.entries(obj.nodeSelector).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "provisioningConfig": obj.provisioningConfig,
    "sharedDevNum": obj.sharedDevNum,
    "tolerations": obj.tolerations?.map((y) =>
      toJson_IaaDevicePluginSpecTolerations(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema IaaDevicePluginSpecTolerations
 */
export interface IaaDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema IaaDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema IaaDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema IaaDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema IaaDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema IaaDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'IaaDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IaaDevicePluginSpecTolerations(
  obj: IaaDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "effect": obj.effect,
    "key": obj.key,
    "operator": obj.operator,
    "tolerationSeconds": obj.tolerationSeconds,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * QatDevicePlugin is the Schema for the qatdeviceplugins API. It represents the QAT device
plugin responsible for advertising Intel QuickAssist Technology hardware resources
to the kubelet.
 *
 * @schema QatDevicePlugin
 */
export class QatDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "QatDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "QatDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "QatDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: QatDevicePluginProps = {}): any {
    return {
      ...QatDevicePlugin.GVK,
      ...toJson_QatDevicePluginProps(props),
    };
  }

  /**
   * Defines a "QatDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: QatDevicePluginProps = {},
  ) {
    super(scope, id, {
      ...QatDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...QatDevicePlugin.GVK,
      ...toJson_QatDevicePluginProps(resolved),
    };
  }
}

/**
 * QatDevicePlugin is the Schema for the qatdeviceplugins API. It represents the QAT device
 * plugin responsible for advertising Intel QuickAssist Technology hardware resources
 * to the kubelet.
 *
 * @schema QatDevicePlugin
 */
export interface QatDevicePluginProps {
  /**
   * @schema QatDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * QatDevicePluginSpec defines the desired state of QatDevicePlugin.
   *
   * @schema QatDevicePlugin#spec
   */
  readonly spec?: QatDevicePluginSpec;
}

/**
 * Converts an object of type 'QatDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_QatDevicePluginProps(
  obj: QatDevicePluginProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_QatDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * QatDevicePluginSpec defines the desired state of QatDevicePlugin.
 *
 * @schema QatDevicePluginSpec
 */
export interface QatDevicePluginSpec {
  /**
   * DpdkDriver is a DPDK device driver for configuring the QAT device.
   *
   * @schema QatDevicePluginSpec#dpdkDriver
   */
  readonly dpdkDriver?: QatDevicePluginSpecDpdkDriver;

  /**
   * Image is a container image with QAT device plugin executable.
   *
   * @schema QatDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is a container image with a script that initialize devices.
   *
   * @schema QatDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * KernelVfDrivers is a list of VF device drivers for the QuickAssist devices in the system.
   *
   * @schema QatDevicePluginSpec#kernelVfDrivers
   */
  readonly kernelVfDrivers?: QatDevicePluginSpecKernelVfDrivers[];

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema QatDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * MaxNumDevices is a maximum number of QAT devices to be provided to the QuickAssist device plugin
   *
   * @schema QatDevicePluginSpec#maxNumDevices
   */
  readonly maxNumDevices?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema QatDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * PreferredAllocationPolicy sets the mode of allocating QAT devices on a node.
   * See documentation for detailed description of the policies.
   *
   * @schema QatDevicePluginSpec#preferredAllocationPolicy
   */
  readonly preferredAllocationPolicy?:
    QatDevicePluginSpecPreferredAllocationPolicy;

  /**
   * ProvisioningConfig is a ConfigMap used to pass the configuration of QAT devices into qat initcontainer.
   *
   * @schema QatDevicePluginSpec#provisioningConfig
   */
  readonly provisioningConfig?: string;

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema QatDevicePluginSpec#tolerations
   */
  readonly tolerations?: QatDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'QatDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_QatDevicePluginSpec(
  obj: QatDevicePluginSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "dpdkDriver": obj.dpdkDriver,
    "image": obj.image,
    "initImage": obj.initImage,
    "kernelVfDrivers": obj.kernelVfDrivers?.map((y) => y),
    "logLevel": obj.logLevel,
    "maxNumDevices": obj.maxNumDevices,
    "nodeSelector": ((obj.nodeSelector) === undefined)
      ? undefined
      : (Object.entries(obj.nodeSelector).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "preferredAllocationPolicy": obj.preferredAllocationPolicy,
    "provisioningConfig": obj.provisioningConfig,
    "tolerations": obj.tolerations?.map((y) =>
      toJson_QatDevicePluginSpecTolerations(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DpdkDriver is a DPDK device driver for configuring the QAT device.
 *
 * @schema QatDevicePluginSpecDpdkDriver
 */
export enum QatDevicePluginSpecDpdkDriver {
  /** igb_uio */
  IGB_UNDERSCORE_UIO = "igb_uio",
  /** vfio-pci */
  VFIO_HYPHEN_PCI = "vfio-pci",
}

/**
 * KernelVfDriver is a VF device driver for QuickAssist devices.
 *
 * @schema QatDevicePluginSpecKernelVfDrivers
 */
export enum QatDevicePluginSpecKernelVfDrivers {
  /** dh895xccvf */
  DH895XCCVF = "dh895xccvf",
  /** c6xxvf */
  C6XXVF = "c6xxvf",
  /** c3xxxvf */
  C3XXXVF = "c3xxxvf",
  /** d15xxvf */
  D15XXVF = "d15xxvf",
  /** 4xxxvf */
  VALUE_4XXXVF = "4xxxvf",
  /** 420xxvf */
  VALUE_420XXVF = "420xxvf",
  /** c4xxxvf */
  C4XXXVF = "c4xxxvf",
}

/**
 * PreferredAllocationPolicy sets the mode of allocating QAT devices on a node.
 * See documentation for detailed description of the policies.
 *
 * @schema QatDevicePluginSpecPreferredAllocationPolicy
 */
export enum QatDevicePluginSpecPreferredAllocationPolicy {
  /** balanced */
  BALANCED = "balanced",
  /** packed */
  PACKED = "packed",
}

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema QatDevicePluginSpecTolerations
 */
export interface QatDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema QatDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema QatDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema QatDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema QatDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema QatDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'QatDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_QatDevicePluginSpecTolerations(
  obj: QatDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "effect": obj.effect,
    "key": obj.key,
    "operator": obj.operator,
    "tolerationSeconds": obj.tolerationSeconds,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SgxDevicePlugin is the Schema for the sgxdeviceplugins API. It represents
the SGX device plugin responsible for advertising SGX device nodes to
the kubelet.
 *
 * @schema SgxDevicePlugin
 */
export class SgxDevicePlugin extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SgxDevicePlugin"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "deviceplugin.intel.com/v1",
    kind: "SgxDevicePlugin",
  };

  /**
   * Renders a Kubernetes manifest for "SgxDevicePlugin".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SgxDevicePluginProps = {}): any {
    return {
      ...SgxDevicePlugin.GVK,
      ...toJson_SgxDevicePluginProps(props),
    };
  }

  /**
   * Defines a "SgxDevicePlugin" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: SgxDevicePluginProps = {},
  ) {
    super(scope, id, {
      ...SgxDevicePlugin.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...SgxDevicePlugin.GVK,
      ...toJson_SgxDevicePluginProps(resolved),
    };
  }
}

/**
 * SgxDevicePlugin is the Schema for the sgxdeviceplugins API. It represents
 * the SGX device plugin responsible for advertising SGX device nodes to
 * the kubelet.
 *
 * @schema SgxDevicePlugin
 */
export interface SgxDevicePluginProps {
  /**
   * @schema SgxDevicePlugin#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SgxDevicePluginSpec defines the desired state of SgxDevicePlugin.
   *
   * @schema SgxDevicePlugin#spec
   */
  readonly spec?: SgxDevicePluginSpec;
}

/**
 * Converts an object of type 'SgxDevicePluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SgxDevicePluginProps(
  obj: SgxDevicePluginProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_SgxDevicePluginSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SgxDevicePluginSpec defines the desired state of SgxDevicePlugin.
 *
 * @schema SgxDevicePluginSpec
 */
export interface SgxDevicePluginSpec {
  /**
   * EnclaveLimit is a number of containers that can share the same SGX enclave device.
   *
   * @schema SgxDevicePluginSpec#enclaveLimit
   */
  readonly enclaveLimit?: number;

  /**
   * Image is a container image with SGX device plugin executable.
   *
   * @schema SgxDevicePluginSpec#image
   */
  readonly image?: string;

  /**
   * InitImage is a container image with tools (i.e., SGX NFD source hook) installed on each node.
   * Recommendation is to leave this unset and prefer the SGX NodeFeatureRule instead.
   *
   * @schema SgxDevicePluginSpec#initImage
   */
  readonly initImage?: string;

  /**
   * LogLevel sets the plugin's log level.
   *
   * @schema SgxDevicePluginSpec#logLevel
   */
  readonly logLevel?: number;

  /**
   * NodeSelector provides a simple way to constrain device plugin pods to nodes with particular labels.
   *
   * @schema SgxDevicePluginSpec#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * ProvisionLimit is a number of containers that can share the same SGX provision device.
   *
   * @schema SgxDevicePluginSpec#provisionLimit
   */
  readonly provisionLimit?: number;

  /**
   * Specialized nodes (e.g., with accelerators) can be Tainted to make sure unwanted pods are not scheduled on them. Tolerations can be set for the plugin pod to neutralize the Taint.
   *
   * @schema SgxDevicePluginSpec#tolerations
   */
  readonly tolerations?: SgxDevicePluginSpecTolerations[];
}

/**
 * Converts an object of type 'SgxDevicePluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SgxDevicePluginSpec(
  obj: SgxDevicePluginSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "enclaveLimit": obj.enclaveLimit,
    "image": obj.image,
    "initImage": obj.initImage,
    "logLevel": obj.logLevel,
    "nodeSelector": ((obj.nodeSelector) === undefined)
      ? undefined
      : (Object.entries(obj.nodeSelector).reduce(
        (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
        {},
      )),
    "provisionLimit": obj.provisionLimit,
    "tolerations": obj.tolerations?.map((y) =>
      toJson_SgxDevicePluginSpecTolerations(y)
    ),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema SgxDevicePluginSpecTolerations
 */
export interface SgxDevicePluginSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema SgxDevicePluginSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema SgxDevicePluginSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   *
   * @default Equal.
   * @schema SgxDevicePluginSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema SgxDevicePluginSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema SgxDevicePluginSpecTolerations#value
   */
  readonly value?: string;
}

/**
 * Converts an object of type 'SgxDevicePluginSpecTolerations' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SgxDevicePluginSpecTolerations(
  obj: SgxDevicePluginSpecTolerations | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "effect": obj.effect,
    "key": obj.key,
    "operator": obj.operator,
    "tolerationSeconds": obj.tolerationSeconds,
    "value": obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
