// deno-lint-ignore-file
// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from "cdk8s";
import { Construct } from "constructs";

/**
 * ZFSBackup describes a zfs backup resource created as a custom resource
 *
 * @schema ZFSBackup
 */
export class ZfsBackup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ZFSBackup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "zfs.openebs.io/v1",
    kind: "ZFSBackup",
  };

  /**
   * Renders a Kubernetes manifest for "ZFSBackup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ZfsBackupProps): any {
    return {
      ...ZfsBackup.GVK,
      ...toJson_ZfsBackupProps(props),
    };
  }

  /**
   * Defines a "ZFSBackup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ZfsBackupProps) {
    super(scope, id, {
      ...ZfsBackup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ZfsBackup.GVK,
      ...toJson_ZfsBackupProps(resolved),
    };
  }
}

/**
 * ZFSBackup describes a zfs backup resource created as a custom resource
 *
 * @schema ZFSBackup
 */
export interface ZfsBackupProps {
  /**
   * @schema ZFSBackup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ZFSBackupSpec is the spec for a ZFSBackup resource
   *
   * @schema ZFSBackup#spec
   */
  readonly spec: ZfsBackupSpec;
}

/**
 * Converts an object of type 'ZfsBackupProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsBackupProps(
  obj: ZfsBackupProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ZfsBackupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ZFSBackupSpec is the spec for a ZFSBackup resource
 *
 * @schema ZfsBackupSpec
 */
export interface ZfsBackupSpec {
  /**
   * BackupDest is the remote address for backup transfer
   *
   * @schema ZfsBackupSpec#backupDest
   */
  readonly backupDest: string;

  /**
   * OwnerNodeID is a name of the nodes where the source volume is
   *
   * @schema ZfsBackupSpec#ownerNodeID
   */
  readonly ownerNodeId: string;

  /**
   * PrevSnapName is the last completed-backup's snapshot name
   *
   * @schema ZfsBackupSpec#prevSnapName
   */
  readonly prevSnapName?: string;

  /**
   * SnapName is the snapshot name for backup
   *
   * @schema ZfsBackupSpec#snapName
   */
  readonly snapName?: string;

  /**
   * VolumeName is a name of the volume for which this backup is destined
   *
   * @schema ZfsBackupSpec#volumeName
   */
  readonly volumeName: string;
}

/**
 * Converts an object of type 'ZfsBackupSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsBackupSpec(
  obj: ZfsBackupSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "backupDest": obj.backupDest,
    "ownerNodeID": obj.ownerNodeId,
    "prevSnapName": obj.prevSnapName,
    "snapName": obj.snapName,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ZFSNode records information about all zfs pools available in a node. In general, the openebs node-agent creates the ZFSNode object & periodically synchronizing the zfs pools available in the node. ZFSNode has an owner reference pointing to the corresponding node object.
 *
 * @schema ZFSNode
 */
export class ZfsNode extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ZFSNode"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "zfs.openebs.io/v1",
    kind: "ZFSNode",
  };

  /**
   * Renders a Kubernetes manifest for "ZFSNode".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ZfsNodeProps): any {
    return {
      ...ZfsNode.GVK,
      ...toJson_ZfsNodeProps(props),
    };
  }

  /**
   * Defines a "ZFSNode" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ZfsNodeProps) {
    super(scope, id, {
      ...ZfsNode.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ZfsNode.GVK,
      ...toJson_ZfsNodeProps(resolved),
    };
  }
}

/**
 * ZFSNode records information about all zfs pools available in a node. In general, the openebs node-agent creates the ZFSNode object & periodically synchronizing the zfs pools available in the node. ZFSNode has an owner reference pointing to the corresponding node object.
 *
 * @schema ZFSNode
 */
export interface ZfsNodeProps {
  /**
   * @schema ZFSNode#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ZFSNode#pools
   */
  readonly pools: ZfsNodePools[];
}

/**
 * Converts an object of type 'ZfsNodeProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsNodeProps(
  obj: ZfsNodeProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "pools": obj.pools?.map((y) => toJson_ZfsNodePools(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Pool specifies attributes of a given zfs pool that exists on the node.
 *
 * @schema ZfsNodePools
 */
export interface ZfsNodePools {
  /**
   * Free specifies the available capacity of zfs pool.
   *
   * @schema ZfsNodePools#free
   */
  readonly free: ZfsNodePoolsFree;

  /**
   * Name of the zfs pool.
   *
   * @schema ZfsNodePools#name
   */
  readonly name: string;

  /**
   * Used specifies the used capacity of zfs pool.
   *
   * @schema ZfsNodePools#used
   */
  readonly used: ZfsNodePoolsUsed;

  /**
   * UUID denotes a unique identity of a zfs pool.
   *
   * @schema ZfsNodePools#uuid
   */
  readonly uuid: string;
}

/**
 * Converts an object of type 'ZfsNodePools' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsNodePools(
  obj: ZfsNodePools | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "free": obj.free?.value,
    "name": obj.name,
    "used": obj.used?.value,
    "uuid": obj.uuid,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Free specifies the available capacity of zfs pool.
 *
 * @schema ZfsNodePoolsFree
 */
export class ZfsNodePoolsFree {
  public static fromNumber(value: number): ZfsNodePoolsFree {
    return new ZfsNodePoolsFree(value);
  }
  public static fromString(value: string): ZfsNodePoolsFree {
    return new ZfsNodePoolsFree(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Used specifies the used capacity of zfs pool.
 *
 * @schema ZfsNodePoolsUsed
 */
export class ZfsNodePoolsUsed {
  public static fromNumber(value: number): ZfsNodePoolsUsed {
    return new ZfsNodePoolsUsed(value);
  }
  public static fromString(value: string): ZfsNodePoolsUsed {
    return new ZfsNodePoolsUsed(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ZFSRestore describes a cstor restore resource created as a custom resource
 *
 * @schema ZFSRestore
 */
export class ZfsRestore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ZFSRestore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "zfs.openebs.io/v1",
    kind: "ZFSRestore",
  };

  /**
   * Renders a Kubernetes manifest for "ZFSRestore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ZfsRestoreProps): any {
    return {
      ...ZfsRestore.GVK,
      ...toJson_ZfsRestoreProps(props),
    };
  }

  /**
   * Defines a "ZFSRestore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ZfsRestoreProps) {
    super(scope, id, {
      ...ZfsRestore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ZfsRestore.GVK,
      ...toJson_ZfsRestoreProps(resolved),
    };
  }
}

/**
 * ZFSRestore describes a cstor restore resource created as a custom resource
 *
 * @schema ZFSRestore
 */
export interface ZfsRestoreProps {
  /**
   * @schema ZFSRestore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ZFSRestoreSpec is the spec for a ZFSRestore resource
   *
   * @schema ZFSRestore#spec
   */
  readonly spec: ZfsRestoreSpec;

  /**
   * VolumeInfo defines ZFS volume parameters for all modes in which ZFS volumes can be created like - ZFS volume with filesystem, ZFS Volume exposed as zfs or ZFS volume exposed as raw block device. Some of the parameters can be only set during creation time (as specified in the details of the parameter), and a few are editable. In case of Cloned volumes, the parameters are assigned the same values as the source volume.
   *
   * @schema ZFSRestore#volSpec
   */
  readonly volSpec?: ZfsRestoreVolSpec;
}

/**
 * Converts an object of type 'ZfsRestoreProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsRestoreProps(
  obj: ZfsRestoreProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ZfsRestoreSpec(obj.spec),
    "volSpec": toJson_ZfsRestoreVolSpec(obj.volSpec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ZFSRestoreSpec is the spec for a ZFSRestore resource
 *
 * @schema ZfsRestoreSpec
 */
export interface ZfsRestoreSpec {
  /**
   * owner node name where restore volume is present
   *
   * @schema ZfsRestoreSpec#ownerNodeID
   */
  readonly ownerNodeId: string;

  /**
   * it can be ip:port in case of restore from remote or volumeName in case of local restore
   *
   * @schema ZfsRestoreSpec#restoreSrc
   */
  readonly restoreSrc: string;

  /**
   * volume name to where restore has to be performed
   *
   * @schema ZfsRestoreSpec#volumeName
   */
  readonly volumeName: string;
}

/**
 * Converts an object of type 'ZfsRestoreSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsRestoreSpec(
  obj: ZfsRestoreSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "ownerNodeID": obj.ownerNodeId,
    "restoreSrc": obj.restoreSrc,
    "volumeName": obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeInfo defines ZFS volume parameters for all modes in which ZFS volumes can be created like - ZFS volume with filesystem, ZFS Volume exposed as zfs or ZFS volume exposed as raw block device. Some of the parameters can be only set during creation time (as specified in the details of the parameter), and a few are editable. In case of Cloned volumes, the parameters are assigned the same values as the source volume.
 *
 * @schema ZfsRestoreVolSpec
 */
export interface ZfsRestoreVolSpec {
  /**
   * Capacity of the volume
   *
   * @schema ZfsRestoreVolSpec#capacity
   */
  readonly capacity: string;

  /**
   * Compression specifies the block-level compression algorithm to be applied to the ZFS Volume. The value "on" indicates ZFS to use the default compression algorithm. The default compression algorithm used by ZFS will be either lzjb or, if the lz4_compress feature is enabled, lz4. Compression property can be edited after the volume has been created. The change will only be applied to the newly-written data. For instance, if the Volume was created with "off" and the next day the compression was modified to "on", the data written prior to setting "on" will not be compressed. Default Value: off.
   *
   * @schema ZfsRestoreVolSpec#compression
   */
  readonly compression?: string;

  /**
   * Deduplication is the process for removing redundant data at the block level, reducing the total amount of data stored. If a file system has the dedup property enabled, duplicate data blocks are removed synchronously. The result is that only unique data is stored and common components are shared among files. Deduplication can consume significant processing power (CPU) and memory as well as generate additional disk IO. Before creating a pool with deduplication enabled, ensure that you have planned your hardware requirements appropriately and implemented appropriate recovery practices, such as regular backups. As an alternative to deduplication consider using compression=lz4, as a less resource-intensive alternative. should be enabled on the zvol. Dedup property can be edited after the volume has been created. Default Value: off.
   *
   * @schema ZfsRestoreVolSpec#dedup
   */
  readonly dedup?: ZfsRestoreVolSpecDedup;

  /**
   * Enabling the encryption feature allows for the creation of encrypted filesystems and volumes. ZFS will encrypt file and zvol data, file attributes, ACLs, permission bits, directory listings, FUID mappings, and userused / groupused data. ZFS will not encrypt metadata related to the pool structure, including dataset and snapshot names, dataset hierarchy, properties, file size, file holes, and deduplication tables (though the deduplicated data itself is encrypted). Default Value: off.
   *
   * @schema ZfsRestoreVolSpec#encryption
   */
  readonly encryption?: string;

  /**
   * FsType specifies filesystem type for the zfs volume/dataset. If FsType is provided as "zfs", then the driver will create a ZFS dataset, formatting is not required as underlying filesystem is ZFS anyway. If FsType is ext2, ext3, ext4 or xfs, then the driver will create a ZVOL and format the volume accordingly. FsType can not be modified once volume has been provisioned. Default Value: ext4.
   *
   * @schema ZfsRestoreVolSpec#fsType
   */
  readonly fsType?: string;

  /**
   * KeyFormat specifies format of the encryption key The supported KeyFormats are passphrase, raw, hex.
   *
   * @schema ZfsRestoreVolSpec#keyformat
   */
  readonly keyformat?: ZfsRestoreVolSpecKeyformat;

  /**
   * KeyLocation is the location of key for the encryption
   *
   * @schema ZfsRestoreVolSpec#keylocation
   */
  readonly keylocation?: string;

  /**
   * OwnerNodeID is the Node ID where the ZPOOL is running which is where the volume has been provisioned. OwnerNodeID can not be edited after the volume has been provisioned.
   *
   * @schema ZfsRestoreVolSpec#ownerNodeID
   */
  readonly ownerNodeId: string;

  /**
   * poolName specifies the name of the pool where the volume has been created. PoolName can not be edited after the volume has been provisioned.
   *
   * @schema ZfsRestoreVolSpec#poolName
   */
  readonly poolName: string;

  /**
   * quotaType determines whether the dataset volume quota type is of type "quota" or "refquota". QuotaType can not be modified once volume has been provisioned. Default Value: quota.
   *
   * @schema ZfsRestoreVolSpec#quotaType
   */
  readonly quotaType?: ZfsRestoreVolSpecQuotaType;

  /**
   * Specifies a suggested block size for files in the file system. The size specified must be a power of two greater than or equal to 512 and less than or equal to 128 Kbytes. RecordSize property can be edited after the volume has been created. Changing the file system's recordsize affects only files created afterward; existing files are unaffected. Default Value: 128k.
   *
   * @schema ZfsRestoreVolSpec#recordsize
   */
  readonly recordsize?: string;

  /**
   * Shared specifies whether the volume can be shared among multiple pods. If it is not set to "yes", then the ZFS-LocalPV Driver will not allow the volumes to be mounted by more than one pods.
   *
   * @schema ZfsRestoreVolSpec#shared
   */
  readonly shared?: ZfsRestoreVolSpecShared;

  /**
   * SnapName specifies the name of the snapshot where the volume has been cloned from. Snapname can not be edited after the volume has been provisioned.
   *
   * @schema ZfsRestoreVolSpec#snapname
   */
  readonly snapname?: string;

  /**
   * ThinProvision describes whether space reservation for the source volume is required or not. The value "yes" indicates that volume should be thin provisioned and "no" means thick provisioning of the volume. If thinProvision is set to "yes" then volume can be provisioned even if the ZPOOL does not have the enough capacity. If thinProvision is set to "no" then volume can be provisioned only if the ZPOOL has enough capacity and capacity required by volume can be reserved. ThinProvision can not be modified once volume has been provisioned. Default Value: no.
   *
   * @schema ZfsRestoreVolSpec#thinProvision
   */
  readonly thinProvision?: ZfsRestoreVolSpecThinProvision;

  /**
   * VolBlockSize specifies the block size for the zvol. The volsize can only be set to a multiple of volblocksize, and cannot be zero. VolBlockSize can not be edited after the volume has been provisioned. Default Value: 8k.
   *
   * @schema ZfsRestoreVolSpec#volblocksize
   */
  readonly volblocksize?: string;

  /**
   * volumeType determines whether the volume is of type "DATASET" or "ZVOL". If fstype provided in the storageclass is "zfs", a volume of type dataset will be created. If "ext4", "ext3", "ext2" or "xfs" is mentioned as fstype in the storageclass, then a volume of type zvol will be created, which will be further formatted as the fstype provided in the storageclass. VolumeType can not be modified once volume has been provisioned.
   *
   * @schema ZfsRestoreVolSpec#volumeType
   */
  readonly volumeType: ZfsRestoreVolSpecVolumeType;
}

/**
 * Converts an object of type 'ZfsRestoreVolSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsRestoreVolSpec(
  obj: ZfsRestoreVolSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "capacity": obj.capacity,
    "compression": obj.compression,
    "dedup": obj.dedup,
    "encryption": obj.encryption,
    "fsType": obj.fsType,
    "keyformat": obj.keyformat,
    "keylocation": obj.keylocation,
    "ownerNodeID": obj.ownerNodeId,
    "poolName": obj.poolName,
    "quotaType": obj.quotaType,
    "recordsize": obj.recordsize,
    "shared": obj.shared,
    "snapname": obj.snapname,
    "thinProvision": obj.thinProvision,
    "volblocksize": obj.volblocksize,
    "volumeType": obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deduplication is the process for removing redundant data at the block level, reducing the total amount of data stored. If a file system has the dedup property enabled, duplicate data blocks are removed synchronously. The result is that only unique data is stored and common components are shared among files. Deduplication can consume significant processing power (CPU) and memory as well as generate additional disk IO. Before creating a pool with deduplication enabled, ensure that you have planned your hardware requirements appropriately and implemented appropriate recovery practices, such as regular backups. As an alternative to deduplication consider using compression=lz4, as a less resource-intensive alternative. should be enabled on the zvol. Dedup property can be edited after the volume has been created. Default Value: off.
 *
 * @schema ZfsRestoreVolSpecDedup
 */
export enum ZfsRestoreVolSpecDedup {
  /** on */
  ON = "on",
  /** off */
  OFF = "off",
}

/**
 * KeyFormat specifies format of the encryption key The supported KeyFormats are passphrase, raw, hex.
 *
 * @schema ZfsRestoreVolSpecKeyformat
 */
export enum ZfsRestoreVolSpecKeyformat {
  /** passphrase */
  PASSPHRASE = "passphrase",
  /** raw */
  RAW = "raw",
  /** hex */
  HEX = "hex",
}

/**
 * quotaType determines whether the dataset volume quota type is of type "quota" or "refquota". QuotaType can not be modified once volume has been provisioned. Default Value: quota.
 *
 * @schema ZfsRestoreVolSpecQuotaType
 */
export enum ZfsRestoreVolSpecQuotaType {
  /** quota */
  QUOTA = "quota",
  /** refquota */
  REFQUOTA = "refquota",
}

/**
 * Shared specifies whether the volume can be shared among multiple pods. If it is not set to "yes", then the ZFS-LocalPV Driver will not allow the volumes to be mounted by more than one pods.
 *
 * @schema ZfsRestoreVolSpecShared
 */
export enum ZfsRestoreVolSpecShared {
  /** yes */
  YES = "yes",
  /** no */
  NO = "no",
}

/**
 * ThinProvision describes whether space reservation for the source volume is required or not. The value "yes" indicates that volume should be thin provisioned and "no" means thick provisioning of the volume. If thinProvision is set to "yes" then volume can be provisioned even if the ZPOOL does not have the enough capacity. If thinProvision is set to "no" then volume can be provisioned only if the ZPOOL has enough capacity and capacity required by volume can be reserved. ThinProvision can not be modified once volume has been provisioned. Default Value: no.
 *
 * @schema ZfsRestoreVolSpecThinProvision
 */
export enum ZfsRestoreVolSpecThinProvision {
  /** yes */
  YES = "yes",
  /** no */
  NO = "no",
}

/**
 * volumeType determines whether the volume is of type "DATASET" or "ZVOL". If fstype provided in the storageclass is "zfs", a volume of type dataset will be created. If "ext4", "ext3", "ext2" or "xfs" is mentioned as fstype in the storageclass, then a volume of type zvol will be created, which will be further formatted as the fstype provided in the storageclass. VolumeType can not be modified once volume has been provisioned.
 *
 * @schema ZfsRestoreVolSpecVolumeType
 */
export enum ZfsRestoreVolSpecVolumeType {
  /** ZVOL */
  ZVOL = "ZVOL",
  /** DATASET */
  DATASET = "DATASET",
}

/**
 * ZFSSnapshot represents a ZFS Snapshot of the zfsvolume
 *
 * @schema ZFSSnapshot
 */
export class ZfsSnapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ZFSSnapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "zfs.openebs.io/v1",
    kind: "ZFSSnapshot",
  };

  /**
   * Renders a Kubernetes manifest for "ZFSSnapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ZfsSnapshotProps): any {
    return {
      ...ZfsSnapshot.GVK,
      ...toJson_ZfsSnapshotProps(props),
    };
  }

  /**
   * Defines a "ZFSSnapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ZfsSnapshotProps) {
    super(scope, id, {
      ...ZfsSnapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ZfsSnapshot.GVK,
      ...toJson_ZfsSnapshotProps(resolved),
    };
  }
}

/**
 * ZFSSnapshot represents a ZFS Snapshot of the zfsvolume
 *
 * @schema ZFSSnapshot
 */
export interface ZfsSnapshotProps {
  /**
   * @schema ZFSSnapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VolumeInfo defines ZFS volume parameters for all modes in which ZFS volumes can be created like - ZFS volume with filesystem, ZFS Volume exposed as zfs or ZFS volume exposed as raw block device. Some of the parameters can be only set during creation time (as specified in the details of the parameter), and a few are editable. In case of Cloned volumes, the parameters are assigned the same values as the source volume.
   *
   * @schema ZFSSnapshot#spec
   */
  readonly spec: ZfsSnapshotSpec;
}

/**
 * Converts an object of type 'ZfsSnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsSnapshotProps(
  obj: ZfsSnapshotProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ZfsSnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeInfo defines ZFS volume parameters for all modes in which ZFS volumes can be created like - ZFS volume with filesystem, ZFS Volume exposed as zfs or ZFS volume exposed as raw block device. Some of the parameters can be only set during creation time (as specified in the details of the parameter), and a few are editable. In case of Cloned volumes, the parameters are assigned the same values as the source volume.
 *
 * @schema ZfsSnapshotSpec
 */
export interface ZfsSnapshotSpec {
  /**
   * Capacity of the volume
   *
   * @schema ZfsSnapshotSpec#capacity
   */
  readonly capacity: string;

  /**
   * Compression specifies the block-level compression algorithm to be applied to the ZFS Volume. The value "on" indicates ZFS to use the default compression algorithm. The default compression algorithm used by ZFS will be either lzjb or, if the lz4_compress feature is enabled, lz4. Compression property can be edited after the volume has been created. The change will only be applied to the newly-written data. For instance, if the Volume was created with "off" and the next day the compression was modified to "on", the data written prior to setting "on" will not be compressed. Default Value: off.
   *
   * @schema ZfsSnapshotSpec#compression
   */
  readonly compression?: string;

  /**
   * Deduplication is the process for removing redundant data at the block level, reducing the total amount of data stored. If a file system has the dedup property enabled, duplicate data blocks are removed synchronously. The result is that only unique data is stored and common components are shared among files. Deduplication can consume significant processing power (CPU) and memory as well as generate additional disk IO. Before creating a pool with deduplication enabled, ensure that you have planned your hardware requirements appropriately and implemented appropriate recovery practices, such as regular backups. As an alternative to deduplication consider using compression=lz4, as a less resource-intensive alternative. should be enabled on the zvol. Dedup property can be edited after the volume has been created. Default Value: off.
   *
   * @schema ZfsSnapshotSpec#dedup
   */
  readonly dedup?: ZfsSnapshotSpecDedup;

  /**
   * Enabling the encryption feature allows for the creation of encrypted filesystems and volumes. ZFS will encrypt file and zvol data, file attributes, ACLs, permission bits, directory listings, FUID mappings, and userused / groupused data. ZFS will not encrypt metadata related to the pool structure, including dataset and snapshot names, dataset hierarchy, properties, file size, file holes, and deduplication tables (though the deduplicated data itself is encrypted). Default Value: off.
   *
   * @schema ZfsSnapshotSpec#encryption
   */
  readonly encryption?: string;

  /**
   * FsType specifies filesystem type for the zfs volume/dataset. If FsType is provided as "zfs", then the driver will create a ZFS dataset, formatting is not required as underlying filesystem is ZFS anyway. If FsType is ext2, ext3, ext4 or xfs, then the driver will create a ZVOL and format the volume accordingly. FsType can not be modified once volume has been provisioned. Default Value: ext4.
   *
   * @schema ZfsSnapshotSpec#fsType
   */
  readonly fsType?: string;

  /**
   * KeyFormat specifies format of the encryption key The supported KeyFormats are passphrase, raw, hex.
   *
   * @schema ZfsSnapshotSpec#keyformat
   */
  readonly keyformat?: ZfsSnapshotSpecKeyformat;

  /**
   * KeyLocation is the location of key for the encryption
   *
   * @schema ZfsSnapshotSpec#keylocation
   */
  readonly keylocation?: string;

  /**
   * OwnerNodeID is the Node ID where the ZPOOL is running which is where the volume has been provisioned. OwnerNodeID can not be edited after the volume has been provisioned.
   *
   * @schema ZfsSnapshotSpec#ownerNodeID
   */
  readonly ownerNodeId: string;

  /**
   * poolName specifies the name of the pool where the volume has been created. PoolName can not be edited after the volume has been provisioned.
   *
   * @schema ZfsSnapshotSpec#poolName
   */
  readonly poolName: string;

  /**
   * quotaType determines whether the dataset volume quota type is of type "quota" or "refquota". QuotaType can not be modified once volume has been provisioned. Default Value: quota.
   *
   * @schema ZfsSnapshotSpec#quotaType
   */
  readonly quotaType?: ZfsSnapshotSpecQuotaType;

  /**
   * Specifies a suggested block size for files in the file system. The size specified must be a power of two greater than or equal to 512 and less than or equal to 128 Kbytes. RecordSize property can be edited after the volume has been created. Changing the file system's recordsize affects only files created afterward; existing files are unaffected. Default Value: 128k.
   *
   * @schema ZfsSnapshotSpec#recordsize
   */
  readonly recordsize?: string;

  /**
   * Shared specifies whether the volume can be shared among multiple pods. If it is not set to "yes", then the ZFS-LocalPV Driver will not allow the volumes to be mounted by more than one pods.
   *
   * @schema ZfsSnapshotSpec#shared
   */
  readonly shared?: ZfsSnapshotSpecShared;

  /**
   * SnapName specifies the name of the snapshot where the volume has been cloned from. Snapname can not be edited after the volume has been provisioned.
   *
   * @schema ZfsSnapshotSpec#snapname
   */
  readonly snapname?: string;

  /**
   * ThinProvision describes whether space reservation for the source volume is required or not. The value "yes" indicates that volume should be thin provisioned and "no" means thick provisioning of the volume. If thinProvision is set to "yes" then volume can be provisioned even if the ZPOOL does not have the enough capacity. If thinProvision is set to "no" then volume can be provisioned only if the ZPOOL has enough capacity and capacity required by volume can be reserved. ThinProvision can not be modified once volume has been provisioned. Default Value: no.
   *
   * @schema ZfsSnapshotSpec#thinProvision
   */
  readonly thinProvision?: ZfsSnapshotSpecThinProvision;

  /**
   * VolBlockSize specifies the block size for the zvol. The volsize can only be set to a multiple of volblocksize, and cannot be zero. VolBlockSize can not be edited after the volume has been provisioned. Default Value: 8k.
   *
   * @schema ZfsSnapshotSpec#volblocksize
   */
  readonly volblocksize?: string;

  /**
   * volumeType determines whether the volume is of type "DATASET" or "ZVOL". If fstype provided in the storageclass is "zfs", a volume of type dataset will be created. If "ext4", "ext3", "ext2" or "xfs" is mentioned as fstype in the storageclass, then a volume of type zvol will be created, which will be further formatted as the fstype provided in the storageclass. VolumeType can not be modified once volume has been provisioned.
   *
   * @schema ZfsSnapshotSpec#volumeType
   */
  readonly volumeType: ZfsSnapshotSpecVolumeType;
}

/**
 * Converts an object of type 'ZfsSnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsSnapshotSpec(
  obj: ZfsSnapshotSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "capacity": obj.capacity,
    "compression": obj.compression,
    "dedup": obj.dedup,
    "encryption": obj.encryption,
    "fsType": obj.fsType,
    "keyformat": obj.keyformat,
    "keylocation": obj.keylocation,
    "ownerNodeID": obj.ownerNodeId,
    "poolName": obj.poolName,
    "quotaType": obj.quotaType,
    "recordsize": obj.recordsize,
    "shared": obj.shared,
    "snapname": obj.snapname,
    "thinProvision": obj.thinProvision,
    "volblocksize": obj.volblocksize,
    "volumeType": obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deduplication is the process for removing redundant data at the block level, reducing the total amount of data stored. If a file system has the dedup property enabled, duplicate data blocks are removed synchronously. The result is that only unique data is stored and common components are shared among files. Deduplication can consume significant processing power (CPU) and memory as well as generate additional disk IO. Before creating a pool with deduplication enabled, ensure that you have planned your hardware requirements appropriately and implemented appropriate recovery practices, such as regular backups. As an alternative to deduplication consider using compression=lz4, as a less resource-intensive alternative. should be enabled on the zvol. Dedup property can be edited after the volume has been created. Default Value: off.
 *
 * @schema ZfsSnapshotSpecDedup
 */
export enum ZfsSnapshotSpecDedup {
  /** on */
  ON = "on",
  /** off */
  OFF = "off",
}

/**
 * KeyFormat specifies format of the encryption key The supported KeyFormats are passphrase, raw, hex.
 *
 * @schema ZfsSnapshotSpecKeyformat
 */
export enum ZfsSnapshotSpecKeyformat {
  /** passphrase */
  PASSPHRASE = "passphrase",
  /** raw */
  RAW = "raw",
  /** hex */
  HEX = "hex",
}

/**
 * quotaType determines whether the dataset volume quota type is of type "quota" or "refquota". QuotaType can not be modified once volume has been provisioned. Default Value: quota.
 *
 * @schema ZfsSnapshotSpecQuotaType
 */
export enum ZfsSnapshotSpecQuotaType {
  /** quota */
  QUOTA = "quota",
  /** refquota */
  REFQUOTA = "refquota",
}

/**
 * Shared specifies whether the volume can be shared among multiple pods. If it is not set to "yes", then the ZFS-LocalPV Driver will not allow the volumes to be mounted by more than one pods.
 *
 * @schema ZfsSnapshotSpecShared
 */
export enum ZfsSnapshotSpecShared {
  /** yes */
  YES = "yes",
  /** no */
  NO = "no",
}

/**
 * ThinProvision describes whether space reservation for the source volume is required or not. The value "yes" indicates that volume should be thin provisioned and "no" means thick provisioning of the volume. If thinProvision is set to "yes" then volume can be provisioned even if the ZPOOL does not have the enough capacity. If thinProvision is set to "no" then volume can be provisioned only if the ZPOOL has enough capacity and capacity required by volume can be reserved. ThinProvision can not be modified once volume has been provisioned. Default Value: no.
 *
 * @schema ZfsSnapshotSpecThinProvision
 */
export enum ZfsSnapshotSpecThinProvision {
  /** yes */
  YES = "yes",
  /** no */
  NO = "no",
}

/**
 * volumeType determines whether the volume is of type "DATASET" or "ZVOL". If fstype provided in the storageclass is "zfs", a volume of type dataset will be created. If "ext4", "ext3", "ext2" or "xfs" is mentioned as fstype in the storageclass, then a volume of type zvol will be created, which will be further formatted as the fstype provided in the storageclass. VolumeType can not be modified once volume has been provisioned.
 *
 * @schema ZfsSnapshotSpecVolumeType
 */
export enum ZfsSnapshotSpecVolumeType {
  /** ZVOL */
  ZVOL = "ZVOL",
  /** DATASET */
  DATASET = "DATASET",
}

/**
 * ZFSSnapshot represents a ZFS Snapshot of the zfsvolume
 *
 * @schema ZFSSnapshotV1Alpha1
 */
export class ZfsSnapshotV1Alpha1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ZFSSnapshotV1Alpha1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "zfs.openebs.io/v1alpha1",
    kind: "ZFSSnapshot",
  };

  /**
   * Renders a Kubernetes manifest for "ZFSSnapshotV1Alpha1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ZfsSnapshotV1Alpha1Props): any {
    return {
      ...ZfsSnapshotV1Alpha1.GVK,
      ...toJson_ZfsSnapshotV1Alpha1Props(props),
    };
  }

  /**
   * Defines a "ZFSSnapshotV1Alpha1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ZfsSnapshotV1Alpha1Props,
  ) {
    super(scope, id, {
      ...ZfsSnapshotV1Alpha1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ZfsSnapshotV1Alpha1.GVK,
      ...toJson_ZfsSnapshotV1Alpha1Props(resolved),
    };
  }
}

/**
 * ZFSSnapshot represents a ZFS Snapshot of the zfsvolume
 *
 * @schema ZFSSnapshotV1Alpha1
 */
export interface ZfsSnapshotV1Alpha1Props {
  /**
   * @schema ZFSSnapshotV1Alpha1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VolumeInfo defines ZFS volume parameters for all modes in which ZFS volumes can be created like - ZFS volume with filesystem, ZFS Volume exposed as zfs or ZFS volume exposed as raw block device. Some of the parameters can be only set during creation time (as specified in the details of the parameter), and a few are editable. In case of Cloned volumes, the parameters are assigned the same values as the source volume.
   *
   * @schema ZFSSnapshotV1Alpha1#spec
   */
  readonly spec: ZfsSnapshotV1Alpha1Spec;
}

/**
 * Converts an object of type 'ZfsSnapshotV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsSnapshotV1Alpha1Props(
  obj: ZfsSnapshotV1Alpha1Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ZfsSnapshotV1Alpha1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeInfo defines ZFS volume parameters for all modes in which ZFS volumes can be created like - ZFS volume with filesystem, ZFS Volume exposed as zfs or ZFS volume exposed as raw block device. Some of the parameters can be only set during creation time (as specified in the details of the parameter), and a few are editable. In case of Cloned volumes, the parameters are assigned the same values as the source volume.
 *
 * @schema ZfsSnapshotV1Alpha1Spec
 */
export interface ZfsSnapshotV1Alpha1Spec {
  /**
   * Capacity of the volume
   *
   * @schema ZfsSnapshotV1Alpha1Spec#capacity
   */
  readonly capacity: string;

  /**
   * Compression specifies the block-level compression algorithm to be applied to the ZFS Volume. The value "on" indicates ZFS to use the default compression algorithm. The default compression algorithm used by ZFS will be either lzjb or, if the lz4_compress feature is enabled, lz4. Compression property can be edited after the volume has been created. The change will only be applied to the newly-written data. For instance, if the Volume was created with "off" and the next day the compression was modified to "on", the data written prior to setting "on" will not be compressed. Default Value: off.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#compression
   */
  readonly compression?: string;

  /**
   * Deduplication is the process for removing redundant data at the block level, reducing the total amount of data stored. If a file system has the dedup property enabled, duplicate data blocks are removed synchronously. The result is that only unique data is stored and common components are shared among files. Deduplication can consume significant processing power (CPU) and memory as well as generate additional disk IO. Before creating a pool with deduplication enabled, ensure that you have planned your hardware requirements appropriately and implemented appropriate recovery practices, such as regular backups. As an alternative to deduplication consider using compression=lz4, as a less resource-intensive alternative. should be enabled on the zvol. Dedup property can be edited after the volume has been created. Default Value: off.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#dedup
   */
  readonly dedup?: ZfsSnapshotV1Alpha1SpecDedup;

  /**
   * Enabling the encryption feature allows for the creation of encrypted filesystems and volumes. ZFS will encrypt file and zvol data, file attributes, ACLs, permission bits, directory listings, FUID mappings, and userused / groupused data. ZFS will not encrypt metadata related to the pool structure, including dataset and snapshot names, dataset hierarchy, properties, file size, file holes, and deduplication tables (though the deduplicated data itself is encrypted). Default Value: off.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#encryption
   */
  readonly encryption?: string;

  /**
   * FsType specifies filesystem type for the zfs volume/dataset. If FsType is provided as "zfs", then the driver will create a ZFS dataset, formatting is not required as underlying filesystem is ZFS anyway. If FsType is ext2, ext3, ext4 or xfs, then the driver will create a ZVOL and format the volume accordingly. FsType can not be modified once volume has been provisioned. Default Value: ext4.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#fsType
   */
  readonly fsType?: string;

  /**
   * KeyFormat specifies format of the encryption key The supported KeyFormats are passphrase, raw, hex.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#keyformat
   */
  readonly keyformat?: ZfsSnapshotV1Alpha1SpecKeyformat;

  /**
   * KeyLocation is the location of key for the encryption
   *
   * @schema ZfsSnapshotV1Alpha1Spec#keylocation
   */
  readonly keylocation?: string;

  /**
   * OwnerNodeID is the Node ID where the ZPOOL is running which is where the volume has been provisioned. OwnerNodeID can not be edited after the volume has been provisioned.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#ownerNodeID
   */
  readonly ownerNodeId: string;

  /**
   * poolName specifies the name of the pool where the volume has been created. PoolName can not be edited after the volume has been provisioned.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#poolName
   */
  readonly poolName: string;

  /**
   * Specifies a suggested block size for files in the file system. The size specified must be a power of two greater than or equal to 512 and less than or equal to 128 Kbytes. RecordSize property can be edited after the volume has been created. Changing the file system's recordsize affects only files created afterward; existing files are unaffected. Default Value: 128k.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#recordsize
   */
  readonly recordsize?: string;

  /**
   * SnapName specifies the name of the snapshot where the volume has been cloned from. Snapname can not be edited after the volume has been provisioned.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#snapname
   */
  readonly snapname?: string;

  /**
   * ThinProvision describes whether space reservation for the source volume is required or not. The value "yes" indicates that volume should be thin provisioned and "no" means thick provisioning of the volume. If thinProvision is set to "yes" then volume can be provisioned even if the ZPOOL does not have the enough capacity. If thinProvision is set to "no" then volume can be provisioned only if the ZPOOL has enough capacity and capacity required by volume can be reserved. ThinProvision can not be modified once volume has been provisioned. Default Value: no.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#thinProvision
   */
  readonly thinProvision?: ZfsSnapshotV1Alpha1SpecThinProvision;

  /**
   * VolBlockSize specifies the block size for the zvol. The volsize can only be set to a multiple of volblocksize, and cannot be zero. VolBlockSize can not be edited after the volume has been provisioned. Default Value: 8k.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#volblocksize
   */
  readonly volblocksize?: string;

  /**
   * volumeType determines whether the volume is of type "DATASET" or "ZVOL". If fstype provided in the storageclass is "zfs", a volume of type dataset will be created. If "ext4", "ext3", "ext2" or "xfs" is mentioned as fstype in the storageclass, then a volume of type zvol will be created, which will be further formatted as the fstype provided in the storageclass. VolumeType can not be modified once volume has been provisioned.
   *
   * @schema ZfsSnapshotV1Alpha1Spec#volumeType
   */
  readonly volumeType: ZfsSnapshotV1Alpha1SpecVolumeType;
}

/**
 * Converts an object of type 'ZfsSnapshotV1Alpha1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsSnapshotV1Alpha1Spec(
  obj: ZfsSnapshotV1Alpha1Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "capacity": obj.capacity,
    "compression": obj.compression,
    "dedup": obj.dedup,
    "encryption": obj.encryption,
    "fsType": obj.fsType,
    "keyformat": obj.keyformat,
    "keylocation": obj.keylocation,
    "ownerNodeID": obj.ownerNodeId,
    "poolName": obj.poolName,
    "recordsize": obj.recordsize,
    "snapname": obj.snapname,
    "thinProvision": obj.thinProvision,
    "volblocksize": obj.volblocksize,
    "volumeType": obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deduplication is the process for removing redundant data at the block level, reducing the total amount of data stored. If a file system has the dedup property enabled, duplicate data blocks are removed synchronously. The result is that only unique data is stored and common components are shared among files. Deduplication can consume significant processing power (CPU) and memory as well as generate additional disk IO. Before creating a pool with deduplication enabled, ensure that you have planned your hardware requirements appropriately and implemented appropriate recovery practices, such as regular backups. As an alternative to deduplication consider using compression=lz4, as a less resource-intensive alternative. should be enabled on the zvol. Dedup property can be edited after the volume has been created. Default Value: off.
 *
 * @schema ZfsSnapshotV1Alpha1SpecDedup
 */
export enum ZfsSnapshotV1Alpha1SpecDedup {
  /** on */
  ON = "on",
  /** off */
  OFF = "off",
}

/**
 * KeyFormat specifies format of the encryption key The supported KeyFormats are passphrase, raw, hex.
 *
 * @schema ZfsSnapshotV1Alpha1SpecKeyformat
 */
export enum ZfsSnapshotV1Alpha1SpecKeyformat {
  /** passphrase */
  PASSPHRASE = "passphrase",
  /** raw */
  RAW = "raw",
  /** hex */
  HEX = "hex",
}

/**
 * ThinProvision describes whether space reservation for the source volume is required or not. The value "yes" indicates that volume should be thin provisioned and "no" means thick provisioning of the volume. If thinProvision is set to "yes" then volume can be provisioned even if the ZPOOL does not have the enough capacity. If thinProvision is set to "no" then volume can be provisioned only if the ZPOOL has enough capacity and capacity required by volume can be reserved. ThinProvision can not be modified once volume has been provisioned. Default Value: no.
 *
 * @schema ZfsSnapshotV1Alpha1SpecThinProvision
 */
export enum ZfsSnapshotV1Alpha1SpecThinProvision {
  /** yes */
  YES = "yes",
  /** no */
  NO = "no",
}

/**
 * volumeType determines whether the volume is of type "DATASET" or "ZVOL". If fstype provided in the storageclass is "zfs", a volume of type dataset will be created. If "ext4", "ext3", "ext2" or "xfs" is mentioned as fstype in the storageclass, then a volume of type zvol will be created, which will be further formatted as the fstype provided in the storageclass. VolumeType can not be modified once volume has been provisioned.
 *
 * @schema ZfsSnapshotV1Alpha1SpecVolumeType
 */
export enum ZfsSnapshotV1Alpha1SpecVolumeType {
  /** ZVOL */
  ZVOL = "ZVOL",
  /** DATASET */
  DATASET = "DATASET",
}

/**
 * ZFSVolume represents a ZFS based volume
 *
 * @schema ZFSVolume
 */
export class ZfsVolume extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ZFSVolume"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "zfs.openebs.io/v1",
    kind: "ZFSVolume",
  };

  /**
   * Renders a Kubernetes manifest for "ZFSVolume".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ZfsVolumeProps): any {
    return {
      ...ZfsVolume.GVK,
      ...toJson_ZfsVolumeProps(props),
    };
  }

  /**
   * Defines a "ZFSVolume" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ZfsVolumeProps) {
    super(scope, id, {
      ...ZfsVolume.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ZfsVolume.GVK,
      ...toJson_ZfsVolumeProps(resolved),
    };
  }
}

/**
 * ZFSVolume represents a ZFS based volume
 *
 * @schema ZFSVolume
 */
export interface ZfsVolumeProps {
  /**
   * @schema ZFSVolume#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VolumeInfo defines ZFS volume parameters for all modes in which ZFS volumes can be created like - ZFS volume with filesystem, ZFS Volume exposed as zfs or ZFS volume exposed as raw block device. Some of the parameters can be only set during creation time (as specified in the details of the parameter), and a few are editable. In case of Cloned volumes, the parameters are assigned the same values as the source volume.
   *
   * @schema ZFSVolume#spec
   */
  readonly spec: ZfsVolumeSpec;
}

/**
 * Converts an object of type 'ZfsVolumeProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsVolumeProps(
  obj: ZfsVolumeProps | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ZfsVolumeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeInfo defines ZFS volume parameters for all modes in which ZFS volumes can be created like - ZFS volume with filesystem, ZFS Volume exposed as zfs or ZFS volume exposed as raw block device. Some of the parameters can be only set during creation time (as specified in the details of the parameter), and a few are editable. In case of Cloned volumes, the parameters are assigned the same values as the source volume.
 *
 * @schema ZfsVolumeSpec
 */
export interface ZfsVolumeSpec {
  /**
   * Capacity of the volume
   *
   * @schema ZfsVolumeSpec#capacity
   */
  readonly capacity: string;

  /**
   * Compression specifies the block-level compression algorithm to be applied to the ZFS Volume. The value "on" indicates ZFS to use the default compression algorithm. The default compression algorithm used by ZFS will be either lzjb or, if the lz4_compress feature is enabled, lz4. Compression property can be edited after the volume has been created. The change will only be applied to the newly-written data. For instance, if the Volume was created with "off" and the next day the compression was modified to "on", the data written prior to setting "on" will not be compressed. Default Value: off.
   *
   * @schema ZfsVolumeSpec#compression
   */
  readonly compression?: string;

  /**
   * Deduplication is the process for removing redundant data at the block level, reducing the total amount of data stored. If a file system has the dedup property enabled, duplicate data blocks are removed synchronously. The result is that only unique data is stored and common components are shared among files. Deduplication can consume significant processing power (CPU) and memory as well as generate additional disk IO. Before creating a pool with deduplication enabled, ensure that you have planned your hardware requirements appropriately and implemented appropriate recovery practices, such as regular backups. As an alternative to deduplication consider using compression=lz4, as a less resource-intensive alternative. should be enabled on the zvol. Dedup property can be edited after the volume has been created. Default Value: off.
   *
   * @schema ZfsVolumeSpec#dedup
   */
  readonly dedup?: ZfsVolumeSpecDedup;

  /**
   * Enabling the encryption feature allows for the creation of encrypted filesystems and volumes. ZFS will encrypt file and zvol data, file attributes, ACLs, permission bits, directory listings, FUID mappings, and userused / groupused data. ZFS will not encrypt metadata related to the pool structure, including dataset and snapshot names, dataset hierarchy, properties, file size, file holes, and deduplication tables (though the deduplicated data itself is encrypted). Default Value: off.
   *
   * @schema ZfsVolumeSpec#encryption
   */
  readonly encryption?: string;

  /**
   * FsType specifies filesystem type for the zfs volume/dataset. If FsType is provided as "zfs", then the driver will create a ZFS dataset, formatting is not required as underlying filesystem is ZFS anyway. If FsType is ext2, ext3, ext4 or xfs, then the driver will create a ZVOL and format the volume accordingly. FsType can not be modified once volume has been provisioned. Default Value: ext4.
   *
   * @schema ZfsVolumeSpec#fsType
   */
  readonly fsType?: string;

  /**
   * KeyFormat specifies format of the encryption key The supported KeyFormats are passphrase, raw, hex.
   *
   * @schema ZfsVolumeSpec#keyformat
   */
  readonly keyformat?: ZfsVolumeSpecKeyformat;

  /**
   * KeyLocation is the location of key for the encryption
   *
   * @schema ZfsVolumeSpec#keylocation
   */
  readonly keylocation?: string;

  /**
   * OwnerNodeID is the Node ID where the ZPOOL is running which is where the volume has been provisioned. OwnerNodeID can not be edited after the volume has been provisioned.
   *
   * @schema ZfsVolumeSpec#ownerNodeID
   */
  readonly ownerNodeId: string;

  /**
   * poolName specifies the name of the pool where the volume has been created. PoolName can not be edited after the volume has been provisioned.
   *
   * @schema ZfsVolumeSpec#poolName
   */
  readonly poolName: string;

  /**
   * quotaType determines whether the dataset volume quota type is of type "quota" or "refquota". QuotaType can not be modified once volume has been provisioned. Default Value: quota.
   *
   * @schema ZfsVolumeSpec#quotaType
   */
  readonly quotaType?: ZfsVolumeSpecQuotaType;

  /**
   * Specifies a suggested block size for files in the file system. The size specified must be a power of two greater than or equal to 512 and less than or equal to 128 Kbytes. RecordSize property can be edited after the volume has been created. Changing the file system's recordsize affects only files created afterward; existing files are unaffected. Default Value: 128k.
   *
   * @schema ZfsVolumeSpec#recordsize
   */
  readonly recordsize?: string;

  /**
   * Shared specifies whether the volume can be shared among multiple pods. If it is not set to "yes", then the ZFS-LocalPV Driver will not allow the volumes to be mounted by more than one pods.
   *
   * @schema ZfsVolumeSpec#shared
   */
  readonly shared?: ZfsVolumeSpecShared;

  /**
   * SnapName specifies the name of the snapshot where the volume has been cloned from. Snapname can not be edited after the volume has been provisioned.
   *
   * @schema ZfsVolumeSpec#snapname
   */
  readonly snapname?: string;

  /**
   * ThinProvision describes whether space reservation for the source volume is required or not. The value "yes" indicates that volume should be thin provisioned and "no" means thick provisioning of the volume. If thinProvision is set to "yes" then volume can be provisioned even if the ZPOOL does not have the enough capacity. If thinProvision is set to "no" then volume can be provisioned only if the ZPOOL has enough capacity and capacity required by volume can be reserved. ThinProvision can not be modified once volume has been provisioned. Default Value: no.
   *
   * @schema ZfsVolumeSpec#thinProvision
   */
  readonly thinProvision?: ZfsVolumeSpecThinProvision;

  /**
   * VolBlockSize specifies the block size for the zvol. The volsize can only be set to a multiple of volblocksize, and cannot be zero. VolBlockSize can not be edited after the volume has been provisioned. Default Value: 8k.
   *
   * @schema ZfsVolumeSpec#volblocksize
   */
  readonly volblocksize?: string;

  /**
   * volumeType determines whether the volume is of type "DATASET" or "ZVOL". If fstype provided in the storageclass is "zfs", a volume of type dataset will be created. If "ext4", "ext3", "ext2" or "xfs" is mentioned as fstype in the storageclass, then a volume of type zvol will be created, which will be further formatted as the fstype provided in the storageclass. VolumeType can not be modified once volume has been provisioned.
   *
   * @schema ZfsVolumeSpec#volumeType
   */
  readonly volumeType: ZfsVolumeSpecVolumeType;
}

/**
 * Converts an object of type 'ZfsVolumeSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsVolumeSpec(
  obj: ZfsVolumeSpec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "capacity": obj.capacity,
    "compression": obj.compression,
    "dedup": obj.dedup,
    "encryption": obj.encryption,
    "fsType": obj.fsType,
    "keyformat": obj.keyformat,
    "keylocation": obj.keylocation,
    "ownerNodeID": obj.ownerNodeId,
    "poolName": obj.poolName,
    "quotaType": obj.quotaType,
    "recordsize": obj.recordsize,
    "shared": obj.shared,
    "snapname": obj.snapname,
    "thinProvision": obj.thinProvision,
    "volblocksize": obj.volblocksize,
    "volumeType": obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deduplication is the process for removing redundant data at the block level, reducing the total amount of data stored. If a file system has the dedup property enabled, duplicate data blocks are removed synchronously. The result is that only unique data is stored and common components are shared among files. Deduplication can consume significant processing power (CPU) and memory as well as generate additional disk IO. Before creating a pool with deduplication enabled, ensure that you have planned your hardware requirements appropriately and implemented appropriate recovery practices, such as regular backups. As an alternative to deduplication consider using compression=lz4, as a less resource-intensive alternative. should be enabled on the zvol. Dedup property can be edited after the volume has been created. Default Value: off.
 *
 * @schema ZfsVolumeSpecDedup
 */
export enum ZfsVolumeSpecDedup {
  /** on */
  ON = "on",
  /** off */
  OFF = "off",
}

/**
 * KeyFormat specifies format of the encryption key The supported KeyFormats are passphrase, raw, hex.
 *
 * @schema ZfsVolumeSpecKeyformat
 */
export enum ZfsVolumeSpecKeyformat {
  /** passphrase */
  PASSPHRASE = "passphrase",
  /** raw */
  RAW = "raw",
  /** hex */
  HEX = "hex",
}

/**
 * quotaType determines whether the dataset volume quota type is of type "quota" or "refquota". QuotaType can not be modified once volume has been provisioned. Default Value: quota.
 *
 * @schema ZfsVolumeSpecQuotaType
 */
export enum ZfsVolumeSpecQuotaType {
  /** quota */
  QUOTA = "quota",
  /** refquota */
  REFQUOTA = "refquota",
}

/**
 * Shared specifies whether the volume can be shared among multiple pods. If it is not set to "yes", then the ZFS-LocalPV Driver will not allow the volumes to be mounted by more than one pods.
 *
 * @schema ZfsVolumeSpecShared
 */
export enum ZfsVolumeSpecShared {
  /** yes */
  YES = "yes",
  /** no */
  NO = "no",
}

/**
 * ThinProvision describes whether space reservation for the source volume is required or not. The value "yes" indicates that volume should be thin provisioned and "no" means thick provisioning of the volume. If thinProvision is set to "yes" then volume can be provisioned even if the ZPOOL does not have the enough capacity. If thinProvision is set to "no" then volume can be provisioned only if the ZPOOL has enough capacity and capacity required by volume can be reserved. ThinProvision can not be modified once volume has been provisioned. Default Value: no.
 *
 * @schema ZfsVolumeSpecThinProvision
 */
export enum ZfsVolumeSpecThinProvision {
  /** yes */
  YES = "yes",
  /** no */
  NO = "no",
}

/**
 * volumeType determines whether the volume is of type "DATASET" or "ZVOL". If fstype provided in the storageclass is "zfs", a volume of type dataset will be created. If "ext4", "ext3", "ext2" or "xfs" is mentioned as fstype in the storageclass, then a volume of type zvol will be created, which will be further formatted as the fstype provided in the storageclass. VolumeType can not be modified once volume has been provisioned.
 *
 * @schema ZfsVolumeSpecVolumeType
 */
export enum ZfsVolumeSpecVolumeType {
  /** ZVOL */
  ZVOL = "ZVOL",
  /** DATASET */
  DATASET = "DATASET",
}

/**
 * ZFSVolume represents a ZFS based volume
 *
 * @schema ZFSVolumeV1Alpha1
 */
export class ZfsVolumeV1Alpha1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ZFSVolumeV1Alpha1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: "zfs.openebs.io/v1alpha1",
    kind: "ZFSVolume",
  };

  /**
   * Renders a Kubernetes manifest for "ZFSVolumeV1Alpha1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ZfsVolumeV1Alpha1Props): any {
    return {
      ...ZfsVolumeV1Alpha1.GVK,
      ...toJson_ZfsVolumeV1Alpha1Props(props),
    };
  }

  /**
   * Defines a "ZFSVolumeV1Alpha1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(
    scope: Construct,
    id: string,
    props: ZfsVolumeV1Alpha1Props,
  ) {
    super(scope, id, {
      ...ZfsVolumeV1Alpha1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ZfsVolumeV1Alpha1.GVK,
      ...toJson_ZfsVolumeV1Alpha1Props(resolved),
    };
  }
}

/**
 * ZFSVolume represents a ZFS based volume
 *
 * @schema ZFSVolumeV1Alpha1
 */
export interface ZfsVolumeV1Alpha1Props {
  /**
   * @schema ZFSVolumeV1Alpha1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VolumeInfo defines ZFS volume parameters for all modes in which ZFS volumes can be created like - ZFS volume with filesystem, ZFS Volume exposed as zfs or ZFS volume exposed as raw block device. Some of the parameters can be only set during creation time (as specified in the details of the parameter), and a few are editable. In case of Cloned volumes, the parameters are assigned the same values as the source volume.
   *
   * @schema ZFSVolumeV1Alpha1#spec
   */
  readonly spec: ZfsVolumeV1Alpha1Spec;
}

/**
 * Converts an object of type 'ZfsVolumeV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsVolumeV1Alpha1Props(
  obj: ZfsVolumeV1Alpha1Props | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "metadata": obj.metadata,
    "spec": toJson_ZfsVolumeV1Alpha1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * VolumeInfo defines ZFS volume parameters for all modes in which ZFS volumes can be created like - ZFS volume with filesystem, ZFS Volume exposed as zfs or ZFS volume exposed as raw block device. Some of the parameters can be only set during creation time (as specified in the details of the parameter), and a few are editable. In case of Cloned volumes, the parameters are assigned the same values as the source volume.
 *
 * @schema ZfsVolumeV1Alpha1Spec
 */
export interface ZfsVolumeV1Alpha1Spec {
  /**
   * Capacity of the volume
   *
   * @schema ZfsVolumeV1Alpha1Spec#capacity
   */
  readonly capacity: string;

  /**
   * Compression specifies the block-level compression algorithm to be applied to the ZFS Volume. The value "on" indicates ZFS to use the default compression algorithm. The default compression algorithm used by ZFS will be either lzjb or, if the lz4_compress feature is enabled, lz4. Compression property can be edited after the volume has been created. The change will only be applied to the newly-written data. For instance, if the Volume was created with "off" and the next day the compression was modified to "on", the data written prior to setting "on" will not be compressed. Default Value: off.
   *
   * @schema ZfsVolumeV1Alpha1Spec#compression
   */
  readonly compression?: string;

  /**
   * Deduplication is the process for removing redundant data at the block level, reducing the total amount of data stored. If a file system has the dedup property enabled, duplicate data blocks are removed synchronously. The result is that only unique data is stored and common components are shared among files. Deduplication can consume significant processing power (CPU) and memory as well as generate additional disk IO. Before creating a pool with deduplication enabled, ensure that you have planned your hardware requirements appropriately and implemented appropriate recovery practices, such as regular backups. As an alternative to deduplication consider using compression=lz4, as a less resource-intensive alternative. should be enabled on the zvol. Dedup property can be edited after the volume has been created. Default Value: off.
   *
   * @schema ZfsVolumeV1Alpha1Spec#dedup
   */
  readonly dedup?: ZfsVolumeV1Alpha1SpecDedup;

  /**
   * Enabling the encryption feature allows for the creation of encrypted filesystems and volumes. ZFS will encrypt file and zvol data, file attributes, ACLs, permission bits, directory listings, FUID mappings, and userused / groupused data. ZFS will not encrypt metadata related to the pool structure, including dataset and snapshot names, dataset hierarchy, properties, file size, file holes, and deduplication tables (though the deduplicated data itself is encrypted). Default Value: off.
   *
   * @schema ZfsVolumeV1Alpha1Spec#encryption
   */
  readonly encryption?: string;

  /**
   * FsType specifies filesystem type for the zfs volume/dataset. If FsType is provided as "zfs", then the driver will create a ZFS dataset, formatting is not required as underlying filesystem is ZFS anyway. If FsType is ext2, ext3, ext4 or xfs, then the driver will create a ZVOL and format the volume accordingly. FsType can not be modified once volume has been provisioned. Default Value: ext4.
   *
   * @schema ZfsVolumeV1Alpha1Spec#fsType
   */
  readonly fsType?: string;

  /**
   * KeyFormat specifies format of the encryption key The supported KeyFormats are passphrase, raw, hex.
   *
   * @schema ZfsVolumeV1Alpha1Spec#keyformat
   */
  readonly keyformat?: ZfsVolumeV1Alpha1SpecKeyformat;

  /**
   * KeyLocation is the location of key for the encryption
   *
   * @schema ZfsVolumeV1Alpha1Spec#keylocation
   */
  readonly keylocation?: string;

  /**
   * OwnerNodeID is the Node ID where the ZPOOL is running which is where the volume has been provisioned. OwnerNodeID can not be edited after the volume has been provisioned.
   *
   * @schema ZfsVolumeV1Alpha1Spec#ownerNodeID
   */
  readonly ownerNodeId: string;

  /**
   * poolName specifies the name of the pool where the volume has been created. PoolName can not be edited after the volume has been provisioned.
   *
   * @schema ZfsVolumeV1Alpha1Spec#poolName
   */
  readonly poolName: string;

  /**
   * Specifies a suggested block size for files in the file system. The size specified must be a power of two greater than or equal to 512 and less than or equal to 128 Kbytes. RecordSize property can be edited after the volume has been created. Changing the file system's recordsize affects only files created afterward; existing files are unaffected. Default Value: 128k.
   *
   * @schema ZfsVolumeV1Alpha1Spec#recordsize
   */
  readonly recordsize?: string;

  /**
   * SnapName specifies the name of the snapshot where the volume has been cloned from. Snapname can not be edited after the volume has been provisioned.
   *
   * @schema ZfsVolumeV1Alpha1Spec#snapname
   */
  readonly snapname?: string;

  /**
   * ThinProvision describes whether space reservation for the source volume is required or not. The value "yes" indicates that volume should be thin provisioned and "no" means thick provisioning of the volume. If thinProvision is set to "yes" then volume can be provisioned even if the ZPOOL does not have the enough capacity. If thinProvision is set to "no" then volume can be provisioned only if the ZPOOL has enough capacity and capacity required by volume can be reserved. ThinProvision can not be modified once volume has been provisioned. Default Value: no.
   *
   * @schema ZfsVolumeV1Alpha1Spec#thinProvision
   */
  readonly thinProvision?: ZfsVolumeV1Alpha1SpecThinProvision;

  /**
   * VolBlockSize specifies the block size for the zvol. The volsize can only be set to a multiple of volblocksize, and cannot be zero. VolBlockSize can not be edited after the volume has been provisioned. Default Value: 8k.
   *
   * @schema ZfsVolumeV1Alpha1Spec#volblocksize
   */
  readonly volblocksize?: string;

  /**
   * volumeType determines whether the volume is of type "DATASET" or "ZVOL". If fstype provided in the storageclass is "zfs", a volume of type dataset will be created. If "ext4", "ext3", "ext2" or "xfs" is mentioned as fstype in the storageclass, then a volume of type zvol will be created, which will be further formatted as the fstype provided in the storageclass. VolumeType can not be modified once volume has been provisioned.
   *
   * @schema ZfsVolumeV1Alpha1Spec#volumeType
   */
  readonly volumeType: ZfsVolumeV1Alpha1SpecVolumeType;
}

/**
 * Converts an object of type 'ZfsVolumeV1Alpha1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ZfsVolumeV1Alpha1Spec(
  obj: ZfsVolumeV1Alpha1Spec | undefined,
): Record<string, any> | undefined {
  if (obj === undefined) return undefined;
  const result = {
    "capacity": obj.capacity,
    "compression": obj.compression,
    "dedup": obj.dedup,
    "encryption": obj.encryption,
    "fsType": obj.fsType,
    "keyformat": obj.keyformat,
    "keylocation": obj.keylocation,
    "ownerNodeID": obj.ownerNodeId,
    "poolName": obj.poolName,
    "recordsize": obj.recordsize,
    "snapname": obj.snapname,
    "thinProvision": obj.thinProvision,
    "volblocksize": obj.volblocksize,
    "volumeType": obj.volumeType,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }),
    {},
  );
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Deduplication is the process for removing redundant data at the block level, reducing the total amount of data stored. If a file system has the dedup property enabled, duplicate data blocks are removed synchronously. The result is that only unique data is stored and common components are shared among files. Deduplication can consume significant processing power (CPU) and memory as well as generate additional disk IO. Before creating a pool with deduplication enabled, ensure that you have planned your hardware requirements appropriately and implemented appropriate recovery practices, such as regular backups. As an alternative to deduplication consider using compression=lz4, as a less resource-intensive alternative. should be enabled on the zvol. Dedup property can be edited after the volume has been created. Default Value: off.
 *
 * @schema ZfsVolumeV1Alpha1SpecDedup
 */
export enum ZfsVolumeV1Alpha1SpecDedup {
  /** on */
  ON = "on",
  /** off */
  OFF = "off",
}

/**
 * KeyFormat specifies format of the encryption key The supported KeyFormats are passphrase, raw, hex.
 *
 * @schema ZfsVolumeV1Alpha1SpecKeyformat
 */
export enum ZfsVolumeV1Alpha1SpecKeyformat {
  /** passphrase */
  PASSPHRASE = "passphrase",
  /** raw */
  RAW = "raw",
  /** hex */
  HEX = "hex",
}

/**
 * ThinProvision describes whether space reservation for the source volume is required or not. The value "yes" indicates that volume should be thin provisioned and "no" means thick provisioning of the volume. If thinProvision is set to "yes" then volume can be provisioned even if the ZPOOL does not have the enough capacity. If thinProvision is set to "no" then volume can be provisioned only if the ZPOOL has enough capacity and capacity required by volume can be reserved. ThinProvision can not be modified once volume has been provisioned. Default Value: no.
 *
 * @schema ZfsVolumeV1Alpha1SpecThinProvision
 */
export enum ZfsVolumeV1Alpha1SpecThinProvision {
  /** yes */
  YES = "yes",
  /** no */
  NO = "no",
}

/**
 * volumeType determines whether the volume is of type "DATASET" or "ZVOL". If fstype provided in the storageclass is "zfs", a volume of type dataset will be created. If "ext4", "ext3", "ext2" or "xfs" is mentioned as fstype in the storageclass, then a volume of type zvol will be created, which will be further formatted as the fstype provided in the storageclass. VolumeType can not be modified once volume has been provisioned.
 *
 * @schema ZfsVolumeV1Alpha1SpecVolumeType
 */
export enum ZfsVolumeV1Alpha1SpecVolumeType {
  /** ZVOL */
  ZVOL = "ZVOL",
  /** DATASET */
  DATASET = "DATASET",
}
